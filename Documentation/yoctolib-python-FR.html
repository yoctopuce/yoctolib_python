<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-FR.html 4133 2013-08-14 16:06:19Z mvuilleu $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce 
 *    and Licensee are governed by Yoctopuce General Terms and 
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived 
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute; 
  left:0px; 
  top:0px; 
  width:800px; 
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute; 
  left:0px; 
  top:80px; 
  width:250px; 
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;
 
}

div#FunctionsLayer
{ position:absolute; 
  left:250px; 
  top:80px; 
  width:600px; 
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute; 
  left:0px; 
  top:570px; 
  width: 800px; 
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute; 
  width:10px; 
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize; 
}

div.container
{ width:100%;
  height:100%;
}
 
span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
} 

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }
 
span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }
 
div.methodsList
 { margin-top:0px;
   padding-top:0px;   
   padding-left:10px;
   margin-bottom:10px;
 } 

div.methodsList A
 { color: navy;
   text-decoration:none;
 }
 
div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }
 
span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }
  
span#pn , td.pn
 { font-weight:bold; 
   color:#004000;
   
 } 
 
td.pn
 {vertical-align:top}
 
span.paramAndRet
 {font-weight:bold;

 } 
 
table
 {font-size:14px;}
 
span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;   
   background-color: #f8f8f8; 
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }
 
p.protolabel
 { border-top:1px  solid #f0f0f0;
 }
 
P.protoretval
 { margin-left:20px;}

.paramtable 
 { margin-left:20px; margin-top:0px;}
  
P.protoretval
 { margin-left:20px;}
 
input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }
 
td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040; 
 }
 
td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }
 
p.methodlist
 { border-top:1px solid #e0e0e0;
 } 
 
a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 } 
 
span.synlist
 { margin-left:10px;
 } 
 
p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }  
</style>

<SCRIPT type="text/JavaScript" language="javascript1.5">
<!--
var WinW; 
var WinH; 

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array(); 
var SVN_Id = '$Id: yoctolib-cpp-FR.html 4133 2013-08-14 16:06:19Z mvuilleu $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'Fonctions g\xE9n\xE9rales',inc:'from yocto_api import *',cmt:'<p>Ces quelques fonctions g\xE9n\xE9rales permettent l\x27initialisation et la configuration de la librairie Yoctopuce. Dans la plupart des cas, un appel \xE0 <tt>yRegisterHub()</tt> suffira en tout et pour tout. Ensuite, vous pourrez appeler la fonction globale <tt>yFind...()</tt> ou <tt>yFirst...()</tt> correspondant \xE0 votre module pour pouvoir interagir avec lui.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction.',lib:'YAPI.CheckLogicalName()',pro:'def CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction. Un nom logique valide est form\xE9 de 19 caract\xE8res au maximum, choisis parmi <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt> et <tt>-</tt>. Lorsqu\x27on configure un nom logique avec une cha\xEEne incorrecte, les caract\xE8res invalides sont ignor\xE9s.</p>',par:{name:'une cha\xEEne de caract\xE8res contenant le nom v\xE9rifier.'},ret:'<tt>true</tt> si le nom est valide, <tt>false</tt> dans le cas contraire.'};
doc['YAPI']['DisableExceptions']={syn:'D\xE9sactive l\x27utilisation d\x27exceptions pour la gestion des erreurs.',lib:'YAPI.DisableExceptions()',pro:'def DisableExceptions()',cmt:'<p>D\xE9sactive l\x27utilisation d\x27exceptions pour la gestion des erreurs. Lorsque les exceptions sont d\xE9sactiv\xE9es, chaque fonction retourne une valeur d\x27erreur sp\xE9cifique selon son type, document\xE9e dans ce manuel de r\xE9f\xE9rence.</p>'};
doc['YAPI']['EnableExceptions']={syn:'R\xE9active l\x27utilisation d\x27exceptions pour la gestion des erreurs.',lib:'YAPI.EnableExceptions()',pro:'def EnableExceptions()',cmt:'<p>R\xE9active l\x27utilisation d\x27exceptions pour la gestion des erreurs. Attention, lorsque les exceptions sont activ\xE9es, tout appel \xE0 une fonction de la librairie qui \xE9choue d\xE9clenche une exception. Dans le cas o\xF9 celle-ci n\x27est pas intercept\xE9e correctement par le code appelant, soit le debugger se lance, soit le programme de l\x27utilisateur est imm\xE9diatement stopp\xE9 (crash).</p>'};
doc['YAPI']['FreeAPI']={syn:'Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce.',lib:'YAPI.FreeAPI()',pro:'def FreeAPI()',cmt:'<p>Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce. Il n\x27est en g\xE9n\xE9ral pas n\xE9cessaire d\x27appeler cette fonction, sauf si vous d\xE9sirez lib\xE9rer tous les blocs de m\xE9moire allou\xE9s dynamiquement dans le but d\x27identifier une source de blocs perdus par exemple. Vous ne devez plus appeler aucune fonction de la librairie apr\xE8s avoir appel\xE9 <tt>yFreeAPI()</tt>, sous peine de crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Retourne la version de la librairie Yoctopuce utilis\xE9e.',lib:'YAPI.GetAPIVersion()',pro:'def GetAPIVersion()',cmt:'<p>Retourne la version de la librairie Yoctopuce utilis\xE9e. La version est retourn\xE9e sous forme d\x27une cha\xEEne de caract\xE8res au format <tt>\x22Majeure.Mineure.NoBuild\x22</tt>, par exemple <tt>\x221.01.5535\x22</tt>. Pour les langages utilisant une DLL externe (par exemple C#, VisualBasic ou Delphi), la cha\xEEne contient en outre la version de la DLL au m\xEAme format, par exemple <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> Si vous d\xE9sirez v\xE9rifier dans votre code que la version de la librairie est compatible avec celle que vous avez utilis\xE9 durant le d\xE9veloppement, v\xE9rifiez que le num\xE9ro majeur soit strictement \xE9gal et que le num\xE9ro mineur soit \xE9gal ou sup\xE9rieur. Le num\xE9ro de build n\x27est pas significatif par rapport \xE0 la compatibilit\xE9 de la librairie.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la version de la librairie.'};
doc['YAPI']['GetTickCount']={syn:'Retourne la valeur du compteur monotone de temps (en millisecondes).',lib:'YAPI.GetTickCount()',pro:'def GetTickCount()',cmt:'<p>Retourne la valeur du compteur monotone de temps (en millisecondes). Ce compteur peut \xEAtre utilis\xE9 pour calculer des d\xE9lais en rapport avec les modules Yoctopuce, dont la base de temps est aussi la milliseconde.</p>',ret:'un long entier contenant la valeur du compteur de millisecondes.'};
doc['YAPI']['HandleEvents']={syn:'Maintient la communication de la librairie avec les modules Yoctopuce.',lib:'YAPI.HandleEvents()',pro:'def HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintient la communication de la librairie avec les modules Yoctopuce. Si votre programme inclut des longues boucles d\x27attente, vous pouvez y inclure un appel \xE0 cette fonction pour que la librairie prenne en charge les informations mise en attente par les modules sur les canaux de communication. Ce n\x27est pas strictement indispensable mais cela peut am\xE9liorer la r\xE9activit\xE9 des la librairie pour les commandes suivantes.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',par:{errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['InitAPI']={syn:'Initialise la librairie de programmation de Yoctopuce explicitement.',lib:'YAPI.InitAPI()',pro:'def InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initialise la librairie de programmation de Yoctopuce explicitement. Il n\x27est pas indispensable d\x27appeler <tt>yInitAPI()</tt>, la librairie sera automatiquement initialis\xE9e de toute mani\xE8re au premier appel \xE0 <tt>yRegisterHub()</tt>.</p><p> Lorsque cette fonctin est utilis\xE9e avec comme <tt>mode</tt> la valeur <tt>Y_DETECT_NONE</tt>, il faut explicitement appeler <tt>yRegisterHub()</tt> pour indiquer \xE0 la librairie sur quel VirtualHub les modules sont connect\xE9s, avant d\x27essayer d\x27y acc\xE9der.</p>',par:{mode:'un entier sp\xE9cifiant le type de d\xE9tection automatique de modules \xE0 utiliser. Les valeurs possibles sont <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt> et <tt>Y_DETECT_ALL</tt>.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'def RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yHandleDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{arrivalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'def RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yHandleDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{removalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterHub']={syn:'Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e.',lib:'YAPI.RegisterHub()',pro:'def RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e. Dans le cas d\x27une utilisation avec la passerelle VirtualHub, vous devez donner en param\xE8tre l\x27adresse de la machine o\xF9 tourne le VirtualHub (typiquement <tt>\x22http://127.0.0.1:4444\x22</tt>, qui d\xE9signe la machine locale). Si vous utilisez un langage qui a un acc\xE8s direct \xE0 USB, vous pouvez utiliser la pseudo-adresse <tt>\x22usb\x22</tt> \xE0 la place.</p><p> Attention, seule une application peut fonctionner \xE0 la fois sur une machine donn\xE9e en acc\xE8s direct \xE0 USB, sinon il y aurait un conflit d\x27acc\xE8s aux modules. Cela signifie en particulier que vous devez stopper le VirtualHub avant de lancer une application utilisant l\x27acc\xE8s direct \xE0 USB. Cette limitation peut \xEAtre contourn\xE9e en passant par un VirtualHub plut\xF4t que d\x27utiliser directement USB. Si vous d\xE9sirez vous connecter \xE0 un VirtualHub sur lequel le controle d\x27acc\xE8s a \xE9t\xE9 activ\xE9, vous devez donner le param\xE8tre url sous la forme: <tt>http://nom:mot_de_passe</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui> ou l\x27URL racine du VirtualHub \xE0 utiliser.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterLogFunction']={syn:'Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire.',lib:'YAPI.RegisterLogFunction()',pro:'def RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire. Utile pour d\xE9bugger le fonctionnement de l\x27API.</p>',par:{logfun:'une procedure qui prend une cha\xEEne de caract\xE8re en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['SelectArchitecture']={syn:'S\xE9lectionne manuellement l\x27architecture de la libraire dynamique \xE0 utiliser pour acc\xE9der \xE0 USB.',lib:'YAPI.SelectArchitecture()',pro:'def SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>S\xE9lectionne manuellement l\x27architecture de la libraire dynamique \xE0 utiliser pour acc\xE9der \xE0 USB. Par d\xE9faut, la libraire Python d\xE9tecte automatiquement la version de la libraire dynamique \xE0 utiliser pour acc\xE9der au port USB. Sous Linux ARM il n\x27est pas possible de d\xE9tecter de mani\xE8re fiable si il s\x27agit d\x27une installation Soft float (armel) ou Hard float (armhf). Dans ce cas, il est donc recommend\xE9 d\x27appeler <tt>SelectArchitecture()</tt> avant tout autre appel \xE0 la librairie pour forcer l\x27utilisation d\x27une architecture sp\xE9cifi\xE9e.</p>',par:{arch:'une cha\xEEne de caract\xE8re sp\xE9cifiant l\x27architecture \xE0 utiliser. Les valeurs possibles sont <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>,<tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'rien. En cas d\x27erreur, d\xE9clenche une exception.'};
doc['YAPI']['Sleep']={syn:'Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e.',lib:'YAPI.Sleep()',pro:'def Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e. L\x27attente est passive, c\x27est-\xE0-dire qu\x27elle n\x27occupe pas significativement le processeur, de sorte \xE0 le laisser disponible pour les autres processus fonctionnant sur la machine. Durant l\x27attente, la librairie va n\xE9anmoins continuer \xE0 lire p\xE9riodiquement les informations en provenance des modules Yoctopuce en appelant la fonction <tt>yHandleEvents()</tt> afin de se maintenir \xE0 jour.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',par:{ms_duration:'un entier correspondant \xE0 la dur\xE9e de la pause, en millisecondes',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['UnregisterHub']={syn:'Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'def UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui> ou l\x27URL racine du VirtualHub \xE0 ne plus utiliser.'}};
doc['YAPI']['UpdateDeviceList']={syn:'Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s.',lib:'YAPI.UpdateDeviceList()',pro:'def UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s. La librairie va v\xE9rifier sur les machines ou ports USB pr\xE9c\xE9demment enregistr\xE9s en utilisant la fonction <tt>yRegisterHub</tt> si un module a \xE9t\xE9 connect\xE9 ou d\xE9connect\xE9, et le cas \xE9ch\xE9ant appeler les fonctions de callback d\xE9finies par l\x27utilisateur.</p><p> Cette fonction peut \xEAtre appel\xE9e aussi souvent que d\xE9sir\xE9, afin de rendre l\x27application r\xE9active aux \xE9v\xE9nements de hot-plug.</p>',par:{errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: YAPI)
//--- (generated code: Module)
var Language='Python';
var IncludeLabel='Pour utiliser les fonctions d\xE9crites ici, vous devez inclure:';
var ParamLabel='Param\xE8tres :';
var ReturnLabel='Retourne :';
var AbbrevHint='L\x27API supporte deux syntaxes, une premi\xE8re purement orient\xE9e objet, et une seconde abr\xE9g\xE9e.';
var NotFound='Aucune correspondance trouv\xE9e';
var AbbrevLabel='Utiliser les noms abr\xE9g\xE9s';
var UseShortcuts=null;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',null:'None'};
doc['Module']={'':{syn:'Interface de contr\xF4le du module',inc:'from yocto_api import *',cmt:'<p>Cette interface est la m\xEAme pour tous les modules USB de Yoctopuce. Elle permet de contr\xF4ler les param\xE8tres g\xE9n\xE9raux du module, et d\x27\xE9num\xE9rer les fonctions fournies par chaque module.</p>'}};
doc['Module']['FindModule']={syn:'Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique.',lib:'YModule.FindModule()',pro:'def FindModule(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique. Cette fonction n\x27exige pas que le module soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YModule.isOnline()</tt> pour tester si le module est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res contenant soit le num\xE9ro de s\xE9rie, soit le nom logique du module d\xE9sir\xE9'},ret:'un objet de classe <tt>YModule</tt> qui permet ensuite de contr\xF4ler le module ou d\x27obtenir de plus amples informations sur le module.'};
doc['Module']['FirstModule']={syn:'Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie.',lib:'YModule.FirstModule()',pro:'def FirstModule()',cmt:'<p>Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie. Utiliser la fonction <tt>YModule.nextModule()</tt> pour it\xE9rer sur les autres modules.</p>',ret:'un pointeur sur un objet <tt>YModule</tt>, correspondant au premier module accessible en ligne, ou <tt>null</tt> si aucun module n\x27a \xE9t\xE9 trouv\xE9.'};
doc['Module']['functionCount']={syn:'Retourne le nombre de fonctions (sans compter l\x27interface \x22module\x22) existant sur le module.',lib:'module.functionCount()',pro:'def functionCount()',cmt:'<p>Retourne le nombre de fonctions (sans compter l\x27interface \x22module\x22) existant sur le module.</p>',ret:'le nombre de fonctions sur le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionId()',pro:'def functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant \xE0 l\x27identifiant mat\xE9riel unique de la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionName']={syn:'Retourne le nom logique de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionName()',pro:'def functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne le nom logique de la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant au nom logique de la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionValue']={syn:'Retourne la valeur publi\xE9e par la <i>n</i>i\xE8me fonction du module.',lib:'module.functionValue()',pro:'def functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne la valeur publi\xE9e par la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant \xE0 la valeur publi\xE9e par la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['get_beacon']={syn:'Retourne l\x27\xE9tat de la balise de localisation.',lib:'module.get_beacon()',pro:'def get_beacon()',cmt:'<p>Retourne l\x27\xE9tat de la balise de localisation.</p>',ret:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>, selon l\x27\xE9tat de la balise de localisation',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_firmwareRelease']={syn:'Retourne la version du logiciel embarqu\xE9 du module.',lib:'module.get_firmwareRelease()',pro:'def get_firmwareRelease()',cmt:'<p>Retourne la version du logiciel embarqu\xE9 du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la version du logiciel embarqu\xE9 du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'module.get_moduleDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Module']['get_icon2d']={syn:'Retourne l\x27ic\xF4ne du module.',lib:'module.get_icon2d()',pro:'def get_icon2d()',cmt:'<p>Retourne l\x27ic\xF4ne du module. L\x27icone est au format PNG et a une taille maximale de 1536 octets.</p>',ret:'un buffer binaire contenant l\x27icone, au format png.'};
doc['Module']['get_lastLogs']={syn:'Retourne une chaine de charact\xE8re contenant les derniers logs du module.',lib:'module.get_lastLogs()',pro:'def get_lastLogs()',cmt:'<p>Retourne une chaine de charact\xE8re contenant les derniers logs du module. Cette methode retourne les derniers logs qui sont encore stock\xE9 dans le module. </p>',ret:'une chaine de charact\xE8re contenant les derniers logs du module.'};
doc['Module']['get_logicalName']={syn:'Retourne le nom logique du module.',lib:'module.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'module.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.',lib:'module.get_persistentSettings()',pro:'def get_persistentSettings()',cmt:'<p>Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.</p>',ret:'une valeur parmi <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> et <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> repr\xE9sentant l\x27\xE9tat courant des r\xE9glages persistents du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productId()',pro:'def get_productId()',cmt:'<p>Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr\xE9sentant l\x27identifiant USB du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productName()',pro:'def get_productName()',cmt:'<p>Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom commercial du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productRelease()',pro:'def get_productRelease()',cmt:'<p>Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr\xE9sentant le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.',lib:'module.get_rebootCountdown()',pro:'def get_rebootCountdown()',cmt:'<p>Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.</p>',ret:'un entier repr\xE9sentant le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.',lib:'module.get_serialNumber()',pro:'def get_serialNumber()',cmt:'<p>Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module ',lib:'module.get_upTime()',pro:'def get_upTime()',cmt:'<p>Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module</p>',ret:'un entier repr\xE9sentant le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbBandwidth']={syn:'Retourne le nombre d\x27interface USB utilis\xE9 par le module.',lib:'module.get_usbBandwidth()',pro:'def get_usbBandwidth()',cmt:'<p>Retourne le nombre d\x27interface USB utilis\xE9 par le module.</p>',ret:'soit <tt>Y_USBBANDWIDTH_SIMPLE</tt>, soit <tt>Y_USBBANDWIDTH_DOUBLE</tt>, selon le nombre d\x27interface USB utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USBBANDWIDTH_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.',lib:'module.get_usbCurrent()',pro:'def get_usbCurrent()',cmt:'<p>Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.</p>',ret:'un entier repr\xE9sentant le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Module']['isOnline']={syn:'V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur.',lib:'module.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs du module en cache sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le module est joignable, <tt>false</tt> sinon'};
doc['Module']['load']={syn:'Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'module.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['nextModule']={syn:'Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'def nextModule()',cmt:'<p>Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>.</p>',ret:'un pointeur sur un objet <tt>YModule</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Module']['reboot']={syn:'Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.',lib:'module.reboot()',pro:'def reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['revertFromFlash']={syn:'Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.',lib:'module.revertFromFlash()',pro:'def revertFromFlash()',cmt:'<p>Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['saveToFlash']={syn:'Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module.',lib:'module.saveToFlash()',pro:'def saveToFlash()',cmt:'<p>Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module. Attention le nombre total de sauvegardes possibles durant la vie du module est limit\xE9 (environ 100000 cycles). N\x27appelez pas cette fonction dans une boucle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_beacon']={syn:'Allume ou \xE9teint la balise de localisation du module.',lib:'module.set_beacon()',pro:'def set_beacon(<span id=pn>newval</span>)',cmt:'<p>Allume ou \xE9teint la balise de localisation du module.</p>',par:{newval:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_logicalName']={syn:'Change le nom logique du module.',lib:'module.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Change le nom logique du module. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_luminosity']={syn:'Modifie la luminosit\xE9 des leds informatives du module.',lib:'module.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9 des leds informatives du module. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_usbBandwidth']={syn:'Modifie le nombre d\x27interface USB utilis\xE9 par le module.',lib:'module.set_usbBandwidth()',pro:'def set_usbBandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre d\x27interface USB utilis\xE9 par le module. Vous devez red\xE9marrer le module apr\xE8s avoir chang\xE9 ce r\xE9glage.</p>',par:{newval:'soit <tt>Y_USBBANDWIDTH_SIMPLE</tt>, soit <tt>Y_USBBANDWIDTH_DOUBLE</tt>, selon le nombre d\x27interface USB utilis\xE9 par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'module.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Module']['triggerFirmwareUpdate']={syn:'Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.',lib:'module.triggerFirmwareUpdate()',pro:'def triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Module)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'Interface de la fonction ColorLed',inc:'from yocto_colorled import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter une led couleur aussi bien en coordonn\xE9es RGB qu\x27en coordonn\xE9es HSL, les conversions RGB vers HSL \xE9tant faites automatiquement par le module. Ceci permet ais\xE9ment d\x27allumer la led avec une certaine teinte et d\x27en faire progressivement varier la saturation ou la luminosit\xE9. Si n\xE9cessaire, vous trouverez plus d\x27information sur la diff\xE9rence entre RGB et HSL dans la section suivante.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Permet de retrouver une led RGB d\x27apr\xE8s un identifiant donn\xE9.',lib:'YColorLed.FindColorLed()',pro:'def FindColorLed(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une led RGB d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la led RGB soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YColorLed.isOnline()</tt> pour tester si la led RGB est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la led RGB sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YColorLed</tt> qui permet ensuite de contr\xF4ler la led RGB.'};
doc['ColorLed']['FirstColorLed']={syn:'Commence l\x27\xE9num\xE9ration des leds RGB accessibles par la librairie.',lib:'YColorLed.FirstColorLed()',pro:'def FirstColorLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des leds RGB accessibles par la librairie. Utiliser la fonction <tt>YColorLed.nextColorLed()</tt> pour it\xE9rer sur les autres leds RGB.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt>, correspondant \xE0 la premi\xE8re led RGB accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de leds RGB disponibles.'};
doc['ColorLed']['get_advertisedValue']={syn:'Retourne la valeur courante de la led RGB (pas plus de 6 caract\xE8res).',lib:'colorled.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la led RGB (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la led RGB (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'colorled.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['ColorLed']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'colorled.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['ColorLed']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'colorled.get_colorledDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['ColorLed']['get_hslColor']={syn:'Retourne la couleur HSL courante de la led.',lib:'colorled.get_hslColor()',pro:'def get_hslColor()',cmt:'<p>Retourne la couleur HSL courante de la led.</p>',ret:'un entier repr\xE9sentant la couleur HSL courante de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Retourne le nom logique de la led RGB.',lib:'colorled.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la led RGB.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led RGB',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'colorled.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Retourne la couleur RGB courante de la led.',lib:'colorled.get_rgbColor()',pro:'def get_rgbColor()',cmt:'<p>Retourne la couleur RGB courante de la led.</p>',ret:'un entier repr\xE9sentant la couleur RGB courante de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'def get_rgbColorAtPowerOn()',cmt:'<p>Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.</p>',ret:'un entier repr\xE9sentant la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['ColorLed']['hslMove']={syn:'Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.',lib:'colorled.hslMove()',pro:'def hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.</p>',par:{hsl_target:'couleur HSL d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'colorled.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['ColorLed']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'colorled.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['nextColorLed']={syn:'Continue l\x27\xE9num\xE9ration des leds RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt>.',lib:'colorled.nextColorLed()',pro:'def nextColorLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des leds RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt>.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['ColorLed']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'colorled.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['ColorLed']['rgbMove']={syn:'Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.',lib:'colorled.rgbMove()',pro:'def rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.</p>',par:{rgb_target:'couleur RGB d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_hslColor']={syn:'Modifie la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e.',lib:'colorled.set_hslColor()',pro:'def set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e. L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xHHSSLL.</p>',par:{newval:'un entier repr\xE9sentant la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_logicalName']={syn:'Modifie le nom logique de la led RGB.',lib:'colorled.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la led RGB. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led RGB'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_rgbColor']={syn:'Modifie la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu).',lib:'colorled.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu). L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xRRGGBB.</p>',par:{newval:'un entier repr\xE9sentant la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Modifie la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module. Cette couleur sera affich\xE9e des que le module sera sous tension. Ne pas oublier d\x27appeler la fonction <tt>saveToFlash()</tt> du module correspondant pour que ce param\xE8tre soit m\xE9moris\xE9.</p>',par:{newval:'un entier repr\xE9sentant la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'colorled.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: ColorLed)
//--- (generated code: DataRun)
doc['DataRun']={'':{syn:'S\xE9quence de donn\xE9es mise en forme',inc:'from yocto_datalogger import *',cmt:'<p>Un Run est un intervalle de temps pendant lequel un module est sous tension. Les objets YDataRun fournissent un acc\xE8s facilit\xE9 \xE0 toutes les mesures collect\xE9es durant un Run donn\xE9, y compris en permettant la lecture par mesure distantes d\x27un intervalle sp\xE9cifi\xE9.</p>'}};
doc['DataRun']['get_averageValue']={syn:'Retourne la valeur moyenne des mesures observ\xE9es au moment choisi.',lib:'datarun.get_averageValue()',pro:'def get_averageValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur moyenne des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur moyenne).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_AVERAGEVALUE_INVALID.'};
doc['DataRun']['get_duration']={syn:'Retourne la dur\xE9e (en secondes) du Run.',lib:'datarun.get_duration()',pro:'def get_duration()',cmt:'<p>Retourne la dur\xE9e (en secondes) du Run. Lorsque cette m\xE9thode est appell\xE9e dur le Run courant et que l\x27enregistreur de donn\xE9es est actif, l\x27appel \xE0 cette m\xE9thode force un rechargement de la derni\xE8re s\xE9quence du module pour s\x27assurer que la r\xE9ponse prend en compte les derni\xE8res donn\xE9es enregistr\xE9es.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le d\xE9but du Run (quand le module a \xE9t\xE9 mis sous tension) et la derni\xE8re mesure enregistr\xE9e.'};
doc['DataRun']['get_maxValue']={syn:'Retourne la valeur maximale des mesures observ\xE9es au moment choisi.',lib:'datarun.get_maxValue()',pro:'def get_maxValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur maximale des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur maximale).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_MAXVALUE_INVALID.'};
doc['DataRun']['get_measureNames']={syn:'Retourne les noms des valeurs mesur\xE9es par l\x27enregistreur de donn\xE9es.',lib:'datarun.get_measureNames()',pro:'def get_measureNames()',cmt:'<p>Retourne les noms des valeurs mesur\xE9es par l\x27enregistreur de donn\xE9es. Dans la plupart des cas, le nom des colonnes correspond \xE0 l\x27identifiant mat\xE9riel du capteur qui a produit la mesure.</p>',ret:'une liste de cha\xEEne de caract\xE8res (les noms des mesures)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataRun']['get_minValue']={syn:'Retourne la valeur minimale des mesures observ\xE9es au moment choisi.',lib:'datarun.get_minValue()',pro:'def get_minValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur minimale des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur minimale).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_MINVALUE_INVALID.'};
doc['DataRun']['get_valueCount']={syn:'Retourne le nombre de valeurs accessibles dans ce Run, \xE9tant donn\xE9 l\x27intervalle de temps choisi entre les valeurs.',lib:'datarun.get_valueCount()',pro:'def get_valueCount()',cmt:'<p>Retourne le nombre de valeurs accessibles dans ce Run, \xE9tant donn\xE9 l\x27intervalle de temps choisi entre les valeurs. Lorsque cette m\xE9thode est appell\xE9e dur le Run courant et que l\x27enregistreur de donn\xE9es est actif, l\x27appel \xE0 cette m\xE9thode force un rechargement de la derni\xE8re s\xE9quence du module pour s\x27assurer que la r\xE9ponse prend en compte les derni\xE8res donn\xE9es enregistr\xE9es.</p>',ret:'un entier positif correspondant \xE0 la dur\xE9e du Run divis\xE9e par l\x27intervalle entre les valeurs.'};
doc['DataRun']['get_valueInterval']={syn:'Retourne l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run.',lib:'datarun.get_valueInterval()',pro:'def get_valueInterval()',cmt:'<p>Retourne l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run. La valeur par d\xE9faut correspond \xE0 la plus grande granularit\xE9 des mesures archiv\xE9es dans la flash de l\x27enregistreur de donn\xE9es pour ce Run, mais l\x27intervalle \xE0 utiliser peut \xEAtre configur\xE9 librement si d\xE9sir\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes couvertes par chaque valeur repr\xE9sent\xE9e dans le Run.'};
doc['DataRun']['set_valueInterval']={syn:'Change l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run.',lib:'datarun.set_valueInterval()',pro:'def set_valueInterval(<span id=pn>valueInterval</span>)',cmt:'<p>Change l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run. La valeur par d\xE9faut correspond \xE0 la plus grande granularit\xE9 des mesures archiv\xE9es dans la flash de l\x27enregistreur de donn\xE9es pour ce Run, mais l\x27intervalle \xE0 utiliser peut \xEAtre configur\xE9 librement si d\xE9sir\xE9.</p>',par:{valueInterval:'un nombre entier de secondes.'},ret:'nothing'};
//--- (end of generated code: DataRun)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'S\xE9quence de donn\xE9es enregistr\xE9es',inc:'from yocto_datalogger import *',cmt:'<p>Les objets DataStream repr\xE9sentent des s\xE9quences de mesures enregistr\xE9es. Ils sont retourn\xE9s par l\x27enregistreur de donn\xE9es pr\xE9sent dans les senseurs de Yoctopuce.</p>'}};
doc['DataStream']['get_columnCount']={syn:'Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence.',lib:'datastream.get_columnCount()',pro:'def get_columnCount()',cmt:'<p>Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence. La s\xE9mantique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'un entier positif correspondant au nombre de colonnes.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_columnNames']={syn:'Retourne le nom (la s\xE9mantique) des colonnes de donn\xE9es contenus dans la s\xE9quence.',lib:'datastream.get_columnNames()',pro:'def get_columnNames()',cmt:'<p>Retourne le nom (la s\xE9mantique) des colonnes de donn\xE9es contenus dans la s\xE9quence. Dans la plupart des cas, le nom des colonnes correspond \xE0 l\x27identifiant mat\xE9riel du capteur qui a produit la mesure. Pour les s\xE9quences d\x27archivage r\xE9sumant des s\xE9quence, un suffixe est ajout\xE9 \xE0 l\x27identifiant du capteur: _min pour la valeur minimale, _avg pour la valeur moyenne et _max pour la valeur maximale.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'une liste de cha\xEEne de caract\xE8res.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataStream']['get_data']={syn:'Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne).',lib:'datastream.get_data()',pro:'def get_data(<span id=pn>row</span>, <span id=pn>col</span>)',cmt:'<p>Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode get_columnNames().</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',par:{row:'index de l\x27enregistrement (ligne)',col:'index de la mesure (colonne)'},ret:'un nombre d\xE9cimal',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle).',lib:'datastream.get_dataRows()',pro:'def get_dataRows()',cmt:'<p>Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'une liste d\x27enregistrements, chaque enregistrement \xE9tant lui-m\xEAme une liste de nombres d\xE9cimaux.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataStream']['get_dataSamplesInterval']={syn:'Retourne le nombre de secondes entre chaque mesure de la s\xE9quence.',lib:'datastream.get_dataSamplesInterval()',pro:'def get_dataSamplesInterval()',cmt:'<p>Retourne le nombre de secondes entre chaque mesure de la s\xE9quence. Par d\xE9faut, l\x27enregistreur m\xE9morise une mesure par seconde, mais la cr\xE9ation de s\xE9quences d\x27archive synth\xE9tisant de plus longue p\xE9riode peut produire des s\xE9quences plus espac\xE9es.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes entre deux mesures cons\xE9cutives.'};
doc['DataStream']['get_rowCount']={syn:'Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.',lib:'datastream.get_rowCount()',pro:'def get_rowCount()',cmt:'<p>Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'un entier positif correspondant au nombre d\x27enregistrements.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_runIndex']={syn:'Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es.',lib:'datastream.get_runIndex()',pro:'def get_runIndex()',cmt:'<p>Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es. Un Run peut \xEAtre compos\xE9 de plusieurs s\xE9quences, couvrant diff\xE9rents intervalles de temps.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au num\xE9ro du Run'};
doc['DataStream']['get_startTime']={syn:'Retourne le nombre de secondes entre le d\xE9but du Run (mise sous tension du module) et le d\xE9but de la s\xE9quence de donn\xE9es.',lib:'datastream.get_startTime()',pro:'def get_startTime()',cmt:'<p>Retourne le nombre de secondes entre le d\xE9but du Run (mise sous tension du module) et le d\xE9but de la s\xE9quence de donn\xE9es. Si vous d\xE9sirez obtenir l\x27heure absolue du d\xE9but de la s\xE9quence, utilisez <tt>get_startTimeUTC()</tt>.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le d\xE9but du Run et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
doc['DataStream']['get_startTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'datastream.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Si l\x27heure UTC n\x27\xE9tait pas configur\xE9e dans l\x27enregistreur de donn\xE9es au d\xE9but de la s\xE9quence, cette m\xE9thode retourne 0.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
//--- (end of generated code: DataStream)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Interface de la fonction Temperature',inc:'from yocto_temperature import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Temperature']['FindTemperature']={syn:'Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9.',lib:'YTemperature.FindTemperature()',pro:'def FindTemperature(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de temp\xE9rature soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YTemperature.isOnline()</tt> pour tester si le capteur de temp\xE9rature est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de temp\xE9rature sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YTemperature</tt> qui permet ensuite de contr\xF4ler le capteur de temp\xE9rature.'};
doc['Temperature']['FirstTemperature']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie.',lib:'YTemperature.FirstTemperature()',pro:'def FirstTemperature()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie. Utiliser la fonction <tt>YTemperature.nextTemperature()</tt> pour it\xE9rer sur les autres capteurs de temp\xE9rature.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt>, correspondant \xE0 le premier capteur de temp\xE9rature accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de temp\xE9rature disponibles.'};
doc['Temperature']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'temperature.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).',lib:'temperature.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'temperature.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'temperature.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'temperature.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Temperature']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'temperature.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Temperature']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'temperature.get_temperatureDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Temperature']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'temperature.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Retourne le nom logique du capteur de temp\xE9rature.',lib:'temperature.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de temp\xE9rature.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'temperature.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'temperature.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Temperature']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'temperature.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module ',lib:'temperature.get_sensorType()',pro:'def get_sensorType()',cmt:'<p>Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module</p>',ret:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt> et <tt>Y_SENSORTYPE_PT100_2WIRES</tt> repr\xE9sentant le type de capteur de temp\xE9rature utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'temperature.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Temperature']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'temperature.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Temperature']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'temperature.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['nextTemperature']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt>.',lib:'temperature.nextTemperature()',pro:'def nextTemperature()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt>.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Temperature']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'temperature.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Temperature']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'temperature.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_logicalName']={syn:'Modifie le nom logique du capteur de temp\xE9rature.',lib:'temperature.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de temp\xE9rature. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'temperature.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_sensorType']={syn:'Change le type de senseur utilis\xE9 par le module.',lib:'temperature.set_sensorType()',pro:'def set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Change le type de senseur utilis\xE9 par le module. Cette function sert \xE0 sp\xE9cifier le type de thermocouple (K,E, etc..) raccord\xE9 au module. Cette fonction n\x27aura pas d\x27effet si le module utilise un capteur digital. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt> et <tt>Y_SENSORTYPE_PT100_2WIRES</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'temperature.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'Interface de la fonction DataLogger',inc:'from yocto_datalogger import *',cmt:'<p>Les capteurs de Yoctopuce sont \xE9quip\xE9s d\x27une m\xE9moire non-volatile permettant de m\xE9moriser les donn\xE9es mesur\xE9es d\x27une mani\xE8re autonome, sans n\xE9cessiter le suivi permanent d\x27un ordinateur. La librairie de programmation Yoctopuce permet de contr\xF4ler le fonctionnement de l\x27enregistreur de donn\xE9es interne. Dans la mesure o\xF9 les capteurs n\x27ont pas de pile int\xE9gr\xE9e, ils ne contiennent pas de r\xE9f\xE9rence de temps absolue. C\x27est pourquoi les mesures sont simplement index\xE9es par le num\xE9ro de Run (p\xE9riode continue de fonctionnement lors d\x27une mise sous tension), et \xE0 l\x27intervalle de temps depuis le d\xE9but du Run. Il est par contre possible d\x27indiquer par logiciel \xE0 l\x27enregistreur de donn\xE9es l\x27heure UTC \xE0 un moment donn\xE9e, afin qu\x27il en tienne compte jusqu\x27\xE0 la prochaine mise hors tension.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDataLogger.FindDataLogger()',pro:'def FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27enregistreur de donn\xE9es soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDataLogger.isOnline()</tt> pour tester si l\x27enregistreur de donn\xE9es est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27enregistreur de donn\xE9es sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDataLogger</tt> qui permet ensuite de contr\xF4ler l\x27enregistreur de donn\xE9es.'};
doc['DataLogger']['FirstDataLogger']={syn:'Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie.',lib:'YDataLogger.FirstDataLogger()',pro:'def FirstDataLogger()',cmt:'<p>Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie. Utiliser la fonction <tt>YDataLogger.nextDataLogger()</tt> pour it\xE9rer sur les autres enregistreurs de donn\xE9es.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt>, correspondant \xE0 le premier enregistreur de donn\xE9es accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de enregistreurs de donn\xE9es disponibles.'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es.',lib:'datalogger.forgetAllDataStreams()',pro:'def forgetAllDataStreams()',cmt:'<p>Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es. Cette m\xE9thode remet aussi \xE0 z\xE9ro le compteur de Runs.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).',lib:'datalogger.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.',lib:'datalogger.get_currentRunIndex()',pro:'def get_currentRunIndex()',cmt:'<p>Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataRun']={syn:'Retourne un objet YDataRun contenant toutes les donn\xE9es mesur\xE9es pour une p\xE9riode d\x27enclanchement du module donn\xE9e (un Run).',lib:'datalogger.get_dataRun()',pro:'def get_dataRun(<span id=pn>runIdx</span>)',cmt:'<p>Retourne un objet YDataRun contenant toutes les donn\xE9es mesur\xE9es pour une p\xE9riode d\x27enclanchement du module donn\xE9e (un Run). Cet objet pourra \xEAtre utilis\xE9 pour r\xE9cup\xE9rer les mesures (valeur min, valeur moyenne et valeur max) avec la granularit\xE9 d\xE9sir\xE9e.</p>',par:{runIdx:'l\x27index du Run d\xE9sir\xE9'},ret:'un objet <tt>YDataRun</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_dataStreams']={syn:'Construit une liste de toutes les s\xE9quences de mesures m\xE9moris\xE9es par l\x27enregistreur.',lib:'datalogger.get_dataStreams()',pro:'def get_dataStreams(<span id=pn>v</span>)',cmt:'<p>Construit une liste de toutes les s\xE9quences de mesures m\xE9moris\xE9es par l\x27enregistreur. L\x27appelant doit passer par r\xE9f\xE9rence un tableau vide pout stocker les objets YDataStream, et la m\xE9thode va les remplire avec des objets d\xE9crivant les s\xE9quences de donn\xE9es disponibles.</p>',par:{v:'un tableau de YDataStreams qui sera rempli avec les s\xE9quences trouv\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'datalogger.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DataLogger']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'datalogger.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DataLogger']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'datalogger.get_dataloggerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DataLogger']['get_logicalName']={syn:'Retourne le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'datalogger.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DataLogger']['get_oldestRunIndex']={syn:'Retourne le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es.',lib:'datalogger.get_oldestRunIndex()',pro:'def get_oldestRunIndex()',cmt:'<p>Retourne le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OLDESTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_recording']={syn:'Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_recording()',pro:'def get_recording()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',ret:'soit <tt>Y_RECORDING_OFF</tt>, soit <tt>Y_RECORDING_ON</tt>, selon l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.',lib:'datalogger.get_timeUTC()',pro:'def get_timeUTC()',cmt:'<p>Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.</p>',ret:'un entier repr\xE9sentant le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DataLogger']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'datalogger.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['DataLogger']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'datalogger.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['nextDataLogger']={syn:'Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt>.',lib:'datalogger.nextDataLogger()',pro:'def nextDataLogger()',cmt:'<p>Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DataLogger']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'datalogger.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DataLogger']['set_autoStart']={syn:'Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_logicalName']={syn:'Modifie le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27enregistreur de donn\xE9es. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_recording']={syn:'Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_recording()',pro:'def set_recording(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',par:{newval:'soit <tt>Y_RECORDING_OFF</tt>, soit <tt>Y_RECORDING_ON</tt>, selon l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_timeUTC']={syn:'Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.',lib:'datalogger.set_timeUTC()',pro:'def set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.</p>',par:{newval:'un entier repr\xE9sentant la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'datalogger.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'Interface de contr\xF4le de l\x27alimentation',inc:'from yocto_dualpower import *',cmt:'<p>La librairie de programmation Yoctopuce permet de contr\xF4ler la source d\x27alimentation qui doit \xEAtre utilis\xE9e pour les fonctions du module consommant beaucoup de courant. Le module est par ailleurs capable de couper automatiquement l\x27alimentation externe lorsqu\x27il d\xE9tecte que la tension a trop chut\xE9 (batterie \xE9puis\xE9e).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDualPower.FindDualPower()',pro:'def FindDualPower(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le contr\xF4le d\x27alimentation soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDualPower.isOnline()</tt> pour tester si le contr\xF4le d\x27alimentation est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4le d\x27alimentation sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDualPower</tt> qui permet ensuite de contr\xF4ler le contr\xF4le d\x27alimentation.'};
doc['DualPower']['FirstDualPower']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie.',lib:'YDualPower.FirstDualPower()',pro:'def FirstDualPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie. Utiliser la fonction <tt>YDualPower.nextDualPower()</tt> pour it\xE9rer sur les autres contr\xF4les d\x27alimentation.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt>, correspondant \xE0 le premier contr\xF4le d\x27alimentation accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4les d\x27alimentation disponibles.'};
doc['DualPower']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).',lib:'dualpower.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'dualpower.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DualPower']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'dualpower.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DualPower']['get_extVoltage']={syn:'Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.',lib:'dualpower.get_extVoltage()',pro:'def get_extVoltage()',cmt:'<p>Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.</p>',ret:'un entier repr\xE9sentant la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'dualpower.get_dualpowerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DualPower']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4le d\x27alimentation.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'dualpower.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerControl()',pro:'def get_powerControl()',cmt:'<p>Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr\xE9sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerState()',pro:'def get_powerState()',cmt:'<p>Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> et <tt>Y_POWERSTATE_FROM_EXT</tt> repr\xE9sentant la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DualPower']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'dualpower.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['DualPower']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'dualpower.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['nextDualPower']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt>.',lib:'dualpower.nextDualPower()',pro:'def nextDualPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DualPower']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'dualpower.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DualPower']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4le d\x27alimentation. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['set_powerControl']={syn:'Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.set_powerControl()',pro:'def set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',par:{newval:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr\xE9sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'dualpower.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Interface de la fonction Servo',inc:'from yocto_servo import *',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement de d\xE9placer le servo vers une position donn\xE9e, mais aussi de sp\xE9cifier l\x27interval de temps dans lequel le mouvement doit \xEAtre fait, de sorte \xE0 pouvoir synchroniser un mouvement sur plusieurs servos.</p>'}};
doc['Servo']['FindServo']={syn:'Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9.',lib:'YServo.FindServo()',pro:'def FindServo(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le servo soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YServo.isOnline()</tt> pour tester si le servo est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le servo sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YServo</tt> qui permet ensuite de contr\xF4ler le servo.'};
doc['Servo']['FirstServo']={syn:'Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie.',lib:'YServo.FirstServo()',pro:'def FirstServo()',cmt:'<p>Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie. Utiliser la fonction <tt>YServo.nextServo()</tt> pour it\xE9rer sur les autres servo.</p>',ret:'un pointeur sur un objet <tt>YServo</tt>, correspondant \xE0 le premier servo accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de servo disponibles.'};
doc['Servo']['get_advertisedValue']={syn:'Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).',lib:'servo.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du servo (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'servo.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Servo']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'servo.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Servo']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'servo.get_servoDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Servo']['get_logicalName']={syn:'Retourne le nom logique du servo.',lib:'servo.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du servo.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'servo.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.',lib:'servo.get_neutral()',pro:'def get_neutral()',cmt:'<p>Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.</p>',ret:'un entier repr\xE9sentant la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Retourne la position courante du servo.',lib:'servo.get_position()',pro:'def get_position()',cmt:'<p>Retourne la position courante du servo.</p>',ret:'un entier repr\xE9sentant la position courante du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Retourne la plage d\x27utilisation du servo.',lib:'servo.get_range()',pro:'def get_range()',cmt:'<p>Retourne la plage d\x27utilisation du servo.</p>',ret:'un entier repr\xE9sentant la plage d\x27utilisation du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Servo']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'servo.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Servo']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'servo.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['move']={syn:'D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.',lib:'servo.move()',pro:'def move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.</p>',par:{target:'nouvelle position \xE0 la fin du mouvement',ms_duration:'dur\xE9e totale du mouvement, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['nextServo']={syn:'Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt>.',lib:'servo.nextServo()',pro:'def nextServo()',cmt:'<p>Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt>.</p>',ret:'un pointeur sur un objet <tt>YServo</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Servo']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'servo.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Servo']['set_logicalName']={syn:'Modifie le nom logique du servo.',lib:'servo.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du servo. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_neutral']={syn:'Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo.',lib:'servo.set_neutral()',pro:'def set_neutral(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo. La dur\xE9e est sp\xE9cifi\xE9e en microsecondes, et la valeur standard est 1500 [us]. Ce r\xE9glage permet de d\xE9caler la plage d\x27utilisation du servo. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo.</p>',par:{newval:'un entier repr\xE9sentant la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_position']={syn:'Modifie imm\xE9diatement la consigne de position du servo.',lib:'servo.set_position()',pro:'def set_position(<span id=pn>newval</span>)',cmt:'<p>Modifie imm\xE9diatement la consigne de position du servo.</p>',par:{newval:'un entier repr\xE9sentant imm\xE9diatement la consigne de position du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_range']={syn:'Modifie la plage d\x27utilisation du servo, en pourcents.',lib:'servo.set_range()',pro:'def set_range(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage d\x27utilisation du servo, en pourcents. La valeur 100% correspond \xE0 un signal de commande standard, variant de 1 [ms] \xE0 2 [ms]. Pour les servos supportent une plage double, de 0.5 [ms] \xE0 2.5 [ms], vous pouvez utiliser une valeur allant jusqu\x27\xE0 200%. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo.</p>',par:{newval:'un entier repr\xE9sentant la plage d\x27utilisation du servo, en pourcents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'servo.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Interface de la fonction Relay',inc:'from yocto_relay import *',cmt:'<p>La librairie de programmation Yoctopuce permet simplement de changer l\x27\xE9tat du relais. Le changement d\x27\xE9tat n\x27est pas persistant: le relais retournera spontan\xE9ment \xE0 sa position de repos d\xE8s que le module est mis hors tension ou red\xE9marr\xE9. La librairie permet aussi de cr\xE9er des courtes impulsions de dur\xE9e d\xE9termin\xE9e. Pour les modules dot\xE9s de deux sorties par relais (relai inverseur), les deux sorties sont appel\xE9es A et B, la sortie A correspondant a la position de repos (hors tension) et la sortie B correspondant \xE0 l\x27\xE9tat actif. Si vous pr\xE9f\xE9reriez l\x27\xE9tat par d\xE9faut oppos\xE9, vous pouvez simplement changer vos fils sur le bornier.</p>'}};
doc['Relay']['FindRelay']={syn:'Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRelay.FindRelay()',pro:'def FindRelay(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le relais soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRelay.isOnline()</tt> pour tester si le relais est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le relais sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRelay</tt> qui permet ensuite de contr\xF4ler le relais.'};
doc['Relay']['FirstRelay']={syn:'Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie.',lib:'YRelay.FirstRelay()',pro:'def FirstRelay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie. Utiliser la fonction <tt>YRelay.nextRelay()</tt> pour it\xE9rer sur les autres relais.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt>, correspondant \xE0 le premier relais accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de relais disponibles.'};
doc['Relay']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'relay.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27implusion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['get_advertisedValue']={syn:'Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).',lib:'relay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du relais (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'relay.get_countdown()',pro:'def get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'relay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Relay']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'relay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Relay']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'relay.get_relayDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Relay']['get_logicalName']={syn:'Retourne le nom logique du relais.',lib:'relay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du relais.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'relay.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.get_output()',pro:'def get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'relay.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.get_state()',pro:'def get_state()',cmt:'<p>Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Relay']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'relay.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Relay']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'relay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['nextRelay']={syn:'Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt>.',lib:'relay.nextRelay()',pro:'def nextRelay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt>.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Relay']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'relay.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'relay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Relay']['set_logicalName']={syn:'Modifie le nom logique du relais.',lib:'relay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du relais. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_state']={syn:'Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'relay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Relay)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Interface de la fonction Humidity',inc:'from yocto_humidity import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHumidity.FindHumidity()',pro:'def FindHumidity(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur d\x27humidit\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHumidity.isOnline()</tt> pour tester si le capteur d\x27humidit\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur d\x27humidit\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHumidity</tt> qui permet ensuite de contr\xF4ler le capteur d\x27humidit\xE9.'};
doc['Humidity']['FirstHumidity']={syn:'Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie.',lib:'YHumidity.FirstHumidity()',pro:'def FirstHumidity()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie. Utiliser la fonction <tt>YHumidity.nextHumidity()</tt> pour it\xE9rer sur les autres capteurs d\x27humidit\xE9.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt>, correspondant \xE0 le premier capteur d\x27humidit\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs d\x27humidit\xE9 disponibles.'};
doc['Humidity']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'humidity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).',lib:'humidity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'humidity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'humidity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'humidity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Humidity']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'humidity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Humidity']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'humidity.get_humidityDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Humidity']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'humidity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Retourne le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur d\x27humidit\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'humidity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'humidity.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Humidity']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'humidity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'humidity.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Humidity']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'humidity.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Humidity']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'humidity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['nextHumidity']={syn:'Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt>.',lib:'humidity.nextHumidity()',pro:'def nextHumidity()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt>.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Humidity']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'humidity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Humidity']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'humidity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_logicalName']={syn:'Modifie le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur d\x27humidit\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'humidity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'humidity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Interface de la fonction Pressure',inc:'from yocto_pressure import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Pressure']['FindPressure']={syn:'Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPressure.FindPressure()',pro:'def FindPressure(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de pression soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPressure.isOnline()</tt> pour tester si le capteur de pression est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de pression sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPressure</tt> qui permet ensuite de contr\xF4ler le capteur de pression.'};
doc['Pressure']['FirstPressure']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie.',lib:'YPressure.FirstPressure()',pro:'def FirstPressure()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie. Utiliser la fonction <tt>YPressure.nextPressure()</tt> pour it\xE9rer sur les autres capteurs de pression.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt>, correspondant \xE0 le premier capteur de pression accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de pression disponibles.'};
doc['Pressure']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'pressure.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).',lib:'pressure.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de pression (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'pressure.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'pressure.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'pressure.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Pressure']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'pressure.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Pressure']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pressure.get_pressureDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Pressure']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'pressure.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Retourne le nom logique du capteur de pression.',lib:'pressure.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de pression.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'pressure.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pressure.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Pressure']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'pressure.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'pressure.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Pressure']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'pressure.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Pressure']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pressure.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['nextPressure']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt>.',lib:'pressure.nextPressure()',pro:'def nextPressure()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt>.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Pressure']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pressure.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Pressure']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'pressure.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_logicalName']={syn:'Modifie le nom logique du capteur de pression.',lib:'pressure.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de pression. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'pressure.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pressure.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'Interface de la fonction LightSensor',inc:'from yocto_lightsensor import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLightSensor.FindLightSensor()',pro:'def FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de lumi\xE8re soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLightSensor.isOnline()</tt> pour tester si le capteur de lumi\xE8re est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de lumi\xE8re sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLightSensor</tt> qui permet ensuite de contr\xF4ler le capteur de lumi\xE8re.'};
doc['LightSensor']['FirstLightSensor']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie.',lib:'YLightSensor.FirstLightSensor()',pro:'def FirstLightSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie. Utiliser la fonction <tt>YLightSensor.nextLightSensor()</tt> pour it\xE9rer sur les autres capteurs de lumi\xE8re.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt>, correspondant \xE0 le premier capteur de lumi\xE8re accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de lumi\xE8re disponibles.'};
doc['LightSensor']['calibrate']={syn:'Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).',lib:'lightsensor.calibrate()',pro:'def calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).</p>',par:{calibratedVal:'la consigne de valeur d\xE9sir\xE9e. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'lightsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).',lib:'lightsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'lightsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'lightsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'lightsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['LightSensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'lightsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['LightSensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'lightsensor.get_lightsensorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['LightSensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'lightsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Retourne le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de lumi\xE8re.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'lightsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'lightsensor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['LightSensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'lightsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'lightsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['LightSensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'lightsensor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['LightSensor']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'lightsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['nextLightSensor']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt>.',lib:'lightsensor.nextLightSensor()',pro:'def nextLightSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt>.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['LightSensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'lightsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['LightSensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'lightsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_logicalName']={syn:'Modifie le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de lumi\xE8re. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'lightsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'lightsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: LightSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Interface d\x27un port de Yocto-hub',inc:'from yocto_hubport import *'}};
doc['HubPort']['FindHubPort']={syn:'Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHubPort.FindHubPort()',pro:'def FindHubPort(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le port de Yocto-hub soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHubPort.isOnline()</tt> pour tester si le port de Yocto-hub est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port de Yocto-hub sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHubPort</tt> qui permet ensuite de contr\xF4ler le port de Yocto-hub.'};
doc['HubPort']['FirstHubPort']={syn:'Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie.',lib:'YHubPort.FirstHubPort()',pro:'def FirstHubPort()',cmt:'<p>Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie. Utiliser la fonction <tt>YHubPort.nextHubPort()</tt> pour it\xE9rer sur les autres port de Yocto-hub.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt>, correspondant \xE0 le premier port de Yocto-hub accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de port de Yocto-hub disponibles.'};
doc['HubPort']['get_advertisedValue']={syn:'Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).',lib:'hubport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps.',lib:'hubport.get_baudRate()',pro:'def get_baudRate()',cmt:'<p>Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps. La valeur par d\xE9faut est 1000 kbps, une valeur inf\xE9rieure r\xE9v\xE8le des probl\xE8mes de communication.</p>',ret:'un entier repr\xE9sentant la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.',lib:'hubport.get_enabled()',pro:'def get_enabled()',cmt:'<p>Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon vrai si le port du Yocto-hub est aliment\xE9, faux sinon',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'hubport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['HubPort']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'hubport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['HubPort']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'hubport.get_hubportDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['HubPort']['get_logicalName']={syn:'Retourne le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9.',lib:'hubport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'hubport.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Retourne l\x27\xE9tat actuel du port de Yocto-hub.',lib:'hubport.get_portState()',pro:'def get_portState()',cmt:'<p>Retourne l\x27\xE9tat actuel du port de Yocto-hub.</p>',ret:'une valeur parmi <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> et <tt>Y_PORTSTATE_PROG</tt> repr\xE9sentant l\x27\xE9tat actuel du port de Yocto-hub',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['HubPort']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'hubport.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['HubPort']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'hubport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['nextHubPort']={syn:'Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt>.',lib:'hubport.nextHubPort()',pro:'def nextHubPort()',cmt:'<p>Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt>.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['HubPort']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'hubport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['HubPort']['set_enabled']={syn:'Modifie le mode d\x27activation du port du Yocto-hub.',lib:'hubport.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation du port du Yocto-hub. Si le port est actif, il * sera aliment\xE9. Sinon, l\x27alimentation du module est coup\xE9e.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon le mode d\x27activation du port du Yocto-hub'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['set_logicalName']={syn:'Il n\x27est pas possible de configurer le nom logique d\x27un port de Yocto-hub.',lib:'hubport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Il n\x27est pas possible de configurer le nom logique d\x27un port de Yocto-hub. Son nom est automatiquement configur\xE9 comme le num\xE9ro de s\xE9rie du module qui y est connect\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'hubport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'Interface de la fonction AnButton',inc:'from yocto_anbutton import *',cmt:'<p>La librairie de programmation Yoctopuce permet aussi bien de mesurer l\x27\xE9tat d\x27un simple bouton que de lire un potentiom\xE8tre analogique (r\xE9sistance variable), comme par exmple bouton rotatif continue, une poign\xE9e de commande de gaz ou un joystick. Le module est capable de se calibrer sur les valeurs minimales et maximales du potentiom\xE8tre, et de restituer une valeur calibr\xE9e variant proportionnellement avec la position du potentiom\xE8tre, ind\xE9pendant de sa r\xE9sistance totale.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAnButton.FindAnButton()',pro:'def FindAnButton(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27entr\xE9e analogique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAnButton.isOnline()</tt> pour tester si l\x27entr\xE9e analogique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27entr\xE9e analogique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAnButton</tt> qui permet ensuite de contr\xF4ler l\x27entr\xE9e analogique.'};
doc['AnButton']['FirstAnButton']={syn:'Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie.',lib:'YAnButton.FirstAnButton()',pro:'def FirstAnButton()',cmt:'<p>Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie. Utiliser la fonction <tt>YAnButton.nextAnButton()</tt> pour it\xE9rer sur les autres entr\xE9es analogiques.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt>, correspondant \xE0 la premi\xE8re entr\xE9e analogique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de entr\xE9es analogiques disponibles.'};
doc['AnButton']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).',lib:'anbutton.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.',lib:'anbutton.get_analogCalibration()',pro:'def get_analogCalibration()',cmt:'<p>Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.</p>',ret:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).',lib:'anbutton.get_calibratedValue()',pro:'def get_calibratedValue()',cmt:'<p>Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).</p>',ret:'un entier repr\xE9sentant la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMax()',pro:'def get_calibrationMax()',cmt:'<p>Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMin()',pro:'def get_calibrationMin()',cmt:'<p>Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'anbutton.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['AnButton']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'anbutton.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['AnButton']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'anbutton.get_anbuttonDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['AnButton']['get_isPressed']={syn:'Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.',lib:'anbutton.get_isPressed()',pro:'def get_isPressed()',cmt:'<p>Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.</p>',ret:'soit <tt>Y_ISPRESSED_FALSE</tt>, soit <tt>Y_ISPRESSED_TRUE</tt>, selon vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).',lib:'anbutton.get_lastTimePressed()',pro:'def get_lastTimePressed()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).</p>',ret:'un entier repr\xE9sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).',lib:'anbutton.get_lastTimeReleased()',pro:'def get_lastTimeReleased()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).</p>',ret:'un entier repr\xE9sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Retourne le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27entr\xE9e analogique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'anbutton.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Retourne la valeur du compteur d\x27impulsions.',lib:'anbutton.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Retourne la valeur du compteur d\x27impulsions.</p>',ret:'un entier repr\xE9sentant la valeur du compteur d\x27impulsions',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Retourne le timer du compteur d\x27impulsions (ms) ',lib:'anbutton.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le timer du compteur d\x27impulsions (ms)</p>',ret:'un entier repr\xE9sentant le timer du compteur d\x27impulsions (ms)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).',lib:'anbutton.get_rawValue()',pro:'def get_rawValue()',cmt:'<p>Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.',lib:'anbutton.get_sensitivity()',pro:'def get_sensitivity()',cmt:'<p>Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.</p>',ret:'un entier repr\xE9sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['AnButton']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'anbutton.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['AnButton']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'anbutton.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['nextAnButton']={syn:'Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt>.',lib:'anbutton.nextAnButton()',pro:'def nextAnButton()',cmt:'<p>Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt>.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['AnButton']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'anbutton.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['AnButton']['resetCounter']={syn:'r\xE9initialise le compteur d\x27impulsions et son timer ',lib:'anbutton.resetCounter()',pro:'def resetCounter()',cmt:'<p>r\xE9initialise le compteur d\x27impulsions et son timer</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_analogCalibration']={syn:'Enclenche ou d\xE9clenche le proc\xE9dure de calibration.',lib:'anbutton.set_analogCalibration()',pro:'def set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Enclenche ou d\xE9clenche le proc\xE9dure de calibration. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module \xE0 la fin de la calibration si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_calibrationMax']={syn:'Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMax()',pro:'def set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_calibrationMin']={syn:'Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMin()',pro:'def set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_logicalName']={syn:'Modifie le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27entr\xE9e analogique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_sensitivity']={syn:'Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.',lib:'anbutton.set_sensitivity()',pro:'def set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks. La sensibilit\xE9 sert \xE0 filtrer les variations autour d\x27une valeur fixe, mais ne pr\xE9t\xE9rite pas la transmission d\x27\xE9v\xE9nements lorsque la valeur d\x27entr\xE9e \xE9volue constamment dans la m\xEAme direction. Cas particulier: lorsque la valeur 1000 est utilis\xE9e, seuls les valeurs d\xE9clenchant une commutation d\x27\xE9tat press\xE9/non-press\xE9 sont transmises. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'anbutton.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Interface de la fonction Voltage',inc:'from yocto_voltage import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoltage.FindVoltage()',pro:'def FindVoltage(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoltage.isOnline()</tt> pour tester si le capteur de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoltage</tt> qui permet ensuite de contr\xF4ler le capteur de tension.'};
doc['Voltage']['FirstVoltage']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie.',lib:'YVoltage.FirstVoltage()',pro:'def FirstVoltage()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie. Utiliser la fonction <tt>YVoltage.nextVoltage()</tt> pour it\xE9rer sur les autres capteurs de tension.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt>, correspondant \xE0 le premier capteur de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de tension disponibles.'};
doc['Voltage']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voltage.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).',lib:'voltage.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de tension (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'voltage.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'voltage.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voltage.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voltage']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voltage.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voltage']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voltage.get_voltageDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voltage']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'voltage.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Retourne le nom logique du capteur de tension.',lib:'voltage.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'voltage.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voltage.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voltage']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voltage.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'voltage.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voltage']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'voltage.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Voltage']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voltage.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['nextVoltage']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt>.',lib:'voltage.nextVoltage()',pro:'def nextVoltage()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voltage']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voltage.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voltage']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voltage.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_logicalName']={syn:'Modifie le nom logique du capteur de tension.',lib:'voltage.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voltage.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs mesur\xE9es.',lib:'voltage.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Changer la r\xE9solution ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voltage.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Interface de la fonction Current',inc:'from yocto_current import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Current']['FindCurrent']={syn:'Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCurrent.FindCurrent()',pro:'def FindCurrent(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de courant soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCurrent.isOnline()</tt> pour tester si le capteur de courant est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de courant sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCurrent</tt> qui permet ensuite de contr\xF4ler le capteur de courant.'};
doc['Current']['FirstCurrent']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie.',lib:'YCurrent.FirstCurrent()',pro:'def FirstCurrent()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie. Utiliser la fonction <tt>YCurrent.nextCurrent()</tt> pour it\xE9rer sur les autres capteurs de courant.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt>, correspondant \xE0 le premier capteur de courant accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de courant disponibles.'};
doc['Current']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'current.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).',lib:'current.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de courant (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'current.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'current.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'current.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Current']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'current.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Current']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'current.get_currentDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Current']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'current.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Retourne le nom logique du capteur de courant.',lib:'current.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de courant.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'current.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'current.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Current']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'current.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'current.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Current']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'current.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Current']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'current.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['nextCurrent']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt>.',lib:'current.nextCurrent()',pro:'def nextCurrent()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt>.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Current']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'current.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Current']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'current.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_logicalName']={syn:'Modifie le nom logique du capteur de courant.',lib:'current.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de courant. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'current.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs mesur\xE9es.',lib:'current.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Changer la r\xE9solution ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'current.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'Interface de la fonction CarbonDioxide',inc:'from yocto_carbondioxide import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'def FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de CO2 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCarbonDioxide.isOnline()</tt> pour tester si le capteur de CO2 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de CO2 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCarbonDioxide</tt> qui permet ensuite de contr\xF4ler le capteur de CO2.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'def FirstCarbonDioxide()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie. Utiliser la fonction <tt>YCarbonDioxide.nextCarbonDioxide()</tt> pour it\xE9rer sur les autres capteurs de CO2.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt>, correspondant \xE0 le premier capteur de CO2 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de CO2 disponibles.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'carbondioxide.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).',lib:'carbondioxide.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'carbondioxide.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'carbondioxide.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'carbondioxide.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['CarbonDioxide']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'carbondioxide.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'carbondioxide.get_carbondioxideDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['CarbonDioxide']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'carbondioxide.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Retourne le nom logique du capteur de CO2.',lib:'carbondioxide.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de CO2.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'carbondioxide.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'carbondioxide.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['CarbonDioxide']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'carbondioxide.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'carbondioxide.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['CarbonDioxide']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'carbondioxide.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['CarbonDioxide']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'carbondioxide.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide.nextCarbonDioxide()',pro:'def nextCarbonDioxide()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['CarbonDioxide']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'carbondioxide.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['CarbonDioxide']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'carbondioxide.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Modifie le nom logique du capteur de CO2.',lib:'carbondioxide.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de CO2. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'carbondioxide.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'carbondioxide.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Led)
doc['Led']={'':{syn:'Interface de la fonction Led',inc:'from yocto_led import *',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement d\x27allumer la led \xE0 une intensit\xE9 donn\xE9e, mais aussi de la faire osciller \xE0 plusieurs fr\xE9quences.</p>'}};
doc['Led']['FindLed']={syn:'Permet de retrouver une led d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLed.FindLed()',pro:'def FindLed(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une led d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la led soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLed.isOnline()</tt> pour tester si la led est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la led sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLed</tt> qui permet ensuite de contr\xF4ler la led.'};
doc['Led']['FirstLed']={syn:'Commence l\x27\xE9num\xE9ration des leds accessibles par la librairie.',lib:'YLed.FirstLed()',pro:'def FirstLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des leds accessibles par la librairie. Utiliser la fonction <tt>YLed.nextLed()</tt> pour it\xE9rer sur les autres leds.</p>',ret:'un pointeur sur un objet <tt>YLed</tt>, correspondant \xE0 la premi\xE8re led accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de leds disponibles.'};
doc['Led']['get_advertisedValue']={syn:'Retourne la valeur courante de la led (pas plus de 6 caract\xE8res).',lib:'led.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la led (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la led (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Retourne le mode de signalisation de la led.',lib:'led.get_blinking()',pro:'def get_blinking()',cmt:'<p>Retourne le mode de signalisation de la led.</p>',ret:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr\xE9sentant le mode de signalisation de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'led.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Led']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'led.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Led']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'led.get_ledDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Led']['get_logicalName']={syn:'Retourne le nom logique de la led.',lib:'led.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la led.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Retourne l\x27intensit\xE9 de la led en pour cent.',lib:'led.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Retourne l\x27intensit\xE9 de la led en pour cent.</p>',ret:'un entier repr\xE9sentant l\x27intensit\xE9 de la led en pour cent',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'led.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Retourne l\x27\xE9tat courant de la led.',lib:'led.get_power()',pro:'def get_power()',cmt:'<p>Retourne l\x27\xE9tat courant de la led.</p>',ret:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Led']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'led.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Led']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'led.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['nextLed']={syn:'Continue l\x27\xE9num\xE9ration des leds commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt>.',lib:'led.nextLed()',pro:'def nextLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des leds commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt>.</p>',ret:'un pointeur sur un objet <tt>YLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Led']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'led.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Led']['set_blinking']={syn:'Modifie le mode de signalisation de la led.',lib:'led.set_blinking()',pro:'def set_blinking(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de signalisation de la led.</p>',par:{newval:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr\xE9sentant le mode de signalisation de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_logicalName']={syn:'Modifie le nom logique de la led.',lib:'led.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la led. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_luminosity']={syn:'Modifie l\x27intensit\xE9 lumineuse de la led (en pour cent).',lib:'led.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27intensit\xE9 lumineuse de la led (en pour cent).</p>',par:{newval:'un entier repr\xE9sentant l\x27intensit\xE9 lumineuse de la led (en pour cent)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_power']={syn:'Modifie l\x27\xE9tat courant de la led.',lib:'led.set_power()',pro:'def set_power(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat courant de la led.</p>',par:{newval:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'led.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Led)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Interface de la fonction Source de tension',inc:'from yocto_vsource import *',cmt:'<p>La librairie de programmation Yoctopuce permet de commande la tension de srotir du module. Vous pouvez affecter une valeur fixe,ou faire des transition de voltage.</p>'}};
doc['VSource']['FindVSource']={syn:'Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVSource.FindVSource()',pro:'def FindVSource(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la source de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVSource.isOnline()</tt> pour tester si la source de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la source de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVSource</tt> qui permet ensuite de contr\xF4ler la source de tension.'};
doc['VSource']['FirstVSource']={syn:'Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie.',lib:'YVSource.FirstVSource()',pro:'def FirstVSource()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie. Utiliser la fonction <tt>YVSource.nextVSource()</tt> pour it\xE9rer sur les autres sources de tension.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt>, correspondant \xE0 la premi\xE8re source de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sources de tension disponibles.'};
doc['VSource']['get_advertisedValue']={syn:'Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).',lib:'vsource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la source de tension (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_extPowerFailure']={syn:'Rend TRUE si le voltage de l\x27alimentation externe est trop bas.',lib:'vsource.get_extPowerFailure()',pro:'def get_extPowerFailure()',cmt:'<p>Rend TRUE si le voltage de l\x27alimentation externe est trop bas.</p>',ret:'soit <tt>Y_EXTPOWERFAILURE_FALSE</tt>, soit <tt>Y_EXTPOWERFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Indique si le module est en condition d\x27erreur.',lib:'vsource.get_failure()',pro:'def get_failure()',cmt:'<p>Indique si le module est en condition d\x27erreur. Il possible de savoir de quelle erreur il s\x27agit en testant get_overheat, get_overcurrent etc... Lorsqu\x27un condition d\x27erreur est rencont\xE9e, la tension de sortie est mise \xE0 z\xE9ro est ne peut pas \xEAtre chang\xE9e tant la fonction reset() n\x27aura pas appell\xE9e.</p>',ret:'soit <tt>Y_FAILURE_FALSE</tt>, soit <tt>Y_FAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'vsource.get_vsourceDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['VSource']['get_logicalName']={syn:'Retourne le nom logique de la source de tension.',lib:'vsource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la source de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'vsource.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.',lib:'vsource.get_overCurrent()',pro:'def get_overCurrent()',cmt:'<p>Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.</p>',ret:'soit <tt>Y_OVERCURRENT_FALSE</tt>, soit <tt>Y_OVERCURRENT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Rend TRUE si le module est en surchauffe.',lib:'vsource.get_overHeat()',pro:'def get_overHeat()',cmt:'<p>Rend TRUE si le module est en surchauffe.</p>',ret:'soit <tt>Y_OVERHEAT_FALSE</tt>, soit <tt>Y_OVERHEAT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.',lib:'vsource.get_overLoad()',pro:'def get_overLoad()',cmt:'<p>Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.</p>',ret:'soit <tt>Y_OVERLOAD_FALSE</tt>, soit <tt>Y_OVERLOAD_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.',lib:'vsource.get_regulationFailure()',pro:'def get_regulationFailure()',cmt:'<p>Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.</p>',ret:'soit <tt>Y_REGULATIONFAILURE_FALSE</tt>, soit <tt>Y_REGULATIONFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.',lib:'vsource.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la tension est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['VSource']['get_voltage']={syn:'Retourne la valeur de la commande de tension de sortie en mV ',lib:'vsource.get_voltage()',pro:'def get_voltage()',cmt:'<p>Retourne la valeur de la commande de tension de sortie en mV</p>',ret:'un entier repr\xE9sentant la valeur de la commande de tension de sortie en mV',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'vsource.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['VSource']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'vsource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['nextVSource']={syn:'Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'def nextVSource()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['VSource']['pulse']={syn:'Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.',lib:'vsource.pulse()',pro:'def pulse(<span id=pn>voltage</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.</p>',par:{voltage:'tension demand\xE9e, en millivolts',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'vsource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['VSource']['set_logicalName']={syn:'Modifie le nom logique de la source de tension.',lib:'vsource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la source de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'vsource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['VSource']['set_voltage']={syn:'R\xE8gle la tension de sortie du module (en milliVolts).',lib:'vsource.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle la tension de sortie du module (en milliVolts).</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['voltageMove']={syn:'D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e.',lib:'vsource.voltageMove()',pro:'def voltageMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e. </p>',par:{target:'nouvelle valeur de sortie \xE0 la fin de la transition, en milliVolts.',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Interface de la fonction Network',inc:'from yocto_network import *',cmt:'<p>Les objets YNetwork permettent de controller les param\xE8tres TCP/IP des modules Yoctopuce dot\xE9s d\x27une interface r\xE9seau.</p>'}};
doc['Network']['FindNetwork']={syn:'Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9.',lib:'YNetwork.FindNetwork()',pro:'def FindNetwork(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27interface r\xE9seau soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YNetwork.isOnline()</tt> pour tester si l\x27interface r\xE9seau est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YNetwork</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau.'};
doc['Network']['FirstNetwork']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie.',lib:'YNetwork.FirstNetwork()',pro:'def FirstNetwork()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie. Utiliser la fonction <tt>YNetwork.nextNetwork()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau disponibles.'};
doc['Network']['callbackLogin']={syn:'Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter.',lib:'network.callbackLogin()',pro:'def callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter. Le mot de passe ne sera pas stock\xE9 dans le module, mais seulement une version hash\xE9e non r\xE9versible. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{username:'nom d\x27utilisateur pour s\x27identifier au callback',password:'mot de passe pour s\x27identifier au callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['get_adminPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.',lib:'network.get_adminPassword()',pro:'def get_adminPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).',lib:'network.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Retourne une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.',lib:'network.get_callbackCredentials()',pro:'def get_callbackCredentials()',cmt:'<p>Retourne une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.get_callbackEncoding()',pro:'def get_callbackEncoding()',cmt:'<p>Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> et <tt>Y_CALLBACKENCODING_YOCTO_API</tt> repr\xE9sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Retourne l\x27attente maximale entre deux notifications par callback, en secondes.',lib:'network.get_callbackMaxDelay()',pro:'def get_callbackMaxDelay()',cmt:'<p>Retourne l\x27attente maximale entre deux notifications par callback, en secondes.</p>',ret:'un entier repr\xE9sentant l\x27attente maximale entre deux notifications par callback, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.get_callbackMethod()',pro:'def get_callbackMethod()',cmt:'<p>Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr\xE9sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Retourne l\x27attente minimale entre deux notifications par callback, en secondes.',lib:'network.get_callbackMinDelay()',pro:'def get_callbackMinDelay()',cmt:'<p>Retourne l\x27attente minimale entre deux notifications par callback, en secondes.</p>',ret:'un entier repr\xE9sentant l\x27attente minimale entre deux notifications par callback, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.get_callbackUrl()',pro:'def get_callbackUrl()',cmt:'<p>Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Retourne l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).',lib:'network.get_discoverable()',pro:'def get_discoverable()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).</p>',ret:'soit <tt>Y_DISCOVERABLE_FALSE</tt>, soit <tt>Y_DISCOVERABLE_TRUE</tt>, selon l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'network.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Network']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'network.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Network']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'network.get_networkDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Network']['get_ipAddress']={syn:'Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce.',lib:'network.get_ipAddress()',pro:'def get_ipAddress()',cmt:'<p>Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce. Il peut s\x27agir d\x27une adresse configur\xE9e statiquement, ou d\x27une adresse re\xE7ue par un serveur DHCP.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP utilis\xE9e par le module Yoctopuce',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.',lib:'network.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module.',lib:'network.get_macAddress()',pro:'def get_macAddress()',cmt:'<p>Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module. L\x27adresse MAC est aussi pr\xE9sente sur un autocollant sur le module, repr\xE9sent\xE9e en chiffres et en code-barres.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'network.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Network']['get_poeCurrent']={syn:'Retourne le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res.',lib:'network.get_poeCurrent()',pro:'def get_poeCurrent()',cmt:'<p>Retourne le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res. La consommation est mesur\xE9e apr\xE8s conversion en 5 Volt, et ne doit jamais d\xE9passer 1800 mA.</p>',ret:'un entier repr\xE9sentant le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Retourne l\x27adresse IP du serveur de noms primaire que le module doit utiliser.',lib:'network.get_primaryDNS()',pro:'def get_primaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de noms primaire que le module doit utiliser.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de noms primaire que le module doit utiliser',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau.',lib:'network.get_readiness()',pro:'def get_readiness()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau. Le niveau z\xE9ro (DOWN_0) signifie qu\x27aucun support r\xE9seau mat\xE9riel n\x27a \xE9t\xE9 d\xE9tect\xE9. Soit il n\x27y a pas de signal sur le cable r\xE9seau, soit le point d\x27acc\xE8s sans fil choisi n\x27est pas d\xE9tect\xE9. Le niveau 1 (LIVE_1) est atteint lorsque le r\xE9seau est d\xE9tect\xE9, mais n\x27est pas encore connect\xE9. Pour un r\xE9seau sans fil, cela confirme la l\x27existence du SSID configur\xE9. Le niveau 2 (LINK_2) est atteint lorsque le support mat\xE9riel du r\xE9seau est fonctionnel. Pour une connection r\xE9seau filaire, le niveau 2 signifie que le cable est connect\xE9 aux deux bouts. Pour une connection \xE0 un point d\x27acc\xE8s r\xE9seau sans fil, il d\xE9montre que les param\xE8tres de s\xE9curit\xE9s configur\xE9s sont corrects. Pour une connection sans fil en mode ad-hoc, cela signifie qu\x27il y a au moins un partenaire sur le r\xE9seau ad-hoc. Le niveau 3 (DHCP_3) est atteint lorsque qu\x27une adresse IP a \xE9t\xE9 obtenue par DHCP. Le niveau 4 (DNS_4) est atteint lorsqu\x27un serveur DNS est joignable par le r\xE9seau. Le niveau 5 (WWW_5) est atteint lorsque la connectivit\xE9 globale \xE0 internet est av\xE9r\xE9e par l\x27obtention de l\x27heure courante sur une serveur NTP.</p>',ret:'une valeur parmi <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> et <tt>Y_READINESS_WWW_OK</tt> repr\xE9sentant l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).',lib:'network.get_router()',pro:'def get_router()',cmt:'<p>Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Retourne l\x27adresse IP du serveur de noms secondaire que le module doit utiliser.',lib:'network.get_secondaryDNS()',pro:'def get_secondaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de noms secondaire que le module doit utiliser.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de noms secondaire que le module doit utiliser',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.',lib:'network.get_subnetMask()',pro:'def get_subnetMask()',cmt:'<p>Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le masque de sous-r\xE9seau utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Network']['get_userPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.',lib:'network.get_userPassword()',pro:'def get_userPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Retourne la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet.',lib:'network.get_wwwWatchdogDelay()',pro:'def get_wwwWatchdogDelay()',cmt:'<p>Retourne la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet. Une valeur nulle d\xE9sactive le red\xE9marrage automatique en cas de perte de connectivit\xE9 WWW.</p>',ret:'un entier repr\xE9sentant la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'network.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Network']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'network.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['nextNetwork']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'def nextNetwork()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt>.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Network']['ping']={syn:'Ping str_host pour v\xE9rifier la connexion r\xE9seau.',lib:'network.ping()',pro:'def ping(<span id=pn>host</span>)',cmt:'<p>Ping str_host pour v\xE9rifier la connexion r\xE9seau. Envoie quatre requ\xEAtes ICMP ECHO_RESPONSER \xE0 la cible str_host depuis le module. Cette m\xE9thode retourne une cha\xEEne de caract\xE8res avec le r\xE9sultat des 4 requ\xEAtes ICMP ECHO_RESPONSE.</p>',par:{host:'le nom d\x27h\xF4te ou l\x27adresse IP de la cible'},ret:'une cha\xEEne de caract\xE8res contenant le r\xE9sultat du ping.'};
doc['Network']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'network.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Network']['set_adminPassword']={syn:'Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module.',lib:'network.set_adminPassword()',pro:'def set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackCredentials']={syn:'Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback.',lib:'network.set_callbackCredentials()',pro:'def set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback. Le laisser-passer doit \xEAtre fourni tel que retourn\xE9 par la fonction <tt>get_callbackCredentials</tt>, sous la forme <tt>username:hash</tt>. La valeur du hash d\xE9pend de la m\xE9thode d\x27autorisation impl\xE9ment\xE9e par le callback. Pour une autorisation de type Basic, le hash est le MD5 de la cha\xEEne <tt>username:password</tt>. Pour une autorisation de type Digest, le hash est le MD5 de la cha\xEEne <tt>username:realm:password</tt>. Pour une utilisation simplifi\xE9e, utilisez la fonction <tt>callbackLogin</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le laisser-passer pour se connecter \xE0 l\x27adresse de callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackEncoding']={syn:'Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.set_callbackEncoding()',pro:'def set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> et <tt>Y_CALLBACKENCODING_YOCTO_API</tt> repr\xE9sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMaxDelay']={syn:'Modifie l\x27attente maximale entre deux notifications par callback, en secondes.',lib:'network.set_callbackMaxDelay()',pro:'def set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente maximale entre deux notifications par callback, en secondes.</p>',par:{newval:'un entier repr\xE9sentant l\x27attente maximale entre deux notifications par callback, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMethod']={syn:'Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.set_callbackMethod()',pro:'def set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr\xE9sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMinDelay']={syn:'Modifie l\x27attente minimale entre deux notifications par callback, en secondes.',lib:'network.set_callbackMinDelay()',pro:'def set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente minimale entre deux notifications par callback, en secondes.</p>',par:{newval:'un entier repr\xE9sentant l\x27attente minimale entre deux notifications par callback, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackUrl']={syn:'Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.set_callbackUrl()',pro:'def set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_discoverable']={syn:'Modifie l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).',lib:'network.set_discoverable()',pro:'def set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).</p>',par:{newval:'soit <tt>Y_DISCOVERABLE_FALSE</tt>, soit <tt>Y_DISCOVERABLE_TRUE</tt>, selon l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.',lib:'network.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_primaryDNS']={syn:'Modifie l\x27adresse IP du serveur de noms primaire que le module doit utiliser.',lib:'network.set_primaryDNS()',pro:'def set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de noms primaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de noms primaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_secondaryDNS']={syn:'Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser.',lib:'network.set_secondaryDNS()',pro:'def set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de nom secondaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'network.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Network']['set_userPassword']={syn:'Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module.',lib:'network.set_userPassword()',pro:'def set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Modifie la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet.',lib:'network.set_wwwWatchdogDelay()',pro:'def set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet. Une valeur nulle d\xE9sactive le red\xE9marrage automatique en cas de perte de connectivit\xE9 WWW. La plus petite dur\xE9e non-nulle utilisable est 90 secondes.</p>',par:{newval:'un entier repr\xE9sentant la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useDHCP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP.',lib:'network.useDHCP()',pro:'def useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP. En attendant qu\x27une adresse soit re\xE7ue (et ind\xE9finiment si aucun serveur DHCP ne r\xE9pond), le module utilisera les param\xE8tres IP sp\xE9cifi\xE9s \xE0 cette fonction. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{fallbackIpAddr:'adresse IP \xE0 utiliser si aucun serveur DHCP ne r\xE9pond',fallbackSubnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser si aucun serveur DHCP ne r\xE9pond. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',fallbackRouter:'adresse de la passerelle \xE0 utiliser si aucun serveur DHCP ne r\xE9pond'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useStaticIP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique).',lib:'network.useStaticIP()',pro:'def useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ipAddress:'adresse IP \xE0 utiliser par le module',subnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',router:'adresse IP de la passerelle \xE0 utiliser (\x22default gateway\x22)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Interface de la fonction Wireless',inc:'from yocto_wireless import *'}};
doc['Wireless']['FindWireless']={syn:'Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWireless.FindWireless()',pro:'def FindWireless(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27interface r\xE9seau sans fil soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWireless.isOnline()</tt> pour tester si l\x27interface r\xE9seau sans fil est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans fil sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWireless</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau sans fil.'};
doc['Wireless']['FirstWireless']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie.',lib:'YWireless.FirstWireless()',pro:'def FirstWireless()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie. Utiliser la fonction <tt>YWireless.nextWireless()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau sans fil.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau sans fil accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau sans fil disponibles.'};
doc['Wireless']['adhocNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22.',lib:'wireless.adhocNetwork()',pro:'def adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22. Si une clef d\x27acc\xE8s est sp\xE9cifi\xE9e, le r\xE9seau sera prot\xE9g\xE9 par une s\xE9curit\xE9 WEP128 (l\x27utilisation de WPA n\x27est pas standardis\xE9e en mode ad-hoc). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 cr\xE9er',securityKey:'cl\xE9 d\x27acc\xE8s de r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).',lib:'wireless.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Retourne le num\xE9ro du canal 802.',lib:'wireless.get_channel()',pro:'def get_channel()',cmt:'<p>Retourne le num\xE9ro du canal 802.11 utilis\xE9, ou 0 si le r\xE9seau s\xE9lectionn\xE9 n\x27a pas \xE9t\xE9 trouv\xE9.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du canal 802',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les r\xE9seaux sans fils d\xE9tect\xE9s.',lib:'wireless.get_detectedWlans()',pro:'def get_detectedWlans()',cmt:'<p>Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les r\xE9seaux sans fils d\xE9tect\xE9s. La liste n\x27est pas mise \xE0 jour quand le module est d\xE9j\xE0 connect\xE9 \xE0 un acc\xE8s sans fil (mode \x22infrastructure\x22). Pour forcer la d\xE9tection des r\xE9seaux sans fil, il faut appeler <tt>addhocNetwork()</tt> pour se d\xE9connecter du r\xE9seau actuel. L\x27appelant est responsable de la d\xE9sallocation de la liste retourn\xE9e.</p>',ret:'une liste d\x27objets <tt>YWlanRecord</tt>, contenant le SSID, le canal, la qualit\xE9 du signal, et l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['Wireless']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wireless.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Wireless']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wireless.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Wireless']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wireless.get_wirelessDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Wireless']['get_linkQuality']={syn:'Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.',lib:'wireless.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.</p>',ret:'un entier repr\xE9sentant la qualit\xE9 de la connection, exprim\xE9e en pourcents',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau sans fil.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.',lib:'wireless.get_message()',pro:'def get_message()',cmt:'<p>Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wireless.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9.',lib:'wireless.get_security()',pro:'def get_security()',cmt:'<p>Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9.</p>',ret:'une valeur parmi <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> et <tt>Y_SECURITY_WPA2</tt> repr\xE9sentant l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Retourne le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9.',lib:'wireless.get_ssid()',pro:'def get_ssid()',cmt:'<p>Retourne le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Wireless']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'wireless.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Wireless']['joinNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22).',lib:'wireless.joinNetwork()',pro:'def joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 utiliser',securityKey:'cl\xE9 d\x27acc\xE8s au r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wireless.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['nextWireless']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt>.',lib:'wireless.nextWireless()',pro:'def nextWireless()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Wireless']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wireless.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Wireless']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau sans fil. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wireless.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Interface de la fonction Voc',inc:'from yocto_voc import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Voc']['FindVoc']={syn:'Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoc.FindVoc()',pro:'def FindVoc(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de Compos\xE9s Organiques Volatils soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoc.isOnline()</tt> pour tester si le capteur de Compos\xE9s Organiques Volatils est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de Compos\xE9s Organiques Volatils sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoc</tt> qui permet ensuite de contr\xF4ler le capteur de Compos\xE9s Organiques Volatils.'};
doc['Voc']['FirstVoc']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie.',lib:'YVoc.FirstVoc()',pro:'def FirstVoc()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie. Utiliser la fonction <tt>YVoc.nextVoc()</tt> pour it\xE9rer sur les autres capteurs de Compos\xE9s Organiques Volatils.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt>, correspondant \xE0 le premier capteur de Compos\xE9s Organiques Volatils accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de Compos\xE9s Organiques Volatils disponibles.'};
doc['Voc']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).',lib:'voc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'voc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'voc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voc']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voc']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voc.get_vocDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voc']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'voc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'voc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voc.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voc']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'voc.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voc']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'voc.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Voc']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['nextVoc']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt>.',lib:'voc.nextVoc()',pro:'def nextVoc()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voc']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voc']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_logicalName']={syn:'Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Interface de la fonction Watchdog',inc:'from yocto_watchdog import *',cmt:'<p>La fonction WatchDog est g\xE9r\xE9e comme un relais qui couperait bri\xE8vement l\x27alimentation d\x27un appareil apr\xE8s un d\x27attente temps donn\xE9 afin de provoquer une r\xE9initialisation compl\xE8te de cet appareil. Il suffit d\x27appeler le watchdog \xE0 intervale r\xE9gulier pour l\x27emp\xE8cher de provoquer la r\xE9initialisation. Le watchog peut aussi \xEAtre pilot\xE9 directement \xE0 l\x27aide des methode <i>pulse</i> et <i>delayedpulse</i> pour \xE9teindre un appareil pendant un temps donn\xE9.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWatchdog.FindWatchdog()',pro:'def FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le watchdog soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWatchdog.isOnline()</tt> pour tester si le watchdog est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le watchdog sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWatchdog</tt> qui permet ensuite de contr\xF4ler le watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie.',lib:'YWatchdog.FirstWatchdog()',pro:'def FirstWatchdog()',cmt:'<p>Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie. Utiliser la fonction <tt>YWatchdog.nextWatchdog()</tt> pour it\xE9rer sur les autres watchdog.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt>, correspondant \xE0 le premier watchdog accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de watchdog disponibles.'};
doc['Watchdog']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'watchdog.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27implusion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['get_advertisedValue']={syn:'Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).',lib:'watchdog.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du watchdog (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.',lib:'watchdog.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watchdog \xE0 la mise sous tension du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'watchdog.get_countdown()',pro:'def get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'watchdog.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Watchdog']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'watchdog.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Watchdog']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'watchdog.get_watchdogDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Watchdog']['get_logicalName']={syn:'Retourne le nom logique du watchdog.',lib:'watchdog.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du watchdog.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'watchdog.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.get_output()',pro:'def get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'watchdog.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Retourne l\x27\xE9tat du watchdog.',lib:'watchdog.get_running()',pro:'def get_running()',cmt:'<p>Retourne l\x27\xE9tat du watchdog.</p>',ret:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon l\x27\xE9tat du watchdog',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.get_state()',pro:'def get_state()',cmt:'<p>Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDelay()',pro:'def get_triggerDelay()',cmt:'<p>Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr\xE9sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDuration()',pro:'def get_triggerDuration()',cmt:'<p>Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr\xE9sentant la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Watchdog']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'watchdog.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Watchdog']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'watchdog.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['nextWatchdog']={syn:'Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt>.',lib:'watchdog.nextWatchdog()',pro:'def nextWatchdog()',cmt:'<p>Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Watchdog']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'watchdog.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'watchdog.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Watchdog']['resetWatchdog']={syn:'R\xE9initialise le WatchDog.',lib:'watchdog.resetWatchdog()',pro:'def resetWatchdog()',cmt:'<p>R\xE9initialise le WatchDog. Quand le watchdog est en fonctionnement cette fonction doit \xEAtre appel\xE9e \xE0 interval r\xE9gulier, pour emp\xE9cher que le watdog ne se d\xE9clenche</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_autoStart']={syn:'Modifie l\x27\xE9tat du watching au d\xE9marrage du module.',lib:'watchdog.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watching au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watching au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_logicalName']={syn:'Modifie le nom logique du watchdog.',lib:'watchdog.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du watchdog. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_running']={syn:'Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.',lib:'watchdog.set_running()',pro:'def set_running(<span id=pn>newval</span>)',cmt:'<p>Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.</p>',par:{newval:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon manuellement l\x27\xE9tat de fonctionnement du watchdog'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_state']={syn:'Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_triggerDelay']={syn:'Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.set_triggerDelay()',pro:'def set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',par:{newval:'un entier repr\xE9sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_triggerDuration']={syn:'Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.',lib:'watchdog.set_triggerDuration()',pro:'def set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.</p>',par:{newval:'un entier repr\xE9sentant la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'watchdog.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Interface de la fonction Power',inc:'from yocto_power import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Power']['FindPower']={syn:'Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPower.FindPower()',pro:'def FindPower(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de puissance electrique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPower.isOnline()</tt> pour tester si le capteur de puissance electrique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de puissance electrique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPower</tt> qui permet ensuite de contr\xF4ler le capteur de puissance electrique.'};
doc['Power']['FirstPower']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie.',lib:'YPower.FirstPower()',pro:'def FirstPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie. Utiliser la fonction <tt>YPower.nextPower()</tt> pour it\xE9rer sur les autres capteurs de puissance electrique.</p>',ret:'un pointeur sur un objet <tt>YPower</tt>, correspondant \xE0 le premier capteur de puissance electrique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de puissance electrique disponibles.'};
doc['Power']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'power.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).',lib:'power.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).',lib:'power.get_cosPhi()',pro:'def get_cosPhi()',cmt:'<p>Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).</p>',ret:'une valeur num\xE9rique repr\xE9sentant le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'power.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'power.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'power.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Power']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'power.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Power']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'power.get_powerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Power']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'power.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Retourne le nom logique du capteur de puissance electrique.',lib:'power.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de puissance electrique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'power.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e.',lib:'power.get_meter()',pro:'def get_meter()',cmt:'<p>Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e. Ce compteur est r\xE9initialis\xE9 \xE0 chaque d\xE9marrage du module.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes ',lib:'power.get_meterTimer()',pro:'def get_meterTimer()',cmt:'<p>Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes</p>',ret:'un entier repr\xE9sentant le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'power.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Power']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'power.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'power.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Power']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'power.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Power']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'power.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['nextPower']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt>.',lib:'power.nextPower()',pro:'def nextPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt>.</p>',ret:'un pointeur sur un objet <tt>YPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Power']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'power.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Power']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'power.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_logicalName']={syn:'Modifie le nom logique du capteur de puissance electrique.',lib:'power.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de puissance electrique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'power.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs mesur\xE9es.',lib:'power.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Changer la r\xE9solution ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'power.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Interface de la fonction Display',inc:'from yocto_display import *',cmt:'<p>L\x27interface de contr\xF4le des \xE9crans Yoctopuce est con\xE7ue pour afficher facilement des informations et des images. Le module est capable de g\xE9rer seul la superposition de plusieurs couches graphiques, qui peuvent \xEAtre dessin\xE9es individuellement, sans affichage imm\xE9diat, puis librement positionn\xE9es sur l\x27\xE9cran. Il est aussi capable de rejouer des s\xE9quences de commandes pr\xE9-enregistr\xE9es (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDisplay.FindDisplay()',pro:'def FindDisplay(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27ecran soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDisplay.isOnline()</tt> pour tester si l\x27ecran est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27ecran sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDisplay</tt> qui permet ensuite de contr\xF4ler l\x27ecran.'};
doc['Display']['FirstDisplay']={syn:'Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie.',lib:'YDisplay.FirstDisplay()',pro:'def FirstDisplay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie. Utiliser la fonction <tt>YDisplay.nextDisplay()</tt> pour it\xE9rer sur les autres \xE9cran.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt>, correspondant \xE0 le premier \xE9cran accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de \xE9cran disponibles.'};
doc['Display']['copyLayerContent']={syn:'Copie le contentu d\x27un couche d\x27affichage vers une autre couche.',lib:'display.copyLayerContent()',pro:'def copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copie le contentu d\x27un couche d\x27affichage vers une autre couche. La couleur et la transparence de tous les pixels de la couche de destination sont chang\xE9s pour correspondre \xE0 la couche source. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{srcLayerId:'l\x27identifiant de la couche d\x27origine (un chiffre parmi 0..layerCount-1)',dstLayerId:'l\x27identifiant de la couche de destination (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['fade']={syn:'Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.',lib:'display.fade()',pro:'def fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.</p>',par:{brightness:'nouvelle valeur de luminosit\xE9 de l\x27\xE9cran',duration:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).',lib:'display.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'display.get_brightness()',pro:'def get_brightness()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Retourne la hauteur de l\x27\xE9cran, en pixels.',lib:'display.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Retourne la hauteur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayType']={syn:'Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.',lib:'display.get_displayType()',pro:'def get_displayType()',cmt:'<p>Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.</p>',ret:'une valeur parmi <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> et <tt>Y_DISPLAYTYPE_RGB</tt> repr\xE9sentant le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Retourne la largeur de l\x27\xE9cran, en pixels.',lib:'display.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Retourne la largeur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'display.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Display']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'display.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Display']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'display.get_displayDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Display']['get_layerCount']={syn:'Retourne le nombre des couches affichables disponibles.',lib:'display.get_layerCount()',pro:'def get_layerCount()',cmt:'<p>Retourne le nombre des couches affichables disponibles.</p>',ret:'un entier repr\xE9sentant le nombre des couches affichables disponibles',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Retourne la hauteur des couches affichables, en pixels.',lib:'display.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Retourne la hauteur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur des couches affichables, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Retourne la largeur des couches affichables, en pixels.',lib:'display.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Retourne la largeur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur des couches affichables, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Retourne le nom logique de l\x27ecran.',lib:'display.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27ecran.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'display.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.',lib:'display.get_orientation()',pro:'def get_orientation()',cmt:'<p>Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.</p>',ret:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr\xE9sentant l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_powerState']={syn:'Retourne l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.',lib:'display.get_powerState()',pro:'def get_powerState()',cmt:'<p>Retourne l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.</p>',ret:'soit <tt>Y_POWERSTATE_OFF</tt>, soit <tt>Y_POWERSTATE_ON</tt>, selon l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.get_startupSeq()',pro:'def get_startupSeq()',cmt:'<p>Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Display']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'display.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Display']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'display.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['newSequence']={syn:'Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement.',lib:'display.newSequence()',pro:'def newSequence()',cmt:'<p>Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement. Le nom de la s\xE9quence sera donn\xE9 au moment de l\x27appel \xE0 <tt>saveSequence()</tt>, une fois la s\xE9quence termin\xE9e.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['nextDisplay']={syn:'Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt>.',lib:'display.nextDisplay()',pro:'def nextDisplay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Display']['pauseSequence']={syn:'Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active.',lib:'display.pauseSequence()',pro:'def pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active. Cette m\xE9thode peut \xEAtre utilis\xE9e lors de l\x27enregistrement d\x27une s\xE9quence d\x27affichage, pour ins\xE9rer une attente mesur\xE9e lors de l\x27ex\xE9cution (mais sans effet imm\xE9diat). Cette m\xE9thode peut aussi \xEAtre appel\xE9e dynamiquement pendant l\x27ex\xE9cution d\x27une s\xE9quence enregistr\xE9e, pour suspendre temporairement ou reprendre l\x27ex\xE9cution. Pour annuler une attente, appelez simplement la m\xE9thode avec une attente de z\xE9ro.</p>',par:{delay_ms:'la dur\xE9e de l\x27attente, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['playSequence']={syn:'Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'def playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'display.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Display']['resetAll']={syn:'Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial.',lib:'display.resetAll()',pro:'def resetAll()',cmt:'<p>Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['saveSequence']={syn:'Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi.',lib:'display.saveSequence()',pro:'def saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi. La s\xE9quence peut \xEAtre rejou\xE9e ult\xE9rieurement \xE0 l\x27aide de la m\xE9thode <tt>playSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_brightness']={syn:'Modifie la luminosit\xE9de l\x27\xE9cran.',lib:'display.set_brightness()',pro:'def set_brightness(<span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9de l\x27\xE9cran. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la luminosit\xE9de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_logicalName']={syn:'Modifie le nom logique de l\x27ecran.',lib:'display.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27ecran. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_orientation']={syn:'Modifie l\x27orientation de l\x27\xE9cran.',lib:'display.set_orientation()',pro:'def set_orientation(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27orientation de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr\xE9sentant l\x27orientation de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_powerState']={syn:'Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.',lib:'display.set_powerState()',pro:'def set_powerState(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.</p>',par:{newval:'soit <tt>Y_POWERSTATE_OFF</tt>, soit <tt>Y_POWERSTATE_ON</tt>, selon l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_startupSeq']={syn:'Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.set_startupSeq()',pro:'def set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'display.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Display']['stopSequence']={syn:'Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran.',lib:'display.stopSequence()',pro:'def stopSequence()',cmt:'<p>Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran. L\x27affichage est laiss\xE9 tel quel.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['swapLayerContent']={syn:'Permute le contentu de deux couches d\x27affichage.',lib:'display.swapLayerContent()',pro:'def swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Permute le contentu de deux couches d\x27affichage. La couleur et la transparence de tous les pixels des deux couches sont permut\xE9es. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. En particulier, la visibilit\xE9 des deux couches reste inchang\xE9e. Cela permet d\x27impl\xE9menter tr\xE8s efficacement un affichage par double-buffering, en utilisant une couche cach\xE9e et une couche visible. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{layerIdA:'l\x27identifiant de la premi\xE8re couche (un chiffre parmi 0..layerCount-1)',layerIdB:'l\x27identifiant de la deuxi\xE8me couche (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['upload']={syn:'T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'display.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.',content:'contenu du fichier \xE0 t\xE9l\xE9charger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'Interface des objets DisplayLayer',inc:'from yocto_display import *',cmt:'<p>Un DisplayLayer est une couche de contenu affichable (images, texte, etc.). Le contenu n\x27est visible sur l\x27\xE9cran que lorsque la couche est active sur l\x27\xE9cran (et non masqu\xE9e par une couche sup\xE9rieure).</p>'}};
doc['DisplayLayer']['clear']={syn:'Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente.',lib:'displaylayer.clear()',pro:'def clear()',cmt:'<p>Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente. Cette m\xE9thode ne change pas les r\xE9glages de le couche. Si vous d\xE9sirez remettre la couche dans son \xE9tat initial, utilisez plut\xF4t la m\xE9thode <tt>reset()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['clearConsole']={syn:'Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.',lib:'displaylayer.clearConsole()',pro:'def clearConsole()',cmt:'<p>Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['consoleOut']={syn:'Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte.',lib:'displaylayer.consoleOut()',pro:'def consoleOut(<span id=pn>text</span>)',cmt:'<p>Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte. Le curseur revient automatiquement en d\xE9but de ligne suivante lorsqu\x27un saut de ligne est rencontr\xE9, ou lorsque la marge droite est atteinte. Lorsque le texte \xE0 afficher s\x27appr\xEAte \xE0 d\xE9passer la marge inf\xE9rieure, le contenu de la zone de console est automatiquement d\xE9cal\xE9 vers le haut afin de laisser la place \xE0 la nouvelle ligne de texte.</p>',par:{text:'le message \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBar']={syn:'Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawBar()',pro:'def drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBitmap']={syn:'Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawBitmap()',pro:'def drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche. Le bitmap est pass\xE9 sous forme d\x27un objet binaire, o\xF9 chaque bit correspond \xE0 un pixel, de gauche \xE0 droite et de haut en bas. Le bit de poids fort de chaque octet correspond au pixel de gauche, et le bit de poids faible au pixel le plus \xE0 droite. Les bits \xE0 1 sont dessin\xE9s avec la couleur active de la couche. Les bits \xE0 0 avec la couleur de fond sp\xE9cifi\xE9e, sauf si la valeur -1 a \xE9t\xE9 choisie, auquel cas ils ne sont pas dessin\xE9s (ils sont consid\xE9r\xE9s comme transparents). Chaque ligne commence sur un nouvel octet. La hauteur du bitmap est donn\xE9e implicitement par la taille de l\x27objet binaire.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du bitmap',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du bitmap',w:'la largeur du bitmap, en pixels',bitmap:'l\x27objet binaire contenant le bitmap',bgcol:'le niveau de gris \xE0 utiliser pour les bits \xE0 z\xE9ro (0 = noir, 255 = blanc), ou -1 pour lasser les pixels inchang\xE9s'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawCircle']={syn:'Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawCircle()',pro:'def drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du cercle',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du cercle',r:'le rayon du cercle, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawDisc']={syn:'Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawDisc()',pro:'def drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du disque',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du disque',r:'le rayon du disque, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawImage']={syn:'Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawImage()',pro:'def drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche. L\x27image GIF doit avoir \xE9t\xE9 pr\xE9alablement pr\xE9charg\xE9e dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une image bitmap, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier d\x27image manquant ou d\x27un format de fichier invalide.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche de l\x27image',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur de l\x27image',imagename:'le nom du fichier GIF \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawPixel']={syn:'Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawPixel()',pro:'def drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche',y:'la distance en pixels depuis le haut de la couche'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawRect']={syn:'Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawRect()',pro:'def drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawText']={syn:'Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawText()',pro:'def drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche. Le point du texte qui sera align\xE9 sur la position sp\xE9cifi\xE9e est appel\xE9 point d\x27ancrage, et peut \xEAtre choisi parmi plusieurs options.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point d\x27ancrage du texte',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point d\x27ancrage du texte',anchor:'le point d\x27ancrage du texte, choisi parmi l\x27\xE9num\xE9ration <tt>Y_ALIGN</tt>: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'le texte \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['get_display']={syn:'Retourne l\x27YDisplay parent.',lib:'displaylayer.get_display()',pro:'def get_display()',cmt:'<p>Retourne l\x27YDisplay parent. Retourne l\x27objet YDisplay parent du YDisplayLayer courant.</p>',ret:'un objet <tt>YDisplay</tt>'};
doc['DisplayLayer']['hide']={syn:'Cache la couche de dessin.',lib:'displaylayer.hide()',pro:'def hide()',cmt:'<p>Cache la couche de dessin. L\x27etat de la couche est pr\xE9serv\xE9, mais la couche ne sera plus plus affich\xE9s \xE0 l\x27\xE9cran jusqu\x27au prochain appel \xE0 <tt>unhide()</tt>. Le fait de cacher la couche am\xE9liore les performances de toutes les primitives d\x27affichage, car il \xE9vite de consacrer inutilement des cycles de calcul \xE0 afficher les \xE9tats interm\xE9diaires (technique de double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['lineTo']={syn:'Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.lineTo()',pro:'def lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e. Le pixel final sp\xE9cifi\xE9 est inclus dans la ligne dessin\xE9e. Le point de dessin courant est d\xE9plac\xE9 \xE0 au point final de la ligne.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point final',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point final'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['moveTo']={syn:'D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.moveTo()',pro:'def moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche de dessin',y:'la distance en pixels depuis le haut de la couche de dessin'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['reset']={syn:'Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut).',lib:'displaylayer.reset()',pro:'def reset()',cmt:'<p>Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut). R\xE9initialise la position du point de dessin courant au coin sup\xE9rieur gauche, et la couleur de dessin \xE0 la valeur la plus lumineuse. Si vous d\xE9sirez simplement effacer le contenu de la couche, utilisez plut\xF4t la m\xE9thode <tt>clear()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectColorPen']={syn:'Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectColorPen()',pro:'def selectColorPen(<span id=pn>color</span>)',cmt:'<p>Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. La couleur est fournie sous forme de couleur RGB. Pour les \xE9crans monochromes ou en niveaux de gris, la couleur est automatiquement ramen\xE9e dans les valeurs permises.</p>',par:{color:'la couleur RGB d\xE9sir\xE9e (sous forme d\x27entier 24 bits)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectEraser']={syn:'Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de l\x27affichage de texte et de copie d\x27images bitmaps.',lib:'displaylayer.selectEraser()',pro:'def selectEraser()',cmt:'<p>Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de l\x27affichage de texte et de copie d\x27images bitmaps. Tous les points dessin\xE9s \xE0 la gomme redeviennent transparents (comme ils l\x27\xE9taient lorsque la couche \xE9tait vide), rendant ainsi visibles les couches inf\xE9rieures.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectFont']={syn:'S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes.',lib:'displaylayer.selectFont()',pro:'def selectFont(<span id=pn>fontname</span>)',cmt:'<p>S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes. La police est sp\xE9cifi\xE9e par le nom de son fichier. Vous pouvez utiliser l\x27une des polices pr\xE9d\xE9finies dans le module, ou une autre police que vous avez pr\xE9alablement pr\xE9charg\xE9 dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une police de caract\xE8res, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier de police manquant ou d\x27un format de fichier invalide.</p>',par:{fontname:'le nom du fichier d\xE9finissant la police de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectGrayPen()',pro:'def selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. Le niveau de gris est fourni sous forme d\x27un chiffre allant de 0 (noir) \xE0 255 (blanc, ou la couleur la plus claire de l\x27\xE9cran, quelle qu\x27elle soit). Pour les \xE9crans monochromes (sans niveaux de gris), tout valeur inf\xE9rieure \xE0 128 conduit \xE0 un point noir, et toue valeur sup\xE9rieure ou \xE9gale \xE0 128 devient un point lumineux.</p>',par:{graylevel:'le niveau de gris d\xE9sir\xE9, de 0 \xE0 255'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles.',lib:'displaylayer.setAntialiasingMode()',pro:'def setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles. L\x27anti-aliasing est att\xE9nue la pixelisation des images lorsqu\x27on regarde l\x27\xE9cran depuis une distance suffisante, mais peut aussi donner parfois une impression de flou lorsque l\x27\xE9cran est regard\xE9 de tr\xE8s pr\xE8s. Au final, c\x27est un choix esth\xE9tique qui vous revient. L\x27anti-aliasing est activ\xE9 par d\xE9faut pour les \xE9crans en niveaux de gris et les \xE9crans couleurs, mais vous pouvez le d\xE9sactiver si vous pr\xE9f\xE9rez. Ce r\xE9glage n\x27a pas d\x27effet sur les \xE9crans monochromes.</p>',par:{mode:'<t>true</t> pour activer l\x27antialiasing, <t>false</t> pour le d\xE9sactiver.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.',lib:'displaylayer.setConsoleBackground()',pro:'def setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.</p>',par:{bgcol:'le niveau de gris \xE0 utiliser pour le fond lors de d\xE9filement (0 = noir, 255 = blanc), ou -1 pour un fond transparent'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleMargins()',pro:'def setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge gauche',y1:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge sup\xE9rieure',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge droite',y2:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge inf\xE9rieure'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleWordWrap()',pro:'def setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.</p>',par:{wordwrap:'<tt>true</tt> pour retourner \xE0 la ligne entre les mots seulements, <tt>false</tt> pour retourner \xE0 l\x27extr\xEAme droite de chaque ligne.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setLayerPosition']={syn:'D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran.',lib:'displaylayer.setLayerPosition()',pro:'def setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran. Lorsqu\x27une dur\xE9e de d\xE9filement est configur\xE9e, la position d\x27affichage de la couche est automatiquement mise \xE0 jour durant les millisecondes suivantes pour animer le d\xE9placement.</p>',par:{x:'la distance en pixels depuis la gauche de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',y:'la distance en pixels depuis le haut de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',scrollTime:'dur\xE9e en millisecondes du d\xE9placement, ou 0 si le d\xE9placement doit \xEAtre imm\xE9diat.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['unhide']={syn:'Affiche la couche.',lib:'displaylayer.unhide()',pro:'def unhide()',cmt:'<p>Affiche la couche. Affiche a nouveau la couche apr\xE8s la command hide.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Files)
doc['Files']={'':{syn:'Interface de la fonction Files',inc:'from yocto_files import *',cmt:'<p>L\x27interface de stockage de fichiers permet de stocker des fichiers sur certains modules, par exemple pour personnaliser un service web (dans le cas d\x27un module connect\xE9 au r\xE9seau) ou pour ajouter un police de caract\xE8res (dans le cas d\x27un module d\x27affichage).</p>'}};
doc['Files']['FindFiles']={syn:'Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9.',lib:'YFiles.FindFiles()',pro:'def FindFiles(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le syst\xE8me de fichier soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YFiles.isOnline()</tt> pour tester si le syst\xE8me de fichier est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le syst\xE8me de fichier sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YFiles</tt> qui permet ensuite de contr\xF4ler le syst\xE8me de fichier.'};
doc['Files']['FirstFiles']={syn:'Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie.',lib:'YFiles.FirstFiles()',pro:'def FirstFiles()',cmt:'<p>Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie. Utiliser la fonction <tt>YFiles.nextFiles()</tt> pour it\xE9rer sur les autres syst\xE8me de fichier.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt>, correspondant \xE0 le premier syst\xE8me de fichier accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de syst\xE8me de fichier disponibles.'};
doc['Files']['download']={syn:'T\xE9l\xE9charge le fichier choisi du filesyst\xE8me et retourne son contenu.',lib:'files.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>T\xE9l\xE9charge le fichier choisi du filesyst\xE8me et retourne son contenu.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'le contenu du fichier charg\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un contenu vide.'};
doc['Files']['format_fs']={syn:'R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9.',lib:'files.format_fs()',pro:'def format_fs()',cmt:'<p>R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9. enti\xE8rement vide. Tous les fichiers pr\xE9c\xE9demment charg\xE9s sont irr\xE9m\xE9diablement effac\xE9s.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['get_advertisedValue']={syn:'Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).',lib:'files.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'files.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Files']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'files.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Files']['get_filesCount']={syn:'Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_filesCount()',pro:'def get_filesCount()',cmt:'<p>Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',ret:'un entier repr\xE9sentant le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.',lib:'files.get_freeSpace()',pro:'def get_freeSpace()',cmt:'<p>Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.</p>',ret:'un entier repr\xE9sentant l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'files.get_filesDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Files']['get_list']={syn:'Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_list()',pro:'def get_list(<span id=pn>pattern</span>)',cmt:'<p>Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',par:{pattern:'un filtre optionel sur les noms de fichiers retourn\xE9s, pouvant contenir des ast\xE9risques et des points d\x27interrogations comme jokers. Si le pattern fourni est vide, tous les fichiers sont retourn\xE9s.'},ret:'une liste d\x27objets <tt>YFileRecord</tt>, contenant le nom complet (y compris le chemin d\x27acc\xE8s), la taille en octets et le CRC 32-bit du contenu du fichier.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['Files']['get_logicalName']={syn:'Retourne le nom logique du syst\xE8me de fichier.',lib:'files.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du syst\xE8me de fichier.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'files.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Files']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'files.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Files']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'files.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['nextFiles']={syn:'Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt>.',lib:'files.nextFiles()',pro:'def nextFiles()',cmt:'<p>Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt>.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Files']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'files.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Files']['remove']={syn:'Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier.',lib:'files.remove()',pro:'def remove(<span id=pn>pathname</span>)',cmt:'<p>Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier. A cause de la fragmentation, l\x27effacement d\x27un fichier ne lib\xE8re pas toujours la totalit\xE9 de l\x27espace qu\x27il occuppe. Par contre, la r\xE9-\xE9criture d\x27un fichier du m\xEAme nom r\xE9cup\xE9rera dans tout les cas l\x27espace qui n\x27aurait \xE9ventuellement pas \xE9t\xE9 lib\xE9r\xE9. Pour s\x27assurer de lib\xE9rer la totalit\xE9 de l\x27espace du syst\xE8me de fichier, utilisez la fonction <tt>format_fs</tt>.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_logicalName']={syn:'Modifie le nom logique du syst\xE8me de fichier.',lib:'files.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du syst\xE8me de fichier. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'files.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Files']['upload']={syn:'T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'files.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.',content:'contenu du fichier \xE0 t\xE9l\xE9charger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Interface de la fonction Horloge Temps Real',inc:'from yocto_realtimeclock import *',cmt:'<p>La fonction RealTimeClock fourni la date et l\x27heure courante de mani\xE8re persistante, m\xEAme en cas de coupure de courant de plusieurs jours. Elle est le fondement des fonctions de r\xE9veil automatique impl\xE9ment\xE9es par le WakeUpScheduler. L\x27heure courante peut repr\xE9senter aussi bien une heure locale qu\x27une heure UTC, mais aucune adaptation automatique n\x27est fait au changement d\x27heure \xE9t\xE9/hiver.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Permet de retrouver une horloge d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'def FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une horloge d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27horloge soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRealTimeClock.isOnline()</tt> pour tester si l\x27horloge est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27horloge sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRealTimeClock</tt> qui permet ensuite de contr\xF4ler l\x27horloge.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Commence l\x27\xE9num\xE9ration des horloge accessibles par la librairie.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'def FirstRealTimeClock()',cmt:'<p>Commence l\x27\xE9num\xE9ration des horloge accessibles par la librairie. Utiliser la fonction <tt>YRealTimeClock.nextRealTimeClock()</tt> pour it\xE9rer sur les autres horloge.</p>',ret:'un pointeur sur un objet <tt>YRealTimeClock</tt>, correspondant \xE0 la premi\xE8re horloge accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de horloge disponibles.'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res).',lib:'realtimeclock.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22 ',lib:'realtimeclock.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'realtimeclock.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['RealTimeClock']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'realtimeclock.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'realtimeclock.get_realtimeclockDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['RealTimeClock']['get_logicalName']={syn:'Retourne le nom logique de l\x27horloge.',lib:'realtimeclock.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27horloge.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27horloge',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'realtimeclock.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Retourne vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux.',lib:'realtimeclock.get_timeSet()',pro:'def get_timeSet()',cmt:'<p>Retourne vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux.</p>',ret:'soit <tt>Y_TIMESET_FALSE</tt>, soit <tt>Y_TIMESET_TRUE</tt>, selon vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Retourne l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970).',lib:'realtimeclock.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Retourne l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970).</p>',ret:'un entier repr\xE9sentant l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'realtimeclock.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'realtimeclock.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).</p>',ret:'un entier repr\xE9sentant le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'realtimeclock.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['RealTimeClock']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'realtimeclock.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continue l\x27\xE9num\xE9ration des horloge commenc\xE9e \xE0 l\x27aide de <tt>yFirstRealTimeClock()</tt>.',lib:'realtimeclock.nextRealTimeClock()',pro:'def nextRealTimeClock()',cmt:'<p>Continue l\x27\xE9num\xE9ration des horloge commenc\xE9e \xE0 l\x27aide de <tt>yFirstRealTimeClock()</tt>.</p>',ret:'un pointeur sur un objet <tt>YRealTimeClock</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'realtimeclock.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Modifie le nom logique de l\x27horloge.',lib:'realtimeclock.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27horloge. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27horloge'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['set_unixTime']={syn:'Modifie l\x27heure courante.',lib:'realtimeclock.set_unixTime()',pro:'def set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27heure courante. L\x27heure est pass\xE9e au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970). Si l\x27heure UTC est connue, l\x27attribut utcOffset sera automatiquement ajust\xE9 en fonction de l\x27heure configur\xE9e.</p>',par:{newval:'un entier repr\xE9sentant l\x27heure courante'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'realtimeclock.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'realtimeclock.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone). Le d\xE9callage est automatiquement arrondi au quart d\x27heure le plus proche. Si l\x27heure UTC est connue, l\x27heure courante sera automatiquement adapt\xE9e en fonction du d\xE9calage choisi.</p>',par:{newval:'un entier repr\xE9sentant le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'Interface de la fonction WakeUpMonitor',inc:'from yocto_wakeupmonitor import *'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Permet de retrouver un moniteur d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'def FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un moniteur d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le moniteur soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWakeUpMonitor.isOnline()</tt> pour tester si le moniteur est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le moniteur sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWakeUpMonitor</tt> qui permet ensuite de contr\xF4ler le moniteur.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Commence l\x27\xE9num\xE9ration des Moniteurs accessibles par la librairie.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'def FirstWakeUpMonitor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des Moniteurs accessibles par la librairie. Utiliser la fonction <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> pour it\xE9rer sur les autres Moniteurs.</p>',ret:'un pointeur sur un objet <tt>YWakeUpMonitor</tt>, correspondant \xE0 le premier moniteur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de Moniteurs disponibles.'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Retourne la valeur courante du moniteur (pas plus de 6 caract\xE8res).',lib:'wakeupmonitor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du moniteur (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du moniteur (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wakeupmonitor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['WakeUpMonitor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wakeupmonitor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wakeupmonitor.get_wakeupmonitorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Retourne le nom logique du moniteur.',lib:'wakeupmonitor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du moniteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moniteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wakeupmonitor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Retourne la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX) ',lib:'wakeupmonitor.get_nextWakeUp()',pro:'def get_nextWakeUp()',cmt:'<p>Retourne la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX)</p>',ret:'un entier repr\xE9sentant la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Retourne le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.',lib:'wakeupmonitor.get_powerDuration()',pro:'def get_powerDuration()',cmt:'<p>Retourne le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.</p>',ret:'un entier repr\xE9sentant le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Retourne le temps avant le prochain sommeil.',lib:'wakeupmonitor.get_sleepCountdown()',pro:'def get_sleepCountdown()',cmt:'<p>Retourne le temps avant le prochain sommeil.</p>',ret:'un entier repr\xE9sentant le temps avant le prochain sommeil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wakeupmonitor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Renvoie la raison du dernier r\xE9veil.',lib:'wakeupmonitor.get_wakeUpReason()',pro:'def get_wakeUpReason()',cmt:'<p>Renvoie la raison du dernier r\xE9veil.</p>',ret:'une valeur parmi <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_EXTSIG2</tt>, <tt>Y_WAKEUPREASON_EXTSIG3</tt>, <tt>Y_WAKEUPREASON_EXTSIG4</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE2</tt>, <tt>Y_WAKEUPREASON_SCHEDULE3</tt>, <tt>Y_WAKEUPREASON_SCHEDULE4</tt>, <tt>Y_WAKEUPREASON_SCHEDULE5</tt> et <tt>Y_WAKEUPREASON_SCHEDULE6</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Revoie l\x27\xE9tata ctuel du moniteur ',lib:'wakeupmonitor.get_wakeUpState()',pro:'def get_wakeUpState()',cmt:'<p>Revoie l\x27\xE9tata ctuel du moniteur</p>',ret:'soit <tt>Y_WAKEUPSTATE_SLEEPING</tt>, soit <tt>Y_WAKEUPSTATE_AWAKE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'wakeupmonitor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['WakeUpMonitor']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wakeupmonitor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continue l\x27\xE9num\xE9ration des Moniteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpMonitor()</tt>.',lib:'wakeupmonitor.nextWakeUpMonitor()',pro:'def nextWakeUpMonitor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des Moniteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpMonitor()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWakeUpMonitor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wakeupmonitor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'R\xE9initialise le compteur de mise en sommeil.',lib:'wakeupmonitor.resetSleepCountDown()',pro:'def resetSleepCountDown()',cmt:'<p>R\xE9initialise le compteur de mise en sommeil.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Modifie le nom logique du moniteur.',lib:'wakeupmonitor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du moniteur. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moniteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupmonitor.set_nextWakeUp()',pro:'def set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr\xE9sentant les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Modifie le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.',lib:'wakeupmonitor.set_powerDuration()',pro:'def set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Modifie le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.</p>',par:{newval:'un entier repr\xE9sentant le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Modifie le temps avant le prochain sommeil .',lib:'wakeupmonitor.set_sleepCountdown()',pro:'def set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Modifie le temps avant le prochain sommeil .</p>',par:{newval:'un entier repr\xE9sentant le temps avant le prochain sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wakeupmonitor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['WakeUpMonitor']['sleep']={syn:'D\xE9clenche une mise en sommeil jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleep()',pro:'def sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.</p>',par:{secBeforeSleep:'nombre de seconde avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['sleepFor']={syn:'D\xE9clenche une mise en sommeil pour un temps donn\xE9 o\xF9 jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleepFor()',pro:'def sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil pour un temps donn\xE9 o\xF9 jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable. Le compte \xE0 rebourt avant la mise en sommeil peut \xEAtre annul\xE9 gr\xE2ce \xE0 resetSleepCountDown.</p>',par:{secUntilWakeUp:'dur\xE9e de la mise en someil, en secondes',secBeforeSleep:'nombre de secondes avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'D\xE9clenche une mise en sommeil jusqu\x27\xE0 une date donn\xE9e ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleepUntil()',pro:'def sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil jusqu\x27\xE0 une date donn\xE9e ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable. Le compte \xE0 rebourt avant la mise en sommeil peut \xEAtre annul\xE9 gr\xE2ce \xE0 resetSleepCountDown.</p>',par:{wakeUpTime:'date/heure du r\xE9veil (format UNIX)',secBeforeSleep:'nombre de secondes avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Force un r\xE9veil.',lib:'wakeupmonitor.wakeUp()',pro:'def wakeUp()',cmt:'<p>Force un r\xE9veil.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'Interface de la fonction WakeUpSchedule',inc:'from yocto_wakeupschedule import *',cmt:'<p>La fonction WakeUpSchedule impl\xE9mente une condition de r\xE9veil. Le r\xE9veil est sp\xE9cifi\xE9e par un ensemble de mois et/ou jours et/ou heures et/ou minutes o\xF9 il doit se produire.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Permet de retrouver un r\xE9veil agend\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'def FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un r\xE9veil agend\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le r\xE9veil agend\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWakeUpSchedule.isOnline()</tt> pour tester si le r\xE9veil agend\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le r\xE9veil agend\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWakeUpSchedule</tt> qui permet ensuite de contr\xF4ler le r\xE9veil agend\xE9.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Commence l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s accessibles par la librairie.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'def FirstWakeUpSchedule()',cmt:'<p>Commence l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s accessibles par la librairie. Utiliser la fonction <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> pour it\xE9rer sur les autres r\xE9veils agend\xE9s.</p>',ret:'un pointeur sur un objet <tt>YWakeUpSchedule</tt>, correspondant \xE0 le premier r\xE9veil agend\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de r\xE9veils agend\xE9s disponibles.'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Retourne la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res).',lib:'wakeupschedule.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wakeupschedule.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['WakeUpSchedule']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wakeupschedule.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wakeupschedule.get_wakeupscheduleDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['WakeUpSchedule']['get_hours']={syn:'Retourne les heures o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_hours()',pro:'def get_hours()',cmt:'<p>Retourne les heures o\xF9 le r\xE9veil est actif..</p>',ret:'un entier repr\xE9sentant les heures o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Retourne le nom logique du r\xE9veil agend\xE9.',lib:'wakeupschedule.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du r\xE9veil agend\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9veil agend\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Retourne toutes les minutes de chaque heures o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutes()',pro:'def get_minutes()',cmt:'<p>Retourne toutes les minutes de chaque heures o\xF9 le r\xE9veil est actif.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Retourne les minutes 00-29 de chaque heures o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutesA()',pro:'def get_minutesA()',cmt:'<p>Retourne les minutes 00-29 de chaque heures o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr\xE9sentant les minutes 00-29 de chaque heures o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Retourne les minutes 30-59 de chaque heures o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutesB()',pro:'def get_minutesB()',cmt:'<p>Retourne les minutes 30-59 de chaque heures o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr\xE9sentant les minutes 30-59 de chaque heures o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wakeupschedule.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Retourne les jours de la semaine o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_monthDays()',pro:'def get_monthDays()',cmt:'<p>Retourne les jours de la semaine o\xF9 le r\xE9veil est actif..</p>',ret:'un entier repr\xE9sentant les jours de la semaine o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Retourne les jours de la semaine o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_months()',pro:'def get_months()',cmt:'<p>Retourne les jours de la semaine o\xF9 le r\xE9veil est actif..</p>',ret:'un entier repr\xE9sentant les jours de la semaine o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Retourne la date/heure de la prochaine occurence de r\xE9veil ',lib:'wakeupschedule.get_nextOccurence()',pro:'def get_nextOccurence()',cmt:'<p>Retourne la date/heure de la prochaine occurence de r\xE9veil</p>',ret:'un entier repr\xE9sentant la date/heure de la prochaine occurence de r\xE9veil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wakeupschedule.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Retourne les jours de la semaine o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_weekDays()',pro:'def get_weekDays()',cmt:'<p>Retourne les jours de la semaine o\xF9 le r\xE9veil est actif..</p>',ret:'un entier repr\xE9sentant les jours de la semaine o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'wakeupschedule.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['WakeUpSchedule']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wakeupschedule.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continue l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpSchedule()</tt>.',lib:'wakeupschedule.nextWakeUpSchedule()',pro:'def nextWakeUpSchedule()',cmt:'<p>Continue l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpSchedule()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWakeUpSchedule</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wakeupschedule.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Modifie les heures o\xF9 un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_hours()',pro:'def set_hours(<span id=pn>newval</span>)',cmt:'<p>Modifie les heures o\xF9 un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Modifie le nom logique du r\xE9veil agend\xE9.',lib:'wakeupschedule.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du r\xE9veil agend\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9veil agend\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Modifie toutes les minutes ou un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_minutes()',pro:'def set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Modifie toutes les minutes ou un r\xE9veil doit avoir lieu</p>',par:{bitmap:'Minutes 00-59 de chaque heure o\xF9 le r\xE9veil est actif.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Modifie les minutes 00-29 ou un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_minutesA()',pro:'def set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Modifie les minutes 00-29 ou un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Modifie les minutes 30-59 ou un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_minutesB()',pro:'def set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Modifie les minutes 30-59 ou un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_monthDays()',pro:'def set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_months']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_months()',pro:'def set_months(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wakeupschedule.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_weekDays()',pro:'def set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'Interface de la fonction GenericSensor',inc:'from yocto_genericsensor import *',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Permet de retrouver un capteur g\xE9n\xE9rique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YGenericSensor.FindGenericSensor()',pro:'def FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur g\xE9n\xE9rique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur g\xE9n\xE9rique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YGenericSensor.isOnline()</tt> pour tester si le capteur g\xE9n\xE9rique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur g\xE9n\xE9rique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YGenericSensor</tt> qui permet ensuite de contr\xF4ler le capteur g\xE9n\xE9rique.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Commence l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques accessibles par la librairie.',lib:'YGenericSensor.FirstGenericSensor()',pro:'def FirstGenericSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques accessibles par la librairie. Utiliser la fonction <tt>YGenericSensor.nextGenericSensor()</tt> pour it\xE9rer sur les autres capteurs g\xE9n\xE9riques.</p>',ret:'un pointeur sur un objet <tt>YGenericSensor</tt>, correspondant \xE0 le premier capteur g\xE9n\xE9rique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs g\xE9n\xE9riques disponibles.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'genericsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res).',lib:'genericsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'genericsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'genericsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'genericsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['GenericSensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'genericsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'genericsensor.get_genericsensorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['GenericSensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'genericsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Retourne le nom logique du capteur g\xE9n\xE9rique.',lib:'genericsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur g\xE9n\xE9rique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur g\xE9n\xE9rique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'genericsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'genericsensor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['GenericSensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'genericsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Retourne la plage de signal \xE9lectrique utilis\xE9e par le capteur.',lib:'genericsensor.get_signalRange()',pro:'def get_signalRange()',cmt:'<p>Retourne la plage de signal \xE9lectrique utilis\xE9e par le capteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la plage de signal \xE9lectrique utilis\xE9e par le capteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9e par le capteur.',lib:'genericsensor.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9e par le capteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 du signal \xE9lectrique utilis\xE9e par le capteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Retourne la valeur mesur\xE9e du signal \xE9lectrique utilis\xE9e par le capteur.',lib:'genericsensor.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Retourne la valeur mesur\xE9e du signal \xE9lectrique utilis\xE9e par le capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e du signal \xE9lectrique utilis\xE9e par le capteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'genericsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'genericsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['GenericSensor']['get_valueRange']={syn:'Retourne la plage de valeurs physiques mesur\xE9s par le capteur.',lib:'genericsensor.get_valueRange()',pro:'def get_valueRange()',cmt:'<p>Retourne la plage de valeurs physiques mesur\xE9s par le capteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la plage de valeurs physiques mesur\xE9s par le capteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'genericsensor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['GenericSensor']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'genericsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continue l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques commenc\xE9e \xE0 l\x27aide de <tt>yFirstGenericSensor()</tt>.',lib:'genericsensor.nextGenericSensor()',pro:'def nextGenericSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques commenc\xE9e \xE0 l\x27aide de <tt>yFirstGenericSensor()</tt>.</p>',ret:'un pointeur sur un objet <tt>YGenericSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['GenericSensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'genericsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['GenericSensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'genericsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_logicalName']={syn:'Modifie le nom logique du capteur g\xE9n\xE9rique.',lib:'genericsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur g\xE9n\xE9rique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur g\xE9n\xE9rique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'genericsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'genericsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_signalRange']={syn:'Modifie la plage de signal \xE9lectrique utilis\xE9e par le capteur.',lib:'genericsensor.set_signalRange()',pro:'def set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage de signal \xE9lectrique utilis\xE9e par le capteur.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant la plage de signal \xE9lectrique utilis\xE9e par le capteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'genericsensor.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e. N\x27oubliez pas d\x27appeler \x09\x09 la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'genericsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['GenericSensor']['set_valueRange']={syn:'Modifie la plage de valeurs physiques mesur\xE9s par le capteur.',lib:'genericsensor.set_valueRange()',pro:'def set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage de valeurs physiques mesur\xE9s par le capteur. Le changement de plage peut avoir pour effet de bord un changement automatique de la r\xE9solution affich\xE9e.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant la plage de valeurs physiques mesur\xE9s par le capteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'contr\xF4le d\x27OS',inc:'from yocto_oscontrol import *',cmt:'<p>L\x27objet OsControl permet de controler le syst\xE8m d\x27exploitation sur lequel tourne un VirtualHub. OsControl n\x27est disponible que dans le VirtualHub software. Attention, cette fonctionnalit\xE9 doit \xEAtre explicitement activ\xE9 au lancement du VirtualHub, avec l\x27option -o.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Permet de retrouver un contr\xF4le d\x27OS d\x27apr\xE8s un identifiant donn\xE9.',lib:'YOsControl.FindOsControl()',pro:'def FindOsControl(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4le d\x27OS d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le contr\xF4le d\x27OS soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YOsControl.isOnline()</tt> pour tester si le contr\xF4le d\x27OS est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4le d\x27OS sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YOsControl</tt> qui permet ensuite de contr\xF4ler le contr\xF4le d\x27OS.'};
doc['OsControl']['FirstOsControl']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4le d\x27OS accessibles par la librairie.',lib:'YOsControl.FirstOsControl()',pro:'def FirstOsControl()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4le d\x27OS accessibles par la librairie. Utiliser la fonction <tt>YOsControl.nextOsControl()</tt> pour it\xE9rer sur les autres contr\xF4le d\x27OS.</p>',ret:'un pointeur sur un objet <tt>YOsControl</tt>, correspondant \xE0 le premier contr\xF4le d\x27OS accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4le d\x27OS disponibles.'};
doc['OsControl']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res).',lib:'oscontrol.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'oscontrol.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['OsControl']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'oscontrol.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['OsControl']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'oscontrol.get_oscontrolDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['OsControl']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4le d\x27OS, qui correspond au nom r\xE9seau du module.',lib:'oscontrol.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4le d\x27OS, qui correspond au nom r\xE9seau du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27OS, qui correspond au nom r\xE9seau du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'oscontrol.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Retourne le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9.',lib:'oscontrol.get_shutdownCountdown()',pro:'def get_shutdownCountdown()',cmt:'<p>Retourne le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9.</p>',ret:'un entier repr\xE9sentant le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['OsControl']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'oscontrol.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['OsControl']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'oscontrol.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['nextOsControl']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4le d\x27OS commenc\xE9e \xE0 l\x27aide de <tt>yFirstOsControl()</tt>.',lib:'oscontrol.nextOsControl()',pro:'def nextOsControl()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4le d\x27OS commenc\xE9e \xE0 l\x27aide de <tt>yFirstOsControl()</tt>.</p>',ret:'un pointeur sur un objet <tt>YOsControl</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['OsControl']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'oscontrol.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['OsControl']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4le d\x27OS.',lib:'oscontrol.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4le d\x27OS. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27OS'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'oscontrol.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['OsControl']['shutdown']={syn:'Agende un arr\xEAt de l\x27OS dans un nombre donn\xE9 de secondes.',lib:'oscontrol.shutdown()',pro:'def shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Agende un arr\xEAt de l\x27OS dans un nombre donn\xE9 de secondes.</p>',par:{secBeforeShutDown:'nombre de secondes avant l\x27arr\xEAt'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: OsControl)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 } 	 

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);  
 }	  
 
function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);  
 }	  

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 } 
 
function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }
 
function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist." 
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 } 
 
function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."  
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }
 
function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."  
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."  
    it.style.top  = parseInt(t) + "px";
 } 

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."  
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }
 
function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }
 
function computeWinWH()
 { WinW             = GetWindowWidth() ;  
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight(); 
   if (WinH<400) WinH=400;
} 

 
 function getInnerHeight()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );  
 }		
 
 function getInnerWidth()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct) 
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct; 
  }
  
function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++) 
      resizeCallBacks[i]();
  }  

function jsQuote(str_in) 
{ str_in = str_in+'';
  var str_out   = ''; 
  for (i=0;i<str_in.length;i++) 
   { 
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else 
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex; 
      }  
   } 
   return str_out; 
  }  
 

function resizeMargin()
 { 
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 } 
 
function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110); 
 }
 
function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 } 
 
function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches) 
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }  
  return new positionObject(x,y);
 } 
 
  
function EnableDrag(var_element,onDragMove,onDragEnd)
  {  
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y   
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }  
   else 
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);
       
   if (onDragMove)  var_element.onDragMove = onDragMove;    
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;    
  }
  
 var LastDraggedObject = null;  
  
 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos) 
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;    
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;
   
   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }
   
   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }
      
   if (event.preventDefault)   event.preventDefault();  
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source, 
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else  
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    } 
   document.onmouseup   =   Drag_stopMouseCapture;
 } 
 
 
function Drag_mouseCapture(event)
 { 
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault(); 

 
   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y); 
   
   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;
   
   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;
   
   var p = {x:x,y:y};
  
   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);
    
   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;
    
   lastDraggedObject.element.style.left = p.x+"px";  
   lastDraggedObject.element.style.top  = p.y+"px";  
 }

function Drag_stopMouseCapture()
 { 
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent) 
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }
 
  if (lastDraggedObject) 
    { lastDraggedObject.element.style.cursor='col-resize';   
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }  
 
 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin() 
  }
  
 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  { 
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }
  
    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex; 
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par) 
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'   
          }      

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }              
        
         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }      
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml; 
  } 
  
  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else  
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }    
  } 
  
 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname) 
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'>&nbsp;<img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";
        
       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }  
       }
       marginhtml = marginhtml+'</div>'  
    }
  
    document.getElementById("MarginLayer").innerHTML = marginhtml; 
  }
  
 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()
    
    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }
    
    for (var i=0;i<tosearch.length;i++) 
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }            
          
          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }              
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;    
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;
          
          if (!found) return false;
       }       
    
  
    return true;

  }
 
 var searchTimer = null; 
 
 function doSearch()
  { searchTimer = null; 
    var value= document.forms['yoctoForm'].elements['search'].value;
    
    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           } 
          container["originalDisplay"]=null;           
        }
        Show(lastindex_shown,lastname_shown);
       return;        
      }   
      
    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');  
       for (var method in doc[classname])
       
         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}        
                 } 
              else 
                 { if (it) it.style.display="none";
                 } 
         } 
        
      if  (matchfound) 
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }
   
    Show(firstindex,firstname); 
        
    
  }
  
 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }  
  
 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown); 
    Show(lastindex_shown,lastname_shown); 

  }
  

 
 
 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form> 
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" language="javascript1.5"> 
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);  
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" checked onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;
   
 
 }
doc = sortObject(doc);
ShowFunctions(); 
Show(doc["YAPI"]?"YAPI":"Module",""); 


window.onresize = windowResized;  
-->  
</script>

</BODY>


</HEAD>

