<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-python-FR.html 33736 2018-12-14 16:23:49Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-python-FR.html 33736 2018-12-14 16:23:49Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: Module)
var Language='Python';
var IncludeLabel='Pour utiliser les fonctions d&eacute;crites ici, vous devez inclure:';
var ParamLabel='Param&egrave;tres :';
var ReturnLabel='Retourne :';
var AbbrevHint='L\x27API supporte deux syntaxes, une premi&egrave;re purement orient&eacute;e objet, et une seconde abr&eacute;g&eacute;e.';
var NotFound='Aucune correspondance trouv&eacute;e';
var AbbrevLabel='Utiliser les noms abr&eacute;g&eacute;s';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'YAPI.FILE_NOT_FOUND',null:'None'};
doc['Module']={'':{syn:'Interface de contr\xF4le du module',inc:'from yocto_api import *',cmt:'<p>Cette interface est la m\xEAme pour tous les modules USB de Yoctopuce. Elle permet de contr\xF4ler les param\xE8tres g\xE9n\xE9raux du module, et d\x27\xE9num\xE9rer les fonctions fournies par chaque module.</p>'}};
doc['Module']['FindModule']={syn:'Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique.',lib:'YModule.FindModule()',pro:'def FindModule(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique.</p><p> Cette fonction n\x27exige pas que le module soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YModule.isOnline()</tt> pour tester si le module est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res contenant soit le num\xE9ro de s\xE9rie, soit le nom logique du module d\xE9sir\xE9'},ret:'un objet de classe <tt>YModule</tt> qui permet ensuite de contr\xF4ler le module ou d\x27obtenir de plus amples informations sur le module.'};
doc['Module']['FirstModule']={syn:'Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie.',lib:'YModule.FirstModule()',pro:'def FirstModule()',cmt:'<p>Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie. Utiliser la fonction <tt>YModule.nextModule()</tt> pour it\xE9rer sur les autres modules.</p>',ret:'un pointeur sur un objet <tt>YModule</tt>, correspondant au premier module accessible en ligne, ou <tt>null</tt> si aucun module n\x27a \xE9t\xE9 trouv\xE9.'};
doc['Module']['checkFirmware']={syn:'Teste si le fichier byn est valide pour le module.',lib:'module.checkFirmware()',pro:'def checkFirmware(<span id=pn>path</span>, <span id=pn>onlynew</span>)',cmt:'<p>Teste si le fichier byn est valide pour le module. Cette m\xE9thode est utile pour v\xE9rifier si il est n\xE9cessaire de mettre \xE0 jour le module avec un nouveau firmware. Il est possible de passer un r\xE9pertoire qui contiens plusieurs fichier <tt>.byn</tt>. Dans ce cas cette methode retourne le path du fichier <tt>.byn</tt> compatible le plus r\xE9cent. Si le parametre <tt>onlynew</tt> est vrais, les firmwares \xE9quivalents ou plus anciens que le firmware actuellement install\xE9 sont ignor\xE9s.</p>',par:{path:'le path d\x27un fichier <tt>.byn</tt> ou d\x27un r\xE9pertoire contenant plusieurs fichier <tt>.byn</tt>',onlynew:'retourne uniquement les fichiers strictement plus r\xE9cents'},ret:'le path du fichier <tt>.byn</tt> \xE0 utiliser, ou une cha\xEEne vide si aucun firmware plus r\xE9cent n\x27est disponible En cas d\x27erreur, d\xE9clenche une exception ou retourne une chaine de caract\xE8re qui comment par \x22error:\x22.'};
doc['Module']['clearCache']={syn:'Invalide le cache.',lib:'module.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du module. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Module']['describe']={syn:'Retourne un court texte d\xE9crivant le module.',lib:'module.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant le module. Ce texte peut contenir soit le nom logique du module, soit son num\xE9ro de s\xE9rie.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le module'};
doc['Module']['download']={syn:'T\xE9l\xE9charge le fichier choisi du module et retourne son contenu.',lib:'module.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>T\xE9l\xE9charge le fichier choisi du module et retourne son contenu.</p>',par:{pathname:'nom complet du fichier'},ret:'le contenu du fichier charg\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['functionBaseType']={syn:'Retourne le type de base de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionBaseType()',pro:'def functionBaseType(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne le type de base de la <i>n</i>i\xE8me fonction du module. Par exemple, le type de base de toutes les fonctions de mesure est \x22Sensor\x22.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant au type de base de la fonction',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionCount']={syn:'Retourne le nombre de fonctions (sans compter l\x27interface \x22module\x22) existant sur le module.',lib:'module.functionCount()',pro:'def functionCount()',cmt:'<p>Retourne le nombre de fonctions (sans compter l\x27interface \x22module\x22) existant sur le module.</p>',ret:'le nombre de fonctions sur le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionId()',pro:'def functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant \xE0 l\x27identifiant mat\xE9riel unique de la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionName']={syn:'Retourne le nom logique de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionName()',pro:'def functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne le nom logique de la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant au nom logique de la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionType']={syn:'Retourne le type de la <i>n</i>i\xE8me fonction du module.',lib:'module.functionType()',pro:'def functionType(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne le type de la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant au type de la fonction',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['functionValue']={syn:'Retourne la valeur publi\xE9e par la <i>n</i>i\xE8me fonction du module.',lib:'module.functionValue()',pro:'def functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retourne la valeur publi\xE9e par la <i>n</i>i\xE8me fonction du module.</p>',par:{functionIndex:'l\x27index de la fonction pour laquelle l\x27information est d\xE9sir\xE9e, en commen\xE7ant \xE0 0 pour la premi\xE8re fonction.'},ret:'une cha\xEEne de caract\xE8res correspondant \xE0 la valeur publi\xE9e par la fonction d\xE9sir\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Module']['get_allSettings']={syn:'Retourne tous les param\xE8tres de configuration du module.',lib:'module.get_allSettings()',pro:'def get_allSettings()',cmt:'<p>Retourne tous les param\xE8tres de configuration du module. Utile pour sauvgarder les noms logiques, les calibrations et fichies upload\xE9s d\x27un module.</p>',ret:'un objet binaire avec tous les param\xE8tres',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un objet binaire de taille 0.'};
doc['Module']['get_beacon']={syn:'Retourne l\x27\xE9tat de la balise de localisation.',lib:'module.get_beacon()',pro:'def get_beacon()',cmt:'<p>Retourne l\x27\xE9tat de la balise de localisation.</p>',ret:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>, selon l\x27\xE9tat de la balise de localisation',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_firmwareRelease']={syn:'Retourne la version du logiciel embarqu\xE9 du module.',lib:'module.get_firmwareRelease()',pro:'def get_firmwareRelease()',cmt:'<p>Retourne la version du logiciel embarqu\xE9 du module.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la version du logiciel embarqu\xE9 du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionIds']={syn:'Retourne les identifiants mat\xE9riels des fonctions correspondant au type pass\xE9 en argument.',lib:'module.get_functionIds()',pro:'def get_functionIds(<span id=pn>funType</span>)',cmt:'<p>Retourne les identifiants mat\xE9riels des fonctions correspondant au type pass\xE9 en argument.</p>',par:{funType:'Le type de fonction (Relay, LightSensor, Voltage,...)'},ret:'un tableau de cha\xEEnes de caract\xE8re.'};
doc['Module']['get_hardwareId']={syn:'Retourne l\x27identifiant unique du module.',lib:'module.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant unique du module. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module suivi de la cha\xEEne \x22.module\x22.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction'};
doc['Module']['get_icon2d']={syn:'Retourne l\x27ic\xF4ne du module.',lib:'module.get_icon2d()',pro:'def get_icon2d()',cmt:'<p>Retourne l\x27ic\xF4ne du module. L\x27icone est au format PNG et a une taille maximale de 1536 octets.</p>',ret:'un buffer binaire contenant l\x27icone, au format png. En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Retourne une chaine de charact\xE8re contenant les derniers logs du module.',lib:'module.get_lastLogs()',pro:'def get_lastLogs()',cmt:'<p>Retourne une chaine de charact\xE8re contenant les derniers logs du module. Cette m\xE9thode retourne les derniers logs qui sont encore stock\xE9 dans le module.</p>',ret:'une cha\xEEne de caract\xE8re contenant les derniers logs du module. En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Retourne le nom logique du module.',lib:'module.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du module.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom logique du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'module.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr&eacute;sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_parentHub']={syn:'Retourne le num\xE9ro de s\xE9rie du YoctoHub sur lequel est connect\xE9 le module.',lib:'module.get_parentHub()',pro:'def get_parentHub()',cmt:'<p>Retourne le num\xE9ro de s\xE9rie du YoctoHub sur lequel est connect\xE9 le module. Si le module est connect\xE9 par USB, ou si le module est le YoctoHub racine, une cha\xEEne vide est retourn\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res contenant le num\xE9ro de s\xE9rie du YoctoHub, ou une cha\xEEne vide.'};
doc['Module']['get_persistentSettings']={syn:'Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.',lib:'module.get_persistentSettings()',pro:'def get_persistentSettings()',cmt:'<p>Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.</p>',ret:'une valeur parmi <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> et <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> repr&eacute;sentant l\x27\xE9tat courant des r\xE9glages persistents du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productId()',pro:'def get_productId()',cmt:'<p>Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr&eacute;sentant l\x27identifiant USB du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productName()',pro:'def get_productName()',cmt:'<p>Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom commercial du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productRelease()',pro:'def get_productRelease()',cmt:'<p>Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr&eacute;sentant le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.',lib:'module.get_rebootCountdown()',pro:'def get_rebootCountdown()',cmt:'<p>Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.</p>',ret:'un entier repr&eacute;sentant le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.',lib:'module.get_serialNumber()',pro:'def get_serialNumber()',cmt:'<p>Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_subDevices']={syn:'Retourne la liste des modules branch\xE9s au module courant.',lib:'module.get_subDevices()',pro:'def get_subDevices()',cmt:'<p>Retourne la liste des modules branch\xE9s au module courant. Cette fonction n\x27est pertinente que lorsqu\x27elle appel\xE9e pour un YoctoHub ou pour le VirtualHub. Dans le cas contraire, un tableau vide est retourn\xE9.</p>',ret:'un tableau de cha\xEEnes de caract\xE8res contenant les num\xE9ros de s\xE9rie des sous-modules connect\xE9s au module'};
doc['Module']['get_upTime']={syn:'Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module ',lib:'module.get_upTime()',pro:'def get_upTime()',cmt:'<p>Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module</p>',ret:'un entier repr&eacute;sentant le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_url']={syn:'Retourne l\x27URL utilis\xE9e pour acc\xE9der au module.',lib:'module.get_url()',pro:'def get_url()',cmt:'<p>Retourne l\x27URL utilis\xE9e pour acc\xE9der au module. Si le module est connect\xE9 par USB la cha\xEEne de caract\xE8re \x27usb\x27 est retourn\xE9e.</p>',ret:'une cha\xEEne de caract\xE8re contenant l\x27URL du module.'};
doc['Module']['get_usbCurrent']={syn:'Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.',lib:'module.get_usbCurrent()',pro:'def get_usbCurrent()',cmt:'<p>Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.</p>',ret:'un entier repr&eacute;sentant le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Module']['get_userVar']={syn:'Retourne la valeur enti\xE8re pr\xE9c\xE9demment stock\xE9e dans cet attribut.',lib:'module.get_userVar()',pro:'def get_userVar()',cmt:'<p>Retourne la valeur enti\xE8re pr\xE9c\xE9demment stock\xE9e dans cet attribut. Au d\xE9marrage du module (ou apr\xE8s un red\xE9marrage), la valeur est toujours z\xE9ro.</p>',ret:'un entier repr&eacute;sentant la valeur enti\xE8re pr\xE9c\xE9demment stock\xE9e dans cet attribut',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_USERVAR_INVALID</tt>.'};
doc['Module']['hasFunction']={syn:'Teste la pr\xE9sence d\x27une fonction pour le module courant.',lib:'module.hasFunction()',pro:'def hasFunction(<span id=pn>funcId</span>)',cmt:'<p>Teste la pr\xE9sence d\x27une fonction pour le module courant. La m\xE9thode prend en param\xE8tre l\x27identifiant de la fonction (relay1, voltage2,...) et retourne un bool\xE9en.</p>',par:{funcId:'identifiant mat\xE9riel de la fonction'},ret:'vrai si le module inclut la fonction demand\xE9e'};
doc['Module']['isOnline']={syn:'V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur.',lib:'module.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs du module en cache sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le module est joignable, <tt>false</tt> sinon'};
doc['Module']['load']={syn:'Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'module.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionnellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['log']={syn:'Ajoute un message arbitraire dans les logs du module.',lib:'module.log()',pro:'def log(<span id=pn>text</span>)',cmt:'<p>Ajoute un message arbitraire dans les logs du module. Cette fonction est utile en particulier pour tracer l\x27ex\xE9cution de callbacks HTTP. Si un saut de ligne est d\xE9sir\xE9 apr\xE8s le message, il doit \xEAtre inclus dans la cha\xEEne de caract\xE8re.</p>',par:{text:'le message \xE0 ajouter aux logs du module.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['nextModule']={syn:'Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'def nextModule()',cmt:'<p>Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>. Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les modules sont retourn\xE9s. Si vous souhaitez retrouver un module sp\xE9cifique, utilisez <tt>Module.findModule()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YModule</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Module']['reboot']={syn:'Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.',lib:'module.reboot()',pro:'def reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['registerBeaconCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement d\x27\xE9tat de la balise de localisation du module.',lib:'module.registerBeaconCallback()',pro:'def registerBeaconCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement d\x27\xE9tat de la balise de localisation du module. La fonction de callback doit accepter deux arguments: l\x92objet YModule dont la balise a chang\xE9, et un entier repr\xE9sentant l\x27\xE9tat de la balise de localisation.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou <tt>null</tt> pour supprimer un callback d\xE9j\xE0 enregistr\xE9.'}};
doc['Module']['registerConfigChangeCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un r\xE9glage persistant d\x27un module est modifi\xE9 (par exemple changement d\x27unit\xE9 de mesure, etc.) ',lib:'module.registerConfigChangeCallback()',pro:'def registerConfigChangeCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un r\xE9glage persistant d\x27un module est modifi\xE9 (par exemple changement d\x27unit\xE9 de mesure, etc.)</p>',par:{callback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['Module']['registerLogCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois le module \xE9met un message de log.',lib:'module.registerLogCallback()',pro:'def registerLogCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois le module \xE9met un message de log. Utile pour d\xE9bugger le fonctionnement d\x27un module Yoctopuce.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27objet module qui a produit un log, un cha\xEEne de caract\xE8re qui contiens le log On failure, throws an exception or returns a negative error code.'}};
doc['Module']['revertFromFlash']={syn:'Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.',lib:'module.revertFromFlash()',pro:'def revertFromFlash()',cmt:'<p>Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['saveToFlash']={syn:'Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module.',lib:'module.saveToFlash()',pro:'def saveToFlash()',cmt:'<p>Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module. Attention le nombre total de sauvegardes possibles durant la vie du module est limit\xE9 (environ 100000 cycles). N\x27appelez pas cette fonction dans une boucle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_allSettings']={syn:'R\xE9tablit tous les param\xE8tres du module.',lib:'module.set_allSettings()',pro:'def set_allSettings(<span id=pn>settings</span>)',cmt:'<p>R\xE9tablit tous les param\xE8tres du module. Utile pour restorer les noms logiques et les calibrations du module depuis une sauvgarde. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si les r\xE9glages doivent \xEAtre pr\xE9serv\xE9s.</p>',par:{settings:'un objet binaire avec touts les param\xE8tres'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_allSettingsAndFiles']={syn:'R\xE9tablit tous les param\xE8tres de configuration et fichiers sur un module.',lib:'module.set_allSettingsAndFiles()',pro:'def set_allSettingsAndFiles(<span id=pn>settings</span>)',cmt:'<p>R\xE9tablit tous les param\xE8tres de configuration et fichiers sur un module. Cette m\xE9thode est utile pour r\xE9cup\xE9rer les noms logiques, les calibrations, les fichiers upload\xE9s, etc. du module depuis une sauvgarde. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si les r\xE9glages doivent \xEAtre pr\xE9serv\xE9s.</p>',par:{settings:'un buffer binaire avec touts les param\xE8tres'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_beacon']={syn:'Allume ou \xE9teint la balise de localisation du module.',lib:'module.set_beacon()',pro:'def set_beacon(<span id=pn>newval</span>)',cmt:'<p>Allume ou \xE9teint la balise de localisation du module.</p>',par:{newval:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Module']['set_logicalName']={syn:'Change le nom logique du module.',lib:'module.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Change le nom logique du module. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Module']['set_luminosity']={syn:'Modifie la luminosit\xE9 des leds informatives du module.',lib:'module.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9 des leds informatives du module. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la luminosit\xE9 des leds informatives du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Module']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'module.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Module']['set_userVar']={syn:'Stocke une valeur 32 bits dans la m\xE9moire volatile du module.',lib:'module.set_userVar()',pro:'def set_userVar(<span id=pn>newval</span>)',cmt:'<p>Stocke une valeur 32 bits dans la m\xE9moire volatile du module. Cet attribut est \xE0 la disposition du programmeur pour y stocker par exemple une variable d\x27\xE9tat. Au d\xE9marrage du module (ou apr\xE8s un red\xE9marrage), la valeur est toujours z\xE9ro.</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Module']['triggerConfigChangeCallback']={syn:'Force le d\xE9clanchement d\x27un callback de changement de configuration, afin de v\xE9rifier si ils sont disponibles ou pas.',lib:'module.triggerConfigChangeCallback()',pro:'def triggerConfigChangeCallback()',cmt:'<p>Force le d\xE9clanchement d\x27un callback de changement de configuration, afin de v\xE9rifier si ils sont disponibles ou pas.</p>'};
doc['Module']['triggerFirmwareUpdate']={syn:'Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.',lib:'module.triggerFirmwareUpdate()',pro:'def triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['updateFirmware']={syn:'Prepare une mise \xE0 jour de firmware du module.',lib:'module.updateFirmware()',pro:'def updateFirmware(<span id=pn>path</span>)',cmt:'<p>Prepare une mise \xE0 jour de firmware du module. Cette m\xE9thode retourne un object <tt>YFirmwareUpdate</tt> qui est utilis\xE9 pour mettre \xE0 jour le firmware du module.</p>',par:{path:'le path du fichier <tt>.byn</tt> \xE0 utiliser'},ret:'un object <tt>YFirmwareUpdate</tt> ou NULL en cas d\x27erreur'};
doc['Module']['updateFirmwareEx']={syn:'Prepare une mise \xE0 jour de firmware du module.',lib:'module.updateFirmwareEx()',pro:'def updateFirmwareEx(<span id=pn>path</span>, <span id=pn>force</span>)',cmt:'<p>Prepare une mise \xE0 jour de firmware du module. Cette m\xE9thode retourne un object <tt>YFirmwareUpdate</tt> qui est utilis\xE9 pour mettre \xE0 jour le firmware du module.</p>',par:{path:'le path du fichier <tt>.byn</tt> \xE0 utiliser',force:'vrai pour forceer la mise \xE0 jour m\xEAme si un pr\xE9requis ne semble pas satisfait'},ret:'un object <tt>YFirmwareUpdate</tt> ou NULL en cas d\x27erreur'};
//--- (end of generated code: Module)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'Interface de la fonction ColorLed',inc:'from yocto_colorled import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter une LED couleur aussi bien en coordonn\xE9es RGB qu\x27en coordonn\xE9es HSL, les conversions RGB vers HSL \xE9tant faites automatiquement par le module. Ceci permet ais\xE9ment d\x27allumer la LED avec une certaine teinte et d\x27en faire progressivement varier la saturation ou la luminosit\xE9. Si n\xE9cessaire, vous trouverez plus d\x27information sur la diff\xE9rence entre RGB et HSL dans la section suivante.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Permet de retrouver une LED RGB d\x27apr\xE8s un identifiant donn\xE9.',lib:'YColorLed.FindColorLed()',pro:'def FindColorLed(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une LED RGB d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la LED RGB soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YColorLed.isOnline()</tt> pour tester si la LED RGB est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la LED RGB sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YColorLed</tt> qui permet ensuite de contr\xF4ler la LED RGB.'};
doc['ColorLed']['FirstColorLed']={syn:'Commence l\x27\xE9num\xE9ration des LEDs RGB accessibles par la librairie.',lib:'YColorLed.FirstColorLed()',pro:'def FirstColorLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des LEDs RGB accessibles par la librairie. Utiliser la fonction <tt>YColorLed.nextColorLed()</tt> pour it\xE9rer sur les autres LEDs RGB.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt>, correspondant \xE0 la premi\xE8re LED RGB accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de LEDs RGB disponibles.'};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Ajoute une transition \xE0 la s\xE9quence de clignotement du module, la transition s\x27effectuera dans l\x27espace de couleur HSL.',lib:'colorled.addHslMoveToBlinkSeq()',pro:'def addHslMoveToBlinkSeq(<span id=pn>HSLcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Ajoute une transition \xE0 la s\xE9quence de clignotement du module, la transition s\x27effectuera dans l\x27espace de couleur HSL.</p>',par:{HSLcolor:'couleur HSL d\xE9sir\xE9e \xE0 la fin de la transition',msDelay:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Ajoute une transition \xE0 la s\xE9quence de clignotement du module, la transition s\x27effectuera dans l\x27espace de couleur RGB ',lib:'colorled.addRgbMoveToBlinkSeq()',pro:'def addRgbMoveToBlinkSeq(<span id=pn>RGBcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Ajoute une transition \xE0 la s\xE9quence de clignotement du module, la transition s\x27effectuera dans l\x27espace de couleur RGB</p>',par:{RGBcolor:'couleur RGB d\xE9sir\xE9e \xE0 la fin de la transition',msDelay:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['clearCache']={syn:'Invalide le cache.',lib:'colorled.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la LED RGB. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['ColorLed']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la LED RGB au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la LED RGB au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la LED RGB (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Retourne la valeur courante de la LED RGB (pas plus de 6 caract\xE8res).',lib:'colorled.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la LED RGB (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la LED RGB (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqMaxSize']={syn:'Retourne la longueur maximum de la sequence de clignotement.',lib:'colorled.get_blinkSeqMaxSize()',pro:'def get_blinkSeqMaxSize()',cmt:'<p>Retourne la longueur maximum de la sequence de clignotement.</p>',ret:'un entier repr&eacute;sentant la longueur maximum de la sequence de clignotement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Retourne la signature de la signature de la s\xE9quence de clignotement.',lib:'colorled.get_blinkSeqSignature()',pro:'def get_blinkSeqSignature()',cmt:'<p>Retourne la signature de la signature de la s\xE9quence de clignotement. Les s\xE9quences de clignotement ne pouvant pas \xEAtre relues du module, ce m\xE9canisme peut \xEAtre utilis\xE9 pour d\xE9tecter si une s\xE9quence sp\xE9cifique est d\xE9ja programm\xE9e.</p>',ret:'un entier repr&eacute;sentant la signature de la signature de la s\xE9quence de clignotement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKSEQSIGNATURE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSize']={syn:'Retourne la longueur actuelle de la sequence de clignotement.',lib:'colorled.get_blinkSeqSize()',pro:'def get_blinkSeqSize()',cmt:'<p>Retourne la longueur actuelle de la sequence de clignotement.</p>',ret:'un entier repr&eacute;sentant la longueur actuelle de la sequence de clignotement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKSEQSIZE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED RGB.',lib:'colorled.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED RGB. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la LED RGB.'};
doc['ColorLed']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED RGB.',lib:'colorled.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED RGB. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la LED RGB.'};
doc['ColorLed']['get_friendlyName']={syn:'Retourne un identifiant global de la LED RGB au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'colorled.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la LED RGB au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la LED RGB si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la LED RGB (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED RGB en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'colorled.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['ColorLed']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la LED RGB, sans r\xE9f\xE9rence au module.',lib:'colorled.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la LED RGB, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED RGB (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la LED RGB au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorled.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la LED RGB au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la LED RGB (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED RGB (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Retourne la couleur HSL courante de la LED.',lib:'colorled.get_hslColor()',pro:'def get_hslColor()',cmt:'<p>Retourne la couleur HSL courante de la LED.</p>',ret:'un entier repr&eacute;sentant la couleur HSL courante de la LED',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Retourne le nom logique de la LED RGB.',lib:'colorled.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la LED RGB.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la LED RGB.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'colorled.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Retourne la couleur RGB courante de la LED.',lib:'colorled.get_rgbColor()',pro:'def get_rgbColor()',cmt:'<p>Retourne la couleur RGB courante de la LED.</p>',ret:'un entier repr&eacute;sentant la couleur RGB courante de la LED',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'def get_rgbColorAtPowerOn()',cmt:'<p>Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.</p>',ret:'un entier repr&eacute;sentant la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['ColorLed']['hslMove']={syn:'Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.',lib:'colorled.hslMove()',pro:'def hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.</p>',par:{hsl_target:'couleur HSL d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLed']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la LED RGB est joignable, sans d\xE9clencher d\x27erreur.',lib:'colorled.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la LED RGB est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la LED RGB sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la LED RGB est joignable, <tt>false</tt> sinon'};
doc['ColorLed']['load']={syn:'Met en cache les valeurs courantes de la LED RGB, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'colorled.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la LED RGB, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'colorled.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['ColorLed']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'colorled.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['nextColorLed']={syn:'Continue l\x27\xE9num\xE9ration des LEDs RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les LEDs RGB sont retourn\xE9s.',lib:'colorled.nextColorLed()',pro:'def nextColorLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des LEDs RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les LEDs RGB sont retourn\xE9s. Si vous souhaitez retrouver une LED RGB sp\xE9cifique, utilisez <tt>ColorLed.findColorLed()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['ColorLed']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'colorled.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['ColorLed']['resetBlinkSeq']={syn:'efface le contenu de la sequence de clignotement.',lib:'colorled.resetBlinkSeq()',pro:'def resetBlinkSeq()',cmt:'<p>efface le contenu de la sequence de clignotement.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['rgbMove']={syn:'Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.',lib:'colorled.rgbMove()',pro:'def rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.</p>',par:{rgb_target:'couleur RGB d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLed']['set_hslColor']={syn:'Modifie la couleur courante de la LED, en utilisant une couleur HSL sp\xE9cifi\xE9e.',lib:'colorled.set_hslColor()',pro:'def set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la LED, en utilisant une couleur HSL sp\xE9cifi\xE9e. L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xHHSSLL.</p>',par:{newval:'un entier repr&eacute;sentant la couleur courante de la LED, en utilisant une couleur HSL sp\xE9cifi\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLed']['set_logicalName']={syn:'Modifie le nom logique de la LED RGB.',lib:'colorled.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la LED RGB. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la LED RGB.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_rgbColor']={syn:'Modifie la couleur courante de la LED, en utilisant une couleur RGB (Rouge Vert Bleu).',lib:'colorled.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la LED, en utilisant une couleur RGB (Rouge Vert Bleu). L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xRRGGBB.</p>',par:{newval:'un entier repr&eacute;sentant la couleur courante de la LED, en utilisant une couleur RGB (Rouge Vert Bleu)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Modifie la couleur que la LED va afficher \xE0 l\x27allumage du module.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Modifie la couleur que la LED va afficher \xE0 l\x27allumage du module.</p>',par:{newval:'un entier repr&eacute;sentant la couleur que la LED va afficher \xE0 l\x27allumage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLed']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'colorled.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['ColorLed']['startBlinkSeq']={syn:'D\xE9marre l\x27ex\xE9cution de la s\xE9quence pr\xE9programm\xE9e de clignotement.',lib:'colorled.startBlinkSeq()',pro:'def startBlinkSeq()',cmt:'<p>D\xE9marre l\x27ex\xE9cution de la s\xE9quence pr\xE9programm\xE9e de clignotement. La s\xE9quence va tourner en boucle jusqu\x27\xE0 ce qu\x27elle soit stopp\xE9e par stopBlinkSeq ou un changement explicite.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Arr\xEAte l\x27ex\xE9cution de la s\xE9quence pr\xE9programm\xE9e de clignotement.',lib:'colorled.stopBlinkSeq()',pro:'def stopBlinkSeq()',cmt:'<p>Arr\xEAte l\x27ex\xE9cution de la s\xE9quence pr\xE9programm\xE9e de clignotement.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'colorled.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: ColorLed)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Interface de la fonction Temperature',inc:'from yocto_temperature import *',cmt:'<p>La classe YTemperature permet de lire et de configurer les capteurs de temp\xE9rature Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet de configurer les param\xE8tres sp\xE9cifiques de certains types de capteur (type de connection, table d\x27\xE9talonnage).</p>'}};
doc['Temperature']['FindTemperature']={syn:'Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9.',lib:'YTemperature.FindTemperature()',pro:'def FindTemperature(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de temp\xE9rature soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YTemperature.isOnline()</tt> pour tester si le capteur de temp\xE9rature est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de temp\xE9rature sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YTemperature</tt> qui permet ensuite de contr\xF4ler le capteur de temp\xE9rature.'};
doc['Temperature']['FirstTemperature']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie.',lib:'YTemperature.FirstTemperature()',pro:'def FirstTemperature()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie. Utiliser la fonction <tt>YTemperature.nextTemperature()</tt> pour it\xE9rer sur les autres capteurs de temp\xE9rature.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt>, correspondant au premier capteur de temp\xE9rature accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de temp\xE9rature disponibles.'};
doc['Temperature']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'temperature.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['clearCache']={syn:'Invalide le cache.',lib:'temperature.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de temp\xE9rature. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Temperature']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de temp\xE9rature au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de temp\xE9rature au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de temp\xE9rature (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'temperature.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Temperature']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).',lib:'temperature.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s Celsius, sous forme de nombre \xE0 virgule.',lib:'temperature.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s Celsius, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s Celsius, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Retourne la valeur actuelle de la temp\xE9rature, en degr\xE9s Celsius, sous forme de nombre \xE0 virgule.',lib:'temperature.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la temp\xE9rature, en degr\xE9s Celsius, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la temp\xE9rature, en degr\xE9s Celsius, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'temperature.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Temperature']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de temp\xE9rature.',lib:'temperature.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de temp\xE9rature. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de temp\xE9rature.'};
doc['Temperature']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de temp\xE9rature.',lib:'temperature.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de temp\xE9rature. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de temp\xE9rature.'};
doc['Temperature']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de temp\xE9rature au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'temperature.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de temp\xE9rature au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de temp\xE9rature si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de temp\xE9rature (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de temp\xE9rature en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'temperature.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Temperature']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de temp\xE9rature, sans r\xE9f\xE9rence au module.',lib:'temperature.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de temp\xE9rature, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de temp\xE9rature (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de temp\xE9rature au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'temperature.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de temp\xE9rature au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de temp\xE9rature (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de temp\xE9rature (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module.',lib:'temperature.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'temperature.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Retourne le nom logique du capteur de temp\xE9rature.',lib:'temperature.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de temp\xE9rature.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module.',lib:'temperature.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la temp\xE9rature depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'temperature.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Temperature']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'temperature.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Temperature']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'temperature.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'temperature.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'temperature.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module ',lib:'temperature.get_sensorType()',pro:'def get_sensorType()',cmt:'<p>Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module</p>',ret:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt>, <tt>Y_SENSORTYPE_RES_INTERNAL</tt> et <tt>Y_SENSORTYPE_IR</tt> repr&eacute;sentant le type de capteur de temp\xE9rature utilis\xE9 par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_signalUnit']={syn:'Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur.',lib:'temperature.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['Temperature']['get_signalValue']={syn:'Retourne la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur.',lib:'temperature.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Retourne la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la temp\xE9rature est exprim\xE9e.',lib:'temperature.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la temp\xE9rature est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la temp\xE9rature est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Temperature']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de temp\xE9rature est joignable, sans d\xE9clencher d\x27erreur.',lib:'temperature.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de temp\xE9rature est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de temp\xE9rature sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de temp\xE9rature est joignable, <tt>false</tt> sinon'};
doc['Temperature']['load']={syn:'Met en cache les valeurs courantes du capteur de temp\xE9rature, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'temperature.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de temp\xE9rature, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'temperature.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Temperature']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'temperature.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['loadThermistorResponseTable']={syn:'R\xE9cup\xE8re la table de r\xE9ponse d\x27un thermistor pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_thermistorResponseTable</tt>.',lib:'temperature.loadThermistorResponseTable()',pro:'def loadThermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>R\xE9cup\xE8re la table de r\xE9ponse d\x27un thermistor pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_thermistorResponseTable</tt>. Cette fonction ne peut \xEAtre utilis\xE9e qu\x27avec les capteurs de temp\xE9rature bas\xE9s sur un thermistor.</p>',par:{tempValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les diff\xE9rentes temp\xE9ratures (en degr\xE9s Celsius) pour lesquelles la r\xE9sistance du thermistor est sp\xE9cifi\xE9e.',resValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les r\xE9sistances (en Ohms) pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'temperature.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['nextTemperature']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de temp\xE9rature sont retourn\xE9s.',lib:'temperature.nextTemperature()',pro:'def nextTemperature()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de temp\xE9rature sont retourn\xE9s. Si vous souhaitez retrouver un capteur de temp\xE9rature sp\xE9cifique, utilisez <tt>Temperature.findTemperature()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Temperature']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'temperature.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Temperature']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'temperature.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Temperature']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'temperature.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'temperature.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'temperature.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_logicalName']={syn:'Modifie le nom logique du capteur de temp\xE9rature.',lib:'temperature.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de temp\xE9rature. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'temperature.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_ntcParameters']={syn:'Configure les param\xE8tres d\x27un thermistor NTC pour calculer correctement la temp\xE9rature sur la base de la r\xE9sistance mesur\xE9e.',lib:'temperature.set_ntcParameters()',pro:'def set_ntcParameters(<span id=pn>res25</span>, <span id=pn>beta</span>)',cmt:'<p>Configure les param\xE8tres d\x27un thermistor NTC pour calculer correctement la temp\xE9rature sur la base de la r\xE9sistance mesur\xE9e. Pour plus de pr\xE9cision, vous pouvez saisir une table compl\xE8te \xE0 l\x27aide de la fonction set_thermistorResponseTable. Cette fonction ne peut \xEAtre utilis\xE9e qu\x27avec les capteurs de temp\xE9rature bas\xE9s sur un thermistor.</p>',par:{res25:'r\xE9sistance \xE0 25 degr\xE9s Celsius',beta:'coefficient Beta'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'temperature.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'temperature.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_sensorType']={syn:'Modifie le type de senseur utilis\xE9 par le module.',lib:'temperature.set_sensorType()',pro:'def set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de senseur utilis\xE9 par le module. Cette function sert \xE0 sp\xE9cifier le type de thermocouple (K,E, etc..) raccord\xE9 au module. Cette fonction n\x27aura pas d\x27effet si le module utilise un capteur digital ou un thermistor. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt>, <tt>Y_SENSORTYPE_RES_INTERNAL</tt> et <tt>Y_SENSORTYPE_IR</tt> repr&eacute;sentant le type de senseur utilis\xE9 par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_thermistorResponseTable']={syn:'Enregistre la table de r\xE9ponse d\x27un thermistor, afin de pouvoir interpoler la temp\xE9rature sur la base de la r\xE9sistance mesur\xE9e.',lib:'temperature.set_thermistorResponseTable()',pro:'def set_thermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Enregistre la table de r\xE9ponse d\x27un thermistor, afin de pouvoir interpoler la temp\xE9rature sur la base de la r\xE9sistance mesur\xE9e. Cette fonction ne peut \xEAtre utilis\xE9e qu\x27avec les capteurs de temp\xE9rature bas\xE9s sur un thermistor.</p>',par:{tempValues:'tableau de nombres flottants, correspondant aux diff\xE9rentes temp\xE9ratures (en degr\xE9s Celsius) pour lesquelles la r\xE9sistance du thermistor est sp\xE9cifi\xE9e.',resValues:'tableau de nombres flottants, correspondant aux r\xE9sistances (en Ohms) pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle la temp\xE9rature mesur\xE9e est exprim\xE9e.',lib:'temperature.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle la temp\xE9rature mesur\xE9e est exprim\xE9e. Cette unit\xE9 est une cha\xEEne de charact\xE8re. Si cette cha\xEEne de caract\xE8re se termine par un F les valeurs mesur\xE9e seront rendues en degr\xE9s Fahrenheit, si elle se termine par un K, les valeurs de temp\xE9rature seront rendues en degr\xE9s Kelvin. Si elle se termine par un C, les valeurs de temp\xE9rature seront rendues en degr\xE9s Celsius. Si elle ne setermine n\x27importe quel autre caract\xE8re, le changement est ignor\xE9. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. Attention: si une calibration sp\xE9cifique est d\xE9finie pour la fonction temperature, un changement d\x27unit\xE9 a toutes les chances de la fausser.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Temperature']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'temperature.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Temperature']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'temperature.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Temperature']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'temperature.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Temperature']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'temperature.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'Interface de la fonction DataLogger',inc:'from yocto_api import *',cmt:'<p>Les capteurs de Yoctopuce sont \xE9quip\xE9s d\x27une m\xE9moire non-volatile permettant de m\xE9moriser les donn\xE9es mesur\xE9es d\x27une mani\xE8re autonome, sans n\xE9cessiter le suivi permanent d\x27un ordinateur. La fonction DataLogger contr\xF4le les param\xE8tres globaux de cet enregistreur de donn\xE9es.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDataLogger.FindDataLogger()',pro:'def FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27enregistreur de donn\xE9es soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDataLogger.isOnline()</tt> pour tester si l\x27enregistreur de donn\xE9es est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27enregistreur de donn\xE9es sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDataLogger</tt> qui permet ensuite de contr\xF4ler l\x27enregistreur de donn\xE9es.'};
doc['DataLogger']['FirstDataLogger']={syn:'Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie.',lib:'YDataLogger.FirstDataLogger()',pro:'def FirstDataLogger()',cmt:'<p>Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie. Utiliser la fonction <tt>YDataLogger.nextDataLogger()</tt> pour it\xE9rer sur les autres enregistreurs de donn\xE9es.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt>, correspondant au premier enregistreur de donn\xE9es accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de enregistreurs de donn\xE9es disponibles.'};
doc['DataLogger']['clearCache']={syn:'Invalide le cache.',lib:'datalogger.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27enregistreur de donn\xE9es. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['DataLogger']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27enregistreur de donn\xE9es au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27enregistreur de donn\xE9es au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27enregistreur de donn\xE9es (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es.',lib:'datalogger.forgetAllDataStreams()',pro:'def forgetAllDataStreams()',cmt:'<p>Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es. Cette m\xE9thode remet aussi \xE0 z\xE9ro le compteur de Runs.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).',lib:'datalogger.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_beaconDriven']={syn:'Retourne vrais si l\x27enregistreur de donn\xE9es est synchronis\xE9 avec la balise de localisation.',lib:'datalogger.get_beaconDriven()',pro:'def get_beaconDriven()',cmt:'<p>Retourne vrais si l\x27enregistreur de donn\xE9es est synchronis\xE9 avec la balise de localisation.</p>',ret:'soit <tt>Y_BEACONDRIVEN_OFF</tt>, soit <tt>Y_BEACONDRIVEN_ON</tt>, selon vrais si l\x27enregistreur de donn\xE9es est synchronis\xE9 avec la balise de localisation',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BEACONDRIVEN_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.',lib:'datalogger.get_currentRunIndex()',pro:'def get_currentRunIndex()',cmt:'<p>Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.</p>',ret:'un entier repr&eacute;sentant le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataSets']={syn:'Retourne une liste d\x27objets YDataSet permettant de r\xE9cup\xE9rer toutes les mesures stock\xE9es par l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_dataSets()',pro:'def get_dataSets()',cmt:'<p>Retourne une liste d\x27objets YDataSet permettant de r\xE9cup\xE9rer toutes les mesures stock\xE9es par l\x27enregistreur de donn\xE9es.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets YDataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',ret:'une liste d\x27objets YDataSet',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataLogger']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27enregistreur de donn\xE9es. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27enregistreur de donn\xE9es.'};
doc['DataLogger']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27enregistreur de donn\xE9es. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27enregistreur de donn\xE9es.'};
doc['DataLogger']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27enregistreur de donn\xE9es au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'datalogger.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27enregistreur de donn\xE9es au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27enregistreur de donn\xE9es si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27enregistreur de donn\xE9es (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27enregistreur de donn\xE9es en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'datalogger.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DataLogger']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27enregistreur de donn\xE9es, sans r\xE9f\xE9rence au module.',lib:'datalogger.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27enregistreur de donn\xE9es, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27enregistreur de donn\xE9es (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27enregistreur de donn\xE9es au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'datalogger.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27enregistreur de donn\xE9es au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27enregistreur de donn\xE9es (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27enregistreur de donn\xE9es (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Retourne le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'datalogger.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DataLogger']['get_recording']={syn:'Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_recording()',pro:'def get_recording()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',ret:'une valeur parmi <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> et <tt>Y_RECORDING_PENDING</tt> repr&eacute;sentant l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.',lib:'datalogger.get_timeUTC()',pro:'def get_timeUTC()',cmt:'<p>Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.</p>',ret:'un entier repr&eacute;sentant le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_usage']={syn:'Retourne le pourcentage d\x27utilisation de la m\xE9moire d\x27enregistrement.',lib:'datalogger.get_usage()',pro:'def get_usage()',cmt:'<p>Retourne le pourcentage d\x27utilisation de la m\xE9moire d\x27enregistrement.</p>',ret:'un entier repr&eacute;sentant le pourcentage d\x27utilisation de la m\xE9moire d\x27enregistrement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_USAGE_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DataLogger']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27enregistreur de donn\xE9es est joignable, sans d\xE9clencher d\x27erreur.',lib:'datalogger.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27enregistreur de donn\xE9es est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27enregistreur de donn\xE9es sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27enregistreur de donn\xE9es est joignable, <tt>false</tt> sinon'};
doc['DataLogger']['load']={syn:'Met en cache les valeurs courantes de l\x27enregistreur de donn\xE9es, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'datalogger.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27enregistreur de donn\xE9es, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'datalogger.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['DataLogger']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'datalogger.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['nextDataLogger']={syn:'Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les enregistreurs de donn\xE9es sont retourn\xE9s.',lib:'datalogger.nextDataLogger()',pro:'def nextDataLogger()',cmt:'<p>Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les enregistreurs de donn\xE9es sont retourn\xE9s. Si vous souhaitez retrouver un enregistreur de donn\xE9es sp\xE9cifique, utilisez <tt>DataLogger.findDataLogger()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DataLogger']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'datalogger.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DataLogger']['set_autoStart']={syn:'Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DataLogger']['set_beaconDriven']={syn:'Modifie le mode de synchronisation de l\x27enregistreur de donn\xE9es .',lib:'datalogger.set_beaconDriven()',pro:'def set_beaconDriven(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de synchronisation de l\x27enregistreur de donn\xE9es . N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_BEACONDRIVEN_OFF</tt>, soit <tt>Y_BEACONDRIVEN_ON</tt>, selon le mode de synchronisation de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DataLogger']['set_logicalName']={syn:'Modifie le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27enregistreur de donn\xE9es. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_recording']={syn:'Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_recording()',pro:'def set_recording(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',par:{newval:'une valeur parmi <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> et <tt>Y_RECORDING_PENDING</tt> repr&eacute;sentant l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DataLogger']['set_timeUTC']={syn:'Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.',lib:'datalogger.set_timeUTC()',pro:'def set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.</p>',par:{newval:'un entier repr&eacute;sentant la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DataLogger']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'datalogger.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['DataLogger']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'datalogger.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'Interface de contr\xF4le de l\x27alimentation',inc:'from yocto_dualpower import *',cmt:'<p>La librairie de programmation Yoctopuce permet de contr\xF4ler la source d\x27alimentation qui doit \xEAtre utilis\xE9e pour les fonctions du module consommant beaucoup de courant. Le module est par ailleurs capable de couper automatiquement l\x27alimentation externe lorsqu\x27il d\xE9tecte que la tension a trop chut\xE9 (batterie \xE9puis\xE9e).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDualPower.FindDualPower()',pro:'def FindDualPower(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le contr\xF4le d\x27alimentation soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDualPower.isOnline()</tt> pour tester si le contr\xF4le d\x27alimentation est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4le d\x27alimentation sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDualPower</tt> qui permet ensuite de contr\xF4ler le contr\xF4le d\x27alimentation.'};
doc['DualPower']['FirstDualPower']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie.',lib:'YDualPower.FirstDualPower()',pro:'def FirstDualPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie. Utiliser la fonction <tt>YDualPower.nextDualPower()</tt> pour it\xE9rer sur les autres contr\xF4les d\x27alimentation.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt>, correspondant au premier contr\xF4le d\x27alimentation accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4les d\x27alimentation disponibles.'};
doc['DualPower']['clearCache']={syn:'Invalide le cache.',lib:'dualpower.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du contr\xF4le d\x27alimentation. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['DualPower']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4le d\x27alimentation au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4le d\x27alimentation au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le contr\xF4le d\x27alimentation (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).',lib:'dualpower.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27alimentation.',lib:'dualpower.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27alimentation. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4le d\x27alimentation.'};
doc['DualPower']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27alimentation.',lib:'dualpower.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27alimentation. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4le d\x27alimentation.'};
doc['DualPower']['get_extVoltage']={syn:'Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.',lib:'dualpower.get_extVoltage()',pro:'def get_extVoltage()',cmt:'<p>Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.</p>',ret:'un entier repr&eacute;sentant la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Retourne un identifiant global du contr\xF4le d\x27alimentation au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'dualpower.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du contr\xF4le d\x27alimentation au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du contr\xF4le d\x27alimentation si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du contr\xF4le d\x27alimentation (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27alimentation en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'dualpower.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DualPower']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du contr\xF4le d\x27alimentation, sans r\xE9f\xE9rence au module.',lib:'dualpower.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du contr\xF4le d\x27alimentation, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27alimentation (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du contr\xF4le d\x27alimentation au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'dualpower.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du contr\xF4le d\x27alimentation au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du contr\xF4le d\x27alimentation (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27alimentation (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4le d\x27alimentation.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'dualpower.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerControl()',pro:'def get_powerControl()',cmt:'<p>Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr&eacute;sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerState()',pro:'def get_powerState()',cmt:'<p>Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> et <tt>Y_POWERSTATE_FROM_EXT</tt> repr&eacute;sentant la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DualPower']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le contr\xF4le d\x27alimentation est joignable, sans d\xE9clencher d\x27erreur.',lib:'dualpower.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le contr\xF4le d\x27alimentation est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du contr\xF4le d\x27alimentation sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le contr\xF4le d\x27alimentation est joignable, <tt>false</tt> sinon'};
doc['DualPower']['load']={syn:'Met en cache les valeurs courantes du contr\xF4le d\x27alimentation, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'dualpower.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du contr\xF4le d\x27alimentation, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'dualpower.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['DualPower']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'dualpower.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['nextDualPower']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4les d\x27alimentation sont retourn\xE9s.',lib:'dualpower.nextDualPower()',pro:'def nextDualPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4les d\x27alimentation sont retourn\xE9s. Si vous souhaitez retrouver un contr\xF4le d\x27alimentation sp\xE9cifique, utilisez <tt>DualPower.findDualPower()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DualPower']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'dualpower.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DualPower']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4le d\x27alimentation. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['set_powerControl']={syn:'Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.set_powerControl()',pro:'def set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',par:{newval:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr&eacute;sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DualPower']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'dualpower.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['DualPower']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'dualpower.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Interface de la fonction Servo',inc:'from yocto_servo import *',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement de d\xE9placer le servo vers une position donn\xE9e, mais aussi de sp\xE9cifier l\x27interval de temps dans lequel le mouvement doit \xEAtre fait, de sorte \xE0 pouvoir synchroniser un mouvement sur plusieurs servos.</p>'}};
doc['Servo']['FindServo']={syn:'Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9.',lib:'YServo.FindServo()',pro:'def FindServo(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le servo soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YServo.isOnline()</tt> pour tester si le servo est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le servo sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YServo</tt> qui permet ensuite de contr\xF4ler le servo.'};
doc['Servo']['FirstServo']={syn:'Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie.',lib:'YServo.FirstServo()',pro:'def FirstServo()',cmt:'<p>Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie. Utiliser la fonction <tt>YServo.nextServo()</tt> pour it\xE9rer sur les autres servo.</p>',ret:'un pointeur sur un objet <tt>YServo</tt>, correspondant au premier servo accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de servo disponibles.'};
doc['Servo']['clearCache']={syn:'Invalide le cache.',lib:'servo.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du servo. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Servo']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du servo au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du servo au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le servo (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).',lib:'servo.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du servo (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_enabled']={syn:'Retourne l\x27\xE9tat de fonctionnement du $FUNCTION$.',lib:'servo.get_enabled()',pro:'def get_enabled()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement du $FUNCTION$.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon l\x27\xE9tat de fonctionnement du $FUNCTION$',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['Servo']['get_enabledAtPowerOn']={syn:'Retourne l\x27\xE9tat du g\xE9n\xE9rateur de signal de commande du servo au d\xE9marrage du module.',lib:'servo.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Retourne l\x27\xE9tat du g\xE9n\xE9rateur de signal de commande du servo au d\xE9marrage du module.</p>',ret:'soit <tt>Y_ENABLEDATPOWERON_FALSE</tt>, soit <tt>Y_ENABLEDATPOWERON_TRUE</tt>, selon l\x27\xE9tat du g\xE9n\xE9rateur de signal de commande du servo au d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du servo.',lib:'servo.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du servo. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du servo.'};
doc['Servo']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du servo.',lib:'servo.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du servo. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du servo.'};
doc['Servo']['get_friendlyName']={syn:'Retourne un identifiant global du servo au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'servo.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du servo au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du servo si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du servo (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le servo en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'servo.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Servo']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du servo, sans r\xE9f\xE9rence au module.',lib:'servo.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du servo, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le servo (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du servo au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'servo.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du servo au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du servo (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le servo (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Retourne le nom logique du servo.',lib:'servo.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du servo.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'servo.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.',lib:'servo.get_neutral()',pro:'def get_neutral()',cmt:'<p>Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Retourne la position courante du servo.',lib:'servo.get_position()',pro:'def get_position()',cmt:'<p>Retourne la position courante du servo.</p>',ret:'un entier repr&eacute;sentant la position courante du servo',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_positionAtPowerOn']={syn:'Retourne la position du servo au d\xE9marrage du module.',lib:'servo.get_positionAtPowerOn()',pro:'def get_positionAtPowerOn()',cmt:'<p>Retourne la position du servo au d\xE9marrage du module.</p>',ret:'un entier repr&eacute;sentant la position du servo au d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POSITIONATPOWERON_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Retourne la plage d\x27utilisation du servo.',lib:'servo.get_range()',pro:'def get_range()',cmt:'<p>Retourne la plage d\x27utilisation du servo.</p>',ret:'un entier repr&eacute;sentant la plage d\x27utilisation du servo',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Servo']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le servo est joignable, sans d\xE9clencher d\x27erreur.',lib:'servo.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le servo est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du servo sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le servo est joignable, <tt>false</tt> sinon'};
doc['Servo']['load']={syn:'Met en cache les valeurs courantes du servo, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'servo.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du servo, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'servo.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Servo']['move']={syn:'D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.',lib:'servo.move()',pro:'def move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.</p>',par:{target:'nouvelle position \xE0 la fin du mouvement',ms_duration:'dur\xE9e totale du mouvement, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'servo.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['nextServo']={syn:'Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les servo sont retourn\xE9s.',lib:'servo.nextServo()',pro:'def nextServo()',cmt:'<p>Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les servo sont retourn\xE9s. Si vous souhaitez retrouver un servo sp\xE9cifique, utilisez <tt>Servo.findServo()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YServo</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Servo']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'servo.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Servo']['set_enabled']={syn:'D\xE9marre ou arr\xEAte le $FUNCTION$.',lib:'servo.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>D\xE9marre ou arr\xEAte le $FUNCTION$.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure l\x27\xE9tat du g\xE9n\xE9rateur de signal de commande du servo au d\xE9marrage du module.',lib:'servo.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure l\x27\xE9tat du g\xE9n\xE9rateur de signal de commande du servo au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'soit <tt>Y_ENABLEDATPOWERON_FALSE</tt>, soit <tt>Y_ENABLEDATPOWERON_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_logicalName']={syn:'Modifie le nom logique du servo.',lib:'servo.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du servo. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_neutral']={syn:'Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo.',lib:'servo.set_neutral()',pro:'def set_neutral(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo. La dur\xE9e est sp\xE9cifi\xE9e en microsecondes, et la valeur standard est 1500 [us]. Ce r\xE9glage permet de d\xE9caler la plage d\x27utilisation du servo. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_position']={syn:'Modifie imm\xE9diatement la consigne de position du servo.',lib:'servo.set_position()',pro:'def set_position(<span id=pn>newval</span>)',cmt:'<p>Modifie imm\xE9diatement la consigne de position du servo.</p>',par:{newval:'un entier repr&eacute;sentant imm\xE9diatement la consigne de position du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure la position du servo au d\xE9marrage du module.',lib:'servo.set_positionAtPowerOn()',pro:'def set_positionAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure la position du servo au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_range']={syn:'Modifie la plage d\x27utilisation du servo, en pourcents.',lib:'servo.set_range()',pro:'def set_range(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage d\x27utilisation du servo, en pourcents. La valeur 100% correspond \xE0 un signal de commande standard, variant de 1 [ms] \xE0 2 [ms]. Pour les servos supportent une plage double, de 0.5 [ms] \xE0 2.5 [ms], vous pouvez utiliser une valeur allant jusqu\x27\xE0 200%. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'un entier repr&eacute;sentant la plage d\x27utilisation du servo, en pourcents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Servo']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'servo.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Servo']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'servo.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Interface de la fonction Relay',inc:'from yocto_relay import *',cmt:'<p>La librairie de programmation Yoctopuce permet simplement de changer l\x27\xE9tat du relais. Le changement d\x27\xE9tat n\x27est pas persistant: le relais retournera spontan\xE9ment \xE0 sa position de repos d\xE8s que le module est mis hors tension ou red\xE9marr\xE9. La librairie permet aussi de cr\xE9er des courtes impulsions de dur\xE9e d\xE9termin\xE9e. Pour les modules dot\xE9s de deux sorties par relais (relai inverseur), les deux sorties sont appel\xE9es A et B, la sortie A correspondant a la position de repos (hors tension) et la sortie B correspondant \xE0 l\x27\xE9tat actif. Si vous pr\xE9f\xE9reriez l\x27\xE9tat par d\xE9faut oppos\xE9, vous pouvez simplement changer vos fils sur le bornier.</p>'}};
doc['Relay']['FindRelay']={syn:'Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRelay.FindRelay()',pro:'def FindRelay(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le relais soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRelay.isOnline()</tt> pour tester si le relais est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le relais sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRelay</tt> qui permet ensuite de contr\xF4ler le relais.'};
doc['Relay']['FirstRelay']={syn:'Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie.',lib:'YRelay.FirstRelay()',pro:'def FirstRelay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie. Utiliser la fonction <tt>YRelay.nextRelay()</tt> pour it\xE9rer sur les autres relais.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt>, correspondant au premier relais accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de relais disponibles.'};
doc['Relay']['clearCache']={syn:'Invalide le cache.',lib:'relay.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du relais. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Relay']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'relay.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27impulsion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du relais au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du relais au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le relais (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).',lib:'relay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du relais (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'relay.get_countdown()',pro:'def get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du relais.',lib:'relay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du relais. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du relais.'};
doc['Relay']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du relais.',lib:'relay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du relais. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du relais.'};
doc['Relay']['get_friendlyName']={syn:'Retourne un identifiant global du relais au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'relay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du relais au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du relais si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du relais (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le relais en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'relay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Relay']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du relais, sans r\xE9f\xE9rence au module.',lib:'relay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du relais, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le relais (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du relais au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'relay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du relais au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du relais (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le relais (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Retourne le nom logique du relais.',lib:'relay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du relais.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B.',lib:'relay.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',ret:'un entier repr&eacute;sentant le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A.',lib:'relay.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',ret:'un entier repr&eacute;sentant le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'relay.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.get_output()',pro:'def get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'relay.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.get_state()',pro:'def get_state()',cmt:'<p>Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_stateAtPowerOn']={syn:'Retourne l\x27\xE9tat du relais au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).',lib:'relay.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Retourne l\x27\xE9tat du relais au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).</p>',ret:'une valeur parmi <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> et <tt>Y_STATEATPOWERON_B</tt> repr&eacute;sentant l\x27\xE9tat du relais au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Relay']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le relais est joignable, sans d\xE9clencher d\x27erreur.',lib:'relay.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le relais est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du relais sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le relais est joignable, <tt>false</tt> sinon'};
doc['Relay']['load']={syn:'Met en cache les valeurs courantes du relais, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'relay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du relais, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'relay.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Relay']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'relay.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['nextRelay']={syn:'Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les relais sont retourn\xE9s.',lib:'relay.nextRelay()',pro:'def nextRelay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les relais sont retourn\xE9s. Si vous souhaitez retrouver un relais sp\xE9cifique, utilisez <tt>Relay.findRelay()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Relay']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'relay.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'relay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Relay']['set_logicalName']={syn:'Modifie le nom logique du relais.',lib:'relay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du relais. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_maxTimeOnStateA']={syn:'R\xE8gle le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B.',lib:'relay.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['set_maxTimeOnStateB']={syn:'R\xE8gle le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A.',lib:'relay.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle le temps maximal (en ms) pendant lequel le relais peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['set_state']={syn:'Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['set_stateAtPowerOn']={syn:'Pr\xE9-programme l\x27\xE9tat du relais au d\xE9marrage du module(A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).',lib:'relay.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Pr\xE9-programme l\x27\xE9tat du relais au d\xE9marrage du module(A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur parmi <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> et <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Relay']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'relay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Relay']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'relay.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Relay)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Interface de la fonction Humidity',inc:'from yocto_humidity import *',cmt:'<p>La classe YHumidity permet de lire et de configurer les capteurs d\x27humidit\xE9 Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHumidity.FindHumidity()',pro:'def FindHumidity(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur d\x27humidit\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHumidity.isOnline()</tt> pour tester si le capteur d\x27humidit\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur d\x27humidit\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHumidity</tt> qui permet ensuite de contr\xF4ler le capteur d\x27humidit\xE9.'};
doc['Humidity']['FirstHumidity']={syn:'Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie.',lib:'YHumidity.FirstHumidity()',pro:'def FirstHumidity()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie. Utiliser la fonction <tt>YHumidity.nextHumidity()</tt> pour it\xE9rer sur les autres capteurs d\x27humidit\xE9.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt>, correspondant au premier capteur d\x27humidit\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs d\x27humidit\xE9 disponibles.'};
doc['Humidity']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'humidity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['clearCache']={syn:'Invalide le cache.',lib:'humidity.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur d\x27humidit\xE9. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Humidity']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur d\x27humidit\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur d\x27humidit\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur d\x27humidit\xE9 (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_absHum']={syn:'Retourne la valeur actuelle de l\x27humidit\xE9 absolue, en gramme par m\xE8tre cube d\x27air.',lib:'humidity.get_absHum()',pro:'def get_absHum()',cmt:'<p>Retourne la valeur actuelle de l\x27humidit\xE9 absolue, en gramme par m\xE8tre cube d\x27air.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27humidit\xE9 absolue, en gramme par m\xE8tre cube d\x27air',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ABSHUM_INVALID</tt>.'};
doc['Humidity']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'humidity.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Humidity']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).',lib:'humidity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en %RH, sous forme de nombre \xE0 virgule.',lib:'humidity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en %RH, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en %RH, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Retourne la valeur actuelle de l\x27humidit\xE9, en %RH, sous forme de nombre \xE0 virgule.',lib:'humidity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de l\x27humidit\xE9, en %RH, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27humidit\xE9, en %RH, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'humidity.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Humidity']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur d\x27humidit\xE9.',lib:'humidity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur d\x27humidit\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur d\x27humidit\xE9.'};
doc['Humidity']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur d\x27humidit\xE9.',lib:'humidity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur d\x27humidit\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur d\x27humidit\xE9.'};
doc['Humidity']['get_friendlyName']={syn:'Retourne un identifiant global du capteur d\x27humidit\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'humidity.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur d\x27humidit\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur d\x27humidit\xE9 si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur d\x27humidit\xE9 (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur d\x27humidit\xE9 en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'humidity.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Humidity']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur d\x27humidit\xE9, sans r\xE9f\xE9rence au module.',lib:'humidity.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur d\x27humidit\xE9, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur d\x27humidit\xE9 (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur d\x27humidit\xE9 au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'humidity.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur d\x27humidit\xE9 au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur d\x27humidit\xE9 (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur d\x27humidit\xE9 (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module.',lib:'humidity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'humidity.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Retourne le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur d\x27humidit\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module.',lib:'humidity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour l\x27humidit\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'humidity.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Humidity']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'humidity.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Humidity']['get_relHum']={syn:'Retourne la valeur actuelle de l\x27humidit\xE9 relative, en pour cent.',lib:'humidity.get_relHum()',pro:'def get_relHum()',cmt:'<p>Retourne la valeur actuelle de l\x27humidit\xE9 relative, en pour cent.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27humidit\xE9 relative, en pour cent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RELHUM_INVALID</tt>.'};
doc['Humidity']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'humidity.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'humidity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'humidity.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle l\x27humidit\xE9 est exprim\xE9e.',lib:'humidity.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle l\x27humidit\xE9 est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle l\x27humidit\xE9 est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Humidity']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur d\x27humidit\xE9 est joignable, sans d\xE9clencher d\x27erreur.',lib:'humidity.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur d\x27humidit\xE9 est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur d\x27humidit\xE9 sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur d\x27humidit\xE9 est joignable, <tt>false</tt> sinon'};
doc['Humidity']['load']={syn:'Met en cache les valeurs courantes du capteur d\x27humidit\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'humidity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur d\x27humidit\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'humidity.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Humidity']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'humidity.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'humidity.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['nextHumidity']={syn:'Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs d\x27humidit\xE9 sont retourn\xE9s.',lib:'humidity.nextHumidity()',pro:'def nextHumidity()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs d\x27humidit\xE9 sont retourn\xE9s. Si vous souhaitez retrouver un capteur d\x27humidit\xE9 sp\xE9cifique, utilisez <tt>Humidity.findHumidity()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Humidity']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'humidity.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Humidity']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'humidity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Humidity']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'humidity.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'humidity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'humidity.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_logicalName']={syn:'Modifie le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur d\x27humidit\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'humidity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'humidity.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'humidity.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_unit']={syn:'Change l\x27unit\xE9 principale dans laquelle l\x27humidit\xE9 est exprim\xE9e.',lib:'humidity.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 principale dans laquelle l\x27humidit\xE9 est exprim\xE9e. Cette unit\xE9 est une cha\xEEne de charact\xE8re. Si la cha\xEEne commence par une lettre \x27g\x27, la valeur principale est l\x27humidit\xE9 absolue en g/m3. Autrement, la valeur principale sera l\x27humidit\xE9 relative, en pour cent.</p><p> N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Humidity']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'humidity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Humidity']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'humidity.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Humidity']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'humidity.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Humidity']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'humidity.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Interface de la fonction Pressure',inc:'from yocto_pressure import *',cmt:'<p>La classe YPressure permet de lire et de configurer les capteurs de pression Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Pressure']['FindPressure']={syn:'Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPressure.FindPressure()',pro:'def FindPressure(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de pression soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPressure.isOnline()</tt> pour tester si le capteur de pression est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de pression sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPressure</tt> qui permet ensuite de contr\xF4ler le capteur de pression.'};
doc['Pressure']['FirstPressure']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie.',lib:'YPressure.FirstPressure()',pro:'def FirstPressure()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie. Utiliser la fonction <tt>YPressure.nextPressure()</tt> pour it\xE9rer sur les autres capteurs de pression.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt>, correspondant au premier capteur de pression accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de pression disponibles.'};
doc['Pressure']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'pressure.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['clearCache']={syn:'Invalide le cache.',lib:'pressure.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de pression. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Pressure']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de pression au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de pression au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de pression (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'pressure.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Pressure']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).',lib:'pressure.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en millibar (hPa), sous forme de nombre \xE0 virgule.',lib:'pressure.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en millibar (hPa), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en millibar (hPa), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Retourne la valeur actuelle de la pression, en millibar (hPa), sous forme de nombre \xE0 virgule.',lib:'pressure.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la pression, en millibar (hPa), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la pression, en millibar (hPa), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'pressure.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Pressure']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de pression.',lib:'pressure.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de pression. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de pression.'};
doc['Pressure']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de pression.',lib:'pressure.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de pression. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de pression.'};
doc['Pressure']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de pression au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'pressure.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de pression au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de pression si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de pression (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de pression en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pressure.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Pressure']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de pression, sans r\xE9f\xE9rence au module.',lib:'pressure.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de pression, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de pression (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de pression au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'pressure.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de pression au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de pression (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de pression (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la pression depuis le d\xE9marrage du module.',lib:'pressure.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la pression depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la pression depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'pressure.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Retourne le nom logique du capteur de pression.',lib:'pressure.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de pression.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la pression depuis le d\xE9marrage du module.',lib:'pressure.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la pression depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la pression depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pressure.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Pressure']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'pressure.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Pressure']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'pressure.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'pressure.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'pressure.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la pression est exprim\xE9e.',lib:'pressure.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la pression est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la pression est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Pressure']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de pression est joignable, sans d\xE9clencher d\x27erreur.',lib:'pressure.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de pression est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de pression sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de pression est joignable, <tt>false</tt> sinon'};
doc['Pressure']['load']={syn:'Met en cache les valeurs courantes du capteur de pression, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pressure.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de pression, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'pressure.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Pressure']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'pressure.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pressure.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['nextPressure']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de pression sont retourn\xE9s.',lib:'pressure.nextPressure()',pro:'def nextPressure()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de pression sont retourn\xE9s. Si vous souhaitez retrouver un capteur de pression sp\xE9cifique, utilisez <tt>Pressure.findPressure()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Pressure']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'pressure.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Pressure']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pressure.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Pressure']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'pressure.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'pressure.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'pressure.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_logicalName']={syn:'Modifie le nom logique du capteur de pression.',lib:'pressure.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de pression. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'pressure.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'pressure.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'pressure.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Pressure']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pressure.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Pressure']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'pressure.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Pressure']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'pressure.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Pressure']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pressure.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'Interface de la fonction LightSensor',inc:'from yocto_lightsensor import *',cmt:'<p>La classe YLightSensor permet de lire et de configurer les capteurs de lumi\xE8re Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet d\x27effectuer facilement une calibration lin\xE9aire \xE0 un point pour compenser l\x27effet d\x27une vitre ou d\x27un filtre plac\xE9 devant le capteur. Pour certains capteurs de lumi\xE8re ayant plusieurs modes de fonctionnement, cette classe permet aussi de configurer le mode d\xE9sir\xE9.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLightSensor.FindLightSensor()',pro:'def FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de lumi\xE8re soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLightSensor.isOnline()</tt> pour tester si le capteur de lumi\xE8re est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de lumi\xE8re sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLightSensor</tt> qui permet ensuite de contr\xF4ler le capteur de lumi\xE8re.'};
doc['LightSensor']['FirstLightSensor']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie.',lib:'YLightSensor.FirstLightSensor()',pro:'def FirstLightSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie. Utiliser la fonction <tt>YLightSensor.nextLightSensor()</tt> pour it\xE9rer sur les autres capteurs de lumi\xE8re.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt>, correspondant au premier capteur de lumi\xE8re accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de lumi\xE8re disponibles.'};
doc['LightSensor']['calibrate']={syn:'Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).',lib:'lightsensor.calibrate()',pro:'def calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).</p>',par:{calibratedVal:'la consigne de valeur d\xE9sir\xE9e.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'lightsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['clearCache']={syn:'Invalide le cache.',lib:'lightsensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de lumi\xE8re. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['LightSensor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de lumi\xE8re au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de lumi\xE8re au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de lumi\xE8re (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'lightsensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['LightSensor']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).',lib:'lightsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'lightsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Retourne la valeur actuelle de la lumi\xE8re ambiante, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'lightsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la lumi\xE8re ambiante, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la lumi\xE8re ambiante, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'lightsensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['LightSensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de lumi\xE8re.',lib:'lightsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de lumi\xE8re. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de lumi\xE8re.'};
doc['LightSensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de lumi\xE8re.',lib:'lightsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de lumi\xE8re. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de lumi\xE8re.'};
doc['LightSensor']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de lumi\xE8re au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'lightsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de lumi\xE8re au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de lumi\xE8re si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de lumi\xE8re (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de lumi\xE8re en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'lightsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['LightSensor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de lumi\xE8re, sans r\xE9f\xE9rence au module.',lib:'lightsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de lumi\xE8re, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de lumi\xE8re (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de lumi\xE8re au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'lightsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de lumi\xE8re au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de lumi\xE8re (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de lumi\xE8re (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module.',lib:'lightsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'lightsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Retourne le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de lumi\xE8re.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module.',lib:'lightsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la lumi\xE8re ambiante depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_measureType']={syn:'Retourne le type de mesure de lumi\xE8re utilis\xE9 par le module.',lib:'lightsensor.get_measureType()',pro:'def get_measureType()',cmt:'<p>Retourne le type de mesure de lumi\xE8re utilis\xE9 par le module.</p>',ret:'une valeur parmi <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> et <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> repr&eacute;sentant le type de mesure de lumi\xE8re utilis\xE9 par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MEASURETYPE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'lightsensor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['LightSensor']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'lightsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['LightSensor']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'lightsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'lightsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'lightsensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la lumi\xE8re ambiante est exprim\xE9e.',lib:'lightsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la lumi\xE8re ambiante est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la lumi\xE8re ambiante est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['LightSensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de lumi\xE8re est joignable, sans d\xE9clencher d\x27erreur.',lib:'lightsensor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de lumi\xE8re est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de lumi\xE8re sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de lumi\xE8re est joignable, <tt>false</tt> sinon'};
doc['LightSensor']['load']={syn:'Met en cache les valeurs courantes du capteur de lumi\xE8re, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'lightsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de lumi\xE8re, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'lightsensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['LightSensor']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'lightsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'lightsensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['nextLightSensor']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de lumi\xE8re sont retourn\xE9s.',lib:'lightsensor.nextLightSensor()',pro:'def nextLightSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de lumi\xE8re sont retourn\xE9s. Si vous souhaitez retrouver un capteur de lumi\xE8re sp\xE9cifique, utilisez <tt>LightSensor.findLightSensor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['LightSensor']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'lightsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['LightSensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'lightsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['LightSensor']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'lightsensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'lightsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'lightsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_logicalName']={syn:'Modifie le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de lumi\xE8re. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'lightsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_measureType']={syn:'Modifie le type dde mesure de lumi\xE8re effectu\xE9e par le capteur.',lib:'lightsensor.set_measureType()',pro:'def set_measureType(<span id=pn>newval</span>)',cmt:'<p>Modifie le type dde mesure de lumi\xE8re effectu\xE9e par le capteur. La mesure peut soit approximer la r\xE9ponse de l\x27oeil humain, soit donner une valeur ciblant un spectre particulier, en fonction des possibilit\xE9s offertes par le r\xE9cepteur de lumi\xE8re. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> et <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> repr&eacute;sentant le type dde mesure de lumi\xE8re effectu\xE9e par le capteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'lightsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'lightsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['LightSensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'lightsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['LightSensor']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'lightsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['LightSensor']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'lightsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['LightSensor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'lightsensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: LightSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Interface d\x27un port de Yocto-hub',inc:'from yocto_hubport import *',cmt:'<p>Les objets YHubPort permettent de contr\xF4ler l\x27alimentation des ports d\x27un YoctoHub, ainsi que de d\xE9tecter si un module y est raccord\xE9 et lequel. Un YHubPort re\xE7oit toujours automatiquement comme nom logique le num\xE9ro de s\xE9rie unique du module Yoctopuce qui y est connect\xE9.</p>'}};
doc['HubPort']['FindHubPort']={syn:'Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHubPort.FindHubPort()',pro:'def FindHubPort(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le port de Yocto-hub soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHubPort.isOnline()</tt> pour tester si le port de Yocto-hub est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port de Yocto-hub sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHubPort</tt> qui permet ensuite de contr\xF4ler le port de Yocto-hub.'};
doc['HubPort']['FirstHubPort']={syn:'Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie.',lib:'YHubPort.FirstHubPort()',pro:'def FirstHubPort()',cmt:'<p>Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie. Utiliser la fonction <tt>YHubPort.nextHubPort()</tt> pour it\xE9rer sur les autres port de Yocto-hub.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt>, correspondant au premier port de Yocto-hub accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de port de Yocto-hub disponibles.'};
doc['HubPort']['clearCache']={syn:'Invalide le cache.',lib:'hubport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du port de Yocto-hub. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['HubPort']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port de Yocto-hub au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port de Yocto-hub au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le port de Yocto-hub (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).',lib:'hubport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps.',lib:'hubport.get_baudRate()',pro:'def get_baudRate()',cmt:'<p>Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps. La valeur par d\xE9faut est 1000 kbps, une valeur inf\xE9rieure r\xE9v\xE8le des probl\xE8mes de communication.</p>',ret:'un entier repr&eacute;sentant la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.',lib:'hubport.get_enabled()',pro:'def get_enabled()',cmt:'<p>Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon vrai si le port du Yocto-hub est aliment\xE9, faux sinon',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port de Yocto-hub.',lib:'hubport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port de Yocto-hub. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port de Yocto-hub.'};
doc['HubPort']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port de Yocto-hub.',lib:'hubport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port de Yocto-hub. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port de Yocto-hub.'};
doc['HubPort']['get_friendlyName']={syn:'Retourne un identifiant global du port de Yocto-hub au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'hubport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du port de Yocto-hub au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du port de Yocto-hub si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du port de Yocto-hub (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port de Yocto-hub en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'hubport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['HubPort']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du port de Yocto-hub, sans r\xE9f\xE9rence au module.',lib:'hubport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du port de Yocto-hub, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port de Yocto-hub (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du port de Yocto-hub au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'hubport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du port de Yocto-hub au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du port de Yocto-hub (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port de Yocto-hub (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Retourne le nom logique du port de Yocto-hub.',lib:'hubport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du port de Yocto-hub.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port de Yocto-hub.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'hubport.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Retourne l\x27\xE9tat actuel du port de Yocto-hub.',lib:'hubport.get_portState()',pro:'def get_portState()',cmt:'<p>Retourne l\x27\xE9tat actuel du port de Yocto-hub.</p>',ret:'une valeur parmi <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> et <tt>Y_PORTSTATE_PROG</tt> repr&eacute;sentant l\x27\xE9tat actuel du port de Yocto-hub',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['HubPort']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le port de Yocto-hub est joignable, sans d\xE9clencher d\x27erreur.',lib:'hubport.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le port de Yocto-hub est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du port de Yocto-hub sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le port de Yocto-hub est joignable, <tt>false</tt> sinon'};
doc['HubPort']['load']={syn:'Met en cache les valeurs courantes du port de Yocto-hub, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'hubport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du port de Yocto-hub, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'hubport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['HubPort']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'hubport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['nextHubPort']={syn:'Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les port de Yocto-hub sont retourn\xE9s.',lib:'hubport.nextHubPort()',pro:'def nextHubPort()',cmt:'<p>Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les port de Yocto-hub sont retourn\xE9s. Si vous souhaitez retrouver un port de Yocto-hub sp\xE9cifique, utilisez <tt>HubPort.findHubPort()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['HubPort']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'hubport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['HubPort']['set_enabled']={syn:'Modifie le mode d\x27activation du port du Yocto-hub.',lib:'hubport.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation du port du Yocto-hub. Si le port est actif, il sera aliment\xE9. Sinon, l\x27alimentation du module est coup\xE9e.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon le mode d\x27activation du port du Yocto-hub'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['HubPort']['set_logicalName']={syn:'Modifie le nom logique du port de Yocto-hub.',lib:'hubport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du port de Yocto-hub. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port de Yocto-hub.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'hubport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['HubPort']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'hubport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'Interface de la fonction AnButton',inc:'from yocto_anbutton import *',cmt:'<p>La librairie de programmation Yoctopuce permet aussi bien de mesurer l\x27\xE9tat d\x27un simple bouton que de lire un potentiom\xE8tre analogique (r\xE9sistance variable), comme par exmple un bouton rotatif continu, une poign\xE9e de commande de gaz ou un joystick. Le module est capable de se calibrer sur les valeurs minimales et maximales du potentiom\xE8tre, et de restituer une valeur calibr\xE9e variant proportionnellement avec la position du potentiom\xE8tre, ind\xE9pendant de sa r\xE9sistance totale.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAnButton.FindAnButton()',pro:'def FindAnButton(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27entr\xE9e analogique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAnButton.isOnline()</tt> pour tester si l\x27entr\xE9e analogique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27entr\xE9e analogique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAnButton</tt> qui permet ensuite de contr\xF4ler l\x27entr\xE9e analogique.'};
doc['AnButton']['FirstAnButton']={syn:'Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie.',lib:'YAnButton.FirstAnButton()',pro:'def FirstAnButton()',cmt:'<p>Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie. Utiliser la fonction <tt>YAnButton.nextAnButton()</tt> pour it\xE9rer sur les autres entr\xE9es analogiques.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt>, correspondant \xE0 la premi\xE8re entr\xE9e analogique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de entr\xE9es analogiques disponibles.'};
doc['AnButton']['clearCache']={syn:'Invalide le cache.',lib:'anbutton.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27entr\xE9e analogique. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['AnButton']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27entr\xE9e analogique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27entr\xE9e analogique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27entr\xE9e analogique (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).',lib:'anbutton.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.',lib:'anbutton.get_analogCalibration()',pro:'def get_analogCalibration()',cmt:'<p>Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.</p>',ret:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).',lib:'anbutton.get_calibratedValue()',pro:'def get_calibratedValue()',cmt:'<p>Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).</p>',ret:'un entier repr&eacute;sentant la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMax()',pro:'def get_calibrationMax()',cmt:'<p>Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr&eacute;sentant la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMin()',pro:'def get_calibrationMin()',cmt:'<p>Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr&eacute;sentant la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e analogique.',lib:'anbutton.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e analogique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27entr\xE9e analogique.'};
doc['AnButton']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e analogique.',lib:'anbutton.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e analogique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27entr\xE9e analogique.'};
doc['AnButton']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27entr\xE9e analogique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'anbutton.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27entr\xE9e analogique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27entr\xE9e analogique si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27entr\xE9e analogique (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e analogique en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'anbutton.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['AnButton']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27entr\xE9e analogique, sans r\xE9f\xE9rence au module.',lib:'anbutton.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27entr\xE9e analogique, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e analogique (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27entr\xE9e analogique au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'anbutton.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27entr\xE9e analogique au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27entr\xE9e analogique (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e analogique (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.',lib:'anbutton.get_isPressed()',pro:'def get_isPressed()',cmt:'<p>Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.</p>',ret:'soit <tt>Y_ISPRESSED_FALSE</tt>, soit <tt>Y_ISPRESSED_TRUE</tt>, selon vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).',lib:'anbutton.get_lastTimePressed()',pro:'def get_lastTimePressed()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).</p>',ret:'un entier repr&eacute;sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).',lib:'anbutton.get_lastTimeReleased()',pro:'def get_lastTimeReleased()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).</p>',ret:'un entier repr&eacute;sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Retourne le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27entr\xE9e analogique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'anbutton.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Retourne la valeur du compteur d\x27impulsions.',lib:'anbutton.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Retourne la valeur du compteur d\x27impulsions. La valeur est cod\xE9e sur 32 bits. En cas de d\xE9passement de capacite (>=2^32), le compteur repart \xE0 z\xE9ro. Le compteur peut \xEAtre r\xE9initialis\xE9 en appelant la m\xE9thode resetCounter().</p>',ret:'un entier repr&eacute;sentant la valeur du compteur d\x27impulsions',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Retourne le timer du compteur d\x27impulsions (ms).',lib:'anbutton.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le timer du compteur d\x27impulsions (ms).</p>',ret:'un entier repr&eacute;sentant le timer du compteur d\x27impulsions (ms)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).',lib:'anbutton.get_rawValue()',pro:'def get_rawValue()',cmt:'<p>Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).</p>',ret:'un entier repr&eacute;sentant la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.',lib:'anbutton.get_sensitivity()',pro:'def get_sensitivity()',cmt:'<p>Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.</p>',ret:'un entier repr&eacute;sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['AnButton']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27entr\xE9e analogique est joignable, sans d\xE9clencher d\x27erreur.',lib:'anbutton.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27entr\xE9e analogique est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27entr\xE9e analogique sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27entr\xE9e analogique est joignable, <tt>false</tt> sinon'};
doc['AnButton']['load']={syn:'Met en cache les valeurs courantes de l\x27entr\xE9e analogique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'anbutton.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27entr\xE9e analogique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'anbutton.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['AnButton']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'anbutton.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['nextAnButton']={syn:'Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les entr\xE9es analogiques sont retourn\xE9s.',lib:'anbutton.nextAnButton()',pro:'def nextAnButton()',cmt:'<p>Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les entr\xE9es analogiques sont retourn\xE9s. Si vous souhaitez retrouver une entr\xE9e analogique sp\xE9cifique, utilisez <tt>AnButton.findAnButton()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['AnButton']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'anbutton.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['AnButton']['resetCounter']={syn:'R\xE9initialise le compteur d\x27impulsions et son timer.',lib:'anbutton.resetCounter()',pro:'def resetCounter()',cmt:'<p>R\xE9initialise le compteur d\x27impulsions et son timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_analogCalibration']={syn:'Enclenche ou d\xE9clenche le proc\xE9dure de calibration.',lib:'anbutton.set_analogCalibration()',pro:'def set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Enclenche ou d\xE9clenche le proc\xE9dure de calibration. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module \xE0 la fin de la calibration si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AnButton']['set_calibrationMax']={syn:'Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMax()',pro:'def set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AnButton']['set_calibrationMin']={syn:'Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMin()',pro:'def set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AnButton']['set_logicalName']={syn:'Modifie le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27entr\xE9e analogique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_sensitivity']={syn:'Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks.',lib:'anbutton.set_sensitivity()',pro:'def set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks. La sensibilit\xE9 sert \xE0 filtrer les variations autour d\x27une valeur fixe, mais ne pr\xE9t\xE9rite pas la transmission d\x27\xE9v\xE9nements lorsque la valeur d\x27entr\xE9e \xE9volue constamment dans la m\xEAme direction. Cas particulier: lorsque la valeur 1000 est utilis\xE9e, seuls les valeurs d\xE9clenchant une commutation d\x27\xE9tat press\xE9/non-press\xE9 sont transmises. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 1000) pour le d\xE9clanchement de callbacks'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AnButton']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'anbutton.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['AnButton']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'anbutton.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Interface de la fonction Voltage',inc:'from yocto_voltage import *',cmt:'<p>La classe YVoltage permet de lire et de configurer les capteurs de tension Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoltage.FindVoltage()',pro:'def FindVoltage(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoltage.isOnline()</tt> pour tester si le capteur de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoltage</tt> qui permet ensuite de contr\xF4ler le capteur de tension.'};
doc['Voltage']['FirstVoltage']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie.',lib:'YVoltage.FirstVoltage()',pro:'def FirstVoltage()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie. Utiliser la fonction <tt>YVoltage.nextVoltage()</tt> pour it\xE9rer sur les autres capteurs de tension.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt>, correspondant au premier capteur de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de tension disponibles.'};
doc['Voltage']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voltage.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['clearCache']={syn:'Invalide le cache.',lib:'voltage.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de tension. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Voltage']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de tension (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'voltage.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voltage']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).',lib:'voltage.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Volt, sous forme de nombre \xE0 virgule.',lib:'voltage.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Volt, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Volt, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Retourne la valeur actuelle de la tension, en Volt, sous forme de nombre \xE0 virgule.',lib:'voltage.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la tension, en Volt, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la tension, en Volt, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'voltage.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Voltage']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de tension.',lib:'voltage.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de tension.'};
doc['Voltage']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de tension.',lib:'voltage.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de tension.'};
doc['Voltage']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'voltage.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de tension si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de tension (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de tension en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voltage.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voltage']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de tension, sans r\xE9f\xE9rence au module.',lib:'voltage.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de tension, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de tension (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de tension au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltage.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de tension au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de tension (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de tension (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la tension depuis le d\xE9marrage du module.',lib:'voltage.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la tension depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la tension depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'voltage.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Retourne le nom logique du capteur de tension.',lib:'voltage.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la tension depuis le d\xE9marrage du module.',lib:'voltage.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la tension depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la tension depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voltage.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voltage']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'voltage.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Voltage']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'voltage.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voltage.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'voltage.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.',lib:'voltage.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la tension est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voltage']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de tension est joignable, sans d\xE9clencher d\x27erreur.',lib:'voltage.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de tension est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de tension sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de tension est joignable, <tt>false</tt> sinon'};
doc['Voltage']['load']={syn:'Met en cache les valeurs courantes du capteur de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voltage.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'voltage.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Voltage']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'voltage.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voltage.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['nextVoltage']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de tension sont retourn\xE9s.',lib:'voltage.nextVoltage()',pro:'def nextVoltage()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de tension sont retourn\xE9s. Si vous souhaitez retrouver un capteur de tension sp\xE9cifique, utilisez <tt>Voltage.findVoltage()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voltage']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'voltage.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voltage']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voltage.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voltage']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'voltage.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voltage.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'voltage.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_logicalName']={syn:'Modifie le nom logique du capteur de tension.',lib:'voltage.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voltage.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'voltage.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'voltage.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voltage']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voltage.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Voltage']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'voltage.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Voltage']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'voltage.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Voltage']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voltage.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Interface de la fonction Current',inc:'from yocto_current import *',cmt:'<p>La classe YCurrent permet de lire et de configurer les capteurs de courant Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Current']['FindCurrent']={syn:'Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCurrent.FindCurrent()',pro:'def FindCurrent(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de courant soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCurrent.isOnline()</tt> pour tester si le capteur de courant est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de courant sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCurrent</tt> qui permet ensuite de contr\xF4ler le capteur de courant.'};
doc['Current']['FirstCurrent']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie.',lib:'YCurrent.FirstCurrent()',pro:'def FirstCurrent()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie. Utiliser la fonction <tt>YCurrent.nextCurrent()</tt> pour it\xE9rer sur les autres capteurs de courant.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt>, correspondant au premier capteur de courant accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de courant disponibles.'};
doc['Current']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'current.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['clearCache']={syn:'Invalide le cache.',lib:'current.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de courant. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Current']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de courant au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de courant au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de courant (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'current.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Current']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).',lib:'current.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mA, sous forme de nombre \xE0 virgule.',lib:'current.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mA, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mA, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Retourne la valeur actuelle du courant, en mA, sous forme de nombre \xE0 virgule.',lib:'current.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du courant, en mA, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du courant, en mA, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'current.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Current']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de courant.',lib:'current.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de courant. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de courant.'};
doc['Current']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de courant.',lib:'current.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de courant. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de courant.'};
doc['Current']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de courant au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'current.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de courant au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de courant si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de courant (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de courant en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'current.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Current']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de courant, sans r\xE9f\xE9rence au module.',lib:'current.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de courant, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de courant (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de courant au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'current.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de courant au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de courant (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de courant (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le courant depuis le d\xE9marrage du module.',lib:'current.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le courant depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le courant depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'current.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Retourne le nom logique du capteur de courant.',lib:'current.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de courant.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le courant depuis le d\xE9marrage du module.',lib:'current.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le courant depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le courant depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'current.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Current']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'current.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Current']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'current.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Current']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'current.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'current.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le courant est exprim\xE9e.',lib:'current.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le courant est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le courant est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Current']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de courant est joignable, sans d\xE9clencher d\x27erreur.',lib:'current.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de courant est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de courant sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de courant est joignable, <tt>false</tt> sinon'};
doc['Current']['load']={syn:'Met en cache les valeurs courantes du capteur de courant, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'current.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de courant, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'current.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Current']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'current.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'current.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['nextCurrent']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de courant sont retourn\xE9s.',lib:'current.nextCurrent()',pro:'def nextCurrent()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de courant sont retourn\xE9s. Si vous souhaitez retrouver un capteur de courant sp\xE9cifique, utilisez <tt>Current.findCurrent()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Current']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'current.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Current']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'current.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Current']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'current.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'current.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'current.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_logicalName']={syn:'Modifie le nom logique du capteur de courant.',lib:'current.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de courant. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'current.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'current.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'current.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Current']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'current.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Current']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'current.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Current']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'current.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Current']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'current.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'Interface de la fonction CarbonDioxide',inc:'from yocto_carbondioxide import *',cmt:'<p>La classe YCarbonDioxide permet de lire et de configurer les capteurs de CO2 Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet d\x27effectuer des calibrations manuelles si n\xE9cessaire.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'def FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de CO2 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCarbonDioxide.isOnline()</tt> pour tester si le capteur de CO2 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de CO2 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCarbonDioxide</tt> qui permet ensuite de contr\xF4ler le capteur de CO2.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'def FirstCarbonDioxide()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie. Utiliser la fonction <tt>YCarbonDioxide.nextCarbonDioxide()</tt> pour it\xE9rer sur les autres capteurs de CO2.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt>, correspondant au premier capteur de CO2 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de CO2 disponibles.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'carbondioxide.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['clearCache']={syn:'Invalide le cache.',lib:'carbondioxide.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de CO2. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['CarbonDioxide']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de CO2 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de CO2 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de CO2 (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Retourne la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures.',lib:'carbondioxide.get_abcPeriod()',pro:'def get_abcPeriod()',cmt:'<p>Retourne la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures. Une valeur n\xE9gative signifie que la correction automatique de r\xE9f\xE9rence est d\xE9sactiv\xE9e.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ABCPERIOD_INVALID</tt>.'};
doc['CarbonDioxide']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'carbondioxide.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).',lib:'carbondioxide.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (val), sous forme de nombre \xE0 virgule.',lib:'carbondioxide.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (val), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (val), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Retourne la valeur actuelle du taux de CO2, en ppm (val), sous forme de nombre \xE0 virgule.',lib:'carbondioxide.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du taux de CO2, en ppm (val), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du taux de CO2, en ppm (val), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'carbondioxide.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de CO2.',lib:'carbondioxide.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de CO2. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de CO2.'};
doc['CarbonDioxide']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de CO2.',lib:'carbondioxide.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de CO2. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de CO2.'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de CO2 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'carbondioxide.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de CO2 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de CO2 si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de CO2 (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de CO2 en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'carbondioxide.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['CarbonDioxide']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de CO2, sans r\xE9f\xE9rence au module.',lib:'carbondioxide.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de CO2, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de CO2 (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de CO2 au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'carbondioxide.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de CO2 au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de CO2 (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de CO2 (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module.',lib:'carbondioxide.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'carbondioxide.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Retourne le nom logique du capteur de CO2.',lib:'carbondioxide.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de CO2.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module.',lib:'carbondioxide.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le taux de CO2 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'carbondioxide.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['CarbonDioxide']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'carbondioxide.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'carbondioxide.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'carbondioxide.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'carbondioxide.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le taux de CO2 est exprim\xE9e.',lib:'carbondioxide.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le taux de CO2 est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le taux de CO2 est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['CarbonDioxide']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de CO2 est joignable, sans d\xE9clencher d\x27erreur.',lib:'carbondioxide.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de CO2 est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de CO2 sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de CO2 est joignable, <tt>false</tt> sinon'};
doc['CarbonDioxide']['load']={syn:'Met en cache les valeurs courantes du capteur de CO2, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'carbondioxide.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de CO2, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'carbondioxide.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'carbondioxide.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'carbondioxide.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de CO2 sont retourn\xE9s.',lib:'carbondioxide.nextCarbonDioxide()',pro:'def nextCarbonDioxide()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de CO2 sont retourn\xE9s. Si vous souhaitez retrouver un capteur de CO2 sp\xE9cifique, utilisez <tt>CarbonDioxide.findCarbonDioxide()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['CarbonDioxide']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'carbondioxide.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['CarbonDioxide']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'carbondioxide.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Modifie la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures.',lib:'carbondioxide.set_abcPeriod()',pro:'def set_abcPeriod(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures. Pour d\xE9sactivez la correction automatique de r\xE9f\xE9rence (par exemple lorsque le capteur est utilis\xE9 dans un environement constamment au dessus de 400ppm CO2), configurez la p\xE9riode \xE0 la valeur -1. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e de la p\xE9riode pour la correction automatique de r\xE9f\xE9rence (auto-calibration) du capteur, exprim\xE9e en heures'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'carbondioxide.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'carbondioxide.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'carbondioxide.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Modifie le nom logique du capteur de CO2.',lib:'carbondioxide.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de CO2. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'carbondioxide.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'carbondioxide.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'carbondioxide.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CarbonDioxide']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'carbondioxide.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['CarbonDioxide']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'carbondioxide.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'carbondioxide.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['CarbonDioxide']['triggerBaselineCalibration']={syn:'Lance une calibration au niveau de CO2 ambiant standard (400ppm).',lib:'carbondioxide.triggerBaselineCalibration()',pro:'def triggerBaselineCalibration()',cmt:'<p>Lance une calibration au niveau de CO2 ambiant standard (400ppm). Il n\x27est normalement pas n\xE9cessaire de calibrer le capteur, car is est con\xE7u pour compenser automatiquement toute d\xE9rive sur le long terme en se basant sur la plus faible valeur observ\xE9e durant la p\xE9riode de calibration automatique. Toutefois, si vous d\xE9sactivez la calibration automatique, vous pouvez lancer manuellement cette calibration ambiante en prenant soit de placer pr\xE9alablement le capteur dans un environnement standard (par exemple \xE0 l\x27ext\xE9rieur) \xE0 400ppm.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['triggerZeroCalibration']={syn:'Lance une calibration au niveau z\xE9ro (air exempt de CO2).',lib:'carbondioxide.triggerZeroCalibration()',pro:'def triggerZeroCalibration()',cmt:'<p>Lance une calibration au niveau z\xE9ro (air exempt de CO2). Il n\x27est normalement pas n\xE9cessaire de calibrer le capteur, car is est con\xE7u pour compenser automatiquement toute d\xE9rive sur le long terme en se basant sur la plus faible valeur observ\xE9e durant la p\xE9riode de calibration automatique. Toutefois, si vous d\xE9sactivez la calibration automatique, vous pouvez lancer manuellement cette calibration au niveau z\xE9ro apr\xE8s avoir fait circuler dans le capteur pendant une minute ou deux de l\x27air exempt de CO2, \xE0 l\x27aide d\x27un petit tube branch\xE9 sur le capteur. Contactez support@yoctopuce.com pour plus de d\xE9tail sur la proc\xE9dure de calibration au niveau z\xE9ro.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'carbondioxide.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Led)
doc['Led']={'':{syn:'Interface de la fonction Led',inc:'from yocto_led import *',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement d\x27allumer la LED \xE0 une intensit\xE9 donn\xE9e, mais aussi de la faire osciller \xE0 plusieurs fr\xE9quences.</p>'}};
doc['Led']['FindLed']={syn:'Permet de retrouver une LED d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLed.FindLed()',pro:'def FindLed(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une LED d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la LED soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLed.isOnline()</tt> pour tester si la LED est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la LED sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLed</tt> qui permet ensuite de contr\xF4ler la LED.'};
doc['Led']['FirstLed']={syn:'Commence l\x27\xE9num\xE9ration des LEDs accessibles par la librairie.',lib:'YLed.FirstLed()',pro:'def FirstLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des LEDs accessibles par la librairie. Utiliser la fonction <tt>YLed.nextLed()</tt> pour it\xE9rer sur les autres LEDs.</p>',ret:'un pointeur sur un objet <tt>YLed</tt>, correspondant \xE0 la premi\xE8re LED accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de LEDs disponibles.'};
doc['Led']['clearCache']={syn:'Invalide le cache.',lib:'led.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la LED. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Led']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la LED au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la LED au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Retourne la valeur courante de la LED (pas plus de 6 caract\xE8res).',lib:'led.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la LED (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la LED (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Retourne le mode de signalisation de la LED.',lib:'led.get_blinking()',pro:'def get_blinking()',cmt:'<p>Retourne le mode de signalisation de la LED.</p>',ret:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr&eacute;sentant le mode de signalisation de la LED',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED.',lib:'led.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la LED.'};
doc['Led']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED.',lib:'led.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la LED. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la LED.'};
doc['Led']['get_friendlyName']={syn:'Retourne un identifiant global de la LED au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'led.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la LED au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la LED si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la LED (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'led.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Led']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la LED, sans r\xE9f\xE9rence au module.',lib:'led.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la LED, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la LED au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'led.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la LED au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la LED (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Retourne le nom logique de la LED.',lib:'led.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la LED.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la LED.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Retourne l\x27intensit\xE9 de la LED en pour cent.',lib:'led.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Retourne l\x27intensit\xE9 de la LED en pour cent.</p>',ret:'un entier repr&eacute;sentant l\x27intensit\xE9 de la LED en pour cent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'led.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Retourne l\x27\xE9tat courant de la LED.',lib:'led.get_power()',pro:'def get_power()',cmt:'<p>Retourne l\x27\xE9tat courant de la LED.</p>',ret:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la LED',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Led']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la LED est joignable, sans d\xE9clencher d\x27erreur.',lib:'led.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la LED est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la LED sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la LED est joignable, <tt>false</tt> sinon'};
doc['Led']['load']={syn:'Met en cache les valeurs courantes de la LED, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'led.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la LED, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'led.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Led']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'led.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['nextLed']={syn:'Continue l\x27\xE9num\xE9ration des LEDs commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les LEDs sont retourn\xE9s.',lib:'led.nextLed()',pro:'def nextLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des LEDs commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les LEDs sont retourn\xE9s. Si vous souhaitez retrouver une LED sp\xE9cifique, utilisez <tt>Led.findLed()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Led']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'led.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Led']['set_blinking']={syn:'Modifie le mode de signalisation de la LED.',lib:'led.set_blinking()',pro:'def set_blinking(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de signalisation de la LED.</p>',par:{newval:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr&eacute;sentant le mode de signalisation de la LED'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Led']['set_logicalName']={syn:'Modifie le nom logique de la LED.',lib:'led.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la LED. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la LED.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_luminosity']={syn:'Modifie l\x27intensit\xE9 lumineuse de la LED (en pour cent).',lib:'led.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27intensit\xE9 lumineuse de la LED (en pour cent).</p>',par:{newval:'un entier repr&eacute;sentant l\x27intensit\xE9 lumineuse de la LED (en pour cent)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Led']['set_power']={syn:'Modifie l\x27\xE9tat courant de la LED.',lib:'led.set_power()',pro:'def set_power(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat courant de la LED.</p>',par:{newval:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la LED'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Led']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'led.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Led']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'led.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Led)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Interface de la fonction Source de tension',inc:'from yocto_vsource import *',cmt:'<p>La librairie de programmation Yoctopuce permet de commande la tension de srotir du module. Vous pouvez affecter une valeur fixe,ou faire des transition de voltage.</p>'}};
doc['VSource']['FindVSource']={syn:'Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVSource.FindVSource()',pro:'def FindVSource(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la source de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVSource.isOnline()</tt> pour tester si la source de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la source de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVSource</tt> qui permet ensuite de contr\xF4ler la source de tension.'};
doc['VSource']['FirstVSource']={syn:'Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie.',lib:'YVSource.FirstVSource()',pro:'def FirstVSource()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie. Utiliser la fonction <tt>YVSource.nextVSource()</tt> pour it\xE9rer sur les autres sources de tension.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt>, correspondant \xE0 la premi\xE8re source de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sources de tension disponibles.'};
doc['VSource']['get_advertisedValue']={syn:'Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).',lib:'vsource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la source de tension (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_extPowerFailure']={syn:'Rend TRUE si le voltage de l\x27alimentation externe est trop bas.',lib:'vsource.get_extPowerFailure()',pro:'def get_extPowerFailure()',cmt:'<p>Rend TRUE si le voltage de l\x27alimentation externe est trop bas.</p>',ret:'soit <tt>Y_EXTPOWERFAILURE_FALSE</tt>, soit <tt>Y_EXTPOWERFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Indique si le module est en condition d\x27erreur.',lib:'vsource.get_failure()',pro:'def get_failure()',cmt:'<p>Indique si le module est en condition d\x27erreur. Il possible de savoir de quelle erreur il s\x27agit en testant get_overheat, get_overcurrent etc... Lorsqu\x27un condition d\x27erreur est rencont\xE9e, la tension de sortie est mise \xE0 z\xE9ro est ne peut pas \xEAtre chang\xE9e tant la fonction reset() n\x27aura pas appell\xE9e.</p>',ret:'soit <tt>Y_FAILURE_FALSE</tt>, soit <tt>Y_FAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'vsource.get_vsourceDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['VSource']['get_logicalName']={syn:'Retourne le nom logique de la source de tension.',lib:'vsource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la source de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'vsource.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.',lib:'vsource.get_overCurrent()',pro:'def get_overCurrent()',cmt:'<p>Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.</p>',ret:'soit <tt>Y_OVERCURRENT_FALSE</tt>, soit <tt>Y_OVERCURRENT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Rend TRUE si le module est en surchauffe.',lib:'vsource.get_overHeat()',pro:'def get_overHeat()',cmt:'<p>Rend TRUE si le module est en surchauffe.</p>',ret:'soit <tt>Y_OVERHEAT_FALSE</tt>, soit <tt>Y_OVERHEAT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.',lib:'vsource.get_overLoad()',pro:'def get_overLoad()',cmt:'<p>Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.</p>',ret:'soit <tt>Y_OVERLOAD_FALSE</tt>, soit <tt>Y_OVERLOAD_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.',lib:'vsource.get_regulationFailure()',pro:'def get_regulationFailure()',cmt:'<p>Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.</p>',ret:'soit <tt>Y_REGULATIONFAILURE_FALSE</tt>, soit <tt>Y_REGULATIONFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.',lib:'vsource.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la tension est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['VSource']['get_voltage']={syn:'Retourne la valeur de la commande de tension de sortie en mV ',lib:'vsource.get_voltage()',pro:'def get_voltage()',cmt:'<p>Retourne la valeur de la commande de tension de sortie en mV</p>',ret:'un entier repr\xE9sentant la valeur de la commande de tension de sortie en mV',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'vsource.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['VSource']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'vsource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['nextVSource']={syn:'Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'def nextVSource()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['VSource']['pulse']={syn:'Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.',lib:'vsource.pulse()',pro:'def pulse(<span id=pn>voltage</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.</p>',par:{voltage:'tension demand\xE9e, en millivolts',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'vsource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['VSource']['set_logicalName']={syn:'Modifie le nom logique de la source de tension.',lib:'vsource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la source de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'vsource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['VSource']['set_voltage']={syn:'R\xE8gle la tension de sortie du module (en milliVolts).',lib:'vsource.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle la tension de sortie du module (en milliVolts).</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['voltageMove']={syn:'D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e.',lib:'vsource.voltageMove()',pro:'def voltageMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e. </p>',par:{target:'nouvelle valeur de sortie \xE0 la fin de la transition, en milliVolts.',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Interface de la fonction Network',inc:'from yocto_network import *',cmt:'<p>Les objets YNetwork permettent de contr\xF4ler les param\xE8tres TCP/IP des modules Yoctopuce dot\xE9s d\x27une interface r\xE9seau.</p>'}};
doc['Network']['FindNetwork']={syn:'Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9.',lib:'YNetwork.FindNetwork()',pro:'def FindNetwork(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27interface r\xE9seau soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YNetwork.isOnline()</tt> pour tester si l\x27interface r\xE9seau est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YNetwork</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau.'};
doc['Network']['FirstNetwork']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie.',lib:'YNetwork.FirstNetwork()',pro:'def FirstNetwork()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie. Utiliser la fonction <tt>YNetwork.nextNetwork()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau disponibles.'};
doc['Network']['callbackLogin']={syn:'Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter.',lib:'network.callbackLogin()',pro:'def callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter. Le mot de passe ne sera pas stock\xE9 dans le module, mais seulement une version hash\xE9e non r\xE9versible. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{username:'nom d\x27utilisateur pour s\x27identifier au callback',password:'mot de passe pour s\x27identifier au callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['clearCache']={syn:'Invalide le cache.',lib:'network.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27interface r\xE9seau. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Network']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface r\xE9seau au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface r\xE9seau au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27interface r\xE9seau (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.',lib:'network.get_adminPassword()',pro:'def get_adminPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).',lib:'network.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Retourne une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.',lib:'network.get_callbackCredentials()',pro:'def get_callbackCredentials()',cmt:'<p>Retourne une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une version hash\xE9e du laisser-passer pour le callback de notification s\x27il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.get_callbackEncoding()',pro:'def get_callbackEncoding()',cmt:'<p>Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> et <tt>Y_CALLBACKENCODING_PRTG</tt> repr&eacute;sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackInitialDelay']={syn:'Retourne l\x27attente initiale avant la premi\xE8re notification par callback, en secondes.',lib:'network.get_callbackInitialDelay()',pro:'def get_callbackInitialDelay()',cmt:'<p>Retourne l\x27attente initiale avant la premi\xE8re notification par callback, en secondes.</p>',ret:'un entier repr&eacute;sentant l\x27attente initiale avant la premi\xE8re notification par callback, en secondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKINITIALDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Retourne l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler, en secondes.',lib:'network.get_callbackMaxDelay()',pro:'def get_callbackMaxDelay()',cmt:'<p>Retourne l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler, en secondes.</p>',ret:'un entier repr&eacute;sentant l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler, en secondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.get_callbackMethod()',pro:'def get_callbackMethod()',cmt:'<p>Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr&eacute;sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Retourne l\x27attente minimale entre deux callbacks HTTP, en secondes.',lib:'network.get_callbackMinDelay()',pro:'def get_callbackMinDelay()',cmt:'<p>Retourne l\x27attente minimale entre deux callbacks HTTP, en secondes.</p>',ret:'un entier repr&eacute;sentant l\x27attente minimale entre deux callbacks HTTP, en secondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackSchedule']={syn:'Retourne la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res.',lib:'network.get_callbackSchedule()',pro:'def get_callbackSchedule()',cmt:'<p>Retourne la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKSCHEDULE_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.get_callbackUrl()',pro:'def get_callbackUrl()',cmt:'<p>Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_defaultPage']={syn:'Retourne la page HTML \xE0 envoyer pour l\x27URL \x22/\x22 ',lib:'network.get_defaultPage()',pro:'def get_defaultPage()',cmt:'<p>Retourne la page HTML \xE0 envoyer pour l\x27URL \x22/\x22</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la page HTML \xE0 envoyer pour l\x27URL \x22/\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DEFAULTPAGE_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Retourne l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).',lib:'network.get_discoverable()',pro:'def get_discoverable()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).</p>',ret:'soit <tt>Y_DISCOVERABLE_FALSE</tt>, soit <tt>Y_DISCOVERABLE_TRUE</tt>, selon l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau.',lib:'network.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface r\xE9seau.'};
doc['Network']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau.',lib:'network.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface r\xE9seau.'};
doc['Network']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27interface r\xE9seau au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'network.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27interface r\xE9seau au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27interface r\xE9seau si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27interface r\xE9seau (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'network.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Network']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau, sans r\xE9f\xE9rence au module.',lib:'network.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27interface r\xE9seau au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'network.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27interface r\xE9seau au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_httpPort']={syn:'Retourne la page HTML \xE0 envoyer pour l\x27URL \x22/\x22 ',lib:'network.get_httpPort()',pro:'def get_httpPort()',cmt:'<p>Retourne la page HTML \xE0 envoyer pour l\x27URL \x22/\x22</p>',ret:'un entier repr&eacute;sentant la page HTML \xE0 envoyer pour l\x27URL \x22/\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HTTPPORT_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce.',lib:'network.get_ipAddress()',pro:'def get_ipAddress()',cmt:'<p>Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce. Il peut s\x27agir d\x27une adresse configur\xE9e statiquement, ou d\x27une adresse re\xE7ue par un serveur DHCP.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP utilis\xE9e par le module Yoctopuce',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_ipConfig']={syn:'Retourne la configuration IP de l\x27interface r\xE9seau.',lib:'network.get_ipConfig()',pro:'def get_ipConfig()',cmt:'<p>Retourne la configuration IP de l\x27interface r\xE9seau.</p><p> Si l\x27interface r\xE9seau est configur\xE9e pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique) la cha\xEEne commence par \x22STATIC:\x22 et est suivie pas l\x27adresse IP, la longueur du masque de sous-r\xE9seau et l\x27adresse IP de la passerelle. Ces trois param\xE8tres sont s\xE9par\xE9s par le caract\xE8re \x22/\x22. Par exemple: \x22STATIC:192.168.1.14/16/192.168.1.1\x22</p><p> Si l\x27interface r\xE9seau est configur\xE9e pour utiliser une adresse assign\xE9e automatiquement par DHCP la cha\xEEne commence par \x22DHCP:\x22 et est suivie d\x27une adresse IP, d\x27une longueur du masque de sous-r\xE9seau et d\x27une adresse IP de passerelle. Ces trois param\xE8tres sont s\xE9par\xE9s par le caract\xE8re \x22/\x22 et sont utilis\xE9s si aucun serveur DHCP ne r\xE9pond.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la configuration IP de l\x27interface r\xE9seau',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_IPCONFIG_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau.',lib:'network.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module.',lib:'network.get_macAddress()',pro:'def get_macAddress()',cmt:'<p>Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module. L\x27adresse MAC est aussi pr\xE9sente sur un autocollant sur le module, repr\xE9sent\xE9e en chiffres et en code-barres.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'network.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Network']['get_ntpServer']={syn:'Retourne l\x27adresse IP du serveur de NTP \xE0 utiliser pour maintenir le module \xE0 l\x27heure.',lib:'network.get_ntpServer()',pro:'def get_ntpServer()',cmt:'<p>Retourne l\x27adresse IP du serveur de NTP \xE0 utiliser pour maintenir le module \xE0 l\x27heure.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur de NTP \xE0 utiliser pour maintenir le module \xE0 l\x27heure',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NTPSERVER_INVALID</tt>.'};
doc['Network']['get_poeCurrent']={syn:'Retourne le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res.',lib:'network.get_poeCurrent()',pro:'def get_poeCurrent()',cmt:'<p>Retourne le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res. La consommation est mesur\xE9e apr\xE8s conversion en 5 Volt, et ne doit jamais d\xE9passer 1800 mA.</p>',ret:'un entier repr&eacute;sentant le courant consomm\xE9 par le module depuis Power-over-Ethernet (PoE), en milliamp\xE8res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Retourne l\x27adresse IP du serveur de noms primaire que le module doit utiliser.',lib:'network.get_primaryDNS()',pro:'def get_primaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de noms primaire que le module doit utiliser.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur de noms primaire que le module doit utiliser',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau.',lib:'network.get_readiness()',pro:'def get_readiness()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau. Le niveau z\xE9ro (DOWN_0) signifie qu\x27aucun support r\xE9seau mat\xE9riel n\x27a \xE9t\xE9 d\xE9tect\xE9. Soit il n\x27y a pas de signal sur le cable r\xE9seau, soit le point d\x27acc\xE8s sans fil choisi n\x27est pas d\xE9tect\xE9. Le niveau 1 (LIVE_1) est atteint lorsque le r\xE9seau est d\xE9tect\xE9, mais n\x27est pas encore connect\xE9. Pour un r\xE9seau sans fil, cela confirme la l\x27existence du SSID configur\xE9. Le niveau 2 (LINK_2) est atteint lorsque le support mat\xE9riel du r\xE9seau est fonctionnel. Pour une connection r\xE9seau filaire, le niveau 2 signifie que le cable est connect\xE9 aux deux bouts. Pour une connection \xE0 un point d\x27acc\xE8s r\xE9seau sans fil, il d\xE9montre que les param\xE8tres de s\xE9curit\xE9s configur\xE9s sont corrects. Pour une connection sans fil en mode ad-hoc, cela signifie qu\x27il y a au moins un partenaire sur le r\xE9seau ad-hoc. Le niveau 3 (DHCP_3) est atteint lorsque qu\x27une adresse IP a \xE9t\xE9 obtenue par DHCP. Le niveau 4 (DNS_4) est atteint lorsqu\x27un serveur DNS est joignable par le r\xE9seau. Le niveau 5 (WWW_5) est atteint lorsque la connectivit\xE9 globale \xE0 internet est av\xE9r\xE9e par l\x27obtention de l\x27heure courante sur une serveur NTP.</p>',ret:'une valeur parmi <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> et <tt>Y_READINESS_WWW_OK</tt> repr&eacute;sentant l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).',lib:'network.get_router()',pro:'def get_router()',cmt:'<p>Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Retourne l\x27adresse IP du serveur de noms secondaire que le module doit utiliser.',lib:'network.get_secondaryDNS()',pro:'def get_secondaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de noms secondaire que le module doit utiliser.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur de noms secondaire que le module doit utiliser',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.',lib:'network.get_subnetMask()',pro:'def get_subnetMask()',cmt:'<p>Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le masque de sous-r\xE9seau utilis\xE9 par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Network']['get_userPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.',lib:'network.get_userPassword()',pro:'def get_userPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Retourne la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet.',lib:'network.get_wwwWatchdogDelay()',pro:'def get_wwwWatchdogDelay()',cmt:'<p>Retourne la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet. Une valeur nulle d\xE9sactive le red\xE9marrage automatique en cas de perte de connectivit\xE9 WWW.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27interface r\xE9seau est joignable, sans d\xE9clencher d\x27erreur.',lib:'network.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27interface r\xE9seau est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27interface r\xE9seau sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27interface r\xE9seau est joignable, <tt>false</tt> sinon'};
doc['Network']['load']={syn:'Met en cache les valeurs courantes de l\x27interface r\xE9seau, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'network.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27interface r\xE9seau, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'network.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Network']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'network.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['nextNetwork']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau sont retourn\xE9s.',lib:'network.nextNetwork()',pro:'def nextNetwork()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau sont retourn\xE9s. Si vous souhaitez retrouver une interface r\xE9seau sp\xE9cifique, utilisez <tt>Network.findNetwork()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Network']['ping']={syn:'Ping l\x27adresse choisie pour v\xE9rifier la connexion r\xE9seau.',lib:'network.ping()',pro:'def ping(<span id=pn>host</span>)',cmt:'<p>Ping l\x27adresse choisie pour v\xE9rifier la connexion r\xE9seau. Envoie quatre requ\xEAtes ICMP ECHO_REQUEST \xE0 la cible host depuis le module. Cette m\xE9thode retourne une cha\xEEne de caract\xE8res avec le r\xE9sultat des 4 requ\xEAtes ICMP ECHO_RESPONSE.</p>',par:{host:'le nom d\x27h\xF4te ou l\x27adresse IP de la cible'},ret:'une cha\xEEne de caract\xE8res contenant le r\xE9sultat du ping.'};
doc['Network']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'network.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Network']['set_adminPassword']={syn:'Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module.',lib:'network.set_adminPassword()',pro:'def set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackCredentials']={syn:'Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback.',lib:'network.set_callbackCredentials()',pro:'def set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback. Le laisser-passer doit \xEAtre fourni tel que retourn\xE9 par la fonction <tt>get_callbackCredentials</tt>, sous la forme <tt>username:hash</tt>. La valeur du hash d\xE9pend de la m\xE9thode d\x27autorisation impl\xE9ment\xE9e par le callback. Pour une autorisation de type Basic, le hash est le MD5 de la cha\xEEne <tt>username:password</tt>. Pour une autorisation de type Digest, le hash est le MD5 de la cha\xEEne <tt>username:realm:password</tt>. Pour une utilisation simplifi\xE9e, utilisez la fonction <tt>callbackLogin</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le laisser-passer pour se connecter \xE0 l\x27adresse de callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackEncoding']={syn:'Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.set_callbackEncoding()',pro:'def set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> et <tt>Y_CALLBACKENCODING_PRTG</tt> repr&eacute;sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackInitialDelay']={syn:'Modifie l\x27attente initiale avant la premi\xE8re notification par callback, en secondes.',lib:'network.set_callbackInitialDelay()',pro:'def set_callbackInitialDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente initiale avant la premi\xE8re notification par callback, en secondes.</p>',par:{newval:'un entier repr&eacute;sentant l\x27attente initiale avant la premi\xE8re notification par callback, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackMaxDelay']={syn:'Modifie l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler.',lib:'network.set_callbackMaxDelay()',pro:'def set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler.</p>',par:{newval:'un entier repr&eacute;sentant l\x27attente entre deux callback HTTP lorsque rien n\x27est \xE0 signaler'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackMethod']={syn:'Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.set_callbackMethod()',pro:'def set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr&eacute;sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackMinDelay']={syn:'Modifie l\x27attente minimale entre deux callbacks HTTP, en secondes.',lib:'network.set_callbackMinDelay()',pro:'def set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente minimale entre deux callbacks HTTP, en secondes.</p>',par:{newval:'un entier repr&eacute;sentant l\x27attente minimale entre deux callbacks HTTP, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackSchedule']={syn:'Modifie la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res.',lib:'network.set_callbackSchedule()',pro:'def set_callbackSchedule(<span id=pn>newval</span>)',cmt:'<p>Modifie la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la planification des callbacks HTTP, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_callbackUrl']={syn:'Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.set_callbackUrl()',pro:'def set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_defaultPage']={syn:'Modifie la page HTML par d\xE9faut du hub.',lib:'network.set_defaultPage()',pro:'def set_defaultPage(<span id=pn>newval</span>)',cmt:'<p>Modifie la page HTML par d\xE9faut du hub. Si aucune valeur n\x27est attribu\xE9e le hub retourne index.html qui est l\x27interface web du hub. Il est possible de changer cet page pour un fichier qui a \xE9t\xE9 upload\xE9 sur le hub.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la page HTML par d\xE9faut du hub'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_discoverable']={syn:'Modifie l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).',lib:'network.set_discoverable()',pro:'def set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour).</p>',par:{newval:'soit <tt>Y_DISCOVERABLE_FALSE</tt>, soit <tt>Y_DISCOVERABLE_TRUE</tt>, selon l\x27\xE9tat d\x27activation du protocole d\x27annonce sur le r\xE9seau permettant de retrouver facilement le module (protocols uPnP/Bonjour)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_httpPort']={syn:'Modifie la page HTML par d\xE9faut du hub.',lib:'network.set_httpPort()',pro:'def set_httpPort(<span id=pn>newval</span>)',cmt:'<p>Modifie la page HTML par d\xE9faut du hub. Si aucune valeur n\x27est attribu\xE9e le hub retourne index.html qui est l\x27interface web du hub. Il est possible de changer cet page pour un fichier qui a \xE9t\xE9 upload\xE9 sur le hub.</p>',par:{newval:'un entier repr&eacute;sentant la page HTML par d\xE9faut du hub'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau.',lib:'network.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_ntpServer']={syn:'Modifie l\x27adresse IP du serveur NTP que le module doit utiliser.',lib:'network.set_ntpServer()',pro:'def set_ntpServer(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur NTP que le module doit utiliser. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur NTP que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_periodicCallbackSchedule']={syn:'Configure la planification de callbacks HTTP p\xE9riodiques (fonction simplifi\xE9e).',lib:'network.set_periodicCallbackSchedule()',pro:'def set_periodicCallbackSchedule(<span id=pn>interval</span>, <span id=pn>offset</span>)',cmt:'<p>Configure la planification de callbacks HTTP p\xE9riodiques (fonction simplifi\xE9e).</p>',par:{interval:'la p\xE9riodicit\xE9 du callback sous forme textuelle, exprim\xE9e en secondes, minutes ou en heures. Par exemple: \x2260s\x22, \x225m\x22, \x221h\x22, \x2248h\x22.',offset:'un entier d\xE9crivant le d\xE9calage du callback par rapport au d\xE9but de la p\xE9riode. Par exemple, si la p\xE9riodicit\xE9 est 24h, un offset de 7 d\xE9clanchera le callback chaque jour \xE0 7h du matin.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Modifie l\x27adresse IP du serveur de noms primaire que le module doit utiliser.',lib:'network.set_primaryDNS()',pro:'def set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de noms primaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur de noms primaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_secondaryDNS']={syn:'Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser.',lib:'network.set_secondaryDNS()',pro:'def set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse IP du serveur de nom secondaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'network.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Network']['set_userPassword']={syn:'Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module.',lib:'network.set_userPassword()',pro:'def set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Modifie la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet.',lib:'network.set_wwwWatchdogDelay()',pro:'def set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet. Une valeur nulle d\xE9sactive le red\xE9marrage automatique en cas de perte de connectivit\xE9 WWW. La plus petite dur\xE9e non-nulle utilisable est 90 secondes.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e de perte de connection WWW tol\xE9r\xE9e (en secondes) avant de d\xE9clancher un red\xE9marrage automatique pour tenter de r\xE9cup\xE9rer la connectivit\xE9 Internet'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Network']['triggerCallback']={syn:'D\xE9clenche un callback HTTP rapidement.',lib:'network.triggerCallback()',pro:'def triggerCallback()',cmt:'<p>D\xE9clenche un callback HTTP rapidement. Cette fonction peut m\xEAme \xEAtre appell\xE9e \xE0 l\x27int\xE9rieur d\x27un callback HTTP, dans quel cas le callback HTTP suivant sera appel\xE9 5 secondes apr\xE8s la fin du callback courant, ind\xE9pendamment de l\x27intervalle minimal configur\xE9 dans le module.</p>',ret:'une cha\xEEne de caract\xE8res contenant le r\xE9sultat du ping.'};
doc['Network']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'network.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useDHCP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP.',lib:'network.useDHCP()',pro:'def useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP. En attendant qu\x27une adresse soit re\xE7ue (et ind\xE9finiment si aucun serveur DHCP ne r\xE9pond), le module utilisera les param\xE8tres IP sp\xE9cifi\xE9s \xE0 cette fonction. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{fallbackIpAddr:'adresse IP \xE0 utiliser si aucun serveur DHCP ne r\xE9pond',fallbackSubnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser si aucun serveur DHCP ne r\xE9pond. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',fallbackRouter:'adresse de la passerelle \xE0 utiliser si aucun serveur DHCP ne r\xE9pond'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useDHCPauto']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP.',lib:'network.useDHCPauto()',pro:'def useDHCPauto()',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP. En attendant qu\x27une adresse soit re\xE7ue (et ind\xE9finiment si aucun serveur DHCP ne r\xE9pond), le module utilise une adresse IP du r\xE9seau 169.254.0.0/16 (APIPA). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useStaticIP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique).',lib:'network.useStaticIP()',pro:'def useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ipAddress:'adresse IP \xE0 utiliser par le module',subnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',router:'adresse IP de la passerelle \xE0 utiliser (\x22default gateway\x22)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Interface de la fonction Wireless',inc:'from yocto_wireless import *',cmt:'<p>La fonction YWireless permet de configurer et de contr\xF4ler la configuration du r\xE9seau sans fil sur les modules Yoctopuce qui en sont dot\xE9s.</p>'}};
doc['Wireless']['FindWireless']={syn:'Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWireless.FindWireless()',pro:'def FindWireless(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27interface r\xE9seau sans fil soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWireless.isOnline()</tt> pour tester si l\x27interface r\xE9seau sans fil est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans fil sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWireless</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau sans fil.'};
doc['Wireless']['FirstWireless']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie.',lib:'YWireless.FirstWireless()',pro:'def FirstWireless()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie. Utiliser la fonction <tt>YWireless.nextWireless()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau sans fil.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau sans fil accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau sans fil disponibles.'};
doc['Wireless']['adhocNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22.',lib:'wireless.adhocNetwork()',pro:'def adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22. Sur le YoctoHub-Wireless-g, il est recommand\xE9 d\x27utiliser de pr\xE9f\xE9rence la fonction softAPNetwork() qui cr\xE9e un pseudo point d\x27acc\xE8s, plus efficace et mieux support\xE9 qu\x27un r\xE9seau ad-hoc.</p><p> Si une clef d\x27acc\xE8s est configur\xE9e pour un r\xE9seau ad-hoc, le r\xE9seau sera prot\xE9g\xE9 par une s\xE9curit\xE9 WEP40 (5 caract\xE8res ou 10 chiffres hexad\xE9cimaux) ou WEP128 (13 caract\xE8res ou 26 chiffres hexad\xE9cimaux). Pour r\xE9duire les risques d\x27intrusion, il est recommand\xE9 d\x27utiliser une cl\xE9 WEP128 bas\xE9e sur 26 chiffres hexad\xE9cimaux provenant d\x27une bonne source al\xE9atoire.</p><p> N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 cr\xE9er',securityKey:'cl\xE9 d\x27acc\xE8s de r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['clearCache']={syn:'Invalide le cache.',lib:'wireless.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27interface r\xE9seau sans fil. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Wireless']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface r\xE9seau sans fil au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface r\xE9seau sans fil au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27interface r\xE9seau sans fil (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).',lib:'wireless.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Retourne le num\xE9ro du canal 802.11 utilis\xE9, ou 0 si le r\xE9seau s\xE9lectionn\xE9 n\x27a pas \xE9t\xE9 trouv\xE9.',lib:'wireless.get_channel()',pro:'def get_channel()',cmt:'<p>Retourne le num\xE9ro du canal 802.11 utilis\xE9, ou 0 si le r\xE9seau s\xE9lectionn\xE9 n\x27a pas \xE9t\xE9 trouv\xE9.</p>',ret:'un entier repr&eacute;sentant le num\xE9ro du canal 802.11 utilis\xE9, ou 0 si le r\xE9seau s\xE9lectionn\xE9 n\x27a pas \xE9t\xE9 trouv\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les r\xE9seaux sans fils d\xE9tect\xE9s.',lib:'wireless.get_detectedWlans()',pro:'def get_detectedWlans()',cmt:'<p>Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les r\xE9seaux sans fils d\xE9tect\xE9s. La liste n\x27est pas mise \xE0 jour quand le module est d\xE9j\xE0 connect\xE9 \xE0 un acc\xE8s sans fil (mode \x22infrastructure\x22). Pour forcer la d\xE9tection des r\xE9seaux sans fil, il faut appeler <tt>startWlanScan()</tt>. L\x27appelant est responsable de la d\xE9sallocation de la liste retourn\xE9e dans les langages ne disposant pas de \x22garbage collection\x22.</p>',ret:'une liste d\x27objets <tt>YWlanRecord</tt>, contenant le SSID, le canal, la qualit\xE9 du signal, et l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['Wireless']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau sans fil. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface r\xE9seau sans fil.'};
doc['Wireless']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface r\xE9seau sans fil. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface r\xE9seau sans fil.'};
doc['Wireless']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27interface r\xE9seau sans fil au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'wireless.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27interface r\xE9seau sans fil au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27interface r\xE9seau sans fil si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27interface r\xE9seau sans fil (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau sans fil en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wireless.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Wireless']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau sans fil, sans r\xE9f\xE9rence au module.',lib:'wireless.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau sans fil, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau sans fil (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27interface r\xE9seau sans fil au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'wireless.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27interface r\xE9seau sans fil au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27interface r\xE9seau sans fil (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface r\xE9seau sans fil (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.',lib:'wireless.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.</p>',ret:'un entier repr&eacute;sentant la qualit\xE9 de la connection, exprim\xE9e en pourcents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau sans fil.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.',lib:'wireless.get_message()',pro:'def get_message()',cmt:'<p>Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wireless.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans fil s\xE9lectionn\xE9.',lib:'wireless.get_security()',pro:'def get_security()',cmt:'<p>Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans fil s\xE9lectionn\xE9.</p>',ret:'une valeur parmi <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> et <tt>Y_SECURITY_WPA2</tt> repr&eacute;sentant l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Retourne le nom (SSID) du r\xE9seau sans fil s\xE9lectionn\xE9.',lib:'wireless.get_ssid()',pro:'def get_ssid()',cmt:'<p>Retourne le nom (SSID) du r\xE9seau sans fil s\xE9lectionn\xE9.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom (SSID) du r\xE9seau sans fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Wireless']['get_wlanState']={syn:'Retourne l\x27\xE9tat actuel de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_wlanState()',pro:'def get_wlanState()',cmt:'<p>Retourne l\x27\xE9tat actuel de l\x27interface r\xE9seau sans fil. L\x27\xE9tat <tt>Y_WLANSTATE_DOWN</tt> indique que l\x27interface n\x27est connect\xE9e \xE0 aucun r\xE9seau. L\x27\xE9tat <tt>Y_WLANSTATE_SCANNING</tt> signifie que la carte r\xE9seau effectue un balayage des fr\xE9quences utilisables. Dans cet \xE9tat le module n\x27est pas joignable et la configuration r\xE9seau n\x27est pas encore appliqu\xE9e. L\x27\xE9tat <tt>Y_WLANSTATE_CONNECTED</tt> signifie que la configuration r\xE9seau a pu \xEAtre appliqu\xE9 et que le module est joignable. Si le l\x27interface est configur\xE9e pour fonctionner en mode ad-hoc ou Soft AP, cela signifie que le r\xE9seau est fonctionnel et que un p\xE9riph\xE9rique peut se connecter au r\xE9seau. L\x27\xE9tat <tt>Y_WLANSTATE_REJECTED</tt> signifie que l\x27interface r\xE9seau n\x27a pas pu joindre le r\xE9seau souhait\xE9. la source de l\x27erreur peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_message()</tt>.</p>',ret:'une valeur parmi <tt>Y_WLANSTATE_DOWN</tt>, <tt>Y_WLANSTATE_SCANNING</tt>, <tt>Y_WLANSTATE_CONNECTED</tt> et <tt>Y_WLANSTATE_REJECTED</tt> repr&eacute;sentant l\x27\xE9tat actuel de l\x27interface r\xE9seau sans fil',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_WLANSTATE_INVALID</tt>.'};
doc['Wireless']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27interface r\xE9seau sans fil est joignable, sans d\xE9clencher d\x27erreur.',lib:'wireless.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27interface r\xE9seau sans fil est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27interface r\xE9seau sans fil sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27interface r\xE9seau sans fil est joignable, <tt>false</tt> sinon'};
doc['Wireless']['joinNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22).',lib:'wireless.joinNetwork()',pro:'def joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 utiliser',securityKey:'cl\xE9 d\x27acc\xE8s au r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['load']={syn:'Met en cache les valeurs courantes de l\x27interface r\xE9seau sans fil, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wireless.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27interface r\xE9seau sans fil, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'wireless.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Wireless']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wireless.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['nextWireless']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau sans fil sont retourn\xE9s.',lib:'wireless.nextWireless()',pro:'def nextWireless()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau sans fil sont retourn\xE9s. Si vous souhaitez retrouver une interface r\xE9seau sans fil sp\xE9cifique, utilisez <tt>Wireless.findWireless()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Wireless']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wireless.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Wireless']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau sans fil. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wireless.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Wireless']['softAPNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un pseudo point d\x27acc\xE8s sans fil (\x22Soft AP\x22).',lib:'wireless.softAPNetwork()',pro:'def softAPNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un pseudo point d\x27acc\xE8s sans fil (\x22Soft AP\x22). Cette fonction ne fonctionne que sur le YoctoHub-Wireless-g.</p><p> Si une clef d\x27acc\xE8s est configur\xE9e pour un r\xE9seau SoftAP, le r\xE9seau sera prot\xE9g\xE9 par une s\xE9curit\xE9 WEP40 (5 caract\xE8res ou 10 chiffres hexad\xE9cimaux) ou WEP128 (13 caract\xE8res ou 26 chiffres hexad\xE9cimaux). Pour r\xE9duire les risques d\x27intrusion, il est recommand\xE9 d\x27utiliser une cl\xE9 WEP128 bas\xE9e sur 26 chiffres hexad\xE9cimaux provenant d\x27une bonne source al\xE9atoire.</p><p> N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 cr\xE9er',securityKey:'cl\xE9 d\x27acc\xE8s de r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['startWlanScan']={syn:'D\xE9clenche un balayage des fr\xE9quences utilisable et construit la liste de r\xE9seau sans fils disponible.',lib:'wireless.startWlanScan()',pro:'def startWlanScan()',cmt:'<p>D\xE9clenche un balayage des fr\xE9quences utilisable et construit la liste de r\xE9seau sans fils disponible. Pendant le balayage des r\xE9seau sans fils, l\x27interface se d\xE9connecte du r\xE9seau sans fils actuel. A la fin du balayage l\x27interface essaye de se reconnecter au r\xE9seau sans fil. Pendant le balayage le <tt>wlanState</tt> passe par l\x27\xE9tat <tt>Y_WLANSTATE_DOWN</tt> puis par l\x27\xE9tat <tt>Y_WLANSTATE_SCANNING</tt>. La liste des r\xE9seaux sans fils disponible peut \xEAtre r\xE9cup\xE9r\xE9 avec la m\xE9thode <tt>get_detectedWlans()</tt> \xE0 partir du moment ou <tt>get_wlanState()</tt> retourne <tt>Y_WLANSTATE_REJECTED</tt> ou <tt>Y_WLANSTATE_CONNECTED</tt>.</p><p> En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.</p>'};
doc['Wireless']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wireless.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Interface de la fonction Voc',inc:'from yocto_voc import *',cmt:'<p>La classe YVoc permet de lire et de configurer les capteurs de composants organiques volatiles Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Voc']['FindVoc']={syn:'Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoc.FindVoc()',pro:'def FindVoc(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de Compos\xE9s Organiques Volatils soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoc.isOnline()</tt> pour tester si le capteur de Compos\xE9s Organiques Volatils est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de Compos\xE9s Organiques Volatils sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoc</tt> qui permet ensuite de contr\xF4ler le capteur de Compos\xE9s Organiques Volatils.'};
doc['Voc']['FirstVoc']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie.',lib:'YVoc.FirstVoc()',pro:'def FirstVoc()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie. Utiliser la fonction <tt>YVoc.nextVoc()</tt> pour it\xE9rer sur les autres capteurs de Compos\xE9s Organiques Volatils.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt>, correspondant au premier capteur de Compos\xE9s Organiques Volatils accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de Compos\xE9s Organiques Volatils disponibles.'};
doc['Voc']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['clearCache']={syn:'Invalide le cache.',lib:'voc.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de Compos\xE9s Organiques Volatils. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Voc']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de Compos\xE9s Organiques Volatils au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de Compos\xE9s Organiques Volatils au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de Compos\xE9s Organiques Volatils (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'voc.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voc']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).',lib:'voc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (vol), sous forme de nombre \xE0 virgule.',lib:'voc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (vol), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppm (vol), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Retourne la valeur actuelle du taux de VOC estim\xE9, en ppm (vol), sous forme de nombre \xE0 virgule.',lib:'voc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du taux de VOC estim\xE9, en ppm (vol), sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du taux de VOC estim\xE9, en ppm (vol), sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'voc.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Voc']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils.'};
doc['Voc']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils.'};
doc['Voc']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de Compos\xE9s Organiques Volatils au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'voc.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de Compos\xE9s Organiques Volatils au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de Compos\xE9s Organiques Volatils si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voc.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voc']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils, sans r\xE9f\xE9rence au module.',lib:'voc.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de Compos\xE9s Organiques Volatils au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'voc.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de Compos\xE9s Organiques Volatils au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module.',lib:'voc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'voc.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module.',lib:'voc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le taux de VOC estim\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voc.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voc']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'voc.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Voc']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'voc.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'voc.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le taux de VOC estim\xE9 est exprim\xE9e.',lib:'voc.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le taux de VOC estim\xE9 est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le taux de VOC estim\xE9 est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voc']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de Compos\xE9s Organiques Volatils est joignable, sans d\xE9clencher d\x27erreur.',lib:'voc.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de Compos\xE9s Organiques Volatils est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de Compos\xE9s Organiques Volatils sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de Compos\xE9s Organiques Volatils est joignable, <tt>false</tt> sinon'};
doc['Voc']['load']={syn:'Met en cache les valeurs courantes du capteur de Compos\xE9s Organiques Volatils, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de Compos\xE9s Organiques Volatils, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'voc.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Voc']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'voc.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voc.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['nextVoc']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de Compos\xE9s Organiques Volatils sont retourn\xE9s.',lib:'voc.nextVoc()',pro:'def nextVoc()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de Compos\xE9s Organiques Volatils sont retourn\xE9s. Si vous souhaitez retrouver un capteur de Compos\xE9s Organiques Volatils sp\xE9cifique, utilisez <tt>Voc.findVoc()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voc']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'voc.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voc']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voc']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'voc.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'voc.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_logicalName']={syn:'Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'voc.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'voc.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Voc']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Voc']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'voc.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Voc']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'voc.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Voc']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voc.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Interface de la fonction Watchdog',inc:'from yocto_watchdog import *',cmt:'<p>La fonction WatchDog est g\xE9r\xE9e comme un relais qui couperait bri\xE8vement l\x27alimentation d\x27un appareil apr\xE8s un d\x27attente temps donn\xE9 afin de provoquer une r\xE9initialisation compl\xE8te de cet appareil. Il suffit d\x27appeler le watchdog \xE0 intervale r\xE9gulier pour l\x27emp\xEAcher de provoquer la r\xE9initialisation. Le watchog peut aussi \xEAtre pilot\xE9 directement \xE0 l\x27aide des m\xE9thode <i>pulse</i> et <i>delayedpulse</i> pour \xE9teindre un appareil pendant un temps donn\xE9.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWatchdog.FindWatchdog()',pro:'def FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le watchdog soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWatchdog.isOnline()</tt> pour tester si le watchdog est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le watchdog sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWatchdog</tt> qui permet ensuite de contr\xF4ler le watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie.',lib:'YWatchdog.FirstWatchdog()',pro:'def FirstWatchdog()',cmt:'<p>Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie. Utiliser la fonction <tt>YWatchdog.nextWatchdog()</tt> pour it\xE9rer sur les autres watchdog.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt>, correspondant au premier watchdog accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de watchdog disponibles.'};
doc['Watchdog']['clearCache']={syn:'Invalide le cache.',lib:'watchdog.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du watchdog. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Watchdog']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'watchdog.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27impulsion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du watchdog au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du watchdog au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le watchdog (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).',lib:'watchdog.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du watchdog (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.',lib:'watchdog.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watchdog \xE0 la mise sous tension du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'watchdog.get_countdown()',pro:'def get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du watchdog.',lib:'watchdog.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du watchdog. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du watchdog.'};
doc['Watchdog']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du watchdog.',lib:'watchdog.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du watchdog. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du watchdog.'};
doc['Watchdog']['get_friendlyName']={syn:'Retourne un identifiant global du watchdog au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'watchdog.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du watchdog au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du watchdog si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du watchdog (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le watchdog en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'watchdog.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Watchdog']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du watchdog, sans r\xE9f\xE9rence au module.',lib:'watchdog.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du watchdog, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le watchdog (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du watchdog au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'watchdog.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du watchdog au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du watchdog (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le watchdog (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Retourne le nom logique du watchdog.',lib:'watchdog.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du watchdog.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B.',lib:'watchdog.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',ret:'un entier repr&eacute;sentant le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A.',lib:'watchdog.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',ret:'un entier repr&eacute;sentant le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'watchdog.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.get_output()',pro:'def get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'watchdog.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Retourne l\x27\xE9tat du watchdog.',lib:'watchdog.get_running()',pro:'def get_running()',cmt:'<p>Retourne l\x27\xE9tat du watchdog.</p>',ret:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon l\x27\xE9tat du watchdog',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.get_state()',pro:'def get_state()',cmt:'<p>Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Retourne l\x27\xE9tat du watchdog au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).',lib:'watchdog.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Retourne l\x27\xE9tat du watchdog au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).</p>',ret:'une valeur parmi <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> et <tt>Y_STATEATPOWERON_B</tt> repr&eacute;sentant l\x27\xE9tat du watchdog au d\xE9marrage du module (A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDelay()',pro:'def get_triggerDelay()',cmt:'<p>Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr&eacute;sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDuration()',pro:'def get_triggerDuration()',cmt:'<p>Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Watchdog']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le watchdog est joignable, sans d\xE9clencher d\x27erreur.',lib:'watchdog.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le watchdog est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du watchdog sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le watchdog est joignable, <tt>false</tt> sinon'};
doc['Watchdog']['load']={syn:'Met en cache les valeurs courantes du watchdog, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'watchdog.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du watchdog, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'watchdog.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Watchdog']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'watchdog.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['nextWatchdog']={syn:'Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les watchdog sont retourn\xE9s.',lib:'watchdog.nextWatchdog()',pro:'def nextWatchdog()',cmt:'<p>Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les watchdog sont retourn\xE9s. Si vous souhaitez retrouver un watchdog sp\xE9cifique, utilisez <tt>Watchdog.findWatchdog()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Watchdog']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'watchdog.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'watchdog.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Watchdog']['resetWatchdog']={syn:'R\xE9initialise le WatchDog.',lib:'watchdog.resetWatchdog()',pro:'def resetWatchdog()',cmt:'<p>R\xE9initialise le WatchDog. Quand le watchdog est en fonctionnement cette fonction doit \xEAtre appel\xE9e \xE0 interval r\xE9gulier, pour emp\xE9cher que le watdog ne se d\xE9clenche</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_autoStart']={syn:'Modifie l\x27\xE9tat du watching au d\xE9marrage du module.',lib:'watchdog.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watching au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watching au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_logicalName']={syn:'Modifie le nom logique du watchdog.',lib:'watchdog.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du watchdog. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'R\xE8gle le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B.',lib:'watchdog.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat A avant de basculer automatiquement dans l\x27\xE9tat B. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'R\xE8gle le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A.',lib:'watchdog.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>R\xE8gle le temps maximal (en ms) pendant lequel le watchdog peut rester dans l\x27\xE9tat B avant de basculer automatiquement dans l\x27\xE9tat A. Z\xE9ro signifie qu\x27il n\x27y a pas de limitation</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_running']={syn:'Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.',lib:'watchdog.set_running()',pro:'def set_running(<span id=pn>newval</span>)',cmt:'<p>Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.</p>',par:{newval:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon manuellement l\x27\xE9tat de fonctionnement du watchdog'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_state']={syn:'Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Pr\xE9-programme l\x27\xE9tat du watchdog au d\xE9marrage du module(A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement).',lib:'watchdog.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Pr\xE9-programme l\x27\xE9tat du watchdog au d\xE9marrage du module(A pour la position de repos, B pour l\x27\xE9tat actif, UNCHANGED pour aucun changement). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur parmi <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> et <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_triggerDelay']={syn:'Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.set_triggerDelay()',pro:'def set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',par:{newval:'un entier repr&eacute;sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_triggerDuration']={syn:'Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.',lib:'watchdog.set_triggerDuration()',pro:'def set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Watchdog']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'watchdog.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Watchdog']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'watchdog.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Interface de la fonction Power',inc:'from yocto_power import *',cmt:'<p>La classe YPower permet de lire et de configurer les capteurs de puissance Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle d\x27acc\xE9der au compteur d\x27\xE9nergie et \xE0 l\x27estimation du facteur de puissance.</p>'}};
doc['Power']['FindPower']={syn:'Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPower.FindPower()',pro:'def FindPower(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de puissance electrique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPower.isOnline()</tt> pour tester si le capteur de puissance electrique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de puissance electrique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPower</tt> qui permet ensuite de contr\xF4ler le capteur de puissance electrique.'};
doc['Power']['FirstPower']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie.',lib:'YPower.FirstPower()',pro:'def FirstPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie. Utiliser la fonction <tt>YPower.nextPower()</tt> pour it\xE9rer sur les autres capteurs de puissance electrique.</p>',ret:'un pointeur sur un objet <tt>YPower</tt>, correspondant au premier capteur de puissance electrique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de puissance electrique disponibles.'};
doc['Power']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'power.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['clearCache']={syn:'Invalide le cache.',lib:'power.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de puissance electrique. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Power']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de puissance electrique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de puissance electrique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de puissance electrique (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'power.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Power']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).',lib:'power.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).',lib:'power.get_cosPhi()',pro:'def get_cosPhi()',cmt:'<p>Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Watt, sous forme de nombre \xE0 virgule.',lib:'power.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Watt, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Watt, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Retourne la valeur actuelle de la puissance \xE9lectrique, en Watt, sous forme de nombre \xE0 virgule.',lib:'power.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la puissance \xE9lectrique, en Watt, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la puissance \xE9lectrique, en Watt, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'power.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Power']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de puissance electrique.',lib:'power.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de puissance electrique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de puissance electrique.'};
doc['Power']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de puissance electrique.',lib:'power.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de puissance electrique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de puissance electrique.'};
doc['Power']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de puissance electrique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'power.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de puissance electrique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de puissance electrique si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de puissance electrique (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de puissance electrique en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'power.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Power']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de puissance electrique, sans r\xE9f\xE9rence au module.',lib:'power.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de puissance electrique, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de puissance electrique (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de puissance electrique au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'power.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de puissance electrique au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de puissance electrique (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de puissance electrique (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module.',lib:'power.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'power.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Retourne le nom logique du capteur de puissance electrique.',lib:'power.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de puissance electrique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module.',lib:'power.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la puissance \xE9lectrique depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e.',lib:'power.get_meter()',pro:'def get_meter()',cmt:'<p>Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e. Ce compteur est r\xE9initialis\xE9 \xE0 chaque d\xE9marrage du module.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes ',lib:'power.get_meterTimer()',pro:'def get_meterTimer()',cmt:'<p>Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes</p>',ret:'un entier repr&eacute;sentant le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'power.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Power']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'power.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Power']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'power.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Power']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'power.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'power.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la puissance \xE9lectrique est exprim\xE9e.',lib:'power.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la puissance \xE9lectrique est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la puissance \xE9lectrique est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Power']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de puissance electrique est joignable, sans d\xE9clencher d\x27erreur.',lib:'power.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de puissance electrique est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de puissance electrique sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de puissance electrique est joignable, <tt>false</tt> sinon'};
doc['Power']['load']={syn:'Met en cache les valeurs courantes du capteur de puissance electrique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'power.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de puissance electrique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'power.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Power']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'power.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'power.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['nextPower']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de puissance electrique sont retourn\xE9s.',lib:'power.nextPower()',pro:'def nextPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de puissance electrique sont retourn\xE9s. Si vous souhaitez retrouver un capteur de puissance electrique sp\xE9cifique, utilisez <tt>Power.findPower()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Power']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'power.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Power']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'power.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Power']['reset']={syn:'R\xE9initialise le compteur d\x27\xE9nergie.',lib:'power.reset()',pro:'def reset()',cmt:'<p>R\xE9initialise le compteur d\x27\xE9nergie.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'power.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'power.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'power.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_logicalName']={syn:'Modifie le nom logique du capteur de puissance electrique.',lib:'power.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de puissance electrique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'power.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'power.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'power.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Power']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'power.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Power']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'power.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Power']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'power.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Power']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'power.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Interface de la fonction Display',inc:'from yocto_display import *',cmt:'<p>L\x27interface de contr\xF4le des \xE9crans Yoctopuce est con\xE7ue pour afficher facilement des informations et des images. Le module est capable de g\xE9rer seul la superposition de plusieurs couches graphiques, qui peuvent \xEAtre dessin\xE9es individuellement, sans affichage imm\xE9diat, puis librement positionn\xE9es sur l\x27\xE9cran. Il est aussi capable de rejouer des s\xE9quences de commandes pr\xE9-enregistr\xE9es (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDisplay.FindDisplay()',pro:'def FindDisplay(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27ecran soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDisplay.isOnline()</tt> pour tester si l\x27ecran est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27ecran sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDisplay</tt> qui permet ensuite de contr\xF4ler l\x27ecran.'};
doc['Display']['FirstDisplay']={syn:'Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie.',lib:'YDisplay.FirstDisplay()',pro:'def FirstDisplay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie. Utiliser la fonction <tt>YDisplay.nextDisplay()</tt> pour it\xE9rer sur les autres \xE9cran.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt>, correspondant au premier \xE9cran accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de \xE9cran disponibles.'};
doc['Display']['clearCache']={syn:'Invalide le cache.',lib:'display.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27ecran. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Display']['copyLayerContent']={syn:'Copie le contentu d\x27un couche d\x27affichage vers une autre couche.',lib:'display.copyLayerContent()',pro:'def copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copie le contentu d\x27un couche d\x27affichage vers une autre couche. La couleur et la transparence de tous les pixels de la couche de destination sont chang\xE9s pour correspondre \xE0 la couche source. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{srcLayerId:'l\x27identifiant de la couche d\x27origine (un chiffre parmi 0..layerCount-1)',dstLayerId:'l\x27identifiant de la couche de destination (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27ecran au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27ecran au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27ecran (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.',lib:'display.fade()',pro:'def fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.</p>',par:{brightness:'nouvelle valeur de luminosit\xE9 de l\x27\xE9cran',duration:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).',lib:'display.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'display.get_brightness()',pro:'def get_brightness()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr&eacute;sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Retourne la hauteur de l\x27\xE9cran, en pixels.',lib:'display.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Retourne la hauteur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr&eacute;sentant la hauteur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Retourne un objet YDisplayLayer utilisable pour dessiner sur la couche d\x27affichage correspondante.',lib:'display.get_displayLayer()',pro:'def get_displayLayer(<span id=pn>layerId</span>)',cmt:'<p>Retourne un objet YDisplayLayer utilisable pour dessiner sur la couche d\x27affichage correspondante. Le contenu n\x27est visible sur l\x27\xE9cran que lorsque la couche est active sur l\x27\xE9cran (et non masqu\xE9e par une couche sup\xE9rieure).</p>',par:{layerId:'l\x27identifiant de la couche d\x27affichage d\xE9sir\xE9e (un chiffre parmi 0..layerCount-1)'},ret:'un objet <tt>YDisplayLayer</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.',lib:'display.get_displayType()',pro:'def get_displayType()',cmt:'<p>Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.</p>',ret:'une valeur parmi <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> et <tt>Y_DISPLAYTYPE_RGB</tt> repr&eacute;sentant le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Retourne la largeur de l\x27\xE9cran, en pixels.',lib:'display.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Retourne la largeur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr&eacute;sentant la largeur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_enabled']={syn:'Retourne vrai si le l\x27ecran est aliment\xE9, faux sinon.',lib:'display.get_enabled()',pro:'def get_enabled()',cmt:'<p>Retourne vrai si le l\x27ecran est aliment\xE9, faux sinon.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon vrai si le l\x27ecran est aliment\xE9, faux sinon',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27ecran.',lib:'display.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27ecran. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27ecran.'};
doc['Display']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27ecran.',lib:'display.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27ecran. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27ecran.'};
doc['Display']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27ecran au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'display.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27ecran au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27ecran si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27ecran (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27ecran en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'display.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Display']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27ecran, sans r\xE9f\xE9rence au module.',lib:'display.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27ecran, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27ecran (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27ecran au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'display.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27ecran au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27ecran (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27ecran (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Retourne le nombre des couches affichables disponibles.',lib:'display.get_layerCount()',pro:'def get_layerCount()',cmt:'<p>Retourne le nombre des couches affichables disponibles.</p>',ret:'un entier repr&eacute;sentant le nombre des couches affichables disponibles',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Retourne la hauteur des couches affichables, en pixels.',lib:'display.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Retourne la hauteur des couches affichables, en pixels.</p>',ret:'un entier repr&eacute;sentant la hauteur des couches affichables, en pixels',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Retourne la largeur des couches affichables, en pixels.',lib:'display.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Retourne la largeur des couches affichables, en pixels.</p>',ret:'un entier repr&eacute;sentant la largeur des couches affichables, en pixels',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Retourne le nom logique de l\x27ecran.',lib:'display.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27ecran.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'display.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.',lib:'display.get_orientation()',pro:'def get_orientation()',cmt:'<p>Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.</p>',ret:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr&eacute;sentant l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.get_startupSeq()',pro:'def get_startupSeq()',cmt:'<p>Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Display']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27ecran est joignable, sans d\xE9clencher d\x27erreur.',lib:'display.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27ecran est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27ecran sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27ecran est joignable, <tt>false</tt> sinon'};
doc['Display']['load']={syn:'Met en cache les valeurs courantes de l\x27ecran, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'display.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27ecran, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'display.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Display']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'display.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['newSequence']={syn:'Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement.',lib:'display.newSequence()',pro:'def newSequence()',cmt:'<p>Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement. Le nom de la s\xE9quence sera donn\xE9 au moment de l\x27appel \xE0 <tt>saveSequence()</tt>, une fois la s\xE9quence termin\xE9e.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['nextDisplay']={syn:'Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les \xE9cran sont retourn\xE9s.',lib:'display.nextDisplay()',pro:'def nextDisplay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les \xE9cran sont retourn\xE9s. Si vous souhaitez retrouver un ecran sp\xE9cifique, utilisez <tt>Display.findDisplay()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Display']['pauseSequence']={syn:'Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active.',lib:'display.pauseSequence()',pro:'def pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active. Cette m\xE9thode peut \xEAtre utilis\xE9e lors de l\x27enregistrement d\x27une s\xE9quence d\x27affichage, pour ins\xE9rer une attente mesur\xE9e lors de l\x27ex\xE9cution (mais sans effet imm\xE9diat). Cette m\xE9thode peut aussi \xEAtre appel\xE9e dynamiquement pendant l\x27ex\xE9cution d\x27une s\xE9quence enregistr\xE9e, pour suspendre temporairement ou reprendre l\x27ex\xE9cution. Pour annuler une attente, appelez simplement la m\xE9thode avec une attente de z\xE9ro.</p>',par:{delay_ms:'la dur\xE9e de l\x27attente, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['playSequence']={syn:'Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'def playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'display.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Display']['resetAll']={syn:'Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial.',lib:'display.resetAll()',pro:'def resetAll()',cmt:'<p>Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial. Utiliser cette fonction dans une sequence va tuer stopper l\x27affichage de la sequence: ne pas utiliser cette fonction pour r\xE9initialiser l\x27\xE9cran au d\xE9but d\x27une s\xE9quence.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['saveSequence']={syn:'Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi.',lib:'display.saveSequence()',pro:'def saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi. La s\xE9quence peut \xEAtre rejou\xE9e ult\xE9rieurement \xE0 l\x27aide de la m\xE9thode <tt>playSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_brightness']={syn:'Modifie la luminosit\xE9de l\x27\xE9cran.',lib:'display.set_brightness()',pro:'def set_brightness(<span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9de l\x27\xE9cran. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la luminosit\xE9de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Display']['set_enabled']={syn:'Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.',lib:'display.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Display']['set_logicalName']={syn:'Modifie le nom logique de l\x27ecran.',lib:'display.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27ecran. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_orientation']={syn:'Modifie l\x27orientation de l\x27\xE9cran.',lib:'display.set_orientation()',pro:'def set_orientation(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27orientation de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr&eacute;sentant l\x27orientation de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Display']['set_startupSeq']={syn:'Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.set_startupSeq()',pro:'def set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Display']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'display.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Display']['stopSequence']={syn:'Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran.',lib:'display.stopSequence()',pro:'def stopSequence()',cmt:'<p>Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran. L\x27affichage est laiss\xE9 tel quel.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['swapLayerContent']={syn:'Permute le contentu de deux couches d\x27affichage.',lib:'display.swapLayerContent()',pro:'def swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Permute le contentu de deux couches d\x27affichage. La couleur et la transparence de tous les pixels des deux couches sont permut\xE9es. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. En particulier, la visibilit\xE9 des deux couches reste inchang\xE9e. Cela permet d\x27impl\xE9menter tr\xE8s efficacement un affichage par double-buffering, en utilisant une couche cach\xE9e et une couche visible. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{layerIdA:'l\x27identifiant de la premi\xE8re couche (un chiffre parmi 0..layerCount-1)',layerIdB:'l\x27identifiant de la deuxi\xE8me couche (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'display.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['upload']={syn:'T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'display.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.',content:'contenu du fichier \xE0 t\xE9l\xE9charger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Display)
//--- (generated code: Files)
doc['Files']={'':{syn:'Interface de la fonction Files',inc:'from yocto_files import *',cmt:'<p>L\x27interface de stockage de fichiers permet de stocker des fichiers sur certains modules, par exemple pour personnaliser un service web (dans le cas d\x27un module connect\xE9 au r\xE9seau) ou pour ajouter un police de caract\xE8res (dans le cas d\x27un module d\x27affichage).</p>'}};
doc['Files']['FindFiles']={syn:'Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9.',lib:'YFiles.FindFiles()',pro:'def FindFiles(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le syst\xE8me de fichier soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YFiles.isOnline()</tt> pour tester si le syst\xE8me de fichier est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le syst\xE8me de fichier sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YFiles</tt> qui permet ensuite de contr\xF4ler le syst\xE8me de fichier.'};
doc['Files']['FirstFiles']={syn:'Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie.',lib:'YFiles.FirstFiles()',pro:'def FirstFiles()',cmt:'<p>Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie. Utiliser la fonction <tt>YFiles.nextFiles()</tt> pour it\xE9rer sur les autres syst\xE8me de fichier.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt>, correspondant au premier syst\xE8me de fichier accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de syst\xE8me de fichier disponibles.'};
doc['Files']['clearCache']={syn:'Invalide le cache.',lib:'files.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du syst\xE8me de fichier. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Files']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du syst\xE8me de fichier au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du syst\xE8me de fichier au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le syst\xE8me de fichier (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['download']={syn:'T\xE9l\xE9charge le fichier choisi du filesyst\xE8me et retourne son contenu.',lib:'files.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>T\xE9l\xE9charge le fichier choisi du filesyst\xE8me et retourne son contenu.</p>',par:{pathname:'nom complet du fichier \xE0 charger, y compris le chemin d\x27acc\xE8s.'},ret:'le contenu du fichier charg\xE9 sous forme d\x27objet binaire',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un contenu vide.'};
doc['Files']['fileExist']={syn:'Test si un fichier esit dans le syst\xE8me de fichier du module.',lib:'files.fileExist()',pro:'def fileExist(<span id=pn>filename</span>)',cmt:'<p>Test si un fichier esit dans le syst\xE8me de fichier du module.</p>',par:{filename:'le nom de fichier.'},ret:'vrais si le fichier existe, et faux is le fichier n\x27existe pas.',ext:'En cas d\x27erreur, d\xE9clenche une exception.'};
doc['Files']['format_fs']={syn:'R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9.',lib:'files.format_fs()',pro:'def format_fs()',cmt:'<p>R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9. enti\xE8rement vide. Tous les fichiers pr\xE9c\xE9demment charg\xE9s sont irr\xE9m\xE9diablement effac\xE9s.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['get_advertisedValue']={syn:'Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).',lib:'files.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du syst\xE8me de fichier.',lib:'files.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du syst\xE8me de fichier. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du syst\xE8me de fichier.'};
doc['Files']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du syst\xE8me de fichier.',lib:'files.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du syst\xE8me de fichier. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du syst\xE8me de fichier.'};
doc['Files']['get_filesCount']={syn:'Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_filesCount()',pro:'def get_filesCount()',cmt:'<p>Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',ret:'un entier repr&eacute;sentant le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.',lib:'files.get_freeSpace()',pro:'def get_freeSpace()',cmt:'<p>Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.</p>',ret:'un entier repr&eacute;sentant l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Retourne un identifiant global du syst\xE8me de fichier au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'files.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du syst\xE8me de fichier au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du syst\xE8me de fichier si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du syst\xE8me de fichier (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le syst\xE8me de fichier en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'files.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Files']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du syst\xE8me de fichier, sans r\xE9f\xE9rence au module.',lib:'files.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du syst\xE8me de fichier, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le syst\xE8me de fichier (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du syst\xE8me de fichier au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'files.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du syst\xE8me de fichier au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du syst\xE8me de fichier (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le syst\xE8me de fichier (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_list()',pro:'def get_list(<span id=pn>pattern</span>)',cmt:'<p>Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',par:{pattern:'un filtre optionel sur les noms de fichiers retourn\xE9s, pouvant contenir des ast\xE9risques et des points d\x27interrogations comme jokers. Si le pattern fourni est vide, tous les fichiers sont retourn\xE9s.'},ret:'une liste d\x27objets <tt>YFileRecord</tt>, contenant le nom complet (y compris le chemin d\x27acc\xE8s), la taille en octets et le CRC 32-bit du contenu du fichier.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['Files']['get_logicalName']={syn:'Retourne le nom logique du syst\xE8me de fichier.',lib:'files.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du syst\xE8me de fichier.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'files.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Files']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le syst\xE8me de fichier est joignable, sans d\xE9clencher d\x27erreur.',lib:'files.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le syst\xE8me de fichier est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du syst\xE8me de fichier sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le syst\xE8me de fichier est joignable, <tt>false</tt> sinon'};
doc['Files']['load']={syn:'Met en cache les valeurs courantes du syst\xE8me de fichier, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'files.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du syst\xE8me de fichier, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'files.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Files']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'files.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['nextFiles']={syn:'Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les syst\xE8me de fichier sont retourn\xE9s.',lib:'files.nextFiles()',pro:'def nextFiles()',cmt:'<p>Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les syst\xE8me de fichier sont retourn\xE9s. Si vous souhaitez retrouver un syst\xE8me de fichier sp\xE9cifique, utilisez <tt>Files.findFiles()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Files']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'files.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Files']['remove']={syn:'Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier.',lib:'files.remove()',pro:'def remove(<span id=pn>pathname</span>)',cmt:'<p>Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier. A cause de la fragmentation, l\x27effacement d\x27un fichier ne lib\xE8re pas toujours la totalit\xE9 de l\x27espace qu\x27il occuppe. Par contre, la r\xE9-\xE9criture d\x27un fichier du m\xEAme nom r\xE9cup\xE9rera dans tout les cas l\x27espace qui n\x27aurait \xE9ventuellement pas \xE9t\xE9 lib\xE9r\xE9. Pour s\x27assurer de lib\xE9rer la totalit\xE9 de l\x27espace du syst\xE8me de fichier, utilisez la fonction <tt>format_fs</tt>.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_logicalName']={syn:'Modifie le nom logique du syst\xE8me de fichier.',lib:'files.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du syst\xE8me de fichier. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'files.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Files']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'files.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['upload']={syn:'T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'files.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.',content:'contenu du fichier \xE0 t\xE9l\xE9charger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Interface de la fonction Horloge Temps Real',inc:'from yocto_realtimeclock import *',cmt:'<p>La fonction RealTimeClock fourni la date et l\x27heure courante de mani\xE8re persistante, m\xEAme en cas de coupure de courant de plusieurs jours. Elle est le fondement des fonctions de r\xE9veil automatique impl\xE9ment\xE9es par le WakeUpScheduler. L\x27heure courante peut repr\xE9senter aussi bien une heure locale qu\x27une heure UTC, mais aucune adaptation automatique n\x27est fait au changement d\x27heure \xE9t\xE9/hiver.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Permet de retrouver une horloge d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'def FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une horloge d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27horloge soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRealTimeClock.isOnline()</tt> pour tester si l\x27horloge est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27horloge sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRealTimeClock</tt> qui permet ensuite de contr\xF4ler l\x27horloge.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Commence l\x27\xE9num\xE9ration des horloge accessibles par la librairie.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'def FirstRealTimeClock()',cmt:'<p>Commence l\x27\xE9num\xE9ration des horloge accessibles par la librairie. Utiliser la fonction <tt>YRealTimeClock.nextRealTimeClock()</tt> pour it\xE9rer sur les autres horloge.</p>',ret:'un pointeur sur un objet <tt>YRealTimeClock</tt>, correspondant \xE0 la premi\xE8re horloge accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de horloge disponibles.'};
doc['RealTimeClock']['clearCache']={syn:'Invalide le cache.',lib:'realtimeclock.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27horloge. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['RealTimeClock']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27horloge au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'realtimeclock.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27horloge au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27horloge (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res).',lib:'realtimeclock.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27horloge (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22.',lib:'realtimeclock.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27horloge.',lib:'realtimeclock.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27horloge. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27horloge.'};
doc['RealTimeClock']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27horloge.',lib:'realtimeclock.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27horloge. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27horloge.'};
doc['RealTimeClock']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27horloge au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'realtimeclock.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27horloge au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27horloge si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27horloge (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27horloge en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'realtimeclock.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['RealTimeClock']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27horloge, sans r\xE9f\xE9rence au module.',lib:'realtimeclock.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27horloge, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27horloge (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RealTimeClock']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27horloge au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'realtimeclock.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27horloge au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27horloge (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27horloge (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RealTimeClock']['get_logicalName']={syn:'Retourne le nom logique de l\x27horloge.',lib:'realtimeclock.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27horloge.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27horloge.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'realtimeclock.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Retourne vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux.',lib:'realtimeclock.get_timeSet()',pro:'def get_timeSet()',cmt:'<p>Retourne vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux.</p>',ret:'soit <tt>Y_TIMESET_FALSE</tt>, soit <tt>Y_TIMESET_TRUE</tt>, selon vrai si l\x27horloge \xE0 \xE9t\xE9 mise \xE0 l\x27heure, sinon faux',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Retourne l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970).',lib:'realtimeclock.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Retourne l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970).</p>',ret:'un entier repr&eacute;sentant l\x27heure courante au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'realtimeclock.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'realtimeclock.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).</p>',ret:'un entier repr&eacute;sentant le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27horloge est joignable, sans d\xE9clencher d\x27erreur.',lib:'realtimeclock.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27horloge est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27horloge sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27horloge est joignable, <tt>false</tt> sinon'};
doc['RealTimeClock']['load']={syn:'Met en cache les valeurs courantes de l\x27horloge, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'realtimeclock.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27horloge, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'realtimeclock.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['RealTimeClock']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'realtimeclock.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continue l\x27\xE9num\xE9ration des horloge commenc\xE9e \xE0 l\x27aide de <tt>yFirstRealTimeClock()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les horloge sont retourn\xE9s.',lib:'realtimeclock.nextRealTimeClock()',pro:'def nextRealTimeClock()',cmt:'<p>Continue l\x27\xE9num\xE9ration des horloge commenc\xE9e \xE0 l\x27aide de <tt>yFirstRealTimeClock()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les horloge sont retourn\xE9s. Si vous souhaitez retrouver une horloge sp\xE9cifique, utilisez <tt>RealTimeClock.findRealTimeClock()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YRealTimeClock</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'realtimeclock.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Modifie le nom logique de l\x27horloge.',lib:'realtimeclock.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27horloge. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27horloge.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RealTimeClock']['set_unixTime']={syn:'Modifie l\x27heure courante.',lib:'realtimeclock.set_unixTime()',pro:'def set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27heure courante. L\x27heure est pass\xE9e au format Unix (nombre de seconds secondes \xE9coul\xE9es depuis le 1er janvier 1970).</p>',par:{newval:'un entier repr&eacute;sentant l\x27heure courante'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RealTimeClock']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'realtimeclock.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'realtimeclock.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone). Le d\xE9callage est automatiquement arrondi au quart d\x27heure le plus proche.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RealTimeClock']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'realtimeclock.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'Interface de la fonction WakeUpMonitor',inc:'from yocto_wakeupmonitor import *',cmt:'<p>La fonction WakeUpMonitor prend en charge le contr\xF4le global de toutes les sources de r\xE9veil possibles ainsi que les mises en sommeil automatiques.</p>'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Permet de retrouver un moniteur d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'def FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un moniteur d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le moniteur soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWakeUpMonitor.isOnline()</tt> pour tester si le moniteur est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le moniteur sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWakeUpMonitor</tt> qui permet ensuite de contr\xF4ler le moniteur.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Commence l\x27\xE9num\xE9ration des Moniteurs accessibles par la librairie.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'def FirstWakeUpMonitor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des Moniteurs accessibles par la librairie. Utiliser la fonction <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> pour it\xE9rer sur les autres Moniteurs.</p>',ret:'un pointeur sur un objet <tt>YWakeUpMonitor</tt>, correspondant au premier moniteur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de Moniteurs disponibles.'};
doc['WakeUpMonitor']['clearCache']={syn:'Invalide le cache.',lib:'wakeupmonitor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du moniteur. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['WakeUpMonitor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moniteur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupmonitor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moniteur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le moniteur (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Retourne la valeur courante du moniteur (pas plus de 6 caract\xE8res).',lib:'wakeupmonitor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du moniteur (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du moniteur (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moniteur.',lib:'wakeupmonitor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moniteur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moniteur.'};
doc['WakeUpMonitor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moniteur.',lib:'wakeupmonitor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moniteur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moniteur.'};
doc['WakeUpMonitor']['get_friendlyName']={syn:'Retourne un identifiant global du moniteur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'wakeupmonitor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du moniteur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du moniteur si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du moniteur (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moniteur en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wakeupmonitor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['WakeUpMonitor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du moniteur, sans r\xE9f\xE9rence au module.',lib:'wakeupmonitor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du moniteur, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moniteur (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du moniteur au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupmonitor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du moniteur au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du moniteur (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moniteur (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Retourne le nom logique du moniteur.',lib:'wakeupmonitor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du moniteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moniteur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wakeupmonitor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Retourne la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX).',lib:'wakeupmonitor.get_nextWakeUp()',pro:'def get_nextWakeUp()',cmt:'<p>Retourne la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX).</p>',ret:'un entier repr&eacute;sentant la prochaine date/heure de r\xE9veil agend\xE9e (format UNIX)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Retourne le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.',lib:'wakeupmonitor.get_powerDuration()',pro:'def get_powerDuration()',cmt:'<p>Retourne le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.</p>',ret:'un entier repr&eacute;sentant le temp d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Retourne le temps avant le prochain sommeil.',lib:'wakeupmonitor.get_sleepCountdown()',pro:'def get_sleepCountdown()',cmt:'<p>Retourne le temps avant le prochain sommeil.</p>',ret:'un entier repr&eacute;sentant le temps avant le prochain sommeil',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wakeupmonitor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Renvoie la raison du dernier r\xE9veil.',lib:'wakeupmonitor.get_wakeUpReason()',pro:'def get_wakeUpReason()',cmt:'<p>Renvoie la raison du dernier r\xE9veil.</p>',ret:'une valeur parmi <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt> et <tt>Y_WAKEUPREASON_SCHEDULE2</tt>',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Revoie l\x27\xE9tat actuel du moniteur.',lib:'wakeupmonitor.get_wakeUpState()',pro:'def get_wakeUpState()',cmt:'<p>Revoie l\x27\xE9tat actuel du moniteur.</p>',ret:'soit <tt>Y_WAKEUPSTATE_SLEEPING</tt>, soit <tt>Y_WAKEUPSTATE_AWAKE</tt>',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le moniteur est joignable, sans d\xE9clencher d\x27erreur.',lib:'wakeupmonitor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le moniteur est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du moniteur sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le moniteur est joignable, <tt>false</tt> sinon'};
doc['WakeUpMonitor']['load']={syn:'Met en cache les valeurs courantes du moniteur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wakeupmonitor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du moniteur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'wakeupmonitor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['WakeUpMonitor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wakeupmonitor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continue l\x27\xE9num\xE9ration des Moniteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpMonitor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Moniteurs sont retourn\xE9s.',lib:'wakeupmonitor.nextWakeUpMonitor()',pro:'def nextWakeUpMonitor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des Moniteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpMonitor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Moniteurs sont retourn\xE9s. Si vous souhaitez retrouver un moniteur sp\xE9cifique, utilisez <tt>WakeUpMonitor.findWakeUpMonitor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YWakeUpMonitor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wakeupmonitor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'R\xE9initialise le compteur de mise en sommeil.',lib:'wakeupmonitor.resetSleepCountDown()',pro:'def resetSleepCountDown()',cmt:'<p>R\xE9initialise le compteur de mise en sommeil.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Modifie le nom logique du moniteur.',lib:'wakeupmonitor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du moniteur. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moniteur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupmonitor.set_nextWakeUp()',pro:'def set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Modifie le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.',lib:'wakeupmonitor.set_powerDuration()',pro:'def set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Modifie le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement.</p>',par:{newval:'un entier repr&eacute;sentant le temps d\x27\xE9veil maximal en secondes avant de retourner en sommeil automatiquement'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Modifie le temps avant le prochain sommeil .',lib:'wakeupmonitor.set_sleepCountdown()',pro:'def set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Modifie le temps avant le prochain sommeil .</p>',par:{newval:'un entier repr&eacute;sentant le temps avant le prochain sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpMonitor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wakeupmonitor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['WakeUpMonitor']['sleep']={syn:'D\xE9clenche une mise en sommeil jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleep()',pro:'def sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.</p>',par:{secBeforeSleep:'nombre de seconde avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['sleepFor']={syn:'D\xE9clenche une mise en sommeil pour un temps donn\xE9 ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleepFor()',pro:'def sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil pour un temps donn\xE9 ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable. Le compte \xE0 rebours avant la mise en sommeil peut \xEAtre annul\xE9 gr\xE2ce \xE0 resetSleepCountDown.</p>',par:{secUntilWakeUp:'nombre de secondes avant le prochain r\xE9veil',secBeforeSleep:'nombre de secondes avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'D\xE9clenche une mise en sommeil jusqu\x27\xE0 une date donn\xE9e ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable.',lib:'wakeupmonitor.sleepUntil()',pro:'def sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>D\xE9clenche une mise en sommeil jusqu\x27\xE0 une date donn\xE9e ou jusqu\x27\xE0 la prochaine condition de r\xE9veil, l\x27heure du RTC du module doit imp\xE9rativement avoir \xE9t\xE9 r\xE9gl\xE9e au pr\xE9alable. Le compte \xE0 rebours avant la mise en sommeil peut \xEAtre annul\xE9 gr\xE2ce \xE0 resetSleepCountDown.</p>',par:{wakeUpTime:'date/heure du r\xE9veil (format UNIX)',secBeforeSleep:'nombre de secondes avant la mise en sommeil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wakeupmonitor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Force un r\xE9veil.',lib:'wakeupmonitor.wakeUp()',pro:'def wakeUp()',cmt:'<p>Force un r\xE9veil.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'Interface de la fonction WakeUpSchedule',inc:'from yocto_wakeupschedule import *',cmt:'<p>La fonction WakeUpSchedule impl\xE9mente une condition de r\xE9veil. Le r\xE9veil est sp\xE9cifi\xE9e par un ensemble de mois et/ou jours et/ou heures et/ou minutes o\xF9 il doit se produire.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Permet de retrouver un r\xE9veil agend\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'def FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un r\xE9veil agend\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le r\xE9veil agend\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWakeUpSchedule.isOnline()</tt> pour tester si le r\xE9veil agend\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le r\xE9veil agend\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWakeUpSchedule</tt> qui permet ensuite de contr\xF4ler le r\xE9veil agend\xE9.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Commence l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s accessibles par la librairie.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'def FirstWakeUpSchedule()',cmt:'<p>Commence l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s accessibles par la librairie. Utiliser la fonction <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> pour it\xE9rer sur les autres r\xE9veils agend\xE9s.</p>',ret:'un pointeur sur un objet <tt>YWakeUpSchedule</tt>, correspondant au premier r\xE9veil agend\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de r\xE9veils agend\xE9s disponibles.'};
doc['WakeUpSchedule']['clearCache']={syn:'Invalide le cache.',lib:'wakeupschedule.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du r\xE9veil agend\xE9. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['WakeUpSchedule']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du r\xE9veil agend\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupschedule.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du r\xE9veil agend\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le r\xE9veil agend\xE9 (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Retourne la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res).',lib:'wakeupschedule.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du r\xE9veil agend\xE9 (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9veil agend\xE9.',lib:'wakeupschedule.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9veil agend\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du r\xE9veil agend\xE9.'};
doc['WakeUpSchedule']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9veil agend\xE9.',lib:'wakeupschedule.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9veil agend\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du r\xE9veil agend\xE9.'};
doc['WakeUpSchedule']['get_friendlyName']={syn:'Retourne un identifiant global du r\xE9veil agend\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'wakeupschedule.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du r\xE9veil agend\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du r\xE9veil agend\xE9 si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du r\xE9veil agend\xE9 (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9veil agend\xE9 en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wakeupschedule.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['WakeUpSchedule']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du r\xE9veil agend\xE9, sans r\xE9f\xE9rence au module.',lib:'wakeupschedule.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du r\xE9veil agend\xE9, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9veil agend\xE9 (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du r\xE9veil agend\xE9 au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupschedule.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du r\xE9veil agend\xE9 au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du r\xE9veil agend\xE9 (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9veil agend\xE9 (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hours']={syn:'Retourne les heures o\xF9 le r\xE9veil est actif..',lib:'wakeupschedule.get_hours()',pro:'def get_hours()',cmt:'<p>Retourne les heures o\xF9 le r\xE9veil est actif..</p>',ret:'un entier repr&eacute;sentant les heures o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Retourne le nom logique du r\xE9veil agend\xE9.',lib:'wakeupschedule.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du r\xE9veil agend\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9veil agend\xE9.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Retourne toutes les minutes de chaque heure o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutes()',pro:'def get_minutes()',cmt:'<p>Retourne toutes les minutes de chaque heure o\xF9 le r\xE9veil est actif.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Retourne les minutes de l\x27interval 00-29 de chaque heures o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutesA()',pro:'def get_minutesA()',cmt:'<p>Retourne les minutes de l\x27interval 00-29 de chaque heures o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr&eacute;sentant les minutes de l\x27interval 00-29 de chaque heures o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Retourne les minutes de l\x27interval 30-59 de chaque heure o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_minutesB()',pro:'def get_minutesB()',cmt:'<p>Retourne les minutes de l\x27interval 30-59 de chaque heure o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr&eacute;sentant les minutes de l\x27interval 30-59 de chaque heure o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wakeupschedule.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Retourne les jours du mois o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_monthDays()',pro:'def get_monthDays()',cmt:'<p>Retourne les jours du mois o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr&eacute;sentant les jours du mois o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Retourne les mois o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_months()',pro:'def get_months()',cmt:'<p>Retourne les mois o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr&eacute;sentant les mois o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Retourne la date/heure de la prochaine occurence de r\xE9veil.',lib:'wakeupschedule.get_nextOccurence()',pro:'def get_nextOccurence()',cmt:'<p>Retourne la date/heure de la prochaine occurence de r\xE9veil.</p>',ret:'un entier repr&eacute;sentant la date/heure de la prochaine occurence de r\xE9veil',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wakeupschedule.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Retourne les jours de la semaine o\xF9 le r\xE9veil est actif.',lib:'wakeupschedule.get_weekDays()',pro:'def get_weekDays()',cmt:'<p>Retourne les jours de la semaine o\xF9 le r\xE9veil est actif.</p>',ret:'un entier repr&eacute;sentant les jours de la semaine o\xF9 le r\xE9veil est actif',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le r\xE9veil agend\xE9 est joignable, sans d\xE9clencher d\x27erreur.',lib:'wakeupschedule.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le r\xE9veil agend\xE9 est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du r\xE9veil agend\xE9 sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le r\xE9veil agend\xE9 est joignable, <tt>false</tt> sinon'};
doc['WakeUpSchedule']['load']={syn:'Met en cache les valeurs courantes du r\xE9veil agend\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wakeupschedule.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du r\xE9veil agend\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'wakeupschedule.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['WakeUpSchedule']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wakeupschedule.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continue l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpSchedule()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les r\xE9veils agend\xE9s sont retourn\xE9s.',lib:'wakeupschedule.nextWakeUpSchedule()',pro:'def nextWakeUpSchedule()',cmt:'<p>Continue l\x27\xE9num\xE9ration des r\xE9veils agend\xE9s commenc\xE9e \xE0 l\x27aide de <tt>yFirstWakeUpSchedule()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les r\xE9veils agend\xE9s sont retourn\xE9s. Si vous souhaitez retrouver un r\xE9veil agend\xE9 sp\xE9cifique, utilisez <tt>WakeUpSchedule.findWakeUpSchedule()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YWakeUpSchedule</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wakeupschedule.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Modifie les heures o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_hours()',pro:'def set_hours(<span id=pn>newval</span>)',cmt:'<p>Modifie les heures o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les heures o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Modifie le nom logique du r\xE9veil agend\xE9.',lib:'wakeupschedule.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du r\xE9veil agend\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9veil agend\xE9.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Modifie toutes les minutes o\xF9 un r\xE9veil doit avoir lieu ',lib:'wakeupschedule.set_minutes()',pro:'def set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Modifie toutes les minutes o\xF9 un r\xE9veil doit avoir lieu</p>',par:{bitmap:'Minutes 00-59 de chaque heure o\xF9 le r\xE9veil est actif.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Modifie les minutes de l\x27interval 00-29 o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_minutesA()',pro:'def set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Modifie les minutes de l\x27interval 00-29 o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les minutes de l\x27interval 00-29 o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Modifie les minutes de l\x27interval 30-59 o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_minutesB()',pro:'def set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Modifie les minutes de l\x27interval 30-59 o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les minutes de l\x27interval 30-59 o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Modifie les jours du mois o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_monthDays()',pro:'def set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours du mois o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les jours du mois o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['set_months']={syn:'Modifie les mois o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_months()',pro:'def set_months(<span id=pn>newval</span>)',cmt:'<p>Modifie les mois o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les mois o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wakeupschedule.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.',lib:'wakeupschedule.set_weekDays()',pro:'def set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Modifie les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu.</p>',par:{newval:'un entier repr&eacute;sentant les jours de la semaine o\xF9 un r\xE9veil doit avoir lieu'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WakeUpSchedule']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'wakeupschedule.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'Interface de la fonction GenericSensor',inc:'from yocto_genericsensor import *',cmt:'<p>La classe YGenericSensor permet de lire et de configurer les transducteurs de signaux Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet de configurer une conversion automatique entre le signal mesur\xE9 et la grandeur physique repr\xE9sent\xE9e.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Permet de retrouver un capteur g\xE9n\xE9rique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YGenericSensor.FindGenericSensor()',pro:'def FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur g\xE9n\xE9rique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur g\xE9n\xE9rique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YGenericSensor.isOnline()</tt> pour tester si le capteur g\xE9n\xE9rique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur g\xE9n\xE9rique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YGenericSensor</tt> qui permet ensuite de contr\xF4ler le capteur g\xE9n\xE9rique.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Commence l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques accessibles par la librairie.',lib:'YGenericSensor.FirstGenericSensor()',pro:'def FirstGenericSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques accessibles par la librairie. Utiliser la fonction <tt>YGenericSensor.nextGenericSensor()</tt> pour it\xE9rer sur les autres capteurs g\xE9n\xE9riques.</p>',ret:'un pointeur sur un objet <tt>YGenericSensor</tt>, correspondant au premier capteur g\xE9n\xE9rique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs g\xE9n\xE9riques disponibles.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'genericsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['clearCache']={syn:'Invalide le cache.',lib:'genericsensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur g\xE9n\xE9rique. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['GenericSensor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur g\xE9n\xE9rique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'genericsensor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur g\xE9n\xE9rique au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur g\xE9n\xE9rique (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GenericSensor']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'genericsensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GenericSensor']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res).',lib:'genericsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur g\xE9n\xE9rique (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'genericsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'genericsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'genericsensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['GenericSensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur g\xE9n\xE9rique.',lib:'genericsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur g\xE9n\xE9rique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur g\xE9n\xE9rique.'};
doc['GenericSensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur g\xE9n\xE9rique.',lib:'genericsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur g\xE9n\xE9rique. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur g\xE9n\xE9rique.'};
doc['GenericSensor']['get_friendlyName']={syn:'Retourne un identifiant global du capteur g\xE9n\xE9rique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'genericsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur g\xE9n\xE9rique au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur g\xE9n\xE9rique si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur g\xE9n\xE9rique (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur g\xE9n\xE9rique en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'genericsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['GenericSensor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur g\xE9n\xE9rique, sans r\xE9f\xE9rence au module.',lib:'genericsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur g\xE9n\xE9rique, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur g\xE9n\xE9rique (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GenericSensor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur g\xE9n\xE9rique au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'genericsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur g\xE9n\xE9rique au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur g\xE9n\xE9rique (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur g\xE9n\xE9rique (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GenericSensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'genericsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'genericsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Retourne le nom logique du capteur g\xE9n\xE9rique.',lib:'genericsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur g\xE9n\xE9rique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur g\xE9n\xE9rique.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'genericsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'genericsensor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['GenericSensor']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'genericsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'genericsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'genericsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'genericsensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GenericSensor']['get_signalBias']={syn:'Retourne le biais du signal \xE9lectrique pour la correction du point z\xE9ro.',lib:'genericsensor.get_signalBias()',pro:'def get_signalBias()',cmt:'<p>Retourne le biais du signal \xE9lectrique pour la correction du point z\xE9ro. Un biais positif correspond \xE0 la correction d\x27un signal trop positif, tandis qu\x27un biais n\xE9gatif correspond \xE0 la correction d\x27un signal trop n\xE9gatif.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le biais du signal \xE9lectrique pour la correction du point z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALBIAS_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Retourne la plage de signal \xE9lectrique utilis\xE9 par le capteur.',lib:'genericsensor.get_signalRange()',pro:'def get_signalRange()',cmt:'<p>Retourne la plage de signal \xE9lectrique utilis\xE9 par le capteur.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de signal \xE9lectrique utilis\xE9 par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalSampling']={syn:'Retourne la m\xE9thode d\x27\xE9chantillonnage du signal utilis\xE9e.',lib:'genericsensor.get_signalSampling()',pro:'def get_signalSampling()',cmt:'<p>Retourne la m\xE9thode d\x27\xE9chantillonnage du signal utilis\xE9e. La m\xE9thode <tt>HIGH_RATE</tt> effectue les mesures le plus rapidement possible, sans aucun filtrage. La m\xE9thode <tt>HIGH_RATE_FILTERED</tt> rajoute un filtre m\xE9dian sur une fen\xEAtre de 7 \xE9chantillons. La m\xE9thode <tt>LOW_NOISE</tt> utilise une fr\xE9quence d\x27aquisition r\xE9duite pour r\xE9duire le bruit. La m\xE9thode <tt>LOW_NOISE_FILTERED</tt> combine la fr\xE9quence r\xE9duite avec un filtre m\xE9dian, pour obtenir des mesures aussi stables que possible m\xEAme sur un signal bruit\xE9.</p>',ret:'une valeur parmi <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> et <tt>Y_SIGNALSAMPLING_HIGHEST_RATE</tt> repr&eacute;sentant la m\xE9thode d\x27\xE9chantillonnage du signal utilis\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALSAMPLING_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur.',lib:'genericsensor.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Retourne l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 du signal \xE9lectrique utilis\xE9 par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Retourne la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur.',lib:'genericsensor.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Retourne la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du signal \xE9lectrique mesur\xE9 par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.',lib:'genericsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la measure est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'genericsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['GenericSensor']['get_valueRange']={syn:'Retourne la plage de valeurs physiques mesur\xE9s par le capteur.',lib:'genericsensor.get_valueRange()',pro:'def get_valueRange()',cmt:'<p>Retourne la plage de valeurs physiques mesur\xE9s par le capteur.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de valeurs physiques mesur\xE9s par le capteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur g\xE9n\xE9rique est joignable, sans d\xE9clencher d\x27erreur.',lib:'genericsensor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur g\xE9n\xE9rique est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur g\xE9n\xE9rique sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur g\xE9n\xE9rique est joignable, <tt>false</tt> sinon'};
doc['GenericSensor']['load']={syn:'Met en cache les valeurs courantes du capteur g\xE9n\xE9rique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'genericsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur g\xE9n\xE9rique, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'genericsensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'genericsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'genericsensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continue l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques commenc\xE9e \xE0 l\x27aide de <tt>yFirstGenericSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs g\xE9n\xE9riques sont retourn\xE9s.',lib:'genericsensor.nextGenericSensor()',pro:'def nextGenericSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs g\xE9n\xE9riques commenc\xE9e \xE0 l\x27aide de <tt>yFirstGenericSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs g\xE9n\xE9riques sont retourn\xE9s. Si vous souhaitez retrouver un capteur g\xE9n\xE9rique sp\xE9cifique, utilisez <tt>GenericSensor.findGenericSensor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YGenericSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['GenericSensor']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'genericsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['GenericSensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'genericsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['GenericSensor']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'genericsensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'genericsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'genericsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_logicalName']={syn:'Modifie le nom logique du capteur g\xE9n\xE9rique.',lib:'genericsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur g\xE9n\xE9rique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur g\xE9n\xE9rique.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'genericsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'genericsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'genericsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_signalBias']={syn:'Modifie le biais du signal \xE9lectrique pour la correction du point z\xE9ro.',lib:'genericsensor.set_signalBias()',pro:'def set_signalBias(<span id=pn>newval</span>)',cmt:'<p>Modifie le biais du signal \xE9lectrique pour la correction du point z\xE9ro. Si votre signal \xE9lectrique est positif lorsqu\x27il devrait \xEAtre nul, configurez un biais positif de la m\xEAme valeur afin de corriger l\x27erreur.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le biais du signal \xE9lectrique pour la correction du point z\xE9ro'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_signalRange']={syn:'Modifie la plage de signal \xE9lectrique utilis\xE9 par le capteur.',lib:'genericsensor.set_signalRange()',pro:'def set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage de signal \xE9lectrique utilis\xE9 par le capteur. La valeur par d\xE9faut est \x22-999999.999...999999.999\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de signal \xE9lectrique utilis\xE9 par le capteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_signalSampling']={syn:'Modifie la m\xE9thode d\x27\xE9chantillonnage du signal \xE0 utiliser.',lib:'genericsensor.set_signalSampling()',pro:'def set_signalSampling(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode d\x27\xE9chantillonnage du signal \xE0 utiliser. La m\xE9thode <tt>HIGH_RATE</tt> effectue les mesures le plus rapidement possible, sans aucun filtrage. La m\xE9thode <tt>HIGH_RATE_FILTERED</tt> rajoute un filtre m\xE9dian sur une fen\xEAtre de 7 \xE9chantillons. La m\xE9thode <tt>LOW_NOISE</tt> utilise une fr\xE9quence d\x27aquisition r\xE9duite pour r\xE9duire le bruit. La m\xE9thode <tt>LOW_NOISE_FILTERED</tt> combine la fr\xE9quence r\xE9duite avec un filtre m\xE9dian, pour obtenir des mesures aussi stables que possible m\xEAme sur un signal bruit\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> et <tt>Y_SIGNALSAMPLING_HIGHEST_RATE</tt> repr&eacute;sentant la m\xE9thode d\x27\xE9chantillonnage du signal \xE0 utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'genericsensor.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'genericsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['GenericSensor']['set_valueRange']={syn:'Modifie la plage de valeurs physiques mesur\xE9s par le capteur.',lib:'genericsensor.set_valueRange()',pro:'def set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Modifie la plage de valeurs physiques mesur\xE9s par le capteur. Le changement de plage peut avoir pour effet de bord un changement automatique de la r\xE9solution affich\xE9e. La valeur par d\xE9faut est \x22-999999.999...999999.999\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de valeurs physiques mesur\xE9s par le capteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GenericSensor']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'genericsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['GenericSensor']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'genericsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['GenericSensor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'genericsensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GenericSensor']['zeroAdjust']={syn:'Ajuste le biais du signal de sorte \xE0 ce que la valeur actuelle du signal soit interpr\xE9t\xE9e comme z\xE9ro (tare).',lib:'genericsensor.zeroAdjust()',pro:'def zeroAdjust()',cmt:'<p>Ajuste le biais du signal de sorte \xE0 ce que la valeur actuelle du signal soit interpr\xE9t\xE9e comme z\xE9ro (tare).</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Interface de la fonction DigitalIO',inc:'from yocto_digitalio import *',cmt:'<p>La librairie de programmation Yoctopuce permet simplement de changer l\x27\xE9tat de chaque canal du port d\x27entr\xE9e sortie. Il est possible de changer tous les canaux du port \xE0 la fois, ou de les changer ind\xE9pendamment. La pluspart des fonctions utilisent une repr\xE9sentation \x09 binaire des canaux o\xF9 le bit 0 correspond au canal N\xB00, le bit 1 correspond au canal N\xB01 \x09 et ainsi de suite. Si la repr\xE9sentation binaire des entiers ne vous est pas famili\xE8re, vous \x09 trouverez plus d\x27informations ici: fr.wikipedia.org/wiki/Syst%C3%A8me_binaire . \x09 La librairie permet aussi de cr\xE9er des courtes impulsions de dur\xE9e d\xE9termin\xE9e. Le comportement \xE9lectrique de chanque entr\xE9e/sortie peut \xEAtre modifi\xE9 (open drain et polarit\xE9 inverse).</p>'}};
doc['DigitalIO']['FindDigitalIO']={syn:'Permet de retrouver un port d\x27E/S digital d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDigitalIO.FindDigitalIO()',pro:'def FindDigitalIO(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un port d\x27E/S digital d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le port d\x27E/S digital soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDigitalIO.isOnline()</tt> pour tester si le port d\x27E/S digital est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port d\x27E/S digital sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDigitalIO</tt> qui permet ensuite de contr\xF4ler le port d\x27E/S digital.'};
doc['DigitalIO']['FirstDigitalIO']={syn:'Commence l\x27\xE9num\xE9ration des ports d\x27E/S digitaux accessibles par la librairie.',lib:'YDigitalIO.FirstDigitalIO()',pro:'def FirstDigitalIO()',cmt:'<p>Commence l\x27\xE9num\xE9ration des ports d\x27E/S digitaux accessibles par la librairie. Utiliser la fonction <tt>YDigitalIO.nextDigitalIO()</tt> pour it\xE9rer sur les autres ports d\x27E/S digitaux.</p>',ret:'un pointeur sur un objet <tt>YDigitalIO</tt>, correspondant au premier port d\x27E/S digital accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de ports d\x27E/S digitaux disponibles.'};
doc['DigitalIO']['clearCache']={syn:'Invalide le cache.',lib:'digitalio.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du port d\x27E/S digital. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['DigitalIO']['delayedPulse']={syn:'Pr\xE9programme une impulsion de dur\xE9e sp\xE9cifi\xE9e sur un bit choisi.',lib:'digitalio.delayedPulse()',pro:'def delayedPulse(<span id=pn>bitno</span>, <span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9programme une impulsion de dur\xE9e sp\xE9cifi\xE9e sur un bit choisi. Le bit va passer \xE0 1 puis automatiquement revenir \xE0 0 apr\xE8s le temps donn\xE9.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',ms_delay:'d\xE9lai d\x27attente avant l\x27impulsion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion d\xE9sir\xE9e, en millisecondes. Notez que la r\xE9solution temporelle du module n\x27est pas garantie \xE0 la milliseconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port d\x27E/S digital au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'digitalio.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port d\x27E/S digital au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le port d\x27E/S digital (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DigitalIO']['get_advertisedValue']={syn:'Retourne la valeur courante du port d\x27E/S digital (pas plus de 6 caract\xE8res).',lib:'digitalio.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port d\x27E/S digital (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port d\x27E/S digital (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DigitalIO']['get_bitDirection']={syn:'Retourne la direction d\x27un seul bit (canal) du port d\x27E/S.',lib:'digitalio.get_bitDirection()',pro:'def get_bitDirection(<span id=pn>bitno</span>)',cmt:'<p>Retourne la direction d\x27un seul bit (canal) du port d\x27E/S. (0 signifie que le bit est une entr\xE9e, 1 une sortie)</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Retourne la direction d\x27un seul bit du port d\x27E/S.',lib:'digitalio.get_bitOpenDrain()',pro:'def get_bitOpenDrain(<span id=pn>bitno</span>)',cmt:'<p>Retourne la direction d\x27un seul bit du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0'},ret:'0 repr\xE9sente une entr\xE9e ou une sortie digitale standard, 1 repr\xE9sente une entr\xE9e ou sortie en mode collecteur ouvert (drain ouvert)..',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['get_bitPolarity']={syn:'Retourne la polarit\xE9 d\x27un seul bit du port d\x27E/S.',lib:'digitalio.get_bitPolarity()',pro:'def get_bitPolarity(<span id=pn>bitno</span>)',cmt:'<p>Retourne la polarit\xE9 d\x27un seul bit du port d\x27E/S. 0 signifie que l\x27entr\xE9e sortie est en mode normal, 1 qu\x27elle est en mode inverse</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['get_bitState']={syn:'Retourne l\x27\xE9tat d\x27un seul bit (i.e.',lib:'digitalio.get_bitState()',pro:'def get_bitState(<span id=pn>bitno</span>)',cmt:'<p>Retourne l\x27\xE9tat d\x27un seul bit (i.e. canal) du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0'},ret:'l\x27\xE9tat du bit (0 ou 1).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port d\x27E/S digital.',lib:'digitalio.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port d\x27E/S digital. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port d\x27E/S digital.'};
doc['DigitalIO']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port d\x27E/S digital.',lib:'digitalio.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port d\x27E/S digital. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port d\x27E/S digital.'};
doc['DigitalIO']['get_friendlyName']={syn:'Retourne un identifiant global du port d\x27E/S digital au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'digitalio.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du port d\x27E/S digital au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du port d\x27E/S digital si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du port d\x27E/S digital (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port d\x27E/S digital en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DigitalIO']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'digitalio.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DigitalIO']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du port d\x27E/S digital, sans r\xE9f\xE9rence au module.',lib:'digitalio.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du port d\x27E/S digital, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port d\x27E/S digital (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DigitalIO']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du port d\x27E/S digital au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'digitalio.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du port d\x27E/S digital au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du port d\x27E/S digital (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port d\x27E/S digital (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DigitalIO']['get_logicalName']={syn:'Retourne le nom logique du port d\x27E/S digital.',lib:'digitalio.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du port d\x27E/S digital.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port d\x27E/S digital.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DigitalIO']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'digitalio.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DigitalIO']['get_outputVoltage']={syn:'Retourne la source de tension utilis\xE9e pour piloter les bits en sortie.',lib:'digitalio.get_outputVoltage()',pro:'def get_outputVoltage()',cmt:'<p>Retourne la source de tension utilis\xE9e pour piloter les bits en sortie.</p>',ret:'une valeur parmi <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> et <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> repr&eacute;sentant la source de tension utilis\xE9e pour piloter les bits en sortie',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OUTPUTVOLTAGE_INVALID</tt>.'};
doc['DigitalIO']['get_portDiags']={syn:'Retourne le diagnostique de l\x27\xE9tat du port (Yocto-IO et Yocto-MaxiIO-V2 seulement).',lib:'digitalio.get_portDiags()',pro:'def get_portDiags()',cmt:'<p>Retourne le diagnostique de l\x27\xE9tat du port (Yocto-IO et Yocto-MaxiIO-V2 seulement). Le bit 0 signale un court-circuit sur la sortie 0, etc. Le bit 8 indique un d\xE9faut d\x27alimentation, et le bit 9 indique une surchauffe (courant excessif). En fonctionnement normal, le diagnostique devrait \xEAtre \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le diagnostique de l\x27\xE9tat du port (Yocto-IO et Yocto-MaxiIO-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTDIAGS_INVALID</tt>.'};
doc['DigitalIO']['get_portDirection']={syn:'Retourne la direction des bits (i.e.',lib:'digitalio.get_portDirection()',pro:'def get_portDirection()',cmt:'<p>Retourne la direction des bits (i.e. canaux)du port (bitmap): 0 repr\xE9sente un bit en entr\xE9e, 1 repr\xE9sente un bit en sortie.</p>',ret:'un entier repr&eacute;sentant la direction des bits (i.e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTDIRECTION_INVALID</tt>.'};
doc['DigitalIO']['get_portOpenDrain']={syn:'Retourne le type d\x27interface \xE9lectrique de chaque bit du port (bitmap).',lib:'digitalio.get_portOpenDrain()',pro:'def get_portOpenDrain()',cmt:'<p>Retourne le type d\x27interface \xE9lectrique de chaque bit du port (bitmap). 0 repr\xE9sente une entr\xE9e ou une sortie digitale standard, 1 repr\xE9sente une entr\xE9e ou sortie en mode collecteur ouvert (drain ouvert).</p>',ret:'un entier repr&eacute;sentant le type d\x27interface \xE9lectrique de chaque bit du port (bitmap)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTOPENDRAIN_INVALID</tt>.'};
doc['DigitalIO']['get_portPolarity']={syn:'Retourne la polarit\xE9 des bits du port (bitmap).',lib:'digitalio.get_portPolarity()',pro:'def get_portPolarity()',cmt:'<p>Retourne la polarit\xE9 des bits du port (bitmap). Pour chaque bit \xE0 0 l\x27entr\xE9e sortie correspondante fonctionne mani\xE8re normale, pour chaque bit \xE0 1 elle fonctionne ne mani\xE8re invers\xE9e.</p>',ret:'un entier repr&eacute;sentant la polarit\xE9 des bits du port (bitmap)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTPOLARITY_INVALID</tt>.'};
doc['DigitalIO']['get_portSize']={syn:'Retourne le nombre de bits (i.e.',lib:'digitalio.get_portSize()',pro:'def get_portSize()',cmt:'<p>Retourne le nombre de bits (i.e. canaux) impl\xE9ment\xE9s dans le port d\x27E/S.</p>',ret:'un entier repr&eacute;sentant le nombre de bits (i.e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTSIZE_INVALID</tt>.'};
doc['DigitalIO']['get_portState']={syn:'Retourne l\x27\xE9tat du port d\x27E/S digital sous la forme d\x27un entier dont chaque bit repr\xE9sente un canal: valeur 0 = <tt>0b00000000</tt> -> tous les canaux \xE0 0 valeur 1 = <tt>0b00000001</tt> -> canal N\xB00 \xE0 1 valeur 2 = <tt>0b00000010</tt> -> canal N\xB01 \xE0 1 valeur 3 = <tt>0b00000011</tt> -> canaux N\xB00 et N\xB01 \xE0 1 valeur 4 = <tt>0b00000100</tt> -> canal N\xB02 \xE0 1 et ainsi de suite..',lib:'digitalio.get_portState()',pro:'def get_portState()',cmt:'<p>Retourne l\x27\xE9tat du port d\x27E/S digital sous la forme d\x27un entier dont chaque bit repr\xE9sente un canal: valeur 0 = <tt>0b00000000</tt> -> tous les canaux \xE0 0 valeur 1 = <tt>0b00000001</tt> -> canal N\xB00 \xE0 1 valeur 2 = <tt>0b00000010</tt> -> canal N\xB01 \xE0 1 valeur 3 = <tt>0b00000011</tt> -> canaux N\xB00 et N\xB01 \xE0 1 valeur 4 = <tt>0b00000100</tt> -> canal N\xB02 \xE0 1 et ainsi de suite...</p>',ret:'un entier repr&eacute;sentant l\x27\xE9tat du port d\x27E/S digital sous la forme d\x27un entier dont chaque bit repr\xE9sente un canal: valeur 0 = <tt>0b00000000</tt> -> tous les canaux \xE0 0 valeur 1 = <tt>0b00000001</tt> -> canal N\xB00 \xE0 1 valeur 2 = <tt>0b00000010</tt> -> canal N\xB01 \xE0 1 valeur 3 = <tt>0b00000011</tt> -> canaux N\xB00 et N\xB01 \xE0 1 valeur 4 = <tt>0b00000100</tt> -> canal N\xB02 \xE0 1 et ainsi de suite.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['DigitalIO']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'digitalio.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DigitalIO']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le port d\x27E/S digital est joignable, sans d\xE9clencher d\x27erreur.',lib:'digitalio.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le port d\x27E/S digital est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du port d\x27E/S digital sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le port d\x27E/S digital est joignable, <tt>false</tt> sinon'};
doc['DigitalIO']['load']={syn:'Met en cache les valeurs courantes du port d\x27E/S digital, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'digitalio.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du port d\x27E/S digital, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'digitalio.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['DigitalIO']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'digitalio.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['nextDigitalIO']={syn:'Continue l\x27\xE9num\xE9ration des ports d\x27E/S digitaux commenc\xE9e \xE0 l\x27aide de <tt>yFirstDigitalIO()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les ports d\x27E/S digitaux sont retourn\xE9s.',lib:'digitalio.nextDigitalIO()',pro:'def nextDigitalIO()',cmt:'<p>Continue l\x27\xE9num\xE9ration des ports d\x27E/S digitaux commenc\xE9e \xE0 l\x27aide de <tt>yFirstDigitalIO()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les ports d\x27E/S digitaux sont retourn\xE9s. Si vous souhaitez retrouver un port d\x27E/S digital sp\xE9cifique, utilisez <tt>DigitalIO.findDigitalIO()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YDigitalIO</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DigitalIO']['pulse']={syn:'D\xE9clenche une impulsion de dur\xE9e sp\xE9cifi\xE9e sur un bit choisi.',lib:'digitalio.pulse()',pro:'def pulse(<span id=pn>bitno</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une impulsion de dur\xE9e sp\xE9cifi\xE9e sur un bit choisi. Le bit va passer \xE0 1 puis automatiquement revenir \xE0 0 apr\xE8s le temps donn\xE9.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',ms_duration:'dur\xE9e de l\x27impulsion d\xE9sir\xE9e, en millisecondes. Notez que la r\xE9solution temporelle du module n\x27est pas garantie \xE0 la milliseconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'digitalio.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DigitalIO']['set_bitDirection']={syn:'Change la direction d\x27un seul bit (i.e.',lib:'digitalio.set_bitDirection()',pro:'def set_bitDirection(<span id=pn>bitno</span>, <span id=pn>bitdirection</span>)',cmt:'<p>Change la direction d\x27un seul bit (i.e. canal) du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',bitdirection:'nouvelle valeur de la direction, 0=entr\xE9e, 1=sortie. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9 apr\xE8s un red\xE9marrage du module.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Change le type d\x27interface \xE9lectrique d\x27un seul bit du port d\x27E/S.',lib:'digitalio.set_bitOpenDrain()',pro:'def set_bitOpenDrain(<span id=pn>bitno</span>, <span id=pn>opendrain</span>)',cmt:'<p>Change le type d\x27interface \xE9lectrique d\x27un seul bit du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',opendrain:'0 pour faire une entr\xE9e ou une sortie digitale standard, 1 pour une entr\xE9e ou sortie en mode collecteur ouvert (drain ouvert). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9 apr\xE8s un red\xE9marrage du module.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['set_bitPolarity']={syn:'Change la polarit\xE9 d\x27un seul bit du port d\x27E/S.',lib:'digitalio.set_bitPolarity()',pro:'def set_bitPolarity(<span id=pn>bitno</span>, <span id=pn>bitpolarity</span>)',cmt:'<p>Change la polarit\xE9 d\x27un seul bit du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',bitpolarity:'nouvelle valeur de la plarit\xE9. 0=mode normal, 1=mode inverse. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9 apr\xE8s un red\xE9marrage du module.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['set_bitState']={syn:'Change l\x27\xE9tat d\x27un seul bit (i.e.',lib:'digitalio.set_bitState()',pro:'def set_bitState(<span id=pn>bitno</span>, <span id=pn>bitstate</span>)',cmt:'<p>Change l\x27\xE9tat d\x27un seul bit (i.e. canal) du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0',bitstate:'nouvel \xE9tat du bit (1 ou 0)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['set_logicalName']={syn:'Modifie le nom logique du port d\x27E/S digital.',lib:'digitalio.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du port d\x27E/S digital. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port d\x27E/S digital.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['set_outputVoltage']={syn:'Modifie la source de tension utilis\xE9e pour piloter les bits en sortie.',lib:'digitalio.set_outputVoltage()',pro:'def set_outputVoltage(<span id=pn>newval</span>)',cmt:'<p>Modifie la source de tension utilis\xE9e pour piloter les bits en sortie. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9 apr\xE8s un red\xE9marrage du module.</p>',par:{newval:'une valeur parmi <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> et <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> repr&eacute;sentant la source de tension utilis\xE9e pour piloter les bits en sortie'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DigitalIO']['set_portDirection']={syn:'Modifie la direction des bits (i.e.',lib:'digitalio.set_portDirection()',pro:'def set_portDirection(<span id=pn>newval</span>)',cmt:'<p>Modifie la direction des bits (i.e. canaux) du port (bitmap): 0 repr\xE9sente un bit en entr\xE9e, 1 repr\xE9sente un bit en sortie. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la direction des bits (i.e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DigitalIO']['set_portOpenDrain']={syn:'Modifie le type d\x27interface \xE9lectrique de chaque bit du port (bitmap).',lib:'digitalio.set_portOpenDrain()',pro:'def set_portOpenDrain(<span id=pn>newval</span>)',cmt:'<p>Modifie le type d\x27interface \xE9lectrique de chaque bit du port (bitmap). 0 repr\xE9sente une entr\xE9e ou une sortie digitale standard, 1 repr\xE9sente une entr\xE9e ou sortie en mode collecteur ouvert (drain ouvert). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr&eacute;sentant le type d\x27interface \xE9lectrique de chaque bit du port (bitmap)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DigitalIO']['set_portPolarity']={syn:'Modifie la polarit\xE9e des bits du port (bitmap): Pour chaque bit \xE0 0 l\x27entr\xE9e sortie correspondante fonctionne mani\xE8re normale, pour chaque bit \xE0 1 elle fonctionne ne mani\xE8re invers\xE9e.',lib:'digitalio.set_portPolarity()',pro:'def set_portPolarity(<span id=pn>newval</span>)',cmt:'<p>Modifie la polarit\xE9e des bits du port (bitmap): Pour chaque bit \xE0 0 l\x27entr\xE9e sortie correspondante fonctionne mani\xE8re normale, pour chaque bit \xE0 1 elle fonctionne ne mani\xE8re invers\xE9e.</p>',par:{newval:'un entier repr&eacute;sentant la polarit\xE9e des bits du port (bitmap): Pour chaque bit \xE0 0 l\x27entr\xE9e sortie correspondante fonctionne mani\xE8re normale, pour chaque bit \xE0 1 elle fonctionne ne mani\xE8re invers\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DigitalIO']['set_portState']={syn:'Modifie l\x27\xE9tat de tous les canaux du port d\x27E/S digital en une seule fois: Le param\xE8tre est un entier dont chaque bit repr\xE9sente un canal avec le canal z\xE9ro correspondant au bit 0.',lib:'digitalio.set_portState()',pro:'def set_portState(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de tous les canaux du port d\x27E/S digital en une seule fois: Le param\xE8tre est un entier dont chaque bit repr\xE9sente un canal avec le canal z\xE9ro correspondant au bit 0. Mettre tous les canaux \xE0 0 -> <tt>0b00000000</tt> -> param\xE8tre = 0 Mettre le canal N\xB00 \xE0 1 -> <tt>0b00000001</tt> -> param\xE8tre = 1 Mettre le canal N\xB01 \xE0 1 -> <tt>0b00000010</tt> -> param\xE8tre = 2 Mettre les canaux N\xB00 et N\xB01 \xE0 1 -> <tt>0b00000011</tt> -> param\xE8tre = 3 Mettre le canal N\xB02 \xE0 1 -> <tt>0b00000100</tt> -> param\xE8tre = 4 et ainsi de suite... Seuls les canaux configur\xE9s en sortie, gr\xE2ce \xE0 <tt>portDirection</tt>, sont affect\xE9s.</p>',par:{newval:'un entier repr&eacute;sentant l\x27\xE9tat de tous les canaux du port d\x27E/S digital en une seule fois: Le param\xE8tre est un entier dont chaque bit repr\xE9sente un canal avec le canal z\xE9ro correspondant au bit 0'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DigitalIO']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'digitalio.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['DigitalIO']['toggle_bitState']={syn:'Inverse l\x27\xE9tat d\x27un seul bit (i.e.',lib:'digitalio.toggle_bitState()',pro:'def toggle_bitState(<span id=pn>bitno</span>)',cmt:'<p>Inverse l\x27\xE9tat d\x27un seul bit (i.e. canal) du port d\x27E/S.</p>',par:{bitno:'index du bit dans le port; le bit de poid faible est \xE0 l\x27index 0'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DigitalIO']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'digitalio.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DigitalIO)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'contr\xF4le d\x27OS',inc:'from yocto_oscontrol import *',cmt:'<p>L\x27objet OsControl permet de controler le syst\xE8m d\x27exploitation sur lequel tourne un VirtualHub. OsControl n\x27est disponible que dans le VirtualHub software. Attention, cette fonctionnalit\xE9 doit \xEAtre explicitement activ\xE9 au lancement du VirtualHub, avec l\x27option -o.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Permet de retrouver un contr\xF4le d\x27OS d\x27apr\xE8s un identifiant donn\xE9.',lib:'YOsControl.FindOsControl()',pro:'def FindOsControl(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4le d\x27OS d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le contr\xF4le d\x27OS soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YOsControl.isOnline()</tt> pour tester si le contr\xF4le d\x27OS est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4le d\x27OS sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YOsControl</tt> qui permet ensuite de contr\xF4ler le contr\xF4le d\x27OS.'};
doc['OsControl']['FirstOsControl']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4le d\x27OS accessibles par la librairie.',lib:'YOsControl.FirstOsControl()',pro:'def FirstOsControl()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4le d\x27OS accessibles par la librairie. Utiliser la fonction <tt>YOsControl.nextOsControl()</tt> pour it\xE9rer sur les autres contr\xF4le d\x27OS.</p>',ret:'un pointeur sur un objet <tt>YOsControl</tt>, correspondant au premier contr\xF4le d\x27OS accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4le d\x27OS disponibles.'};
doc['OsControl']['clearCache']={syn:'Invalide le cache.',lib:'oscontrol.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du contr\xF4le d\x27OS. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['OsControl']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4le d\x27OS au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'oscontrol.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4le d\x27OS au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le contr\xF4le d\x27OS (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['OsControl']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res).',lib:'oscontrol.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4le d\x27OS (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27OS.',lib:'oscontrol.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27OS. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4le d\x27OS.'};
doc['OsControl']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27OS.',lib:'oscontrol.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4le d\x27OS. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4le d\x27OS.'};
doc['OsControl']['get_friendlyName']={syn:'Retourne un identifiant global du contr\xF4le d\x27OS au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'oscontrol.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du contr\xF4le d\x27OS au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du contr\xF4le d\x27OS si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du contr\xF4le d\x27OS (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27OS en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['OsControl']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'oscontrol.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['OsControl']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du contr\xF4le d\x27OS, sans r\xE9f\xE9rence au module.',lib:'oscontrol.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du contr\xF4le d\x27OS, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27OS (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['OsControl']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du contr\xF4le d\x27OS au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'oscontrol.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du contr\xF4le d\x27OS au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du contr\xF4le d\x27OS (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4le d\x27OS (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4le d\x27OS.',lib:'oscontrol.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4le d\x27OS.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27OS.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'oscontrol.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Retourne le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9.',lib:'oscontrol.get_shutdownCountdown()',pro:'def get_shutdownCountdown()',cmt:'<p>Retourne le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9.</p>',ret:'un entier repr&eacute;sentant le nombre de secondes restantes avant un arr\xEAt de l\x27OS, ou z\xE9ro si aucun arr\xEAt n\x27a \xE9t\xE9 agend\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['OsControl']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le contr\xF4le d\x27OS est joignable, sans d\xE9clencher d\x27erreur.',lib:'oscontrol.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le contr\xF4le d\x27OS est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du contr\xF4le d\x27OS sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le contr\xF4le d\x27OS est joignable, <tt>false</tt> sinon'};
doc['OsControl']['load']={syn:'Met en cache les valeurs courantes du contr\xF4le d\x27OS, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'oscontrol.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du contr\xF4le d\x27OS, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'oscontrol.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['OsControl']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'oscontrol.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['nextOsControl']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4le d\x27OS commenc\xE9e \xE0 l\x27aide de <tt>yFirstOsControl()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4le d\x27OS sont retourn\xE9s.',lib:'oscontrol.nextOsControl()',pro:'def nextOsControl()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4le d\x27OS commenc\xE9e \xE0 l\x27aide de <tt>yFirstOsControl()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4le d\x27OS sont retourn\xE9s. Si vous souhaitez retrouver un contr\xF4le d\x27OS sp\xE9cifique, utilisez <tt>OsControl.findOsControl()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YOsControl</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['OsControl']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'oscontrol.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['OsControl']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4le d\x27OS.',lib:'oscontrol.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4le d\x27OS. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27OS.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'oscontrol.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['OsControl']['shutdown']={syn:'Agende un arr\xEAt de l\x27OS dans un nombre donn\xE9 de secondes.',lib:'oscontrol.shutdown()',pro:'def shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Agende un arr\xEAt de l\x27OS dans un nombre donn\xE9 de secondes.</p>',par:{secBeforeShutDown:'nombre de secondes avant l\x27arr\xEAt'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['OsControl']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'oscontrol.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: OsControl)
//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'Fonctions g\xE9n\xE9rales',inc:'from yocto_api import *',cmt:'<p>Ces quelques fonctions g\xE9n\xE9rales permettent l\x27initialisation et la configuration de la librairie Yoctopuce. Dans la plupart des cas, un appel \xE0 <tt>yRegisterHub()</tt> suffira en tout et pour tout. Ensuite, vous pourrez appeler la fonction globale <tt>yFind...()</tt> ou <tt>yFirst...()</tt> correspondant \xE0 votre module pour pouvoir interagir avec lui.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction.',lib:'YAPI.CheckLogicalName()',pro:'def CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction. Un nom logique valide est form\xE9 de 19 caract\xE8res au maximum, choisis parmi <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt> et <tt>-</tt>. Lorsqu\x27on configure un nom logique avec une cha\xEEne incorrecte, les caract\xE8res invalides sont ignor\xE9s.</p>',par:{name:'une cha\xEEne de caract\xE8res contenant le nom v\xE9rifier.'},ret:'<tt>true</tt> si le nom est valide, <tt>false</tt> dans le cas contraire.'};
doc['YAPI']['DisableExceptions']={syn:'D\xE9sactive l\x27utilisation d\x27exceptions pour la gestion des erreurs.',lib:'YAPI.DisableExceptions()',pro:'def DisableExceptions()',cmt:'<p>D\xE9sactive l\x27utilisation d\x27exceptions pour la gestion des erreurs. Lorsque les exceptions sont d\xE9sactiv\xE9es, chaque fonction retourne une valeur d\x27erreur sp\xE9cifique selon son type, document\xE9e dans ce manuel de r\xE9f\xE9rence.</p>'};
doc['YAPI']['EnableExceptions']={syn:'R\xE9active l\x27utilisation d\x27exceptions pour la gestion des erreurs.',lib:'YAPI.EnableExceptions()',pro:'def EnableExceptions()',cmt:'<p>R\xE9active l\x27utilisation d\x27exceptions pour la gestion des erreurs. Attention, lorsque les exceptions sont activ\xE9es, tout appel \xE0 une fonction de la librairie qui \xE9choue d\xE9clenche une exception. Dans le cas o\xF9 celle-ci n\x27est pas intercept\xE9e correctement par le code appelant, soit le debugger se lance, soit le programme de l\x27utilisateur est imm\xE9diatement stopp\xE9 (crash).</p>'};
doc['YAPI']['FreeAPI']={syn:'Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce.',lib:'YAPI.FreeAPI()',pro:'def FreeAPI()',cmt:'<p>Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce. Il n\x27est en g\xE9n\xE9ral pas n\xE9cessaire d\x27appeler cette fonction, sauf si vous d\xE9sirez lib\xE9rer tous les blocs de m\xE9moire allou\xE9s dynamiquement dans le but d\x27identifier une source de blocs perdus par exemple. Vous ne devez plus appeler aucune fonction de la librairie apr\xE8s avoir appel\xE9 <tt>yFreeAPI()</tt>, sous peine de crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Retourne la version de la librairie Yoctopuce utilis\xE9e.',lib:'YAPI.GetAPIVersion()',pro:'def GetAPIVersion()',cmt:'<p>Retourne la version de la librairie Yoctopuce utilis\xE9e. La version est retourn\xE9e sous forme d\x27une cha\xEEne de caract\xE8res au format <tt>\x22Majeure.Mineure.NoBuild\x22</tt>, par exemple <tt>\x221.01.5535\x22</tt>. Pour les langages utilisant une DLL externe (par exemple C#, VisualBasic ou Delphi), la cha\xEEne contient en outre la version de la DLL au m\xEAme format, par exemple <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> Si vous d\xE9sirez v\xE9rifier dans votre code que la version de la librairie est compatible avec celle que vous avez utilis\xE9 durant le d\xE9veloppement, v\xE9rifiez que le num\xE9ro majeur soit strictement \xE9gal et que le num\xE9ro mineur soit \xE9gal ou sup\xE9rieur. Le num\xE9ro de build n\x27est pas significatif par rapport \xE0 la compatibilit\xE9 de la librairie.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la version de la librairie.'};
doc['YAPI']['GetCacheValidity']={syn:'Retourne la dur\xE9e de validit\xE9 des donn\xE9es charg\xE9e par la libraire.',lib:'YAPI.GetCacheValidity()',pro:'def GetCacheValidity()',cmt:'<p>Retourne la dur\xE9e de validit\xE9 des donn\xE9es charg\xE9e par la libraire. Cette m\xE9thode retourne la dur\xE9e de mise en cache de tous les attributs des fonctions du module. Note: Cette fonction doit \xEAtre appel\xE9e apr\xE8s <tt>yInitAPI</tt>.</p>',ret:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes.'};
doc['YAPI']['GetDeviceListValidity']={syn:'Retourne le d\xE9lais entre chaque \xE9num\xE9ration forc\xE9e des YoctoHub utilis\xE9s.',lib:'YAPI.GetDeviceListValidity()',pro:'def GetDeviceListValidity()',cmt:'<p>Retourne le d\xE9lais entre chaque \xE9num\xE9ration forc\xE9e des YoctoHub utilis\xE9s. Note: Cette fonction doit \xEAtre appel\xE9e apr\xE8s <tt>yInitAPI</tt>.</p>',ret:'le nombre de secondes entre chaque \xE9num\xE9ration.'};
doc['YAPI']['GetTickCount']={syn:'Retourne la valeur du compteur monotone de temps (en millisecondes).',lib:'YAPI.GetTickCount()',pro:'def GetTickCount()',cmt:'<p>Retourne la valeur du compteur monotone de temps (en millisecondes). Ce compteur peut \xEAtre utilis\xE9 pour calculer des d\xE9lais en rapport avec les modules Yoctopuce, dont la base de temps est aussi la milliseconde.</p>',ret:'un long entier contenant la valeur du compteur de millisecondes.'};
doc['YAPI']['HandleEvents']={syn:'Maintient la communication de la librairie avec les modules Yoctopuce.',lib:'YAPI.HandleEvents()',pro:'def HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintient la communication de la librairie avec les modules Yoctopuce. Si votre programme inclut des longues boucles d\x27attente, vous pouvez y inclure un appel \xE0 cette fonction pour que la librairie prenne en charge les informations mise en attente par les modules sur les canaux de communication. Ce n\x27est pas strictement indispensable mais cela peut am\xE9liorer la r\xE9activit\xE9 des la librairie pour les commandes suivantes.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',par:{errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['InitAPI']={syn:'Initialise la librairie de programmation de Yoctopuce explicitement.',lib:'YAPI.InitAPI()',pro:'def InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initialise la librairie de programmation de Yoctopuce explicitement. Il n\x27est pas indispensable d\x27appeler <tt>yInitAPI()</tt>, la librairie sera automatiquement initialis\xE9e de toute mani\xE8re au premier appel \xE0 <tt>yRegisterHub()</tt>.</p><p> Lorsque cette fonctin est utilis\xE9e avec comme <tt>mode</tt> la valeur <tt>Y_DETECT_NONE</tt>, il faut explicitement appeler <tt>yRegisterHub()</tt> pour indiquer \xE0 la librairie sur quel VirtualHub les modules sont connect\xE9s, avant d\x27essayer d\x27y acc\xE9der.</p>',par:{mode:'un entier sp\xE9cifiant le type de d\xE9tection automatique de modules \xE0 utiliser. Les valeurs possibles sont <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt> et <tt>Y_DETECT_ALL</tt>.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['PreregisterHub']={syn:'Alternative plus tolerante \xE0 <tt>RegisterHub()</tt>.',lib:'YAPI.PreregisterHub()',pro:'def PreregisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Alternative plus tolerante \xE0 <tt>RegisterHub()</tt>. Cette fonction a le m\xEAme but et la m\xEAme param\xE8tres que la fonction <tt>RegisterHub()</tt>, mais contrairement \xE0 celle-ci <tt>PreregisterHub()</tt> ne d\xE9clanche pas d\x27erreur si le hub choisi n\x27est pas joignable au moment de l\x27appel. Il est ainsi possible d\x27enregistrer un hub r\xE9seau ind\xE9pendemment de la connectivit\xE9, afin de tenter de ne le contacter que lorsqu\x27on cherche r\xE9ellement un module.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui>,<ui>\x22callback\x22,</ui> ou l\x27URL racine du VirtualHub \xE0 utiliser.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'def RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yUpdateDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{arrivalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'def RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yUpdateDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{removalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterHub']={syn:'Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e.',lib:'YAPI.RegisterHub()',pro:'def RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e. Le premier param\xE8tre d\xE9termine le fonctionnement de l\x27API, il peut prendre les valeurs suivantes:</p><p> <b>usb</b>: Si vous utilisez le mot-cl\xE9 <ui>usb</ui>, l\x27API utilise les modules Yoctopuce connect\xE9s directement par USB. Certains languages comme PHP, Javascript et Java ne permettent pas un acc\xE8s direct aux couches mat\xE9rielles, <ui>usb</ui> ne marchera donc pas avec ces languages. Dans ce cas, utilisez un VirtualHub ou un YoctoHub r\xE9seau (voir ci-dessous).</p><p> <b><i>x.x.x.x</i></b> ou <b><i>hostname</i></b>: L\x27API utilise les modules connect\xE9s \xE0 la machine dont l\x27adresse IP est <i>x.x.x.x</i>, ou dont le nom d\x27h\xF4te DNS est <i>hostname</i>. Cette machine peut \xEAtre un ordinateur classique faisant tourner un VirtualHub, ou un YoctoHub avec r\xE9seau (YoctoHub-Ethernet / YoctoHub-Wireless). Si vous d\xE9sirez utiliser le VirtualHub tournant sur votre machine locale, utilisez l\x27adresse IP 127.0.0.1.</p><p> <b>callback</b> Le mot-cl\xE9 <ui>callback</ui> permet de faire fonctionnner l\x27API dans un mode app\xE9l\xE9 \x22<i>callback HTTP</i>\x22. C\x27est un mode sp\xE9cial permettant, entre autres, de prendre le contr\xF4le de modules Yoctopuce \xE0 travers un filtre NAT par l\x27interm\xE9diaire d\x27un VirtualHub ou d\x27un Hub Yoctopuce. Il vous suffit de configuer le hub pour qu\x27il appelle votre script \xE0 intervalle r\xE9gulier. Ce mode de fonctionnement n\x27est disponible actuellement qu\x27en PHP et en Node.JS.</p><p> Attention, seule une application peut fonctionner \xE0 la fois sur une machine donn\xE9e en acc\xE8s direct \xE0 USB, sinon il y aurait un conflit d\x27acc\xE8s aux modules. Cela signifie en particulier que vous devez stopper le VirtualHub avant de lancer une application utilisant l\x27acc\xE8s direct \xE0 USB. Cette limitation peut \xEAtre contourn\xE9e en passant par un VirtualHub plut\xF4t que d\x27utiliser directement USB.</p><p> Si vous d\xE9sirez vous connecter \xE0 un Hub, virtuel ou non, sur lequel le controle d\x27acc\xE8s a \xE9t\xE9 activ\xE9, vous devez donner le param\xE8tre url sous la forme:</p><p> <tt>http://nom:mot_de_passe@adresse:port</tt></p><p> Vous pouvez appeller <i>RegisterHub</i> plusieurs fois pour vous connecter \xE0 plusieurs machines diff\xE9rentes.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui>,<ui>\x22callback\x22,</ui> ou l\x27URL racine du VirtualHub \xE0 utiliser.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterHubDiscoveryCallback']={syn:'Enregistre une fonction de callback qui est appel\xE9e chaque fois qu\x27un hub r\xE9seau s\x27annonce avec un message SSDP.',lib:'YAPI.RegisterHubDiscoveryCallback()',pro:'def RegisterHubDiscoveryCallback(<span id=pn>hubDiscoveryCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui est appel\xE9e chaque fois qu\x27un hub r\xE9seau s\x27annonce avec un message SSDP. la fonction de callback re\xE7ois deux cha\xEEnes de caract\xE8res en param\xE8tre La premi\xE8re cha\xEEne contient le num\xE9ro de s\xE9rie du hub r\xE9seau et la deuxi\xE8me cha\xEEne contient l\x27URL du hub. L\x27URL peut \xEAtre pass\xE9e directement en argument \xE0 la fonction <tt>yRegisterHub</tt>. Le callback sera appel\xE9 pendant l\x27ex\xE9cution de la fonction <tt>yUpdateDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{hubDiscoveryCallback:'une proc\xE9dure qui prend deux cha\xEEne de caract\xE8res en param\xE8tre, le num\xE9ro de s\xE9rie et l\x27URL du hub d\xE9couvert. Pour supprimer un callback d\xE9j\xE0 enregistr\xE9, utilisez <tt>null</tt>.'}};
doc['YAPI']['RegisterLogFunction']={syn:'Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire.',lib:'YAPI.RegisterLogFunction()',pro:'def RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire. Utile pour d\xE9bugger le fonctionnement de l\x27API.</p>',par:{logfun:'une procedure qui prend une cha\xEEne de caract\xE8re en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['SelectArchitecture']={syn:'S\xE9lectionne manuellement l\x27architecture de la libraire dynamique \xE0 utiliser pour acc\xE9der \xE0 USB.',lib:'YAPI.SelectArchitecture()',pro:'def SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>S\xE9lectionne manuellement l\x27architecture de la libraire dynamique \xE0 utiliser pour acc\xE9der \xE0 USB. Par d\xE9faut, la libraire Python d\xE9tecte automatiquement la version de la libraire dynamique \xE0 utiliser pour acc\xE9der au port USB. Sous Linux ARM il n\x27est pas possible de d\xE9tecter de mani\xE8re fiable si il s\x27agit d\x27une installation Soft float (armel) ou Hard float (armhf). Dans ce cas, il est donc recommend\xE9 d\x27appeler <tt>SelectArchitecture()</tt> avant tout autre appel \xE0 la librairie pour forcer l\x27utilisation d\x27une architecture sp\xE9cifi\xE9e.</p>',par:{arch:'une cha\xEEne de caract\xE8re sp\xE9cifiant l\x27architecture \xE0 utiliser. Les valeurs possibles sont <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>,<tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'rien.',ext:'En cas d\x27erreur, d\xE9clenche une exception.'};
doc['YAPI']['SetCacheValidity']={syn:'Change la dur\xE9e de validit\xE9 des donn\xE9es charg\xE9es par la librairie.',lib:'YAPI.SetCacheValidity()',pro:'def SetCacheValidity(<span id=pn>cacheValidityMs</span>)',cmt:'<p>Change la dur\xE9e de validit\xE9 des donn\xE9es charg\xE9es par la librairie. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour changer cette dur\xE9e, par exemple dans le but de r\xE9duire le trafic r\xE9seau ou USB. Ce param\xE8tre n\x27affecte pas les callbacks de changement de valeur Note: Cette fonction doit \xEAtre appel\xE9e apr\xE8s <tt>yInitAPI</tt>.</p>',par:{cacheValidityMs:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes.'}};
doc['YAPI']['SetDeviceListValidity']={syn:'Change le d\xE9lais entre chaque \xE9num\xE9ration forc\xE9e des YoctoHub utilis\xE9s.',lib:'YAPI.SetDeviceListValidity()',pro:'def SetDeviceListValidity(<span id=pn>deviceListValidity</span>)',cmt:'<p>Change le d\xE9lais entre chaque \xE9num\xE9ration forc\xE9e des YoctoHub utilis\xE9s. Par d\xE9faut la librairie effectue une \xE9num\xE9ration compl\xE8te toute les 10 secondes. Pour r\xE9duire le trafic r\xE9seau il est possible d\x27augmenter ce d\xE9lais. C\x27est particuli\xE8rement utile lors un YoctoHub est connect\xE9 \xE0 un r\xE9seau GSM o\xF9 le trafic est factur\xE9. Ce param\xE8tre n\x27affecte pas les modules connect\xE9s par USB, ni le fonctionnement des callback de connexion/d\xE9connexion de module. Note: Cette fonction doit \xEAtre appel\xE9e apr\xE8s <tt>yInitAPI</tt>.</p>',par:{deviceListValidity:'nombre de secondes entre chaque \xE9num\xE9ration.'}};
doc['YAPI']['Sleep']={syn:'Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e.',lib:'YAPI.Sleep()',pro:'def Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e. L\x27attente est passive, c\x27est-\xE0-dire qu\x27elle n\x27occupe pas significativement le processeur, de sorte \xE0 le laisser disponible pour les autres processus fonctionnant sur la machine. Durant l\x27attente, la librairie va n\xE9anmoins continuer \xE0 lire p\xE9riodiquement les informations en provenance des modules Yoctopuce en appelant la fonction <tt>yHandleEvents()</tt> afin de se maintenir \xE0 jour.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',par:{ms_duration:'un entier correspondant \xE0 la dur\xE9e de la pause, en millisecondes',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['TestHub']={syn:'Test si un hub est joignable.',lib:'YAPI.TestHub()',pro:'def TestHub(<span id=pn>url</span>, <span id=pn>mstimeout</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Test si un hub est joignable. Cette m\xE9thode n\x27enregistre pas le hub, elle ne fait que de v\xE9rifier que le hub est joignable. Le param\xE8tre url suit les m\xEAmes conventions que la m\xE9thode <tt>RegisterHub</tt>. Cette m\xE9thode est utile pour v\xE9rifier les param\xE8tres d\x27authentification d\x27un hub. Il est possible de forcer la m\xE9thode \xE0 rendre la main apr\xE8s mstimeout millisecondes.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui>,<ui>\x22callback\x22,</ui> ou l\x27URL racine du VirtualHub \xE0 utiliser.',mstimeout:'le nombre de millisecondes disponible pour tester la connexion.',errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['TriggerHubDiscovery']={syn:'Relance une d\xE9tection des hubs r\xE9seau.',lib:'YAPI.TriggerHubDiscovery()',pro:'def TriggerHubDiscovery(<span id=pn>errmsg</span>=None)',cmt:'<p>Relance une d\xE9tection des hubs r\xE9seau. Si une fonction de callback est enregistr\xE9e avec <tt>yRegisterHubDiscoveryCallback</tt> elle sera appel\xE9e \xE0 chaque hub r\xE9seau qui r\xE9pondra \xE0 la d\xE9tection SSDP.</p>',par:{errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['UnregisterHub']={syn:'Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'def UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui> ou l\x27URL racine du VirtualHub \xE0 ne plus utiliser.'}};
doc['YAPI']['UpdateDeviceList']={syn:'Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s.',lib:'YAPI.UpdateDeviceList()',pro:'def UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s. La librairie va v\xE9rifier sur les machines ou ports USB pr\xE9c\xE9demment enregistr\xE9s en utilisant la fonction <tt>yRegisterHub</tt> si un module a \xE9t\xE9 connect\xE9 ou d\xE9connect\xE9, et le cas \xE9ch\xE9ant appeler les fonctions de callback d\xE9finies par l\x27utilisateur.</p><p> Cette fonction peut \xEAtre appel\xE9e aussi souvent que d\xE9sir\xE9, afin de rendre l\x27application r\xE9active aux \xE9v\xE9nements de hot-plug.</p>',par:{errmsg:'une cha\xEEne de caract\xE8res pass\xE9e par r\xE9f\xE9rence, dans laquelle sera stock\xE9 un \xE9ventuel message d\x27erreur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'S\xE9quence de donn\xE9es enregistr\xE9es brute',inc:'from yocto_api import *',cmt:'<p>Les objets YDataStream correspondent aux s\xE9quences de mesures enregistr\xE9es brutes, directement telles qu\x27obtenues par l\x27enregistreur de donn\xE9es pr\xE9sent dans les senseurs de Yoctopuce.</p><p> Dans la plupart des cas, il n\x27est pas n\xE9cessaire d\x27utiliser les objets DataStream, car les objets YDataSet (retourn\xE9s par la m\xE9thode <tt>get_recordedData()</tt> des senseurs et la m\xE9thode <tt>get_dataSets()</tt> du DataLogger) fournissent une interface plus pratique.</p>'}};
doc['DataStream']['get_averageValue']={syn:'Retourne la moyenne des valeurs observ\xE9es durant cette s\xE9quence.',lib:'datastream.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Retourne la moyenne des valeurs observ\xE9es durant cette s\xE9quence. Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode retournera toujours Y_DATA_INVALID.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la moyenne des valeurs, ou Y_DATA_INVALID si la s\xE9quence n\x27est pas encore termin\xE9e.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_columnCount']={syn:'Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence.',lib:'datastream.get_columnCount()',pro:'def get_columnCount()',cmt:'<p>Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence. La s\xE9mantique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence si n\xE9cessaire, ce qui peut prendre un petit instant.</p>',ret:'un entier positif correspondant au nombre de colonnes.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_columnNames']={syn:'Retourne le nom (la s\xE9mantique) des colonnes de donn\xE9es contenus dans la s\xE9quence.',lib:'datastream.get_columnNames()',pro:'def get_columnNames()',cmt:'<p>Retourne le nom (la s\xE9mantique) des colonnes de donn\xE9es contenus dans la s\xE9quence. Dans la plupart des cas, le nom des colonnes correspond \xE0 l\x27identifiant mat\xE9riel du capteur qui a produit la mesure. Pour les s\xE9quences enregistr\xE9es \xE0 faible f\xE9rquence, l\x27enregistreur de donn\xE9e stocke la valeur min, moyenne et max observ\xE9e durant chaque intervalle de temps dans des colonnes avec les suffixes _min, _avg et _max respectivement.</p><p> Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence si n\xE9cessaire, ce qui peut prendre un petit instant.</p>',ret:'une liste de cha\xEEne de caract\xE8res.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataStream']['get_data']={syn:'Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne).',lib:'datastream.get_data()',pro:'def get_data(<span id=pn>row</span>, <span id=pn>col</span>)',cmt:'<p>Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode get_columnNames().</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',par:{row:'index de l\x27enregistrement (ligne)',col:'index de la mesure (colonne)'},ret:'un nombre d\xE9cimal',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle).',lib:'datastream.get_dataRows()',pro:'def get_dataRows()',cmt:'<p>Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'une liste d\x27enregistrements, chaque enregistrement \xE9tant lui-m\xEAme une liste de nombres d\xE9cimaux.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataStream']['get_dataSamplesIntervalMs']={syn:'Retourne le nombre de millisecondes entre chaque mesure de la s\xE9quence.',lib:'datastream.get_dataSamplesIntervalMs()',pro:'def get_dataSamplesIntervalMs()',cmt:'<p>Retourne le nombre de millisecondes entre chaque mesure de la s\xE9quence. Par d\xE9faut, l\x27enregistreur m\xE9morise une mesure par seconde, mais la fr\xE9quence d\x27enregistrement peut \xEAtre chang\xE9e pour chaque fonction.</p>',ret:'un entier positif correspondant au nombre de millisecondes entre deux mesures cons\xE9cutives.'};
doc['DataStream']['get_maxValue']={syn:'Retourne la plus grande valeur observ\xE9e durant cette s\xE9quence.',lib:'datastream.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Retourne la plus grande valeur observ\xE9e durant cette s\xE9quence. Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode retournera toujours Y_DATA_INVALID.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la plus grande valeur, ou Y_DATA_INVALID si la s\xE9quence n\x27est pas encore termin\xE9e.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_minValue']={syn:'Retourne la plus petite valeur observ\xE9e durant cette s\xE9quence.',lib:'datastream.get_minValue()',pro:'def get_minValue()',cmt:'<p>Retourne la plus petite valeur observ\xE9e durant cette s\xE9quence. Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode retournera toujours Y_DATA_INVALID.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la plus petite valeur, ou Y_DATA_INVALID si la s\xE9quence n\x27est pas encore termin\xE9e.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_realStartTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'datastream.get_realStartTimeUTC()',pro:'def get_realStartTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Si l\x27heure UTC n\x27\xE9tait pas configur\xE9e dans l\x27enregistreur de donn\xE9es au d\xE9but de la s\xE9quence, cette m\xE9thode retourne 0.</p>',ret:'un nombre d\xE9cimal correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
doc['DataStream']['get_rowCount']={syn:'Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.',lib:'datastream.get_rowCount()',pro:'def get_rowCount()',cmt:'<p>Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.</p><p> Si le module utilise un firmware ant\xE9rieur \xE0 la version 13000, cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence si n\xE9cessaire, ce qui peut prendre un petit instant.</p>',ret:'un entier positif correspondant au nombre d\x27enregistrements.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_runIndex']={syn:'Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es.',lib:'datastream.get_runIndex()',pro:'def get_runIndex()',cmt:'<p>Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es. Un Run peut \xEAtre compos\xE9 de plusieurs s\xE9quences, couvrant diff\xE9rents intervalles de temps.</p>',ret:'un entier positif correspondant au num\xE9ro du Run'};
doc['DataStream']['get_startTime']={syn:'Retourne le temps de d\xE9part relatif de la s\xE9quence (en secondes).',lib:'datastream.get_startTime()',pro:'def get_startTime()',cmt:'<p>Retourne le temps de d\xE9part relatif de la s\xE9quence (en secondes). Pour les firmwares r\xE9cents, la valeur est relative \xE0 l\x27heure courantegener (valeur n\xE9gative). Pour les modules utilisant un firmware plus ancien que la version 13000, la valeur est le nombre de secondes depuis la mise sous tension du module (valeure positive). Si vous d\xE9sirez obtenir l\x27heure absolue du d\xE9but de la s\xE9quence, utilisez <tt>get_realStartTimeUTC()</tt>.</p><p> <b>OBSOL\xC8TE</b>: cette methode a \xE9t\xE9 remplac\xE9 par <tt>get_realStartTimeUTC()</tt>.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le d\xE9but du Run et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
doc['DataStream']['get_startTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'datastream.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Si l\x27heure UTC n\x27\xE9tait pas configur\xE9e dans l\x27enregistreur de donn\xE9es au d\xE9but de la s\xE9quence, cette m\xE9thode retourne 0.</p><p> <b>OBSOL\xC8TE</b>: cette methode a \xE9t\xE9 remplac\xE9 par <tt>get_realStartTimeUTC()</tt>.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
//--- (end of generated code: DataStream)
//--- (generated code: DataSet)
doc['DataSet']={'':{syn:'S\xE9quence de donn\xE9es enregistr\xE9es',inc:'from yocto_api import *',cmt:'<p>Les objets YDataSet permettent de r\xE9cup\xE9rer un ensemble de mesures enregistr\xE9es correspondant \xE0 un capteur donn\xE9, pour une p\xE9riode choisie. Ils permettent le chargement progressif des donn\xE9es. Lorsque l\x27objet YDataSet est instanci\xE9 par la fonction <tt>get_recordedData()</tt>, aucune donn\xE9e n\x27est encore charg\xE9e du module. Ce sont les appels successifs \xE0 la m\xE9thode <tt>loadMore()</tt> qui proc\xE8dent au chargement effectif des donn\xE9es depuis l\x27enregistreur de donn\xE9es.</p><p> Un r\xE9sum\xE9 des mesures disponibles est disponible via la fonction <tt>get_preview()</tt> d\xE8s le premier appel \xE0 <tt>loadMore()</tt>. Les mesures elles-m\xEAme sont disponibles via la fonction <tt>get_measures()</tt> au fur et \xE0 mesure de leur chargement.</p><p> Cette classe ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets YDataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>'}};
doc['DataSet']['get_endTimeUTC']={syn:'Retourne l\x27heure absolue de la fin des mesures disponibles, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'dataset.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Retourne l\x27heure absolue de la fin des mesures disponibles, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Lorsque l\x27objet YDataSet est cr\xE9\xE9, l\x27heure de fin est celle qui a \xE9t\xE9 pass\xE9e en param\xE8tre \xE0 la fonction <tt>get_dataSet</tt>. D\xE8s le premier appel \xE0 la m\xE9thode <tt>loadMore()</tt>, l\x27heure de fin est mise \xE0 jour \xE0 la derni\xE8re mesure effectivement disponible dans l\x27enregistreur de donn\xE9es pour la plage sp\xE9cifi\xE9e.</p><p> <b>OBSOL\xC8TE</b>: cette methode a \xE9t\xE9 remplac\xE9 par <tt>get_summary()</tt> qui retoure des informations plus pr\xE9cises.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et la derni\xE8re mesure.'};
doc['DataSet']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction qui a effectu\xE9 les mesures, sans r\xE9f\xE9rence au module.',lib:'dataset.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction qui a effectu\xE9 les mesures, sans r\xE9f\xE9rence au module. Par example <tt>temperature1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>temperature1</tt>)'};
doc['DataSet']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction qui a effectu\xE9 les mesures, au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'dataset.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction qui a effectu\xE9 les mesures, au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>THRMCPL1-123456.temperature1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>THRMCPL1-123456.temperature1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataSet']['get_measures']={syn:'Retourne toutes les mesures d\xE9j\xE0 disponibles pour le DataSet, sous forme d\x27une liste d\x27objets YMeasure.',lib:'dataset.get_measures()',pro:'def get_measures()',cmt:'<p>Retourne toutes les mesures d\xE9j\xE0 disponibles pour le DataSet, sous forme d\x27une liste d\x27objets YMeasure. Chaque \xE9l\xE9ment contient: - le moment ou la mesure a d\xE9but\xE9 - le moment ou la mesure s\x27est termin\xE9e - la valeur minimale observ\xE9e dans l\x27intervalle de temps - la valeur moyenne observ\xE9e dans l\x27intervalle de temps - la valeur maximale observ\xE9e dans l\x27intervalle de temps</p><p> Avant d\x27appeler cette m\xE9thode, vous devez appeler <tt>loadMore()</tt> pour charger des donn\xE9es depuis l\x27enregistreur sur le module. L\x27appel doit \xEAtre r\xE9p\xE9t\xE9 plusieurs fois pour charger toutes les donn\xE9es, mais vous pouvez commencer \xE0 utiliser les donn\xE9es disponibles avant qu\x27elles n\x27aient \xE9t\xE9 toutes charg\xE9es</p><p> Les mesures les plus anciennes sont toujours charg\xE9es les premi\xE8res, et les plus r\xE9centes en dernier. De ce fait, les timestamps dans la table des mesures sont normalement par ordre chronologique. La seule exception est dans le cas o\xF9 il y a eu un ajustement de l\x27horloge UTC de l\x27enregistreur de donn\xE9es pendant l\x27enregistrement.</p>',ret:'un tableau d\x27enregistrements, chaque enregistrement repr\xE9sentant une mesure effectu\xE9e \xE0 un moment pr\xE9cis.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['DataSet']['get_measuresAt']={syn:'Retourne les mesures d\xE9taill\xE9es pour une mesure r\xE9sum\xE9e pr\xE9c\xE9demment retourn\xE9e par <tt>get_preview()</tt>.',lib:'dataset.get_measuresAt()',pro:'def get_measuresAt(<span id=pn>measure</span>)',cmt:'<p>Retourne les mesures d\xE9taill\xE9es pour une mesure r\xE9sum\xE9e pr\xE9c\xE9demment retourn\xE9e par <tt>get_preview()</tt>. Le r\xE9sultat est fourni sous forme d\x27une liste d\x27objets YMeasure.</p>',par:{measure:'mesure r\xE9sum\xE9e extraite de la liste pr\xE9c\xE9demment retourn\xE9e par <tt>get_preview()</tt>.'},ret:'un tableau d\x27enregistrements, chaque enregistrement repr\xE9sentant les mesures observ\xE9e durant un certain intervalle de temps.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['DataSet']['get_preview']={syn:'Retourne une version r\xE9sum\xE9e des mesures qui pourront \xEAtre obtenues de ce YDataSet, sous forme d\x27une liste d\x27objets YMeasure.',lib:'dataset.get_preview()',pro:'def get_preview()',cmt:'<p>Retourne une version r\xE9sum\xE9e des mesures qui pourront \xEAtre obtenues de ce YDataSet, sous forme d\x27une liste d\x27objets YMeasure. Chaque \xE9l\xE9ment contient: - le d\xE9but d\x27un intervalle de temps - la fin d\x27un intervalle de temps - la valeur minimale observ\xE9e dans l\x27intervalle de temps - la valeur moyenne observ\xE9e dans l\x27intervalle de temps - la valeur maximale observ\xE9e dans l\x27intervalle de temps</p><p> Le r\xE9sum\xE9 des mesures est disponible d\xE8s que <tt>loadMore()</tt> a \xE9t\xE9 appel\xE9 pour la premi\xE8re fois.</p>',ret:'un tableau d\x27enregistrements, chaque enregistrement repr\xE9sentant les mesures observ\xE9e durant un certain intervalle de temps.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['DataSet']['get_progress']={syn:'Retourne l\x27\xE9tat d\x27avancement du chargement des donn\xE9es, sur une \xE9chelle de 0 \xE0 100.',lib:'dataset.get_progress()',pro:'def get_progress()',cmt:'<p>Retourne l\x27\xE9tat d\x27avancement du chargement des donn\xE9es, sur une \xE9chelle de 0 \xE0 100. A l\x27instanciation de l\x27objet par la fonction <tt>get_dataSet()</tt>, l\x27avancement est nul. Au fur et \xE0 mesure des appels \xE0 <tt>loadMore()</tt>, l\x27avancement progresse pour atteindre la valeur 100 lorsque toutes les mesures ont \xE9t\xE9 charg\xE9es.</p>',ret:'un nombre entier entre 0 et 100 repr\xE9sentant l\x27avancement du chargement des donn\xE9es demand\xE9es.'};
doc['DataSet']['get_startTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but des mesures disponibels, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'dataset.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but des mesures disponibels, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Lorsque l\x27objet YDataSet est cr\xE9\xE9, l\x27heure de d\xE9part est celle qui a \xE9t\xE9 pass\xE9e en param\xE8tre \xE0 la fonction <tt>get_dataSet</tt>. D\xE8s le premier appel \xE0 la m\xE9thode <tt>loadMore()</tt>, l\x27heure de d\xE9part est mise \xE0 jour \xE0 la premi\xE8re mesure effectivement disponible dans l\x27enregistreur de donn\xE9es pour la plage sp\xE9cifi\xE9e.</p><p> <b>OBSOL\xC8TE</b>: cette methode a \xE9t\xE9 remplac\xE9 par <tt>get_summary()</tt> qui retoure des informations plus pr\xE9cises.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et la premi\xE8re mesure enregistr\xE9e.'};
doc['DataSet']['get_summary']={syn:'Retourne un objet YMeasure r\xE9sumant tout le YDataSet.',lib:'dataset.get_summary()',pro:'def get_summary()',cmt:'<p>Retourne un objet YMeasure r\xE9sumant tout le YDataSet. Il inclut les information suivantes: - le moment de la premi\xE8re mesure - le moment de la derni\xE8re mesure - la valeur minimale observ\xE9e dans l\x27intervalle de temps - la valeur moyenne observ\xE9e dans l\x27intervalle de temps - la valeur maximale observ\xE9e dans l\x27intervalle de temps</p><p> Ce r\xE9sum\xE9 des mesures est disponible d\xE8s que <tt>loadMore()</tt> a \xE9t\xE9 appel\xE9 pour la premi\xE8re fois.</p>',ret:'un objet YMeasure'};
doc['DataSet']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'dataset.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une unit\xE9 physique.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['DataSet']['loadMore']={syn:'Proc\xE8de au chargement du bloc suivant de mesures depuis l\x27enregistreur de donn\xE9es du module, et met \xE0 jour l\x27indicateur d\x27avancement.',lib:'dataset.loadMore()',pro:'def loadMore()',cmt:'<p>Proc\xE8de au chargement du bloc suivant de mesures depuis l\x27enregistreur de donn\xE9es du module, et met \xE0 jour l\x27indicateur d\x27avancement.</p>',ret:'un nombre entier entre 0 et 100 repr\xE9sentant l\x27avancement du chargement des donn\xE9es demand\xE9es, ou un code d\x27erreur n\xE9gatif en cas de probl\xE8me.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DataSet)
//--- (generated code: Measure)
doc['Measure']={'':{syn:'Valeur mesur\xE9e',inc:'from yocto_api import *',cmt:'<p>Les objets YMeasure sont utilis\xE9s dans l\x27interface de programmation Yoctopuce pour repr\xE9senter une valeur observ\xE9e un moment donn\xE9e. Ces objets sont utilis\xE9s en particulier en conjonction avec la classe YDataSet.</p>'}};
doc['Measure']['get_averageValue']={syn:'Retourne la valeur moyenne observ\xE9e durant l\x27intervalle de temps couvert par la mesure.',lib:'measure.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Retourne la valeur moyenne observ\xE9e durant l\x27intervalle de temps couvert par la mesure.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la valeur moyenne observ\xE9e.'};
doc['Measure']['get_endTimeUTC']={syn:'Retourne l\x27heure absolue de la fin de la mesure, sous forme du nombre de secondes depuis le 1er janvier 1970 UTC (date/heure au format Unix).',lib:'measure.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Retourne l\x27heure absolue de la fin de la mesure, sous forme du nombre de secondes depuis le 1er janvier 1970 UTC (date/heure au format Unix). Lors que l\x27enregistrement de donn\xE9es se fait \xE0 une fr\xE9quence sup\xE9rieure \xE0 une mesure par seconde, le timestamp peuvent inclurent une fraction d\xE9cimale.</p>',ret:'un nombre r\xE9el positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 UTC et la fin de la mesure.'};
doc['Measure']['get_maxValue']={syn:'Retourne la plus grande valeur observ\xE9e durant l\x27intervalle de temps couvert par la mesure.',lib:'measure.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Retourne la plus grande valeur observ\xE9e durant l\x27intervalle de temps couvert par la mesure.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la plus grande valeur observ\xE9e.'};
doc['Measure']['get_minValue']={syn:'Retourne la plus petite valeur observ\xE9e durant l\x27intervalle de temps couvert par la mesure.',lib:'measure.get_minValue()',pro:'def get_minValue()',cmt:'<p>Retourne la plus petite valeur observ\xE9e durant l\x27intervalle de temps couvert par la mesure.</p>',ret:'un nombre d\xE9cimal correspondant \xE0 la plus petite valeur observ\xE9e.'};
doc['Measure']['get_startTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but de la mesure, sous forme du nombre de secondes depuis le 1er janvier 1970 UTC (date/heure au format Unix).',lib:'measure.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but de la mesure, sous forme du nombre de secondes depuis le 1er janvier 1970 UTC (date/heure au format Unix). Lors que l\x27enregistrement de donn\xE9es se fait \xE0 une fr\xE9quence sup\xE9rieure \xE0 une mesure par seconde, le timestamp peuvent inclurent une fraction d\xE9cimale.</p>',ret:'un nombre r\xE9el positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 UTC et la d\xE9but de la mesure.'};
//--- (end of generated code: Measure)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'Interface des objets DisplayLayer',inc:'from yocto_display import *',cmt:'<p>Un DisplayLayer est une couche de contenu affichable (images, texte, etc.). Le contenu n\x27est visible sur l\x27\xE9cran que lorsque la couche est active sur l\x27\xE9cran (et non masqu\xE9e par une couche sup\xE9rieure).</p>'}};
doc['DisplayLayer']['clear']={syn:'Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente.',lib:'displaylayer.clear()',pro:'def clear()',cmt:'<p>Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente. Cette m\xE9thode ne change pas les r\xE9glages de le couche. Si vous d\xE9sirez remettre la couche dans son \xE9tat initial, utilisez plut\xF4t la m\xE9thode <tt>reset()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['clearConsole']={syn:'Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.',lib:'displaylayer.clearConsole()',pro:'def clearConsole()',cmt:'<p>Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['consoleOut']={syn:'Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte.',lib:'displaylayer.consoleOut()',pro:'def consoleOut(<span id=pn>text</span>)',cmt:'<p>Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte. Le curseur revient automatiquement en d\xE9but de ligne suivante lorsqu\x27un saut de ligne est rencontr\xE9, ou lorsque la marge droite est atteinte. Lorsque le texte \xE0 afficher s\x27appr\xEAte \xE0 d\xE9passer la marge inf\xE9rieure, le contenu de la zone de console est automatiquement d\xE9cal\xE9 vers le haut afin de laisser la place \xE0 la nouvelle ligne de texte.</p>',par:{text:'le message \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBar']={syn:'Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawBar()',pro:'def drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBitmap']={syn:'Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawBitmap()',pro:'def drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche. Le bitmap est pass\xE9 sous forme d\x27un objet binaire, o\xF9 chaque bit correspond \xE0 un pixel, de gauche \xE0 droite et de haut en bas. Le bit de poids fort de chaque octet correspond au pixel de gauche, et le bit de poids faible au pixel le plus \xE0 droite. Les bits \xE0 1 sont dessin\xE9s avec la couleur active de la couche. Les bits \xE0 0 avec la couleur de fond sp\xE9cifi\xE9e, sauf si la valeur -1 a \xE9t\xE9 choisie, auquel cas ils ne sont pas dessin\xE9s (ils sont consid\xE9r\xE9s comme transparents). Chaque ligne commence sur un nouvel octet. La hauteur du bitmap est donn\xE9e implicitement par la taille de l\x27objet binaire.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du bitmap',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du bitmap',w:'la largeur du bitmap, en pixels',bitmap:'l\x27objet binaire contenant le bitmap',bgcol:'le niveau de gris \xE0 utiliser pour les bits \xE0 z\xE9ro (0 = noir, 255 = blanc), ou -1 pour lasser les pixels inchang\xE9s'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawCircle']={syn:'Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawCircle()',pro:'def drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du cercle',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du cercle',r:'le rayon du cercle, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawDisc']={syn:'Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawDisc()',pro:'def drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du disque',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du disque',r:'le rayon du disque, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawImage']={syn:'Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawImage()',pro:'def drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche. L\x27image GIF doit avoir \xE9t\xE9 pr\xE9alablement pr\xE9charg\xE9e dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une image bitmap, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier d\x27image manquant ou d\x27un format de fichier invalide.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche de l\x27image',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur de l\x27image',imagename:'le nom du fichier GIF \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawPixel']={syn:'Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawPixel()',pro:'def drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche',y:'la distance en pixels depuis le haut de la couche'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawRect']={syn:'Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawRect()',pro:'def drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawText']={syn:'Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawText()',pro:'def drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche. Le point du texte qui sera align\xE9 sur la position sp\xE9cifi\xE9e est appel\xE9 point d\x27ancrage, et peut \xEAtre choisi parmi plusieurs options.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point d\x27ancrage du texte',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point d\x27ancrage du texte',anchor:'le point d\x27ancrage du texte, choisi parmi l\x27\xE9num\xE9ration <tt>Y_ALIGN</tt>: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'le texte \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['get_display']={syn:'Retourne l\x27YDisplay parent.',lib:'displaylayer.get_display()',pro:'def get_display()',cmt:'<p>Retourne l\x27YDisplay parent. Retourne l\x27objet YDisplay parent du YDisplayLayer courant.</p>',ret:'un objet <tt>YDisplay</tt>'};
doc['DisplayLayer']['get_displayHeight']={syn:'Retourne la hauteur de l\x27\xE9cran, en pixels.',lib:'displaylayer.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Retourne la hauteur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DISPLAYHEIGHT_INVALID.'};
doc['DisplayLayer']['get_displayWidth']={syn:'Retourne la largeur de l\x27\xE9cran, en pixels.',lib:'displaylayer.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Retourne la largeur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DISPLAYWIDTH_INVALID.'};
doc['DisplayLayer']['get_layerHeight']={syn:'Retourne la hauteur des couches affichables, en pixels.',lib:'displaylayer.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Retourne la hauteur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur des couches affichables, en pixels.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_LAYERHEIGHT_INVALID.'};
doc['DisplayLayer']['get_layerWidth']={syn:'Retourne la largeur des couches affichables, en pixels.',lib:'displaylayer.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Retourne la largeur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur des couches affichables, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_LAYERWIDTH_INVALID.'};
doc['DisplayLayer']['hide']={syn:'Cache la couche de dessin.',lib:'displaylayer.hide()',pro:'def hide()',cmt:'<p>Cache la couche de dessin. L\x27etat de la couche est pr\xE9serv\xE9, mais la couche ne sera plus plus affich\xE9s \xE0 l\x27\xE9cran jusqu\x27au prochain appel \xE0 <tt>unhide()</tt>. Le fait de cacher la couche am\xE9liore les performances de toutes les primitives d\x27affichage, car il \xE9vite de consacrer inutilement des cycles de calcul \xE0 afficher les \xE9tats interm\xE9diaires (technique de double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['lineTo']={syn:'Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.lineTo()',pro:'def lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e. Le pixel final sp\xE9cifi\xE9 est inclus dans la ligne dessin\xE9e. Le point de dessin courant est d\xE9plac\xE9 \xE0 au point final de la ligne.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point final',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point final'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['moveTo']={syn:'D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.moveTo()',pro:'def moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche de dessin',y:'la distance en pixels depuis le haut de la couche de dessin'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['reset']={syn:'Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut).',lib:'displaylayer.reset()',pro:'def reset()',cmt:'<p>Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut). R\xE9initialise la position du point de dessin courant au coin sup\xE9rieur gauche, et la couleur de dessin \xE0 la valeur la plus lumineuse. Si vous d\xE9sirez simplement effacer le contenu de la couche, utilisez plut\xF4t la m\xE9thode <tt>clear()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectColorPen']={syn:'Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectColorPen()',pro:'def selectColorPen(<span id=pn>color</span>)',cmt:'<p>Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. La couleur est fournie sous forme de couleur RGB. Pour les \xE9crans monochromes ou en niveaux de gris, la couleur est automatiquement ramen\xE9e dans les valeurs permises.</p>',par:{color:'la couleur RGB d\xE9sir\xE9e (sous forme d\x27entier 24 bits)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectEraser']={syn:'Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de copie d\x27images bitmaps.',lib:'displaylayer.selectEraser()',pro:'def selectEraser()',cmt:'<p>Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de copie d\x27images bitmaps. Tous les points dessin\xE9s \xE0 la gomme redeviennent transparents (comme ils l\x27\xE9taient lorsque la couche \xE9tait vide), rendant ainsi visibles les couches inf\xE9rieures.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectFont']={syn:'S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes.',lib:'displaylayer.selectFont()',pro:'def selectFont(<span id=pn>fontname</span>)',cmt:'<p>S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes. La police est sp\xE9cifi\xE9e par le nom de son fichier. Vous pouvez utiliser l\x27une des polices pr\xE9d\xE9finies dans le module, ou une autre police que vous avez pr\xE9alablement pr\xE9charg\xE9 dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une police de caract\xE8res, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier de police manquant ou d\x27un format de fichier invalide.</p>',par:{fontname:'le nom du fichier d\xE9finissant la police de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectGrayPen()',pro:'def selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. Le niveau de gris est fourni sous forme d\x27un chiffre allant de 0 (noir) \xE0 255 (blanc, ou la couleur la plus claire de l\x27\xE9cran, quelle qu\x27elle soit). Pour les \xE9crans monochromes (sans niveaux de gris), tout valeur inf\xE9rieure \xE0 128 conduit \xE0 un point noir, et toue valeur sup\xE9rieure ou \xE9gale \xE0 128 devient un point lumineux.</p>',par:{graylevel:'le niveau de gris d\xE9sir\xE9, de 0 \xE0 255'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles.',lib:'displaylayer.setAntialiasingMode()',pro:'def setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles. L\x27anti-aliasing est att\xE9nue la pixelisation des images lorsqu\x27on regarde l\x27\xE9cran depuis une distance suffisante, mais peut aussi donner parfois une impression de flou lorsque l\x27\xE9cran est regard\xE9 de tr\xE8s pr\xE8s. Au final, c\x27est un choix esth\xE9tique qui vous revient. L\x27anti-aliasing est activ\xE9 par d\xE9faut pour les \xE9crans en niveaux de gris et les \xE9crans couleurs, mais vous pouvez le d\xE9sactiver si vous pr\xE9f\xE9rez. Ce r\xE9glage n\x27a pas d\x27effet sur les \xE9crans monochromes.</p>',par:{mode:'<tt>true</tt> pour activer l\x27antialiasing, <tt>false</tt> pour le d\xE9sactiver.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.',lib:'displaylayer.setConsoleBackground()',pro:'def setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.</p>',par:{bgcol:'le niveau de gris \xE0 utiliser pour le fond lors de d\xE9filement (0 = noir, 255 = blanc), ou -1 pour un fond transparent'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleMargins()',pro:'def setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge gauche',y1:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge sup\xE9rieure',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge droite',y2:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge inf\xE9rieure'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleWordWrap()',pro:'def setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.</p>',par:{wordwrap:'<tt>true</tt> pour retourner \xE0 la ligne entre les mots seulements, <tt>false</tt> pour retourner \xE0 l\x27extr\xEAme droite de chaque ligne.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setLayerPosition']={syn:'D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran.',lib:'displaylayer.setLayerPosition()',pro:'def setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran. Lorsqu\x27une dur\xE9e de d\xE9filement est configur\xE9e, la position d\x27affichage de la couche est automatiquement mise \xE0 jour durant les millisecondes suivantes pour animer le d\xE9placement.</p>',par:{x:'la distance en pixels depuis la gauche de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',y:'la distance en pixels depuis le haut de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',scrollTime:'dur\xE9e en millisecondes du d\xE9placement, ou 0 si le d\xE9placement doit \xEAtre imm\xE9diat.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['unhide']={syn:'Affiche la couche.',lib:'displaylayer.unhide()',pro:'def unhide()',cmt:'<p>Affiche la couche. Affiche a nouveau la couche apr\xE8s la command hide.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Interface des fonctions de type senseur',inc:'from yocto_api import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Sensor']['FindSensor']={syn:'Permet de retrouver un senseur d\x27apr\xE8s un identifiant donn\xE9.',lib:'YSensor.FindSensor()',pro:'def FindSensor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un senseur d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le senseur soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YSensor.isOnline()</tt> pour tester si le senseur est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le senseur sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YSensor</tt> qui permet ensuite de contr\xF4ler le senseur.'};
doc['Sensor']['FirstSensor']={syn:'Commence l\x27\xE9num\xE9ration des senseurs accessibles par la librairie.',lib:'YSensor.FirstSensor()',pro:'def FirstSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des senseurs accessibles par la librairie. Utiliser la fonction <tt>YSensor.nextSensor()</tt> pour it\xE9rer sur les autres senseurs.</p>',ret:'un pointeur sur un objet <tt>YSensor</tt>, correspondant au premier senseur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de senseurs disponibles.'};
doc['Sensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'sensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Sensor']['clearCache']={syn:'Invalide le cache.',lib:'sensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du senseur. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Sensor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du senseur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'sensor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du senseur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le senseur (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Sensor']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'sensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Sensor']['get_advertisedValue']={syn:'Retourne la valeur courante du senseur (pas plus de 6 caract\xE8res).',lib:'sensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du senseur (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du senseur (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'sensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentValue']={syn:'Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'sensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Sensor']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'sensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Sensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du senseur.',lib:'sensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du senseur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du senseur.'};
doc['Sensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du senseur.',lib:'sensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du senseur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du senseur.'};
doc['Sensor']['get_friendlyName']={syn:'Retourne un identifiant global du senseur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'sensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du senseur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du senseur si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du senseur (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le senseur en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Sensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'sensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Sensor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du senseur, sans r\xE9f\xE9rence au module.',lib:'sensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du senseur, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le senseur (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Sensor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du senseur au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'sensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du senseur au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du senseur (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le senseur (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Sensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'sensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'sensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_logicalName']={syn:'Retourne le nom logique du senseur.',lib:'sensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du senseur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du senseur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Sensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'sensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'sensor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Sensor']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'sensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Sensor']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'sensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'sensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Sensor']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'sensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Sensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.',lib:'sensor.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la measure est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Sensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'sensor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Sensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le senseur est joignable, sans d\xE9clencher d\x27erreur.',lib:'sensor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le senseur est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du senseur sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le senseur est joignable, <tt>false</tt> sinon'};
doc['Sensor']['isSensorReady']={syn:'V\xE9rifie si le capteur est actuellement en \xE9tat de transmettre une mesure valide.',lib:'sensor.isSensorReady()',pro:'def isSensorReady()',cmt:'<p>V\xE9rifie si le capteur est actuellement en \xE9tat de transmettre une mesure valide. Retourne faux si le module n\x27est pas joignable, ou que le capteur n\x27a pas de mesure actuelle \xE0 communiquer. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur dispose d\x27une mesure actuelle, <tt>false</tt> sinon'};
doc['Sensor']['load']={syn:'Met en cache les valeurs courantes du senseur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'sensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du senseur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Sensor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'sensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Sensor']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'sensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Sensor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'sensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Sensor']['nextSensor']={syn:'Continue l\x27\xE9num\xE9ration des senseurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les senseurs sont retourn\xE9s.',lib:'sensor.nextSensor()',pro:'def nextSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des senseurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstSensor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les senseurs sont retourn\xE9s. Si vous souhaitez retrouver un senseur sp\xE9cifique, utilisez <tt>Sensor.findSensor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Sensor']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'sensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Sensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'sensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Sensor']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'sensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'sensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'sensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_logicalName']={syn:'Modifie le nom logique du senseur.',lib:'sensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du senseur. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du senseur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Sensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'sensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'sensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'sensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Sensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'sensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Sensor']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'sensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Sensor']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'sensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Sensor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'sensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Sensor)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Interface de la fonction Accelerometer',inc:'from yocto_accelerometer import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Accelerometer']['FindAccelerometer']={syn:'Permet de retrouver un acc\xE9l\xE9rom\xE8tre d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAccelerometer.FindAccelerometer()',pro:'def FindAccelerometer(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un acc\xE9l\xE9rom\xE8tre d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27acc\xE9l\xE9rom\xE8tre soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAccelerometer.isOnline()</tt> pour tester si l\x27acc\xE9l\xE9rom\xE8tre est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27acc\xE9l\xE9rom\xE8tre sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAccelerometer</tt> qui permet ensuite de contr\xF4ler l\x27acc\xE9l\xE9rom\xE8tre.'};
doc['Accelerometer']['FirstAccelerometer']={syn:'Commence l\x27\xE9num\xE9ration des acc\xE9l\xE9rom\xE8tres accessibles par la librairie.',lib:'YAccelerometer.FirstAccelerometer()',pro:'def FirstAccelerometer()',cmt:'<p>Commence l\x27\xE9num\xE9ration des acc\xE9l\xE9rom\xE8tres accessibles par la librairie. Utiliser la fonction <tt>YAccelerometer.nextAccelerometer()</tt> pour it\xE9rer sur les autres acc\xE9l\xE9rom\xE8tres.</p>',ret:'un pointeur sur un objet <tt>YAccelerometer</tt>, correspondant au premier acc\xE9l\xE9rom\xE8tre accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de acc\xE9l\xE9rom\xE8tres disponibles.'};
doc['Accelerometer']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'accelerometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Accelerometer']['clearCache']={syn:'Invalide le cache.',lib:'accelerometer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27acc\xE9l\xE9rom\xE8tre. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Accelerometer']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'accelerometer.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27acc\xE9l\xE9rom\xE8tre (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Accelerometer']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'accelerometer.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Accelerometer']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27acc\xE9l\xE9rom\xE8tre (pas plus de 6 caract\xE8res).',lib:'accelerometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27acc\xE9l\xE9rom\xE8tre (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27acc\xE9l\xE9rom\xE8tre (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_bandwidth']={syn:'Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'accelerometer.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).</p>',ret:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Accelerometer']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en g, sous forme de nombre \xE0 virgule.',lib:'accelerometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en g, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en g, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_currentValue']={syn:'Retourne la valeur actuelle de l\x27acc\xE9l\xE9ration, en g, sous forme de nombre \xE0 virgule.',lib:'accelerometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de l\x27acc\xE9l\xE9ration, en g, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27acc\xE9l\xE9ration, en g, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'accelerometer.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Accelerometer']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre.',lib:'accelerometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre.'};
doc['Accelerometer']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre.',lib:'accelerometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27acc\xE9l\xE9rom\xE8tre.'};
doc['Accelerometer']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'accelerometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27acc\xE9l\xE9rom\xE8tre si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27acc\xE9l\xE9rom\xE8tre (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27acc\xE9l\xE9rom\xE8tre en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Accelerometer']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'accelerometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Accelerometer']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27acc\xE9l\xE9rom\xE8tre, sans r\xE9f\xE9rence au module.',lib:'accelerometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27acc\xE9l\xE9rom\xE8tre, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27acc\xE9l\xE9rom\xE8tre (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Accelerometer']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'accelerometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27acc\xE9l\xE9rom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27acc\xE9l\xE9rom\xE8tre (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27acc\xE9l\xE9rom\xE8tre (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Accelerometer']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module.',lib:'accelerometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'accelerometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_logicalName']={syn:'Retourne le nom logique de l\x27acc\xE9l\xE9rom\xE8tre.',lib:'accelerometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27acc\xE9l\xE9rom\xE8tre.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27acc\xE9l\xE9rom\xE8tre.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Accelerometer']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module.',lib:'accelerometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour l\x27acc\xE9l\xE9ration depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'accelerometer.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Accelerometer']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'accelerometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'accelerometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'accelerometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Accelerometer']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'accelerometer.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Accelerometer']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle l\x27acc\xE9l\xE9ration est exprim\xE9e.',lib:'accelerometer.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle l\x27acc\xE9l\xE9ration est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle l\x27acc\xE9l\xE9ration est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Accelerometer']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'accelerometer.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Accelerometer']['get_xValue']={syn:'Retourne la composante X de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.',lib:'accelerometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Retourne la composante X de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante X de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_XVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_yValue']={syn:'Retourne la composante Y de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.',lib:'accelerometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Retourne la composante Y de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante Y de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_YVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_zValue']={syn:'Retourne la composante Z de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.',lib:'accelerometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Retourne la composante Z de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante Z de l\x27acc\xE9l\xE9ration, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Accelerometer']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27acc\xE9l\xE9rom\xE8tre est joignable, sans d\xE9clencher d\x27erreur.',lib:'accelerometer.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27acc\xE9l\xE9rom\xE8tre est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27acc\xE9l\xE9rom\xE8tre sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27acc\xE9l\xE9rom\xE8tre est joignable, <tt>false</tt> sinon'};
doc['Accelerometer']['load']={syn:'Met en cache les valeurs courantes de l\x27acc\xE9l\xE9rom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'accelerometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27acc\xE9l\xE9rom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Accelerometer']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'accelerometer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'accelerometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Accelerometer']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'accelerometer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Accelerometer']['nextAccelerometer']={syn:'Continue l\x27\xE9num\xE9ration des acc\xE9l\xE9rom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstAccelerometer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les acc\xE9l\xE9rom\xE8tres sont retourn\xE9s.',lib:'accelerometer.nextAccelerometer()',pro:'def nextAccelerometer()',cmt:'<p>Continue l\x27\xE9num\xE9ration des acc\xE9l\xE9rom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstAccelerometer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les acc\xE9l\xE9rom\xE8tres sont retourn\xE9s. Si vous souhaitez retrouver un acc\xE9l\xE9rom\xE8tre sp\xE9cifique, utilisez <tt>Accelerometer.findAccelerometer()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YAccelerometer</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Accelerometer']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'accelerometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Accelerometer']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'accelerometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Accelerometer']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'accelerometer.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_bandwidth']={syn:'Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'accelerometer.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement). Lorsque la fr\xE9quence est plus basse, un moyennage est effectu\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'accelerometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'accelerometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_logicalName']={syn:'Modifie le nom logique de l\x27acc\xE9l\xE9rom\xE8tre.',lib:'accelerometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27acc\xE9l\xE9rom\xE8tre. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27acc\xE9l\xE9rom\xE8tre.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Accelerometer']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'accelerometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'accelerometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'accelerometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Accelerometer']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'accelerometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Accelerometer']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'accelerometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Accelerometer']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'accelerometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Accelerometer']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'accelerometer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Interface de la fonction Magnetometer',inc:'from yocto_magnetometer import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Magnetometer']['FindMagnetometer']={syn:'Permet de retrouver un magn\xE9tom\xE8tre d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMagnetometer.FindMagnetometer()',pro:'def FindMagnetometer(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un magn\xE9tom\xE8tre d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le magn\xE9tom\xE8tre soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMagnetometer.isOnline()</tt> pour tester si le magn\xE9tom\xE8tre est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le magn\xE9tom\xE8tre sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMagnetometer</tt> qui permet ensuite de contr\xF4ler le magn\xE9tom\xE8tre.'};
doc['Magnetometer']['FirstMagnetometer']={syn:'Commence l\x27\xE9num\xE9ration des magn\xE9tom\xE8tres accessibles par la librairie.',lib:'YMagnetometer.FirstMagnetometer()',pro:'def FirstMagnetometer()',cmt:'<p>Commence l\x27\xE9num\xE9ration des magn\xE9tom\xE8tres accessibles par la librairie. Utiliser la fonction <tt>YMagnetometer.nextMagnetometer()</tt> pour it\xE9rer sur les autres magn\xE9tom\xE8tres.</p>',ret:'un pointeur sur un objet <tt>YMagnetometer</tt>, correspondant au premier magn\xE9tom\xE8tre accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de magn\xE9tom\xE8tres disponibles.'};
doc['Magnetometer']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'magnetometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Magnetometer']['clearCache']={syn:'Invalide le cache.',lib:'magnetometer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du magn\xE9tom\xE8tre. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Magnetometer']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du magn\xE9tom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'magnetometer.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du magn\xE9tom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le magn\xE9tom\xE8tre (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Magnetometer']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'magnetometer.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Magnetometer']['get_advertisedValue']={syn:'Retourne la valeur courante du magn\xE9tom\xE8tre (pas plus de 6 caract\xE8res).',lib:'magnetometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du magn\xE9tom\xE8tre (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du magn\xE9tom\xE8tre (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_bandwidth']={syn:'Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'magnetometer.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).</p>',ret:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Magnetometer']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mT, sous forme de nombre \xE0 virgule.',lib:'magnetometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mT, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mT, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_currentValue']={syn:'Retourne la valeur actuelle du champ magn\xE9tique, en mT, sous forme de nombre \xE0 virgule.',lib:'magnetometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du champ magn\xE9tique, en mT, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du champ magn\xE9tique, en mT, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'magnetometer.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Magnetometer']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du magn\xE9tom\xE8tre.',lib:'magnetometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du magn\xE9tom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du magn\xE9tom\xE8tre.'};
doc['Magnetometer']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du magn\xE9tom\xE8tre.',lib:'magnetometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du magn\xE9tom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du magn\xE9tom\xE8tre.'};
doc['Magnetometer']['get_friendlyName']={syn:'Retourne un identifiant global du magn\xE9tom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'magnetometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du magn\xE9tom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du magn\xE9tom\xE8tre si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du magn\xE9tom\xE8tre (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le magn\xE9tom\xE8tre en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Magnetometer']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'magnetometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Magnetometer']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du magn\xE9tom\xE8tre, sans r\xE9f\xE9rence au module.',lib:'magnetometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du magn\xE9tom\xE8tre, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le magn\xE9tom\xE8tre (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Magnetometer']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du magn\xE9tom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'magnetometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du magn\xE9tom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du magn\xE9tom\xE8tre (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le magn\xE9tom\xE8tre (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Magnetometer']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module.',lib:'magnetometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'magnetometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_logicalName']={syn:'Retourne le nom logique du magn\xE9tom\xE8tre.',lib:'magnetometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du magn\xE9tom\xE8tre.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du magn\xE9tom\xE8tre.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Magnetometer']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module.',lib:'magnetometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le champ magn\xE9tique depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'magnetometer.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Magnetometer']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'magnetometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'magnetometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'magnetometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Magnetometer']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'magnetometer.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Magnetometer']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le champ magn\xE9tique est exprim\xE9e.',lib:'magnetometer.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le champ magn\xE9tique est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le champ magn\xE9tique est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Magnetometer']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'magnetometer.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Magnetometer']['get_xValue']={syn:'Retourne la composante X du champ magn\xE9tique, sous forme de nombre \xE0 virgule.',lib:'magnetometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Retourne la composante X du champ magn\xE9tique, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante X du champ magn\xE9tique, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_XVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_yValue']={syn:'Retourne la composante Y du champ magn\xE9tique, sous forme de nombre \xE0 virgule.',lib:'magnetometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Retourne la composante Y du champ magn\xE9tique, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante Y du champ magn\xE9tique, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_YVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_zValue']={syn:'Retourne la composante Z du champ magn\xE9tique, sous forme de nombre \xE0 virgule.',lib:'magnetometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Retourne la composante Z du champ magn\xE9tique, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la composante Z du champ magn\xE9tique, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Magnetometer']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le magn\xE9tom\xE8tre est joignable, sans d\xE9clencher d\x27erreur.',lib:'magnetometer.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le magn\xE9tom\xE8tre est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du magn\xE9tom\xE8tre sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le magn\xE9tom\xE8tre est joignable, <tt>false</tt> sinon'};
doc['Magnetometer']['load']={syn:'Met en cache les valeurs courantes du magn\xE9tom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'magnetometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du magn\xE9tom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Magnetometer']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'magnetometer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'magnetometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Magnetometer']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'magnetometer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Magnetometer']['nextMagnetometer']={syn:'Continue l\x27\xE9num\xE9ration des magn\xE9tom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstMagnetometer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les magn\xE9tom\xE8tres sont retourn\xE9s.',lib:'magnetometer.nextMagnetometer()',pro:'def nextMagnetometer()',cmt:'<p>Continue l\x27\xE9num\xE9ration des magn\xE9tom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstMagnetometer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les magn\xE9tom\xE8tres sont retourn\xE9s. Si vous souhaitez retrouver un magn\xE9tom\xE8tre sp\xE9cifique, utilisez <tt>Magnetometer.findMagnetometer()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMagnetometer</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Magnetometer']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'magnetometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Magnetometer']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'magnetometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Magnetometer']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'magnetometer.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_bandwidth']={syn:'Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'magnetometer.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement). Lorsque la fr\xE9quence est plus basse, un moyennage est effectu\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'magnetometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'magnetometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_logicalName']={syn:'Modifie le nom logique du magn\xE9tom\xE8tre.',lib:'magnetometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du magn\xE9tom\xE8tre. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du magn\xE9tom\xE8tre.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Magnetometer']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'magnetometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'magnetometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'magnetometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Magnetometer']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'magnetometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Magnetometer']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'magnetometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Magnetometer']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'magnetometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Magnetometer']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'magnetometer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Magnetometer)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Configuration du r\xE9f\xE9rentiel',inc:'from yocto_refframe import *',cmt:'<p>Cette classe permet de configurer l\x27orientation dans laquelle le Yocto-3D est utilis\xE9, afin que les fonctions d\x27orientation relatives au plan de la surface terrestre utilisent le r\xE9f\xE9rentiel appropri\xE9. La classe offre aussi un processus de recalibration tridimensionnel des capteurs, permettant de compenser les variations locales de l\x27acc\xE9l\xE9ration terrestre et d\x27am\xE9liorer la pr\xE9cision des capteurs d\x27inclinaisons.</p>'}};
doc['RefFrame']['FindRefFrame']={syn:'Permet de retrouver un r\xE9f\xE9rentiel d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRefFrame.FindRefFrame()',pro:'def FindRefFrame(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un r\xE9f\xE9rentiel d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le r\xE9f\xE9rentiel soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRefFrame.isOnline()</tt> pour tester si le r\xE9f\xE9rentiel est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le r\xE9f\xE9rentiel sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRefFrame</tt> qui permet ensuite de contr\xF4ler le r\xE9f\xE9rentiel.'};
doc['RefFrame']['FirstRefFrame']={syn:'Commence l\x27\xE9num\xE9ration des r\xE9f\xE9rentiels accessibles par la librairie.',lib:'YRefFrame.FirstRefFrame()',pro:'def FirstRefFrame()',cmt:'<p>Commence l\x27\xE9num\xE9ration des r\xE9f\xE9rentiels accessibles par la librairie. Utiliser la fonction <tt>YRefFrame.nextRefFrame()</tt> pour it\xE9rer sur les autres r\xE9f\xE9rentiels.</p>',ret:'un pointeur sur un objet <tt>YRefFrame</tt>, correspondant au premier r\xE9f\xE9rentiel accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de r\xE9f\xE9rentiels disponibles.'};
doc['RefFrame']['cancel3DCalibration']={syn:'Annule la calibration tridimensionnelle en cours, et r\xE9tabli les r\xE9glages normaux.',lib:'refframe.cancel3DCalibration()',pro:'def cancel3DCalibration()',cmt:'<p>Annule la calibration tridimensionnelle en cours, et r\xE9tabli les r\xE9glages normaux.</p><p> En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.</p>'};
doc['RefFrame']['clearCache']={syn:'Invalide le cache.',lib:'refframe.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du r\xE9f\xE9rentiel. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['RefFrame']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du r\xE9f\xE9rentiel au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'refframe.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du r\xE9f\xE9rentiel au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le r\xE9f\xE9rentiel (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Retourne les instructions \xE0 suivre pour proc\xE9der \xE0 la calibration tridimensionnelle initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationHint()',pro:'def get_3DCalibrationHint()',cmt:'<p>Retourne les instructions \xE0 suivre pour proc\xE9der \xE0 la calibration tridimensionnelle initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.</p>',ret:'une cha\xEEne de caract\xE8res.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Retourne le dernier message de log produit par le processus de calibration.',lib:'refframe.get_3DCalibrationLogMsg()',pro:'def get_3DCalibrationLogMsg()',cmt:'<p>Retourne le dernier message de log produit par le processus de calibration. Si aucun nouveau message n\x27est disponible, retourne une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Retourne l\x27avancement global du processus de calibration tridimensionnelle initi\xE9 avec la m\xE9thode <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationProgress()',pro:'def get_3DCalibrationProgress()',cmt:'<p>Retourne l\x27avancement global du processus de calibration tridimensionnelle initi\xE9 avec la m\xE9thode <tt>start3DCalibration</tt>.</p>',ret:'une nombre entier entre 0 (pas commenc\xE9) et 100 (termin\xE9).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Retourne l\x27index de l\x27\xE9tape courante de la calibration initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStage()',pro:'def get_3DCalibrationStage()',cmt:'<p>Retourne l\x27index de l\x27\xE9tape courante de la calibration initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.</p>',ret:'une nombre entier, croissant au fur et \xE0 mesure de la compl\xE9tion des \xE9tapes.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Retourne l\x27avancement de l\x27\xE9tape courante de la calibration initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStageProgress()',pro:'def get_3DCalibrationStageProgress()',cmt:'<p>Retourne l\x27avancement de l\x27\xE9tape courante de la calibration initi\xE9e avec la m\xE9thode <tt>start3DCalibration</tt>.</p>',ret:'une nombre entier entre 0 (pas commenc\xE9) et 100 (termin\xE9).'};
doc['RefFrame']['get_advertisedValue']={syn:'Retourne la valeur courante du r\xE9f\xE9rentiel (pas plus de 6 caract\xE8res).',lib:'refframe.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du r\xE9f\xE9rentiel (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du r\xE9f\xE9rentiel (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RefFrame']['get_bearing']={syn:'Retourne le cap de r\xE9f\xE9rence utilis\xE9 par le compas.',lib:'refframe.get_bearing()',pro:'def get_bearing()',cmt:'<p>Retourne le cap de r\xE9f\xE9rence utilis\xE9 par le compas. Le cap relatif indiqu\xE9 par le compas est la diff\xE9rence entre le Nord magn\xE9tique mesur\xE9 et le cap de r\xE9f\xE9rence sp\xE9cifi\xE9 ici.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le cap de r\xE9f\xE9rence utilis\xE9 par le compas',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BEARING_INVALID</tt>.'};
doc['RefFrame']['get_calibrationState']={syn:'Retourne l\x27\xE9tat de calibration des capteurs 3D (Yocto-3D-V2 seulement).',lib:'refframe.get_calibrationState()',pro:'def get_calibrationState()',cmt:'<p>Retourne l\x27\xE9tat de calibration des capteurs 3D (Yocto-3D-V2 seulement). Cette fonction retourne un entier repr\xE9sentant l\x27\xE9tat de calibration des trois capteurs inertiels du chip BNO055, pr\xE9sent dans le Yocto-3D-V2. Les centaines indiquent l\x27\xE9tat de calibration de l\x27acc\xE9l\xE9rom\xE8tre, les dizaines indiquent l\x27\xE9tat de calibration du magn\xE9tom\xE8tre, et les unit\xE9s indiquent l\x27\xE9tat de calibration du gyroscope. Pour chaque capteur, la valeur 0 indique l\x27absence de calibration tandis que la valeur 3 indique une calibration compl\xE8te.</p>',ret:'un entier repr\xE9sentant l\x27\xE9tat de calibration du Yocto-3D-V2: 333 quand il est enti\xE8rement calibr\xE9, 0 lorsqu\x27il n\x27est pas calibr\xE9 du tout.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif. Pour le Yocto-3D (V1), la valeur retourn\xE9e est toujours -3 (fonction non support\xE9e).'};
doc['RefFrame']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9f\xE9rentiel.',lib:'refframe.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9f\xE9rentiel. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du r\xE9f\xE9rentiel.'};
doc['RefFrame']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9f\xE9rentiel.',lib:'refframe.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du r\xE9f\xE9rentiel. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du r\xE9f\xE9rentiel.'};
doc['RefFrame']['get_friendlyName']={syn:'Retourne un identifiant global du r\xE9f\xE9rentiel au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'refframe.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du r\xE9f\xE9rentiel au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du r\xE9f\xE9rentiel si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du r\xE9f\xE9rentiel (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9f\xE9rentiel en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RefFrame']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'refframe.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['RefFrame']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du r\xE9f\xE9rentiel, sans r\xE9f\xE9rence au module.',lib:'refframe.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du r\xE9f\xE9rentiel, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9f\xE9rentiel (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RefFrame']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du r\xE9f\xE9rentiel au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'refframe.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du r\xE9f\xE9rentiel au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du r\xE9f\xE9rentiel (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le r\xE9f\xE9rentiel (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RefFrame']['get_logicalName']={syn:'Retourne le nom logique du r\xE9f\xE9rentiel.',lib:'refframe.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du r\xE9f\xE9rentiel.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9f\xE9rentiel.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RefFrame']['get_measureQuality']={syn:'Retourne l\x27estimation de qualit\xE9 de la mesure d\x27orientation (Yocto-3D-V2 seulement).',lib:'refframe.get_measureQuality()',pro:'def get_measureQuality()',cmt:'<p>Retourne l\x27estimation de qualit\xE9 de la mesure d\x27orientation (Yocto-3D-V2 seulement). Cette fonction retourne un entier entre 0 et 3 repr\xE9sentant le degr\xE9 de confiance de l\x27estimation de position. Lorsque la valeur est 3, l\x27estimation est fiable. En dessous de 3, il faut s\x27attendre \xE0 des corrections d\x27orientations ult\xE9rieures, en particulier sur la boussole (fonction <tt>compass</tt>). Les causes les plus fr\xE9quentes pour une qualit\xE9 inf\xE9rieure \xE0 3 sont les interf\xE9rences magn\xE9tiques et les acc\xE9l\xE9rations our rotations en del\xE0 des capacit\xE9s du capteur.</p>',ret:'un entier entre 0 et 3 (3 quand la mesure est fiable)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif. Pour le Yocto-3D (V1), la valeur retourn\xE9e est toujours -3 (fonction non support\xE9e).'};
doc['RefFrame']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'refframe.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['RefFrame']['get_mountOrientation']={syn:'Retourne l\x27orientation \xE0 l\x27installation du module, telle que configur\xE9e afin de d\xE9finir le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres.',lib:'refframe.get_mountOrientation()',pro:'def get_mountOrientation()',cmt:'<p>Retourne l\x27orientation \xE0 l\x27installation du module, telle que configur\xE9e afin de d\xE9finir le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres.</p>',ret:'une valeur parmi l\x27\xE9num\xE9ration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) correspondant \xE0 la l\x27orientation de la fl\xE8che \x22X\x22 sur le module par rapport \xE0 un cadran d\x27horloge vu par un observateur au centre de la bo\xEEte. Sur la face BOTTOM le 12h pointe vers l\x27avant, tandis que sur la face TOP le 12h pointe vers l\x27arri\xE8re.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['get_mountPosition']={syn:'Retourne la position d\x27installation du module, telle que configur\xE9e afin de d\xE9finir le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres.',lib:'refframe.get_mountPosition()',pro:'def get_mountPosition()',cmt:'<p>Retourne la position d\x27installation du module, telle que configur\xE9e afin de d\xE9finir le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres.</p>',ret:'une valeur parmi l\x27\xE9num\xE9ration <tt>Y_MOUNTPOSITION</tt> (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), correspondant \xE0 l\x27installation dans une bo\xEEte, sur l\x27une des six faces',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'refframe.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['RefFrame']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le r\xE9f\xE9rentiel est joignable, sans d\xE9clencher d\x27erreur.',lib:'refframe.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le r\xE9f\xE9rentiel est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du r\xE9f\xE9rentiel sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le r\xE9f\xE9rentiel est joignable, <tt>false</tt> sinon'};
doc['RefFrame']['load']={syn:'Met en cache les valeurs courantes du r\xE9f\xE9rentiel, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'refframe.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du r\xE9f\xE9rentiel, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'refframe.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['RefFrame']['more3DCalibration']={syn:'Continue le processus de calibration tridimensionnelle des capteurs initi\xE9 avec la m\xE9thode <tt>start3DCalibration</tt>.',lib:'refframe.more3DCalibration()',pro:'def more3DCalibration()',cmt:'<p>Continue le processus de calibration tridimensionnelle des capteurs initi\xE9 avec la m\xE9thode <tt>start3DCalibration</tt>. Cette m\xE9thode doit \xEAtre appel\xE9e environ 5 fois par secondes apr\xE8s avoir positionn\xE9 le module selon les instructions fournies par la m\xE9thode <tt>get_3DCalibrationHint</tt> (les instructions changent pendant la proc\xE9dure de calibration).</p><p> En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.</p>'};
doc['RefFrame']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'refframe.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['nextRefFrame']={syn:'Continue l\x27\xE9num\xE9ration des r\xE9f\xE9rentiels commenc\xE9e \xE0 l\x27aide de <tt>yFirstRefFrame()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les r\xE9f\xE9rentiels sont retourn\xE9s.',lib:'refframe.nextRefFrame()',pro:'def nextRefFrame()',cmt:'<p>Continue l\x27\xE9num\xE9ration des r\xE9f\xE9rentiels commenc\xE9e \xE0 l\x27aide de <tt>yFirstRefFrame()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les r\xE9f\xE9rentiels sont retourn\xE9s. Si vous souhaitez retrouver un r\xE9f\xE9rentiel sp\xE9cifique, utilisez <tt>RefFrame.findRefFrame()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YRefFrame</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['RefFrame']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'refframe.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['RefFrame']['save3DCalibration']={syn:'Applique les param\xE8tres de calibration tridimensionnelle pr\xE9c\xE9demment calcul\xE9s.',lib:'refframe.save3DCalibration()',pro:'def save3DCalibration()',cmt:'<p>Applique les param\xE8tres de calibration tridimensionnelle pr\xE9c\xE9demment calcul\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9 apr\xE8s le red\xE9marrage du module.</p><p> En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.</p>'};
doc['RefFrame']['set_bearing']={syn:'Modifie le cap de r\xE9f\xE9rence utilis\xE9 par le compas.',lib:'refframe.set_bearing()',pro:'def set_bearing(<span id=pn>newval</span>)',cmt:'<p>Modifie le cap de r\xE9f\xE9rence utilis\xE9 par le compas. Le cap relatif indiqu\xE9 par le compas est la diff\xE9rence entre le Nord magn\xE9tique mesur\xE9 et le cap de r\xE9f\xE9rence sp\xE9cifi\xE9 ici.</p><p> Par exemple, si vous indiquez comme cap de r\xE9f\xE9rence la valeur de la d\xE9clinaison magn\xE9tique terrestre, le compas donnera l\x27orientation par rapport au Nord g\xE9ographique.</p><p> De m\xEAme, si le capteur n\x27est pas positionn\xE9 dans une des directions standard \xE0 cause d\x27un angle de lacet suppl\xE9mentaire, vous pouvez le configurer comme cap de r\xE9f\xE9rence afin que le compas donne la direction naturelle attendue.</p><p> N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le cap de r\xE9f\xE9rence utilis\xE9 par le compas'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RefFrame']['set_logicalName']={syn:'Modifie le nom logique du r\xE9f\xE9rentiel.',lib:'refframe.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du r\xE9f\xE9rentiel. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du r\xE9f\xE9rentiel.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['set_mountPosition']={syn:'Modifie le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres.',lib:'refframe.set_mountPosition()',pro:'def set_mountPosition(<span id=pn>position</span>, <span id=pn>orientation</span>)',cmt:'<p>Modifie le r\xE9f\xE9rentiel de la boussole et des inclinom\xE8tres. La boussole magn\xE9tique et les inclinom\xE8tres gravitationnels fonctionnent par rapport au plan parall\xE8le \xE0 la surface terrestre. Dans les cas o\xF9 le module n\x27est pas utilis\xE9 horizontalement et \xE0 l\x27endroit, il faut indiquer son orientation de r\xE9f\xE9rence (parall\xE8le \xE0 la surface terrestre) afin que les mesures soient faites relativement \xE0 cette position.</p>',par:{position:'une valeur parmi l\x27\xE9num\xE9ration <tt>Y_MOUNTPOSITION</tt> (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), correspondant \xE0 l\x27installation dans une bo\xEEte, sur l\x27une des six faces.',orientation:'une valeur parmi l\x27\xE9num\xE9ration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) correspondant \xE0 la l\x27orientation de la fl\xE8che \x22X\x22 sur le module par rapport \xE0 un cadran d\x27horloge vu par un observateur au centre de la bo\xEEte. Sur la face BOTTOM le 12h pointe vers l\x27avant, tandis que sur la face TOP le 12h pointe vers l\x27arri\xE8re.'},ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RefFrame']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'refframe.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['RefFrame']['start3DCalibration']={syn:'Initie le processus de calibration tridimensionnelle des capteurs.',lib:'refframe.start3DCalibration()',pro:'def start3DCalibration()',cmt:'<p>Initie le processus de calibration tridimensionnelle des capteurs. Cette calibration est utilis\xE9e \xE0 bas niveau pour l\x27estimation innertielle de position et pour am\xE9liorer la pr\xE9cision des mesures d\x27inclinaison.</p><p> Apr\xE8s avoir appel\xE9 cette m\xE9thode, il faut positionner le module selon les instructions fournies par la m\xE9thode <tt>get_3DCalibrationHint</tt> et appeler <tt>more3DCalibration</tt> environ 5 fois par secondes. La proc\xE9dure de calibration est termin\xE9e lorsque la m\xE9thode <tt>get_3DCalibrationProgress</tt> retourne 100. Il est alors possible d\x27appliquer les param\xE8tres calcul\xE9s, \xE0 l\x27aide de la m\xE9thode <tt>save3DCalibration</tt>. A tout moment, la calibration peut \xEAtre abandonn\xE9e \xE0 l\x27aide de <tt>cancel3DCalibration</tt>.</p><p> En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.</p>'};
doc['RefFrame']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'refframe.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: RefFrame)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Interface de la fonction Compass',inc:'from yocto_compass import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Compass']['FindCompass']={syn:'Permet de retrouver un compas d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCompass.FindCompass()',pro:'def FindCompass(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un compas d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le compas soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCompass.isOnline()</tt> pour tester si le compas est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le compas sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCompass</tt> qui permet ensuite de contr\xF4ler le compas.'};
doc['Compass']['FirstCompass']={syn:'Commence l\x27\xE9num\xE9ration des compas accessibles par la librairie.',lib:'YCompass.FirstCompass()',pro:'def FirstCompass()',cmt:'<p>Commence l\x27\xE9num\xE9ration des compas accessibles par la librairie. Utiliser la fonction <tt>YCompass.nextCompass()</tt> pour it\xE9rer sur les autres compas.</p>',ret:'un pointeur sur un objet <tt>YCompass</tt>, correspondant au premier compas accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de compas disponibles.'};
doc['Compass']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'compass.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Compass']['clearCache']={syn:'Invalide le cache.',lib:'compass.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du compas. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Compass']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du compas au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'compass.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du compas au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le compas (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Compass']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'compass.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Compass']['get_advertisedValue']={syn:'Retourne la valeur courante du compas (pas plus de 6 caract\xE8res).',lib:'compass.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du compas (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du compas (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Compass']['get_bandwidth']={syn:'Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'compass.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).</p>',ret:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Compass']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule.',lib:'compass.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Compass']['get_currentValue']={syn:'Retourne la valeur actuelle du cap relatif, en degr\xE9s, sous forme de nombre \xE0 virgule.',lib:'compass.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du cap relatif, en degr\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du cap relatif, en degr\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Compass']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'compass.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Compass']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du compas.',lib:'compass.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du compas. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du compas.'};
doc['Compass']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du compas.',lib:'compass.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du compas. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du compas.'};
doc['Compass']['get_friendlyName']={syn:'Retourne un identifiant global du compas au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'compass.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du compas au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du compas si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du compas (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le compas en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Compass']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'compass.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Compass']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du compas, sans r\xE9f\xE9rence au module.',lib:'compass.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du compas, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le compas (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Compass']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du compas au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'compass.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du compas au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du compas (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le compas (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Compass']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module.',lib:'compass.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Compass']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'compass.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_logicalName']={syn:'Retourne le nom logique du compas.',lib:'compass.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du compas.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du compas.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Compass']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module.',lib:'compass.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le cap relatif depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Compass']['get_magneticHeading']={syn:'Retourne la direction du nord magn\xE9tique, ind\xE9pendemment du cap configur\xE9.',lib:'compass.get_magneticHeading()',pro:'def get_magneticHeading()',cmt:'<p>Retourne la direction du nord magn\xE9tique, ind\xE9pendemment du cap configur\xE9.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la direction du nord magn\xE9tique, ind\xE9pendemment du cap configur\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAGNETICHEADING_INVALID</tt>.'};
doc['Compass']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'compass.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Compass']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'compass.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Compass']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'compass.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'compass.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Compass']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'compass.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Compass']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le cap relatif est exprim\xE9e.',lib:'compass.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le cap relatif est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le cap relatif est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Compass']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'compass.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Compass']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le compas est joignable, sans d\xE9clencher d\x27erreur.',lib:'compass.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le compas est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du compas sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le compas est joignable, <tt>false</tt> sinon'};
doc['Compass']['load']={syn:'Met en cache les valeurs courantes du compas, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'compass.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du compas, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Compass']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'compass.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Compass']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'compass.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Compass']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'compass.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Compass']['nextCompass']={syn:'Continue l\x27\xE9num\xE9ration des compas commenc\xE9e \xE0 l\x27aide de <tt>yFirstCompass()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les compas sont retourn\xE9s.',lib:'compass.nextCompass()',pro:'def nextCompass()',cmt:'<p>Continue l\x27\xE9num\xE9ration des compas commenc\xE9e \xE0 l\x27aide de <tt>yFirstCompass()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les compas sont retourn\xE9s. Si vous souhaitez retrouver un compas sp\xE9cifique, utilisez <tt>Compass.findCompass()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YCompass</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Compass']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'compass.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Compass']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'compass.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Compass']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'compass.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_bandwidth']={syn:'Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'compass.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement). Lorsque la fr\xE9quence est plus basse, un moyennage est effectu\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'compass.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'compass.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_logicalName']={syn:'Modifie le nom logique du compas.',lib:'compass.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du compas. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du compas.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Compass']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'compass.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'compass.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'compass.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Compass']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'compass.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Compass']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'compass.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Compass']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'compass.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Compass']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'compass.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Interface de la fonction Gyro',inc:'from yocto_gyro import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Gyro']['FindGyro']={syn:'Permet de retrouver un gyroscope d\x27apr\xE8s un identifiant donn\xE9.',lib:'YGyro.FindGyro()',pro:'def FindGyro(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un gyroscope d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le gyroscope soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YGyro.isOnline()</tt> pour tester si le gyroscope est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le gyroscope sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YGyro</tt> qui permet ensuite de contr\xF4ler le gyroscope.'};
doc['Gyro']['FirstGyro']={syn:'Commence l\x27\xE9num\xE9ration des gyroscopes accessibles par la librairie.',lib:'YGyro.FirstGyro()',pro:'def FirstGyro()',cmt:'<p>Commence l\x27\xE9num\xE9ration des gyroscopes accessibles par la librairie. Utiliser la fonction <tt>YGyro.nextGyro()</tt> pour it\xE9rer sur les autres gyroscopes.</p>',ret:'un pointeur sur un objet <tt>YGyro</tt>, correspondant au premier gyroscope accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de gyroscopes disponibles.'};
doc['Gyro']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'gyro.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gyro']['clearCache']={syn:'Invalide le cache.',lib:'gyro.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du gyroscope. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Gyro']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du gyroscope au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gyro.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du gyroscope au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le gyroscope (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gyro']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'gyro.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Gyro']['get_advertisedValue']={syn:'Retourne la valeur courante du gyroscope (pas plus de 6 caract\xE8res).',lib:'gyro.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du gyroscope (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du gyroscope (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gyro']['get_bandwidth']={syn:'Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'gyro.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).</p>',ret:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Gyro']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s par seconde, sous forme de nombre \xE0 virgule.',lib:'gyro.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s par seconde, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s par seconde, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Gyro']['get_currentValue']={syn:'Retourne la valeur actuelle de la vitesse angulaire, en degr\xE9s par seconde, sous forme de nombre \xE0 virgule.',lib:'gyro.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la vitesse angulaire, en degr\xE9s par seconde, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la vitesse angulaire, en degr\xE9s par seconde, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Gyro']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'gyro.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Gyro']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du gyroscope.',lib:'gyro.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du gyroscope. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du gyroscope.'};
doc['Gyro']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du gyroscope.',lib:'gyro.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du gyroscope. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du gyroscope.'};
doc['Gyro']['get_friendlyName']={syn:'Retourne un identifiant global du gyroscope au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'gyro.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du gyroscope au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du gyroscope si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du gyroscope (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le gyroscope en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gyro']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'gyro.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Gyro']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du gyroscope, sans r\xE9f\xE9rence au module.',lib:'gyro.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du gyroscope, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le gyroscope (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gyro']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du gyroscope au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'gyro.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du gyroscope au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du gyroscope (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le gyroscope (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gyro']['get_heading']={syn:'Retourne une estimation du cap (angle de lacet), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_heading()',pro:'def get_heading()',cmt:'<p>Retourne une estimation du cap (angle de lacet), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. L\x27axe de lacet peut \xEAtre attribu\xE9 \xE0 n\x27importe laquelle des direction physiques X, Y ou Z du module \xE0 l\x27aide des m\xE9thodes de la classe <tt>YRefFrame</tt>.</p>',ret:'un nombre \xE0 virgule correspondant au cap, exprim\xE9 en degr\xE9s (entre 0 et 360).'};
doc['Gyro']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module.',lib:'gyro.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'gyro.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_logicalName']={syn:'Retourne le nom logique du gyroscope.',lib:'gyro.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du gyroscope.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du gyroscope.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gyro']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module.',lib:'gyro.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la vitesse angulaire depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'gyro.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Gyro']['get_pitch']={syn:'Retourne une estimation de l\x27assiette (angle de tangage), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_pitch()',pro:'def get_pitch()',cmt:'<p>Retourne une estimation de l\x27assiette (angle de tangage), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. L\x27axe de tangage peut \xEAtre attribu\xE9 \xE0 n\x27importe laquelle des direction physiques X, Y ou Z du module \xE0 l\x27aide des m\xE9thodes de la classe <tt>YRefFrame</tt>.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 l\x27assiette, exprim\xE9e en degr\xE9s (entre -90 et +90).'};
doc['Gyro']['get_quaternionW']={syn:'Retourne la composante <tt>w</tt> (composante r\xE9elle) du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_quaternionW()',pro:'def get_quaternionW()',cmt:'<p>Retourne la composante <tt>w</tt> (composante r\xE9elle) du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 la composante <tt>w</tt> du quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Retourne la composante <tt>x</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_quaternionX()',pro:'def get_quaternionX()',cmt:'<p>Retourne la composante <tt>x</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. La composante <tt>x</tt> est essentiellement corr\xE9l\xE9e aux rotations sur l\x27axe de roulis.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 la composante <tt>x</tt> du quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Retourne la composante <tt>y</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_quaternionY()',pro:'def get_quaternionY()',cmt:'<p>Retourne la composante <tt>y</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. La composante <tt>y</tt> est essentiellement corr\xE9l\xE9e aux rotations sur l\x27axe de tangage.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 la composante <tt>y</tt> du quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Retourne la composante <tt>z</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_quaternionZ()',pro:'def get_quaternionZ()',cmt:'<p>Retourne la composante <tt>z</tt> du quaternion d\xE9crivant l\x27orientation estimat\xE9e du module, bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. La composante <tt>z</tt> est essentiellement corr\xE9l\xE9e aux rotations sur l\x27axe de lacet.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 la composante <tt>z</tt> du quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'gyro.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Gyro']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'gyro.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'gyro.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Gyro']['get_roll']={syn:'Retourne une estimation de l\x27inclinaison (angle de roulis), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique.',lib:'gyro.get_roll()',pro:'def get_roll()',cmt:'<p>Retourne une estimation de l\x27inclinaison (angle de roulis), bas\xE9e sur l\x27int\xE9gration de mesures gyroscopiques combin\xE9e \xE0 des mesures statiques d\x27acc\xE9l\xE9ration et de champ magn\xE9tique. L\x27axe de roulis peut \xEAtre attribu\xE9 \xE0 n\x27importe laquelle des direction physiques X, Y ou Z du module \xE0 l\x27aide des m\xE9thodes de la classe <tt>YRefFrame</tt>.</p>',ret:'un nombre \xE0 virgule correspondant \xE0 l\x27inclinaison, exprim\xE9e en degr\xE9s (entre -180 et +180).'};
doc['Gyro']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'gyro.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Gyro']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la vitesse angulaire est exprim\xE9e.',lib:'gyro.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la vitesse angulaire est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la vitesse angulaire est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Gyro']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'gyro.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Gyro']['get_xValue']={syn:'Retourne la vitesse angulaire autour de l\x27axe X du module, sous forme de nombre \xE0 virgule.',lib:'gyro.get_xValue()',pro:'def get_xValue()',cmt:'<p>Retourne la vitesse angulaire autour de l\x27axe X du module, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse angulaire autour de l\x27axe X du module, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_XVALUE_INVALID</tt>.'};
doc['Gyro']['get_yValue']={syn:'Retourne la vitesse angulaire autour de l\x27axe Y du module, sous forme de nombre \xE0 virgule.',lib:'gyro.get_yValue()',pro:'def get_yValue()',cmt:'<p>Retourne la vitesse angulaire autour de l\x27axe Y du module, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse angulaire autour de l\x27axe Y du module, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_YVALUE_INVALID</tt>.'};
doc['Gyro']['get_zValue']={syn:'Retourne la vitesse angulaire autour de l\x27axe Z du module, sous forme de nombre \xE0 virgule.',lib:'gyro.get_zValue()',pro:'def get_zValue()',cmt:'<p>Retourne la vitesse angulaire autour de l\x27axe Z du module, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse angulaire autour de l\x27axe Z du module, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Gyro']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le gyroscope est joignable, sans d\xE9clencher d\x27erreur.',lib:'gyro.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le gyroscope est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du gyroscope sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le gyroscope est joignable, <tt>false</tt> sinon'};
doc['Gyro']['load']={syn:'Met en cache les valeurs courantes du gyroscope, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'gyro.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du gyroscope, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gyro']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'gyro.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Gyro']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'gyro.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gyro']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'gyro.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gyro']['nextGyro']={syn:'Continue l\x27\xE9num\xE9ration des gyroscopes commenc\xE9e \xE0 l\x27aide de <tt>yFirstGyro()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les gyroscopes sont retourn\xE9s.',lib:'gyro.nextGyro()',pro:'def nextGyro()',cmt:'<p>Continue l\x27\xE9num\xE9ration des gyroscopes commenc\xE9e \xE0 l\x27aide de <tt>yFirstGyro()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les gyroscopes sont retourn\xE9s. Si vous souhaitez retrouver un gyroscope sp\xE9cifique, utilisez <tt>Gyro.findGyro()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YGyro</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Gyro']['registerAnglesCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement de l\x27estimation de l\x27orientation du module.',lib:'gyro.registerAnglesCallback()',pro:'def registerAnglesCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement de l\x27estimation de l\x27orientation du module. La fr\xE9quence d\x27appel est typiquement de 95Hz durant un mouvement. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand le callback peut se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que le callback ne soit pas appel\xE9s trop tard. Pour d\xE9sactiver le callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter quatre arguments: l\x27objet YGyro du module qui a tourn\xE9, et les valeurs des trois angles roll, pitch et heading en degr\xE9s (nombres \xE0 virgules).'}};
doc['Gyro']['registerQuaternionCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement de l\x27estimation de l\x27orientation du module.',lib:'gyro.registerQuaternionCallback()',pro:'def registerQuaternionCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque changement de l\x27estimation de l\x27orientation du module. La fr\xE9quence d\x27appel est typiquement de 95Hz durant un mouvement. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand le callback peut se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que le callback ne soit pas appel\xE9s trop tard. Pour d\xE9sactiver le callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter cinq arguments: l\x27objet YGyro du module qui a tourn\xE9, et les valeurs des quatre composantes w, x, y et z du quaternion (nombres \xE0 virgules).'}};
doc['Gyro']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'gyro.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Gyro']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'gyro.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Gyro']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'gyro.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_bandwidth']={syn:'Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'gyro.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement). Lorsque la fr\xE9quence est plus basse, un moyennage est effectu\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'gyro.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'gyro.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_logicalName']={syn:'Modifie le nom logique du gyroscope.',lib:'gyro.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du gyroscope. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du gyroscope.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gyro']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'gyro.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'gyro.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'gyro.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gyro']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'gyro.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Gyro']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'gyro.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Gyro']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'gyro.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Gyro']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'gyro.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Interface de la fonction Tilt',inc:'from yocto_tilt import *',cmt:'<p>La classe YSensor est la classe parente de tous les senseurs Yoctopuce. Elle permet de lire la valeur courante et l\x27unit\xE9 de n\x27importe quel capteur, de lire les valeurs min/max, de configurer la fr\xE9quence d\x27enregistrement autonome des donn\xE9es et de r\xE9cup\xE9rer les mesures enregistr\xE9es. Elle permet aussi d\x27enregistrer un callback appel\xE9 lorsque la valeur mesur\xE9e change ou \xE0 intervalle pr\xE9d\xE9fini. L\x27utilisation de cette classe plut\xF4t qu\x27une de ces sous-classes permet de cr\xE9er des application g\xE9n\xE9riques, compatibles m\xEAme avec les capteurs Yoctopuce futurs. Note: la classe YAnButton est le seul type d\x27entr\xE9e analogique qui n\x27h\xE9rite pas de YSensor.</p>'}};
doc['Tilt']['FindTilt']={syn:'Permet de retrouver un inclinom\xE8tre d\x27apr\xE8s un identifiant donn\xE9.',lib:'YTilt.FindTilt()',pro:'def FindTilt(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un inclinom\xE8tre d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27inclinom\xE8tre soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YTilt.isOnline()</tt> pour tester si l\x27inclinom\xE8tre est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27inclinom\xE8tre sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YTilt</tt> qui permet ensuite de contr\xF4ler l\x27inclinom\xE8tre.'};
doc['Tilt']['FirstTilt']={syn:'Commence l\x27\xE9num\xE9ration des inclinom\xE8tres accessibles par la librairie.',lib:'YTilt.FirstTilt()',pro:'def FirstTilt()',cmt:'<p>Commence l\x27\xE9num\xE9ration des inclinom\xE8tres accessibles par la librairie. Utiliser la fonction <tt>YTilt.nextTilt()</tt> pour it\xE9rer sur les autres inclinom\xE8tres.</p>',ret:'un pointeur sur un objet <tt>YTilt</tt>, correspondant au premier inclinom\xE8tre accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de inclinom\xE8tres disponibles.'};
doc['Tilt']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'tilt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tilt']['clearCache']={syn:'Invalide le cache.',lib:'tilt.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27inclinom\xE8tre. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Tilt']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27inclinom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tilt.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27inclinom\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27inclinom\xE8tre (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tilt']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'tilt.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Tilt']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27inclinom\xE8tre (pas plus de 6 caract\xE8res).',lib:'tilt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27inclinom\xE8tre (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27inclinom\xE8tre (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tilt']['get_bandwidth']={syn:'Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'tilt.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Retourne la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).</p>',ret:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Tilt']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule.',lib:'tilt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en degr\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tilt']['get_currentValue']={syn:'Retourne la valeur actuelle de l\x27inclinaison, en degr\xE9s, sous forme de nombre \xE0 virgule.',lib:'tilt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de l\x27inclinaison, en degr\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27inclinaison, en degr\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tilt']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'tilt.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Tilt']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27inclinom\xE8tre.',lib:'tilt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27inclinom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27inclinom\xE8tre.'};
doc['Tilt']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27inclinom\xE8tre.',lib:'tilt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27inclinom\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27inclinom\xE8tre.'};
doc['Tilt']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27inclinom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'tilt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27inclinom\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27inclinom\xE8tre si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27inclinom\xE8tre (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27inclinom\xE8tre en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tilt']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'tilt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Tilt']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27inclinom\xE8tre, sans r\xE9f\xE9rence au module.',lib:'tilt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27inclinom\xE8tre, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27inclinom\xE8tre (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tilt']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27inclinom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'tilt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27inclinom\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27inclinom\xE8tre (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27inclinom\xE8tre (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tilt']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module.',lib:'tilt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'tilt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_logicalName']={syn:'Retourne le nom logique de l\x27inclinom\xE8tre.',lib:'tilt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27inclinom\xE8tre.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27inclinom\xE8tre.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tilt']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module.',lib:'tilt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour l\x27inclinaison depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'tilt.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Tilt']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'tilt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Tilt']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'tilt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'tilt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tilt']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'tilt.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Tilt']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle l\x27inclinaison est exprim\xE9e.',lib:'tilt.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle l\x27inclinaison est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle l\x27inclinaison est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Tilt']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'tilt.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Tilt']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27inclinom\xE8tre est joignable, sans d\xE9clencher d\x27erreur.',lib:'tilt.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27inclinom\xE8tre est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27inclinom\xE8tre sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27inclinom\xE8tre est joignable, <tt>false</tt> sinon'};
doc['Tilt']['load']={syn:'Met en cache les valeurs courantes de l\x27inclinom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'tilt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27inclinom\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tilt']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'tilt.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Tilt']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'tilt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tilt']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'tilt.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tilt']['nextTilt']={syn:'Continue l\x27\xE9num\xE9ration des inclinom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstTilt()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les inclinom\xE8tres sont retourn\xE9s.',lib:'tilt.nextTilt()',pro:'def nextTilt()',cmt:'<p>Continue l\x27\xE9num\xE9ration des inclinom\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstTilt()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les inclinom\xE8tres sont retourn\xE9s. Si vous souhaitez retrouver un inclinom\xE8tre sp\xE9cifique, utilisez <tt>Tilt.findTilt()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YTilt</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Tilt']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'tilt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Tilt']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'tilt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Tilt']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'tilt.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_bandwidth']={syn:'Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement).',lib:'tilt.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement). Lorsque la fr\xE9quence est plus basse, un moyennage est effectu\xE9.</p>',par:{newval:'un entier repr&eacute;sentant la fr\xE9quence de rafra\xEEchissement de la mesure, en Hz (Yocto-3D-V2 seulement)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'tilt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'tilt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_logicalName']={syn:'Modifie le nom logique de l\x27inclinom\xE8tre.',lib:'tilt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27inclinom\xE8tre. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27inclinom\xE8tre.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tilt']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'tilt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'tilt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'tilt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tilt']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'tilt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Tilt']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'tilt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Tilt']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'tilt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Tilt']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'tilt.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Tilt)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Interface du quaternion',inc:'from yocto_gyro import *',cmt:'<p>La class YQt de la librairie Yoctopuce permet d\x27acc\xE9der \xE0 l\x27estimation de l\x27orientation tridimentionnelle du Yocto-3D sous forme d\x27un quaternion. Il n\x27est en g\xE9n\xE9ral pas n\xE9cessaire d\x27y acc\xE9der directement, la classe YGyro offrant une abstraction de plus haut niveau.</p>'}};
doc['Qt']['FindQt']={syn:'Permet de retrouver un \xE9l\xE9ment de quaternion d\x27apr\xE8s un identifiant donn\xE9.',lib:'YQt.FindQt()',pro:'def FindQt(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un \xE9l\xE9ment de quaternion d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27\xE9l\xE9ment de quaternion soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YQt.isOnline()</tt> pour tester si l\x27\xE9l\xE9ment de quaternion est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27\xE9l\xE9ment de quaternion sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YQt</tt> qui permet ensuite de contr\xF4ler l\x27\xE9l\xE9ment de quaternion.'};
doc['Qt']['FirstQt']={syn:'Commence l\x27\xE9num\xE9ration des \xE9l\xE9ments de quaternion accessibles par la librairie.',lib:'YQt.FirstQt()',pro:'def FirstQt()',cmt:'<p>Commence l\x27\xE9num\xE9ration des \xE9l\xE9ments de quaternion accessibles par la librairie. Utiliser la fonction <tt>YQt.nextQt()</tt> pour it\xE9rer sur les autres \xE9l\xE9ments de quaternion.</p>',ret:'un pointeur sur un objet <tt>YQt</tt>, correspondant au premier \xE9l\xE9ment de quaternion accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de \xE9l\xE9ments de quaternion disponibles.'};
doc['Qt']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'qt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Qt']['clearCache']={syn:'Invalide le cache.',lib:'qt.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27\xE9l\xE9ment de quaternion. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Qt']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27\xE9l\xE9ment de quaternion au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'qt.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27\xE9l\xE9ment de quaternion au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27\xE9l\xE9ment de quaternion (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Qt']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'qt.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Qt']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27\xE9l\xE9ment de quaternion (pas plus de 6 caract\xE8res).',lib:'qt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27\xE9l\xE9ment de quaternion (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27\xE9l\xE9ment de quaternion (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Qt']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en unit\xE9s, sous forme de nombre \xE0 virgule.',lib:'qt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en unit\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en unit\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Qt']['get_currentValue']={syn:'Retourne la valeur actuelle de la coordonn\xE9e, en unit\xE9s, sous forme de nombre \xE0 virgule.',lib:'qt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la coordonn\xE9e, en unit\xE9s, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la coordonn\xE9e, en unit\xE9s, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Qt']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'qt.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Qt']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion.',lib:'qt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion.'};
doc['Qt']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion.',lib:'qt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27\xE9l\xE9ment de quaternion.'};
doc['Qt']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27\xE9l\xE9ment de quaternion au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'qt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27\xE9l\xE9ment de quaternion au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27\xE9l\xE9ment de quaternion si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27\xE9l\xE9ment de quaternion (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27\xE9l\xE9ment de quaternion en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Qt']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'qt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Qt']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27\xE9l\xE9ment de quaternion, sans r\xE9f\xE9rence au module.',lib:'qt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27\xE9l\xE9ment de quaternion, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27\xE9l\xE9ment de quaternion (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Qt']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27\xE9l\xE9ment de quaternion au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'qt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27\xE9l\xE9ment de quaternion au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27\xE9l\xE9ment de quaternion (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27\xE9l\xE9ment de quaternion (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Qt']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module.',lib:'qt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Qt']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'qt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_logicalName']={syn:'Retourne le nom logique de l\x27\xE9l\xE9ment de quaternion.',lib:'qt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27\xE9l\xE9ment de quaternion.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27\xE9l\xE9ment de quaternion.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Qt']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module.',lib:'qt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la coordonn\xE9e depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Qt']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'qt.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Qt']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'qt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Qt']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'qt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'qt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Qt']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'qt.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Qt']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la coordonn\xE9e est exprim\xE9e.',lib:'qt.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la coordonn\xE9e est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la coordonn\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Qt']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'qt.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Qt']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27\xE9l\xE9ment de quaternion est joignable, sans d\xE9clencher d\x27erreur.',lib:'qt.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27\xE9l\xE9ment de quaternion est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27\xE9l\xE9ment de quaternion sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27\xE9l\xE9ment de quaternion est joignable, <tt>false</tt> sinon'};
doc['Qt']['load']={syn:'Met en cache les valeurs courantes de l\x27\xE9l\xE9ment de quaternion, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'qt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27\xE9l\xE9ment de quaternion, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Qt']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'qt.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Qt']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'qt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Qt']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'qt.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Qt']['nextQt']={syn:'Continue l\x27\xE9num\xE9ration des \xE9l\xE9ments de quaternion commenc\xE9e \xE0 l\x27aide de <tt>yFirstQt()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les \xE9l\xE9ments de quaternion sont retourn\xE9s.',lib:'qt.nextQt()',pro:'def nextQt()',cmt:'<p>Continue l\x27\xE9num\xE9ration des \xE9l\xE9ments de quaternion commenc\xE9e \xE0 l\x27aide de <tt>yFirstQt()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les \xE9l\xE9ments de quaternion sont retourn\xE9s. Si vous souhaitez retrouver un \xE9l\xE9ment de quaternion sp\xE9cifique, utilisez <tt>Qt.findQt()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YQt</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Qt']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'qt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Qt']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'qt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Qt']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'qt.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'qt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'qt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_logicalName']={syn:'Modifie le nom logique de l\x27\xE9l\xE9ment de quaternion.',lib:'qt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27\xE9l\xE9ment de quaternion. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27\xE9l\xE9ment de quaternion.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Qt']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'qt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'qt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'qt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Qt']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'qt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Qt']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'qt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Qt']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'qt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Qt']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'qt.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Qt)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'Interface de la fonction PwmOutput',inc:'from yocto_pwmoutput import *',cmt:'<p>La librairie de programmation Yoctopuce permet simplement de configurer, d\xE9marrer et arr\xEAter le PWM.</p>'}};
doc['PwmOutput']['FindPwmOutput']={syn:'Permet de retrouver un PWM d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPwmOutput.FindPwmOutput()',pro:'def FindPwmOutput(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un PWM d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le PWM soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPwmOutput.isOnline()</tt> pour tester si le PWM est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le PWM sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPwmOutput</tt> qui permet ensuite de contr\xF4ler le PWM.'};
doc['PwmOutput']['FirstPwmOutput']={syn:'Commence l\x27\xE9num\xE9ration des PWM accessibles par la librairie.',lib:'YPwmOutput.FirstPwmOutput()',pro:'def FirstPwmOutput()',cmt:'<p>Commence l\x27\xE9num\xE9ration des PWM accessibles par la librairie. Utiliser la fonction <tt>YPwmOutput.nextPwmOutput()</tt> pour it\xE9rer sur les autres PWM.</p>',ret:'un pointeur sur un objet <tt>YPwmOutput</tt>, correspondant au premier PWM accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de PWM disponibles.'};
doc['PwmOutput']['clearCache']={syn:'Invalide le cache.',lib:'pwmoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du PWM. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['PwmOutput']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du PWM au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmoutput.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du PWM au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le PWM (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmOutput']['dutyCycleMove']={syn:'D\xE9clenche une variation progressive de la longueur des impulsions vers une valeur donn\xE9e.',lib:'pwmoutput.dutyCycleMove()',pro:'def dutyCycleMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une variation progressive de la longueur des impulsions vers une valeur donn\xE9e. N\x27importe quel changement de fr\xE9quence, rapport cyclique, p\xE9riode ou encore de longueur d\x27impulsion annulera tout processus de transition en cours.</p>',par:{target:'nouveau rapport cyclique \xE0 la fin de la transition (pourcentage, nombre r\xE9el entre 0 et 100)',ms_duration:'dur\xE9e totale de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['frequencyMove']={syn:'D\xE9clenche une variation progressive de fr\xE9quence des impulsions vers une valeur donn\xE9e.',lib:'pwmoutput.frequencyMove()',pro:'def frequencyMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une variation progressive de fr\xE9quence des impulsions vers une valeur donn\xE9e. N\x27importe quel changement de fr\xE9quence, rapport cyclique, p\xE9riode ou encore de longueur d\x27impulsion annulera tout processus de transition en cours.</p>',par:{target:'nouvelle fr\xE9quence \xE0 la fin de la transition (nombre r\xE9el)',ms_duration:'dur\xE9e totale de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['get_advertisedValue']={syn:'Retourne la valeur courante du PWM (pas plus de 6 caract\xE8res).',lib:'pwmoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du PWM (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du PWM (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycle']={syn:'Retourne le rapport cyclique du PWM, en pour cents.',lib:'pwmoutput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Retourne le rapport cyclique du PWM, en pour cents.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le rapport cyclique du PWM, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycleAtPowerOn']={syn:'Retourne le rapport cyclique du PWM au d\xE9marrage du module, sous la forme d\x27un nombre \xE0 virgule entre 0 et 100.',lib:'pwmoutput.get_dutyCycleAtPowerOn()',pro:'def get_dutyCycleAtPowerOn()',cmt:'<p>Retourne le rapport cyclique du PWM au d\xE9marrage du module, sous la forme d\x27un nombre \xE0 virgule entre 0 et 100.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le rapport cyclique du PWM au d\xE9marrage du module, sous la forme d\x27un nombre \xE0 virgule entre 0 et 100',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DUTYCYCLEATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_enabled']={syn:'Retourne l\x27\xE9tat de fonctionnement du PWM.',lib:'pwmoutput.get_enabled()',pro:'def get_enabled()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement du PWM.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon l\x27\xE9tat de fonctionnement du PWM',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Retourne l\x27\xE9tat de fonctionnement du PWM \xE0 la mise sous tension du module.',lib:'pwmoutput.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement du PWM \xE0 la mise sous tension du module.</p>',ret:'soit <tt>Y_ENABLEDATPOWERON_FALSE</tt>, soit <tt>Y_ENABLEDATPOWERON_TRUE</tt>, selon l\x27\xE9tat de fonctionnement du PWM \xE0 la mise sous tension du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du PWM.',lib:'pwmoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du PWM. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du PWM.'};
doc['PwmOutput']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du PWM.',lib:'pwmoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du PWM. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du PWM.'};
doc['PwmOutput']['get_frequency']={syn:'Retourne la fr\xE9quence du PWM en Hz.',lib:'pwmoutput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Retourne la fr\xE9quence du PWM en Hz.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du PWM en Hz',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmOutput']['get_friendlyName']={syn:'Retourne un identifiant global du PWM au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'pwmoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du PWM au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du PWM si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du PWM (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le PWM en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmOutput']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pwmoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['PwmOutput']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du PWM, sans r\xE9f\xE9rence au module.',lib:'pwmoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du PWM, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le PWM (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmOutput']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du PWM au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du PWM au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du PWM (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le PWM (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmOutput']['get_logicalName']={syn:'Retourne le nom logique du PWM.',lib:'pwmoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du PWM.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du PWM.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmOutput']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pwmoutput.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['PwmOutput']['get_period']={syn:'Retourne la p\xE9riode du PWM en millisecondes.',lib:'pwmoutput.get_period()',pro:'def get_period()',cmt:'<p>Retourne la p\xE9riode du PWM en millisecondes.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la p\xE9riode du PWM en millisecondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmOutput']['get_pulseDuration']={syn:'Retourne la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule.',lib:'pwmoutput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Retourne la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmOutput']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pwmoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['PwmOutput']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le PWM est joignable, sans d\xE9clencher d\x27erreur.',lib:'pwmoutput.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le PWM est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du PWM sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le PWM est joignable, <tt>false</tt> sinon'};
doc['PwmOutput']['load']={syn:'Met en cache les valeurs courantes du PWM, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pwmoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du PWM, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'pwmoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['PwmOutput']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwmoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['nextPwmOutput']={syn:'Continue l\x27\xE9num\xE9ration des PWM commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les PWM sont retourn\xE9s.',lib:'pwmoutput.nextPwmOutput()',pro:'def nextPwmOutput()',cmt:'<p>Continue l\x27\xE9num\xE9ration des PWM commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les PWM sont retourn\xE9s. Si vous souhaitez retrouver un PWM sp\xE9cifique, utilisez <tt>PwmOutput.findPwmOutput()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPwmOutput</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['PwmOutput']['phaseMove']={syn:'D\xE9clenche un d\xE9calage progressif du d\xE9phasage du signal par rapport \xE0 l\x27autre sortie, sur une dur\xE9e sp\xE9cifi\xE9e, par adaptation temporaire de la fr\xE9quence.',lib:'pwmoutput.phaseMove()',pro:'def phaseMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche un d\xE9calage progressif du d\xE9phasage du signal par rapport \xE0 l\x27autre sortie, sur une dur\xE9e sp\xE9cifi\xE9e, par adaptation temporaire de la fr\xE9quence. L\x27utilisation de cette fonction n\x27a de sens que lorsque les deux canaux sont actifs, et que la fr\xE9quence de l\x27autre canal est soit identique, soit un multiple de la fr\xE9quence de ce canal. N\x27importe quel changement de fr\xE9quence, rapport cyclique, p\xE9riode ou encore de longueur d\x27impulsion annulera tout processus de transition en cours.</p>',par:{target:'d\xE9calage de phase d\xE9sir\xE9 \xE0 la fin de la transition, en millisecondes (nombre r\xE9el)',ms_duration:'dur\xE9e totale de la transition, en millisecondes (nombre entier)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['pulseDurationMove']={syn:'D\xE9clenche une transition progressive de la longueur des impulsions vers une valeur donn\xE9e.',lib:'pwmoutput.pulseDurationMove()',pro:'def pulseDurationMove(<span id=pn>ms_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une transition progressive de la longueur des impulsions vers une valeur donn\xE9e. N\x27importe quel changement de fr\xE9quence, rapport cyclique, p\xE9riode ou encore de longueur d\x27impulsion annulera tout processus de transition en cours.</p>',par:{ms_target:'nouvelle longueur des impulsions \xE0 la fin de la transition (nombre flottant repr\xE9sentant la longueur en millisecondes)',ms_duration:'dur\xE9e totale de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pwmoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PwmOutput']['set_dutyCycle']={syn:'Modifie le drapport cyclique du PWM, en pour cents.',lib:'pwmoutput.set_dutyCycle()',pro:'def set_dutyCycle(<span id=pn>newval</span>)',cmt:'<p>Modifie le drapport cyclique du PWM, en pour cents.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le drapport cyclique du PWM, en pour cents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Modifie le rapport cyclique du PWM au d\xE9marrage du module.',lib:'pwmoutput.set_dutyCycleAtPowerOn()',pro:'def set_dutyCycleAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Modifie le rapport cyclique du PWM au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le rapport cyclique du PWM au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_enabled']={syn:'D\xE9marre ou arr\xEAte le PWM.',lib:'pwmoutput.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>D\xE9marre ou arr\xEAte le PWM.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Modifie l\x27\xE9tat du fonctionnement du PWM \xE0 la mise sous tension du module.',lib:'pwmoutput.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du fonctionnement du PWM \xE0 la mise sous tension du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'soit <tt>Y_ENABLEDATPOWERON_FALSE</tt>, soit <tt>Y_ENABLEDATPOWERON_TRUE</tt>, selon l\x27\xE9tat du fonctionnement du PWM \xE0 la mise sous tension du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_frequency']={syn:'Modifie la fr\xE9quence du PWM.',lib:'pwmoutput.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence du PWM. Le rapport cyclique est conserv\xE9 gr\xE2ce \xE0 un changement automatique de la longueur des impulsions, autrement dit le changement ne sera pas effectu\xE9 avant la fin de la p\xE9riode en cours. Cela peut peut avoir un effect significatif sur le temps de r\xE9action dans les basses fr\xE9quences. Pour arr\xEAter le signal PWM ne mettez pas la fr\xE9quence \xE0 z\xE9ro, utilisez la m\xE9thode set_enabled().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du PWM'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_logicalName']={syn:'Modifie le nom logique du PWM.',lib:'pwmoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du PWM. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du PWM.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['set_period']={syn:'Modifie la p\xE9riode du PWM en millisecondes.',lib:'pwmoutput.set_period()',pro:'def set_period(<span id=pn>newval</span>)',cmt:'<p>Modifie la p\xE9riode du PWM en millisecondes. Attention, pour \xE9viter de tronquer al\xE9atoirement l\x27impulsion en court, le changement ne sera pas effectu\xE9 avant la fin de la p\xE9riode en cours. Cela peut peut avoir un effect significatif sur le temps de r\xE9action dans les basses fr\xE9quences.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la p\xE9riode du PWM en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_pulseDuration']={syn:'Modifie la longueur des impulsions du PWM, en millisecondes.',lib:'pwmoutput.set_pulseDuration()',pro:'def set_pulseDuration(<span id=pn>newval</span>)',cmt:'<p>Modifie la longueur des impulsions du PWM, en millisecondes. Attention, la longueur d\x27une impulsion ne peut pas \xEAtre plus grande que la p\xE9riode, sinon la longueur sera automatiquement tronqu\xE9e \xE0 la p\xE9riode.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la longueur des impulsions du PWM, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmOutput']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pwmoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['PwmOutput']['triggerPulsesByDuration']={syn:'D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion de longueur choisie, \xE0 la fr\xE9quence courante.',lib:'pwmoutput.triggerPulsesByDuration()',pro:'def triggerPulsesByDuration(<span id=pn>ms_target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion de longueur choisie, \xE0 la fr\xE9quence courante. Une fois toutes les impulsions g\xE9n\xE9r\xE9es, r\xE9tablit l\x27\xE9tat original du g\xE9n\xE9rateur PWM.</p>',par:{ms_target:'longueur des impulsions souhait\xE9es (nombre r\xE9el repr\xE9sentant la longueur en millisecondes)',n_pulses:'nombre d\x27impulsions \xE0 g\xE9n\xE9rer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['triggerPulsesByDutyCycle']={syn:'D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion de longueur choisie, \xE0 la fr\xE9quence courante.',lib:'pwmoutput.triggerPulsesByDutyCycle()',pro:'def triggerPulsesByDutyCycle(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion de longueur choisie, \xE0 la fr\xE9quence courante. Une fois toutes les impulsions g\xE9n\xE9r\xE9es, r\xE9tablit l\x27\xE9tat original du g\xE9n\xE9rateur PWM.</p>',par:{target:'rapport cyclique des impulsions souhait\xE9es (pourcentage, nombre r\xE9el entre 0 et 100)',n_pulses:'nombre d\x27impulsions \xE0 g\xE9n\xE9rer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['triggerPulsesByFrequency']={syn:'D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion \xE0 une fr\xE9quence choisie, avec le rapport cyclique courant.',lib:'pwmoutput.triggerPulsesByFrequency()',pro:'def triggerPulsesByFrequency(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>D\xE9clenche le nombre sp\xE9cifi\xE9 d\x27impulsion \xE0 une fr\xE9quence choisie, avec le rapport cyclique courant. Une fois toutes les impulsions g\xE9n\xE9r\xE9es, r\xE9tablit l\x27\xE9tat original du g\xE9n\xE9rateur PWM.</p>',par:{target:'fr\xE9quence des impulsions souhait\xE9es (nombre r\xE9el)',n_pulses:'nombre d\x27impulsions \xE0 g\xE9n\xE9rer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmOutput']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwmoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'Interface de la fonction PwmPowerSource',inc:'from yocto_pwmpowersource import *',cmt:'<p>La librairie de programmation Yoctopuce permet de configurer la source de tension utilis\xE9e par tous les PWM situ\xE9s sur un m\xEAme module.</p>'}};
doc['PwmPowerSource']['FindPwmPowerSource']={syn:'Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPwmPowerSource.FindPwmPowerSource()',pro:'def FindPwmPowerSource(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la source de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPwmPowerSource.isOnline()</tt> pour tester si la source de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la source de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPwmPowerSource</tt> qui permet ensuite de contr\xF4ler la source de tension.'};
doc['PwmPowerSource']['FirstPwmPowerSource']={syn:'Commence l\x27\xE9num\xE9ration des Source de tension accessibles par la librairie.',lib:'YPwmPowerSource.FirstPwmPowerSource()',pro:'def FirstPwmPowerSource()',cmt:'<p>Commence l\x27\xE9num\xE9ration des Source de tension accessibles par la librairie. Utiliser la fonction <tt>YPwmPowerSource.nextPwmPowerSource()</tt> pour it\xE9rer sur les autres Source de tension.</p>',ret:'un pointeur sur un objet <tt>YPwmPowerSource</tt>, correspondant \xE0 la premi\xE8re source de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de Source de tension disponibles.'};
doc['PwmPowerSource']['clearCache']={syn:'Invalide le cache.',lib:'pwmpowersource.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la source de tension. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['PwmPowerSource']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la source de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmpowersource.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la source de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la source de tension (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).',lib:'pwmpowersource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la source de tension (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmPowerSource']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la source de tension.',lib:'pwmpowersource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la source de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la source de tension.'};
doc['PwmPowerSource']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la source de tension.',lib:'pwmpowersource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la source de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la source de tension.'};
doc['PwmPowerSource']['get_friendlyName']={syn:'Retourne un identifiant global de la source de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'pwmpowersource.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la source de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la source de tension si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la source de tension (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la source de tension en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pwmpowersource.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['PwmPowerSource']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la source de tension, sans r\xE9f\xE9rence au module.',lib:'pwmpowersource.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la source de tension, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la source de tension (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmPowerSource']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la source de tension au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmpowersource.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la source de tension au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la source de tension (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la source de tension (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmPowerSource']['get_logicalName']={syn:'Retourne le nom logique de la source de tension.',lib:'pwmpowersource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la source de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pwmpowersource.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['PwmPowerSource']['get_powerMode']={syn:'Retourne la source de tension utilis\xE9 par tous les PWM du m\xEAme module.',lib:'pwmpowersource.get_powerMode()',pro:'def get_powerMode()',cmt:'<p>Retourne la source de tension utilis\xE9 par tous les PWM du m\xEAme module.</p>',ret:'une valeur parmi <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> et <tt>Y_POWERMODE_OPNDRN</tt> repr&eacute;sentant la source de tension utilis\xE9 par tous les PWM du m\xEAme module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWERMODE_INVALID</tt>.'};
doc['PwmPowerSource']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pwmpowersource.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['PwmPowerSource']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la source de tension est joignable, sans d\xE9clencher d\x27erreur.',lib:'pwmpowersource.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la source de tension est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la source de tension sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la source de tension est joignable, <tt>false</tt> sinon'};
doc['PwmPowerSource']['load']={syn:'Met en cache les valeurs courantes de la source de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pwmpowersource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la source de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmPowerSource']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'pwmpowersource.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['PwmPowerSource']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwmpowersource.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmPowerSource']['nextPwmPowerSource']={syn:'Continue l\x27\xE9num\xE9ration des Source de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmPowerSource()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Source de tension sont retourn\xE9s.',lib:'pwmpowersource.nextPwmPowerSource()',pro:'def nextPwmPowerSource()',cmt:'<p>Continue l\x27\xE9num\xE9ration des Source de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmPowerSource()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Source de tension sont retourn\xE9s. Si vous souhaitez retrouver une source de tension sp\xE9cifique, utilisez <tt>PwmPowerSource.findPwmPowerSource()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPwmPowerSource</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['PwmPowerSource']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pwmpowersource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PwmPowerSource']['set_logicalName']={syn:'Modifie le nom logique de la source de tension.',lib:'pwmpowersource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la source de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmPowerSource']['set_powerMode']={syn:'Modifie le mode fonctionnement des PWM qui peut sortir du 5 volts isol\xE9 issu de l\x27USB, du 3V isol\xE9 issu de l\x27USB, une tension arbitraire issue de l\x27alimentation externe.',lib:'pwmpowersource.set_powerMode()',pro:'def set_powerMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode fonctionnement des PWM qui peut sortir du 5 volts isol\xE9 issu de l\x27USB, du 3V isol\xE9 issu de l\x27USB, une tension arbitraire issue de l\x27alimentation externe. Le PWM peut aussi en mode open drain, dans ce code il tire activement la ligne \xE0 z\xE9ro volts. Attention ce param\xE8tre est commun \xE0 tous les PWM du module, si vous changez le valeur de ce param\xE8tre, tous les PWM situ\xE9s sur le m\xEAme module seront affect\xE9s. Si vous souhaitez que le changement de ce param\xE8tre soit conserv\xE9 apr\xE8s un red\xE9marrage du module, n\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt>.</p>',par:{newval:'une valeur parmi <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> et <tt>Y_POWERMODE_OPNDRN</tt> repr&eacute;sentant le mode fonctionnement des PWM qui peut sortir du 5 volts isol\xE9 issu de l\x27USB, du 3V isol\xE9 issu de l\x27USB, une tension arbitraire issue de l\x27alimentation externe'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmPowerSource']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pwmpowersource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['PwmPowerSource']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwmpowersource.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Interface de la fonction Altitude',inc:'from yocto_altitude import *',cmt:'<p>La classe YAltitude permet de lire et de configurer les capteurs d\x27altitude Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, pour les capteurs barom\xE9triques, elle permet de faire la configuration de la pression de r\xE9f\xE9rence au niveau de la mer (QNH).</p>'}};
doc['Altitude']['FindAltitude']={syn:'Permet de retrouver un altimetre d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAltitude.FindAltitude()',pro:'def FindAltitude(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un altimetre d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27altim\xE8tre soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAltitude.isOnline()</tt> pour tester si l\x27altim\xE8tre est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27altim\xE8tre sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAltitude</tt> qui permet ensuite de contr\xF4ler l\x27altim\xE8tre.'};
doc['Altitude']['FirstAltitude']={syn:'Commence l\x27\xE9num\xE9ration des altim\xE8tres accessibles par la librairie.',lib:'YAltitude.FirstAltitude()',pro:'def FirstAltitude()',cmt:'<p>Commence l\x27\xE9num\xE9ration des altim\xE8tres accessibles par la librairie. Utiliser la fonction <tt>YAltitude.nextAltitude()</tt> pour it\xE9rer sur les autres altim\xE8tres.</p>',ret:'un pointeur sur un objet <tt>YAltitude</tt>, correspondant au premier altim\xE8tre accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de altim\xE8tres disponibles.'};
doc['Altitude']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'altitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Altitude']['clearCache']={syn:'Invalide le cache.',lib:'altitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27altim\xE8tre. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Altitude']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27altim\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'altitude.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27altim\xE8tre au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27altim\xE8tre (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Altitude']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'altitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Altitude']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27altim\xE8tre (pas plus de 6 caract\xE8res).',lib:'altitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27altim\xE8tre (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27altim\xE8tre (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en m\xE8tres, sous forme de nombre \xE0 virgule.',lib:'altitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en m\xE8tres, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en m\xE8tres, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentValue']={syn:'Retourne la valeur actuelle de l\x27altitude, en m\xE8tres, sous forme de nombre \xE0 virgule.',lib:'altitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de l\x27altitude, en m\xE8tres, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de l\x27altitude, en m\xE8tres, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Altitude']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'altitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Altitude']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27altim\xE8tre.',lib:'altitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27altim\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27altim\xE8tre.'};
doc['Altitude']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27altim\xE8tre.',lib:'altitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27altim\xE8tre. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27altim\xE8tre.'};
doc['Altitude']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27altim\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'altitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27altim\xE8tre au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27altim\xE8tre si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27altim\xE8tre (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27altim\xE8tre en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Altitude']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'altitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Altitude']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27altim\xE8tre, sans r\xE9f\xE9rence au module.',lib:'altitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27altim\xE8tre, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27altim\xE8tre (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Altitude']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27altim\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'altitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27altim\xE8tre au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27altim\xE8tre (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27altim\xE8tre (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Altitude']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module.',lib:'altitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'altitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_logicalName']={syn:'Retourne le nom logique de l\x27altim\xE8tre.',lib:'altitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27altim\xE8tre.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27altim\xE8tre.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Altitude']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module.',lib:'altitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour l\x27altitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'altitude.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Altitude']['get_qnh']={syn:'Retourne la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH).',lib:'altitude.get_qnh()',pro:'def get_qnh()',cmt:'<p>Retourne la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH). Ne s\x27applique qu\x27aux altim\xE8tres barom\xE9triques.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_QNH_INVALID</tt>.'};
doc['Altitude']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'altitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Altitude']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'altitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'altitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Altitude']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'altitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Altitude']['get_technology']={syn:'Renvoie la technologie employ\xE9e par la fonction pour calculer l\x27altitude.',lib:'altitude.get_technology()',pro:'def get_technology()',cmt:'<p>Renvoie la technologie employ\xE9e par la fonction pour calculer l\x27altitude. les valeur possible sont \x22barometric\x22 et \x22gps\x22</p>',ret:'une cha&icirc;ne de caract&egrave;res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TECHNOLOGY_INVALID</tt>.'};
doc['Altitude']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle l\x27altitude est exprim\xE9e.',lib:'altitude.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle l\x27altitude est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle l\x27altitude est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Altitude']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'altitude.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Altitude']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27altim\xE8tre est joignable, sans d\xE9clencher d\x27erreur.',lib:'altitude.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27altim\xE8tre est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27altim\xE8tre sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27altim\xE8tre est joignable, <tt>false</tt> sinon'};
doc['Altitude']['load']={syn:'Met en cache les valeurs courantes de l\x27altim\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'altitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27altim\xE8tre, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Altitude']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'altitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Altitude']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'altitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Altitude']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'altitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Altitude']['nextAltitude']={syn:'Continue l\x27\xE9num\xE9ration des altim\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstAltitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les altim\xE8tres sont retourn\xE9s.',lib:'altitude.nextAltitude()',pro:'def nextAltitude()',cmt:'<p>Continue l\x27\xE9num\xE9ration des altim\xE8tres commenc\xE9e \xE0 l\x27aide de <tt>yFirstAltitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les altim\xE8tres sont retourn\xE9s. Si vous souhaitez retrouver un altimetre sp\xE9cifique, utilisez <tt>Altitude.findAltitude()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YAltitude</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Altitude']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'altitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Altitude']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'altitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Altitude']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'altitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_currentValue']={syn:'Modifie l\x27altitude actuelle suppos\xE9e.',lib:'altitude.set_currentValue()',pro:'def set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27altitude actuelle suppos\xE9e. Ceci permet de compenser les changements de pression ou de travailler en mode relatif.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant l\x27altitude actuelle suppos\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'altitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'altitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_logicalName']={syn:'Modifie le nom logique de l\x27altim\xE8tre.',lib:'altitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27altim\xE8tre. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27altim\xE8tre.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Altitude']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'altitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_qnh']={syn:'Modifie la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH).',lib:'altitude.set_qnh()',pro:'def set_qnh(<span id=pn>newval</span>)',cmt:'<p>Modifie la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH). Ceci permet de compenser les changements de pression atmosph\xE9rique dus au climat. Ne s\x27applique qu\x27aux altim\xE8tres barom\xE9triques.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la pression de r\xE9f\xE9rence au niveau de la mer utilis\xE9e pour le calcul de l\x27altitude (QNH)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'altitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'altitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Altitude']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'altitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Altitude']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'altitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Altitude']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'altitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Altitude']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'altitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Altitude)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Interface de la fonction Motor',inc:'from yocto_motor import *',cmt:'<p>La librairie de programmation yoctopuce permet de piloter la puissance envoy\xE9e au moteur pour le faire tourner aussi bien dans un sens que dans l\x27autre, mais aussi de piloter des acc\xE9l\xE9rations lin\xE9aires: le moteur acc\xE9l\xE9re alors tout seul sans que vous vous ayez \xE0 vous en occuper. La librairie permet aussi de freiner le moteur: cela est r\xE9alis\xE9 en court-circuitant les p\xF4les du moteur, ce qui le transforme en frein \xE9lectro-magn\xE9tique.</p>'}};
doc['Motor']['FindMotor']={syn:'Permet de retrouver un moteur d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMotor.FindMotor()',pro:'def FindMotor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un moteur d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le moteur soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMotor.isOnline()</tt> pour tester si le moteur est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le moteur sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMotor</tt> qui permet ensuite de contr\xF4ler le moteur.'};
doc['Motor']['FirstMotor']={syn:'Commence l\x27\xE9num\xE9ration des moteur accessibles par la librairie.',lib:'YMotor.FirstMotor()',pro:'def FirstMotor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des moteur accessibles par la librairie. Utiliser la fonction <tt>YMotor.nextMotor()</tt> pour it\xE9rer sur les autres moteur.</p>',ret:'un pointeur sur un objet <tt>YMotor</tt>, correspondant au premier moteur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de moteur disponibles.'};
doc['Motor']['brakingForceMove']={syn:'Modifie progressivement la force de freinage appliqu\xE9e au moteur sur une dur\xE9e donn\xE9e.',lib:'motor.brakingForceMove()',pro:'def brakingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Modifie progressivement la force de freinage appliqu\xE9e au moteur sur une dur\xE9e donn\xE9e.</p>',par:{targetPower:'force de freinage finale, en pourcentage',delay:'dur\xE9e (en ms) sur laquelle le changement de puissance sera effectu\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Motor']['clearCache']={syn:'Invalide le cache.',lib:'motor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du moteur. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Motor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moteur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'motor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moteur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le moteur (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Motor']['drivingForceMove']={syn:'Modifie progressivement la puissance envoy\xE9e au moteur sur une dur\xE9e donn\xE9e.',lib:'motor.drivingForceMove()',pro:'def drivingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Modifie progressivement la puissance envoy\xE9e au moteur sur une dur\xE9e donn\xE9e.</p>',par:{targetPower:'puissance finale d\xE9sir\xE9e, en pourcentage de -100% \xE0 +100%',delay:'dur\xE9e (en ms) sur laquelle le changement de puissance sera effectu\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Motor']['get_advertisedValue']={syn:'Retourne la valeur courante du moteur (pas plus de 6 caract\xE8res).',lib:'motor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du moteur (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du moteur (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Motor']['get_brakingForce']={syn:'Retourne la force de freinage appliqu\xE9e au moteur, sous forme de pourcentage.',lib:'motor.get_brakingForce()',pro:'def get_brakingForce()',cmt:'<p>Retourne la force de freinage appliqu\xE9e au moteur, sous forme de pourcentage. La valeur 0 correspond ne pas freiner (moteur en roue libre).</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la force de freinage appliqu\xE9e au moteur, sous forme de pourcentage',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BRAKINGFORCE_INVALID</tt>.'};
doc['Motor']['get_cutOffVoltage']={syn:'Retourne la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation.',lib:'motor.get_cutOffVoltage()',pro:'def get_cutOffVoltage()',cmt:'<p>Retourne la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation. Ce r\xE9glage permet d\x27\xE9viter d\x27endommager un accumulateur un continuant \xE0 l\x27utiliser une fois \x22vide\x22.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CUTOFFVOLTAGE_INVALID</tt>.'};
doc['Motor']['get_drivingForce']={syn:'Retourne la puissance actuelle envoy\xE9e au moteur, sous forme de nombre r\xE9el entre -100% et +100%.',lib:'motor.get_drivingForce()',pro:'def get_drivingForce()',cmt:'<p>Retourne la puissance actuelle envoy\xE9e au moteur, sous forme de nombre r\xE9el entre -100% et +100%.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la puissance actuelle envoy\xE9e au moteur, sous forme de nombre r\xE9el entre -100% et +100%',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DRIVINGFORCE_INVALID</tt>.'};
doc['Motor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur.',lib:'motor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moteur.'};
doc['Motor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur.',lib:'motor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moteur.'};
doc['Motor']['get_failSafeTimeout']={syn:'Retourne le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le.',lib:'motor.get_failSafeTimeout()',pro:'def get_failSafeTimeout()',cmt:'<p>Retourne le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le. Pass\xE9 ce delai, le contr\xF4leur arr\xEAtera le moteur et passera en mode erreur FAILSAFE. La s\xE9curit\xE9 failsafe est d\xE9sactiv\xE9e quand la valeur est \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FAILSAFETIMEOUT_INVALID</tt>.'};
doc['Motor']['get_frequency']={syn:'Retourne la fr\xE9quence du signal PWM utilis\xE9 pour contr\xF4ler le moteur.',lib:'motor.get_frequency()',pro:'def get_frequency()',cmt:'<p>Retourne la fr\xE9quence du signal PWM utilis\xE9 pour contr\xF4ler le moteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du signal PWM utilis\xE9 pour contr\xF4ler le moteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Motor']['get_friendlyName']={syn:'Retourne un identifiant global du moteur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'motor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du moteur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du moteur si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du moteur (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Motor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'motor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Motor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du moteur, sans r\xE9f\xE9rence au module.',lib:'motor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du moteur, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Motor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du moteur au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'motor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du moteur au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du moteur (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Motor']['get_logicalName']={syn:'Retourne le nom logique du moteur.',lib:'motor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du moteur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moteur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Motor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'motor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Motor']['get_motorStatus']={syn:'Retourne l\x27\xE9tat du contr\xF4leur de moteur.',lib:'motor.get_motorStatus()',pro:'def get_motorStatus()',cmt:'<p>Retourne l\x27\xE9tat du contr\xF4leur de moteur. Les \xE9tats possibles sont: IDLE si le moteur est \xE0 l\x27arr\xEAt/en roue libre, pr\xEAt \xE0 d\xE9marrer; FORWD si le contr\xF4leur fait tourner le moteur en marche avant; BACKWD si le contr\xF4leur fait tourner le moteur en marche arri\xE8re; BRAKE si le contr\xF4leur est en train de freiner; LOVOLT si le contr\xF4leur a d\xE9tect\xE9 une tension trop basse; HICURR si le contr\xF4leur a d\xE9tect\xE9 une surconsommation; HIHEAT si le contr\xF4leur a d\xE9tect\xE9 une surchauffe; FAILSF si le contr\xF4leur est pass\xE9 en protection failsafe.</p><p> Si le contr\xF4leur est en erreur (LOVOLT, HICURR, HIHEAT,FAILSF), il doit \xEAtre explicitement r\xE9initialis\xE9 avec la fonction <tt>resetStatus</tt>.</p>',ret:'une valeur parmi <tt>Y_MOTORSTATUS_IDLE</tt>, <tt>Y_MOTORSTATUS_BRAKE</tt>, <tt>Y_MOTORSTATUS_FORWD</tt>, <tt>Y_MOTORSTATUS_BACKWD</tt>, <tt>Y_MOTORSTATUS_LOVOLT</tt>, <tt>Y_MOTORSTATUS_HICURR</tt>, <tt>Y_MOTORSTATUS_HIHEAT</tt> et <tt>Y_MOTORSTATUS_FAILSF</tt> repr&eacute;sentant l\x27\xE9tat du contr\xF4leur de moteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MOTORSTATUS_INVALID</tt>.'};
doc['Motor']['get_overCurrentLimit']={syn:'Retourne la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur.',lib:'motor.get_overCurrentLimit()',pro:'def get_overCurrentLimit()',cmt:'<p>Retourne la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur. Une valeur nulle signifie qu\x27aucune limite n\x27est d\xE9finie.</p>',ret:'un entier repr&eacute;sentant la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OVERCURRENTLIMIT_INVALID</tt>.'};
doc['Motor']['get_starterTime']={syn:'Retourne la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage.',lib:'motor.get_starterTime()',pro:'def get_starterTime()',cmt:'<p>Retourne la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STARTERTIME_INVALID</tt>.'};
doc['Motor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'motor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Motor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le moteur est joignable, sans d\xE9clencher d\x27erreur.',lib:'motor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le moteur est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du moteur sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le moteur est joignable, <tt>false</tt> sinon'};
doc['Motor']['keepALive']={syn:'R\xE9arme la s\xE9curit\xE9 failsafe du contr\xF4leur.',lib:'motor.keepALive()',pro:'def keepALive()',cmt:'<p>R\xE9arme la s\xE9curit\xE9 failsafe du contr\xF4leur. Lorsque le moteur est en marche et que la s\xE9curit\xE9 failsafe est activ\xE9e, cette fonction doit \xEAtre appel\xE9e p\xE9riodiquement pour confirmer le bon fonctionnement du processus de contr\xF4le. A d\xE9faut, le moteur s\x27arr\xEAtera automatiquement au bout du temps pr\xE9vu. Notez que l\x27appel \xE0 une fonction de type <i>set</i> du moteur r\xE9arme aussi la s\xE9curit\xE9 failsafe.</p>'};
doc['Motor']['load']={syn:'Met en cache les valeurs courantes du moteur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'motor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du moteur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Motor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'motor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Motor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'motor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Motor']['nextMotor']={syn:'Continue l\x27\xE9num\xE9ration des moteur commenc\xE9e \xE0 l\x27aide de <tt>yFirstMotor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les moteur sont retourn\xE9s.',lib:'motor.nextMotor()',pro:'def nextMotor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des moteur commenc\xE9e \xE0 l\x27aide de <tt>yFirstMotor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les moteur sont retourn\xE9s. Si vous souhaitez retrouver un moteur sp\xE9cifique, utilisez <tt>Motor.findMotor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMotor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Motor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'motor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Motor']['resetStatus']={syn:'R\xE9initialise l\x27\xE9tat du contr\xF4leur \xE0 IDLE.',lib:'motor.resetStatus()',pro:'def resetStatus()',cmt:'<p>R\xE9initialise l\x27\xE9tat du contr\xF4leur \xE0 IDLE. Cette fonction doit \xEAtre explicitement appel\xE9e apr\xE8s toute condition d\x27erreur pour permettre au contr\xF4leur de repartir.</p>'};
doc['Motor']['set_brakingForce']={syn:'Modifie imm\xE9diatement la force de freinage appliqu\xE9e au moteur (en pourcents).',lib:'motor.set_brakingForce()',pro:'def set_brakingForce(<span id=pn>newval</span>)',cmt:'<p>Modifie imm\xE9diatement la force de freinage appliqu\xE9e au moteur (en pourcents). La valeur 0 correspond \xE0 ne pas freiner (moteur en roue libre). Lorsque la force de freinage est chang\xE9e, la puissance de traction est remise \xE0 z\xE9ro.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant imm\xE9diatement la force de freinage appliqu\xE9e au moteur (en pourcents)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_cutOffVoltage']={syn:'Modifie la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation.',lib:'motor.set_cutOffVoltage()',pro:'def set_cutOffVoltage(<span id=pn>newval</span>)',cmt:'<p>Modifie la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation. Ce r\xE9glage permet d\x27\xE9viter d\x27endommager un accumulateur un continuant \xE0 l\x27utiliser une fois \x22vide\x22. Attention, quel que soit le r\xE9glage du cutoff, le variateur passera en erreur si l\x27alimentation passe (m\xEAme bri\xE8vement) en dessous de 3V.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la limite de l\x27alimentation en dessous de laquelle le contr\xF4leur va automatiquement se mettre en erreur et couper la consommation'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_drivingForce']={syn:'Modifie imm\xE9diatement la puissance envoy\xE9e au moteur.',lib:'motor.set_drivingForce()',pro:'def set_drivingForce(<span id=pn>newval</span>)',cmt:'<p>Modifie imm\xE9diatement la puissance envoy\xE9e au moteur. La valeur est donn\xE9e en pourcentage de -100% \xE0 +100%. Si vous voulez m\xE9nager votre m\xE9canique et \xE9viter d\x27induire des consommations excessives qui pourraient d\xE9passer les capacit\xE9s du contr\xF4leur, \xE9vitez les changements de r\xE9gime trop brusques. Par exemple, passer brutalement de marche avant \xE0 marche arri\xE8re est une tr\xE8s mauvaise id\xE9e. A chaque fois que la puissance envoy\xE9e au moteur est chang\xE9e, le freinage est remis \xE0 z\xE9ro.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant imm\xE9diatement la puissance envoy\xE9e au moteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_failSafeTimeout']={syn:'Modifie le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le.',lib:'motor.set_failSafeTimeout()',pro:'def set_failSafeTimeout(<span id=pn>newval</span>)',cmt:'<p>Modifie le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le. Pass\xE9 ce delai, le contr\xF4leur arr\xEAtera le moteur et passera en mode erreur FAILSAFE. La s\xE9curit\xE9 failsafe est d\xE9sactiv\xE9e quand la valeur est \xE0 z\xE9ro.</p>',par:{newval:'un entier repr&eacute;sentant le temps en millisecondes pendant lequel le variateur pourra fonctionner sans instruction du processus de contr\xF4le'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_frequency']={syn:'Modifie la fr\xE9quence du signal PWM utilis\xE9e pour contr\xF4ler le moteur.',lib:'motor.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence du signal PWM utilis\xE9e pour contr\xF4ler le moteur. Une fr\xE9quence basse est g\xE9n\xE9ralement plus efficace (les composant chauffent moins et le moteur d\xE9marre plus facilement), mais un bruit audible peut \xEAtre g\xE9n\xE9r\xE9. Une fr\xE9quence \xE9lev\xE9e peut r\xE9duire le bruit, mais il y a plus d\x27\xE9nergie perdue en chaleur.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du signal PWM utilis\xE9e pour contr\xF4ler le moteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_logicalName']={syn:'Modifie le nom logique du moteur.',lib:'motor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du moteur. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moteur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Motor']['set_overCurrentLimit']={syn:'Modifie la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur.',lib:'motor.set_overCurrentLimit()',pro:'def set_overCurrentLimit(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur. Une valeur nulle signifie qu\x27aucune limite n\x27est d\xE9finie. Attention, quel que soit le r\xE9glage choisi, le variateur passera en erreur si le courant passe, m\xEAme bri\xE8vement, en dessus de 32A.</p>',par:{newval:'un entier repr&eacute;sentant la valeur limite du courant (en mA) au dessus de laquelle le contr\xF4leur va automatiquement se mettre en erreur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_starterTime']={syn:'Modifie la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage.',lib:'motor.set_starterTime()',pro:'def set_starterTime(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e (en ms) pendant laquelle le moteur est pilot\xE9 \xE0 basse fr\xE9quence pour faciliter son d\xE9marrage'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Motor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'motor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Motor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'motor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Motor)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'Interface de la fonction SerialPort',inc:'from yocto_serialport import *',cmt:'<p>La fonction SerialPort permet de piloter enti\xE8rement un module d\x27interface s\xE9rie Yoctopuce, pour envoyer et recevoir des donn\xE9es et configurer les param\xE8tres de transmission (vitesse, nombre de bits, parit\xE9, contr\xF4le de flux et protocole). Notez que les interfaces s\xE9rie Yoctopuce ne sont pas des visibles comme des ports COM virtuels. Ils sont faits pour \xEAtre utilis\xE9s comme tous les autres modules Yoctopuce.</p>'}};
doc['SerialPort']['FindSerialPort']={syn:'Permet de retrouver un port s\xE9rie d\x27apr\xE8s un identifiant donn\xE9.',lib:'YSerialPort.FindSerialPort()',pro:'def FindSerialPort(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un port s\xE9rie d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le port s\xE9rie soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YSerialPort.isOnline()</tt> pour tester si le port s\xE9rie est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port s\xE9rie sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YSerialPort</tt> qui permet ensuite de contr\xF4ler le port s\xE9rie.'};
doc['SerialPort']['FirstSerialPort']={syn:'Commence l\x27\xE9num\xE9ration des le port s\xE9rie accessibles par la librairie.',lib:'YSerialPort.FirstSerialPort()',pro:'def FirstSerialPort()',cmt:'<p>Commence l\x27\xE9num\xE9ration des le port s\xE9rie accessibles par la librairie. Utiliser la fonction <tt>YSerialPort.nextSerialPort()</tt> pour it\xE9rer sur les autres le port s\xE9rie.</p>',ret:'un pointeur sur un objet <tt>YSerialPort</tt>, correspondant au premier port s\xE9rie accessible en ligne, ou <tt>null</tt> si il n\x27y a pas du port s\xE9rie disponibles.'};
doc['SerialPort']['clearCache']={syn:'Invalide le cache.',lib:'serialport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du port s\xE9rie. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['SerialPort']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port s\xE9rie au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'serialport.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port s\xE9rie au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le port s\xE9rie (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SerialPort']['get_CTS']={syn:'Lit l\x27\xE9tat de la ligne CTS.',lib:'serialport.get_CTS()',pro:'def get_CTS()',cmt:'<p>Lit l\x27\xE9tat de la ligne CTS. La ligne CTS est habituellement pilot\xE9e par le signal RTS du p\xE9riph\xE9rique s\xE9rie connect\xE9.</p>',ret:'1 si le CTS est signal\xE9 (niveau haut), 0 si le CTS n\x27est pas actif (niveau bas).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['get_advertisedValue']={syn:'Retourne la valeur courante du port s\xE9rie (pas plus de 6 caract\xE8res).',lib:'serialport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port s\xE9rie (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port s\xE9rie (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SerialPort']['get_currentJob']={syn:'Retourne le nom du fichier de t\xE2ches actif en ce moment.',lib:'serialport.get_currentJob()',pro:'def get_currentJob()',cmt:'<p>Retourne le nom du fichier de t\xE2ches actif en ce moment.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du fichier de t\xE2ches actif en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SerialPort']['get_errCount']={syn:'Retourne le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'serialport.get_errCount()',pro:'def get_errCount()',cmt:'<p>Retourne le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port s\xE9rie.',lib:'serialport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port s\xE9rie. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port s\xE9rie.'};
doc['SerialPort']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port s\xE9rie.',lib:'serialport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port s\xE9rie. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port s\xE9rie.'};
doc['SerialPort']['get_friendlyName']={syn:'Retourne un identifiant global du port s\xE9rie au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'serialport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du port s\xE9rie au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du port s\xE9rie si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du port s\xE9rie (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port s\xE9rie en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SerialPort']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'serialport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['SerialPort']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du port s\xE9rie, sans r\xE9f\xE9rence au module.',lib:'serialport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du port s\xE9rie, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port s\xE9rie (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SerialPort']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du port s\xE9rie au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'serialport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du port s\xE9rie au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du port s\xE9rie (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port s\xE9rie (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SerialPort']['get_lastMsg']={syn:'Retourne le dernier message re\xE7u (pour les protocoles de type Line, Frame et Modbus).',lib:'serialport.get_lastMsg()',pro:'def get_lastMsg()',cmt:'<p>Retourne le dernier message re\xE7u (pour les protocoles de type Line, Frame et Modbus).</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le dernier message re\xE7u (pour les protocoles de type Line, Frame et Modbus)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SerialPort']['get_logicalName']={syn:'Retourne le nom logique du port s\xE9rie.',lib:'serialport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du port s\xE9rie.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port s\xE9rie.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SerialPort']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'serialport.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['SerialPort']['get_protocol']={syn:'Retourne le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res.',lib:'serialport.get_protocol()',pro:'def get_protocol()',cmt:'<p>Retourne le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res. Les valeurs possibles sont \x22Line\x22 pour des messages ASCII s\xE9par\xE9s par des retours de ligne, \x22Frame:[timeout]ms\x22 pour des messages binaires s\xE9par\xE9s par une temporisation, \x22Modbus-ASCII\x22 pour des messages MODBUS en mode ASCII, \x22Modbus-RTU\x22 pour des messages MODBUS en mode RTU, \x22Wiegand-ASCII\x22 pour des messages Wiegand en mode ASCII, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc pour des messages Wiegand en mode octet, \x22Char\x22 pour un flux ASCII continu ou \x22Byte\x22 pour un flux binaire continue.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SerialPort']['get_rxCount']={syn:'Retourne le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'serialport.get_rxCount()',pro:'def get_rxCount()',cmt:'<p>Retourne le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_rxMsgCount']={syn:'Retourne le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'serialport.get_rxMsgCount()',pro:'def get_rxMsgCount()',cmt:'<p>Retourne le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_serialMode']={syn:'Retourne les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22.',lib:'serialport.get_serialMode()',pro:'def get_serialMode()',cmt:'<p>Retourne les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22. La cha\xEEne contient le taux de transfert, le nombre de bits de donn\xE9es, la parit\xE9 parit\xE9 et le nombre de bits d\x27arr\xEAt. Un suffixe suppl\xE9mentaire optionnel est inclus si une option de contr\xF4le de flux est active: \x22CtsRts\x22 pour le contr\xF4le de flux mat\xE9riel, \x22XOnXOff\x22 pour le contr\xF4le de flux logique et \x22Simplex\x22 pour l\x27utilisation du signal RTS pour l\x27acquisition d\x27un bus partag\xE9 (tel qu\x27utilis\xE9 pour certains adaptateurs RS485 par exemple).</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SERIALMODE_INVALID</tt>.'};
doc['SerialPort']['get_startupJob']={syn:'Retourne le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'serialport.get_startupJob()',pro:'def get_startupJob()',cmt:'<p>Retourne le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SerialPort']['get_txCount']={syn:'Retourne le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'serialport.get_txCount()',pro:'def get_txCount()',cmt:'<p>Retourne le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_txMsgCount']={syn:'Retourne le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'serialport.get_txMsgCount()',pro:'def get_txMsgCount()',cmt:'<p>Retourne le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'serialport.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['SerialPort']['get_voltageLevel']={syn:'Retourne le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.',lib:'serialport.get_voltageLevel()',pro:'def get_voltageLevel()',cmt:'<p>Retourne le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.</p>',ret:'une valeur parmi <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> et <tt>Y_VOLTAGELEVEL_RS485</tt> repr&eacute;sentant le niveau de tension utilis\xE9 par le module sur le port s\xE9rie',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SerialPort']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le port s\xE9rie est joignable, sans d\xE9clencher d\x27erreur.',lib:'serialport.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le port s\xE9rie est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du port s\xE9rie sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le port s\xE9rie est joignable, <tt>false</tt> sinon'};
doc['SerialPort']['load']={syn:'Met en cache les valeurs courantes du port s\xE9rie, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'serialport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du port s\xE9rie, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'serialport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['SerialPort']['modbusReadBits']={syn:'Lit un ou plusieurs bits contigus depuis un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusReadBits()',pro:'def modbusReadBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Lit un ou plusieurs bits contigus depuis un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x01 (Read Coils).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 interroger',pduAddr:'adresse relative du premier bit \xE0 lire (index\xE9 \xE0 partir de z\xE9ro).',nBits:'nombre de bits \xE0 lire'},ret:'un vecteur d\x27entiers, correspondant chacun \xE0 un bit.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['modbusReadInputBits']={syn:'Lit un ou plusieurs bits contigus depuis un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusReadInputBits()',pro:'def modbusReadInputBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Lit un ou plusieurs bits contigus depuis un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 interroger',pduAddr:'adresse relative du premier bit \xE0 lire (index\xE9 \xE0 partir de z\xE9ro).',nBits:'nombre de bits \xE0 lire'},ret:'un vecteur d\x27entiers, correspondant chacun \xE0 un bit.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Lit un ou plusieurs registres d\x27entr\xE9e (registre enlecture seule) depuis un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusReadInputRegisters()',pro:'def modbusReadInputRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Lit un ou plusieurs registres d\x27entr\xE9e (registre enlecture seule) depuis un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x04 (Read Input Registers).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 interroger',pduAddr:'adresse relative du premier registre d\x27entr\xE9e \xE0 lire (index\xE9 \xE0 partir de z\xE9ro).',nWords:'nombre de registres d\x27entr\xE9e \xE0 lire'},ret:'un vecteur d\x27entiers, correspondant chacun \xE0 une valeur d\x27entr\xE9e (16 bits).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['modbusReadRegisters']={syn:'Lit un ou plusieurs registres interne depuis un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusReadRegisters()',pro:'def modbusReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Lit un ou plusieurs registres interne depuis un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x03 (Read Holding Registers).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 interroger',pduAddr:'adresse relative du premier registre interne \xE0 lire (index\xE9 \xE0 partir de z\xE9ro).',nWords:'nombre de registres internes \xE0 lire'},ret:'un vecteur d\x27entiers, correspondant chacun \xE0 une valeur de registre (16 bits).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Modifie l\x27\xE9tat de plusieurs bits (ou relais) contigus sur un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusWriteAndReadRegisters()',pro:'def modbusWriteAndReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduWriteAddr</span>, <span id=pn>values</span>, <span id=pn>pduReadAddr</span>, <span id=pn>nReadWords</span>)',cmt:'<p>Modifie l\x27\xE9tat de plusieurs bits (ou relais) contigus sur un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 piloter',pduWriteAddr:'adresse relative du premier registre interne \xE0 modifier (index\xE9 \xE0 partir de z\xE9ro).',values:'vecteur de valeurs 16 bits \xE0 appliquer',pduReadAddr:'adresse relative du premier registre interne \xE0 lire (index\xE9 \xE0 partir de z\xE9ro).',nReadWords:'nombre de registres internes \xE0 lire'},ret:'un vecteur d\x27entiers, correspondant chacun \xE0 une valeur de registre (16 bits) lue.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['modbusWriteBit']={syn:'Modifie l\x27\xE9tat d\x27un seul bit (ou relais) sur un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusWriteBit()',pro:'def modbusWriteBit(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27un seul bit (ou relais) sur un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x05 (Write Single Coil).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 piloter',pduAddr:'adresse relative du bit \xE0 modifier (index\xE9 \xE0 partir de z\xE9ro).',value:'la valeur \xE0 appliquer (0 pour l\x27\xE9tat OFF, non-z\xE9ro pour l\x27\xE9tat ON)'},ret:'le nombre de bits affect\xE9s sur le p\xE9riph\xE9rique (1)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['SerialPort']['modbusWriteBits']={syn:'Modifie l\x27\xE9tat de plusieurs bits (ou relais) contigus sur un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusWriteBits()',pro:'def modbusWriteBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>bits</span>)',cmt:'<p>Modifie l\x27\xE9tat de plusieurs bits (ou relais) contigus sur un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 piloter',pduAddr:'adresse relative du premier bit \xE0 modifier (index\xE9 \xE0 partir de z\xE9ro).',bits:'vecteur de bits \xE0 appliquer (un entier par bit)'},ret:'le nombre de bits affect\xE9s sur le p\xE9riph\xE9rique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['SerialPort']['modbusWriteRegister']={syn:'Modifie la valeur d\x27un registre interne 16 bits sur un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusWriteRegister()',pro:'def modbusWriteRegister(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Modifie la valeur d\x27un registre interne 16 bits sur un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x06 (Write Single Register).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 piloter',pduAddr:'adresse relative du registre \xE0 modifier (index\xE9 \xE0 partir de z\xE9ro).',value:'la valeur 16 bits \xE0 appliquer'},ret:'le nombre de registres affect\xE9s sur le p\xE9riph\xE9rique (1)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['SerialPort']['modbusWriteRegisters']={syn:'Modifie l\x27\xE9tat de plusieurs registres internes 16 bits contigus sur un p\xE9riph\xE9rique MODBUS.',lib:'serialport.modbusWriteRegisters()',pro:'def modbusWriteRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>values</span>)',cmt:'<p>Modifie l\x27\xE9tat de plusieurs registres internes 16 bits contigus sur un p\xE9riph\xE9rique MODBUS. Cette m\xE9thode utilise le code de fonction MODBUS 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave \xE0 piloter',pduAddr:'adresse relative du premier registre interne \xE0 modifier (index\xE9 \xE0 partir de z\xE9ro).',values:'vecteur de valeurs 16 bits \xE0 appliquer'},ret:'le nombre de registres affect\xE9s sur le p\xE9riph\xE9rique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['SerialPort']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'serialport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['nextSerialPort']={syn:'Continue l\x27\xE9num\xE9ration des le port s\xE9rie commenc\xE9e \xE0 l\x27aide de <tt>yFirstSerialPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le port s\xE9rie sont retourn\xE9s.',lib:'serialport.nextSerialPort()',pro:'def nextSerialPort()',cmt:'<p>Continue l\x27\xE9num\xE9ration des le port s\xE9rie commenc\xE9e \xE0 l\x27aide de <tt>yFirstSerialPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le port s\xE9rie sont retourn\xE9s. Si vous souhaitez retrouver un port s\xE9rie sp\xE9cifique, utilisez <tt>SerialPort.findSerialPort()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YSerialPort</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['SerialPort']['queryLine']={syn:'Envoie un message sous forme de ligne de texte sur le port s\xE9rie, et lit la r\xE9ponse re\xE7ue.',lib:'serialport.queryLine()',pro:'def queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Envoie un message sous forme de ligne de texte sur le port s\xE9rie, et lit la r\xE9ponse re\xE7ue. Cette fonction est pr\xE9vue pour \xEAtre utilis\xE9e lorsque le module est configur\xE9 en protocole \x27Line\x27.</p>',par:{query:'le message \xE0 envoyer (sans le retour de chariot)',maxWait:'le temps maximum d\x27attente pour obtenir une r\xE9ponse (en millisecondes).'},ret:'la premi\xE8re ligne de texte re\xE7ue apr\xE8s l\x27envoi du message. Les lignes suivantes peuvent \xEAtre obtenues avec des appels \xE0 readLine ou readMessages.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['queryMODBUS']={syn:'Envoie un message \xE0 un p\xE9riph\xE9rique MODBUS esclave connect\xE9 au port s\xE9rie, et lit la r\xE9ponse re\xE7ue.',lib:'serialport.queryMODBUS()',pro:'def queryMODBUS(<span id=pn>slaveNo</span>, <span id=pn>pduBytes</span>)',cmt:'<p>Envoie un message \xE0 un p\xE9riph\xE9rique MODBUS esclave connect\xE9 au port s\xE9rie, et lit la r\xE9ponse re\xE7ue. Le contenu du message est le PDU, fourni sous forme de vecteur d\x27octets.</p>',par:{slaveNo:'addresse du p\xE9riph\xE9rique MODBUS esclave',pduBytes:'message \xE0 envoyer (PDU), sous forme de vecteur d\x27octets. Le premier octet du PDU est le code de fonction MODBUS.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide (ou une r\xE9ponse d\x27erreur).'};
doc['SerialPort']['readArray']={syn:'Lit le contenu du tampon de r\xE9ception sous forme de liste d\x27octets, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readArray()',pro:'def readArray(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme de liste d\x27octets, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de bytes \xE0 lire'},ret:'une liste de bytes avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['readBin']={syn:'Lit le contenu du tampon de r\xE9ception sous forme d\x27objet binaire, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readBin()',pro:'def readBin(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme d\x27objet binaire, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de bytes \xE0 lire'},ret:'un objet binaire avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['readByte']={syn:'Lit le prochain byte dans le tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readByte()',pro:'def readByte()',cmt:'<p>Lit le prochain byte dans le tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, ou si aucun octet n\x27est disponible pour l\x27instant, la fonction retourne YAPI_NO_MORE_DATA.</p>',ret:'le prochain byte',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['readHex']={syn:'Lit le contenu du tampon de r\xE9ception sous forme hexad\xE9cimale, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readHex()',pro:'def readHex(<span id=pn>nBytes</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme hexad\xE9cimale, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nBytes:'le nombre maximal d\x27octets \xE0 lire'},ret:'une cha\xEEne de caract\xE8re avec le contenu du tampon de r\xE9ception, encod\xE9 en hexad\xE9cimal',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['readLine']={syn:'Lit la prochaine ligne (ou le prochain message) du tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readLine()',pro:'def readLine()',cmt:'<p>Lit la prochaine ligne (ou le prochain message) du tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e. Cette fonction est destin\xE9e \xE0 \xEAtre utilis\xE9e lorsque le module est configur\xE9 pour un protocole bas\xE9 message, comme en mode \x27Line\x27 ou en protocole \x27Frame\x27.</p><p> Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction retournera la plus ancienne ligne disponible et d\xE9placera le pointeur de position juste apr\xE8s. Si aucune nouvelle ligne enti\xE8re n\x27est disponible, la fonction retourne un cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8re avec une ligne de texte',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['readMessages']={syn:'Cherche les messages entrants dans le tampon de r\xE9ception correspondant \xE0 un format donn\xE9, \xE0 partir de la position courante.',lib:'serialport.readMessages()',pro:'def readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Cherche les messages entrants dans le tampon de r\xE9ception correspondant \xE0 un format donn\xE9, \xE0 partir de la position courante. Cette fonction ne compare et ne retourne que les caract\xE8res imprimables. Les protocoles binaires sont g\xE9r\xE9s sous forme de repr\xE9sentation hexad\xE9cimale.</p><p> La recherche retourne tous les messages trouv\xE9s qui correspondent au format. Tant qu\x27aucun message ad\xE9quat n\x27est trouv\xE9, la fonction attendra, au maximum pour le temps sp\xE9cifi\xE9 en argument (en millisecondes).</p>',par:{pattern:'une expression r\xE9guli\xE8re limit\xE9e d\xE9crivant le format de message d\xE9sir\xE9, ou une cha\xEEne vide si aucun filtrage des messages n\x27est d\xE9sir\xE9. Pour les protocoles binaires, le format est appliqu\xE9 \xE0 la repr\xE9sentation hexad\xE9cimale du message.',maxWait:'le temps maximum d\x27attente pour obtenir un message, tant qu\x27aucun n\x27est trouv\xE9 dans le tampon de r\xE9ception (en millisecondes).'},ret:'un tableau de cha\xEEnes de caract\xE8res contenant les messages trouv\xE9s. Les messages binaires sont convertis automatiquement en repr\xE9sentation hexad\xE9cimale.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['readStr']={syn:'Lit le contenu du tampon de r\xE9ception sous forme de string, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'serialport.readStr()',pro:'def readStr(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme de string, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de caract\xE8res \xE0 lire'},ret:'une cha\xEEne de caract\xE8re avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['read_avail']={syn:'Retourne le nombre de bytes pr\xEAts \xE0 \xEAtre lus dans le tampon de r\xE9ception, depuis la position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.',lib:'serialport.read_avail()',pro:'def read_avail()',cmt:'<p>Retourne le nombre de bytes pr\xEAts \xE0 \xEAtre lus dans le tampon de r\xE9ception, depuis la position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.</p>',ret:'le nombre d\x27octets pr\xEAts \xE0 \xEAtre lus'};
doc['SerialPort']['read_seek']={syn:'Change le pointeur de position courante dans le flux de donn\xE9e \xE0 la valeur sp\xE9cifi\xE9e.',lib:'serialport.read_seek()',pro:'def read_seek(<span id=pn>absPos</span>)',cmt:'<p>Change le pointeur de position courante dans le flux de donn\xE9e \xE0 la valeur sp\xE9cifi\xE9e. Cette fonction n\x27a pas d\x27effet sur le module, elle ne fait que changer la valeur stock\xE9e dans l\x27objet d\x27API qui sera utilis\xE9e pour les prochaines operations de lecture.</p>',par:{absPos:'index de position absolue pour les op\xE9rations de lecture suivantes.'},ret:'rien du tout.'};
doc['SerialPort']['read_tell']={syn:'Retourne la valeur actuelle du pointeur de position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.',lib:'serialport.read_tell()',pro:'def read_tell()',cmt:'<p>Retourne la valeur actuelle du pointeur de position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.</p>',ret:'l\x27index de position absolue pour les prochaines op\xE9rations de lecture.'};
doc['SerialPort']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'serialport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['SerialPort']['reset']={syn:'Remet \xE0 z\xE9ro tous les compteurs et efface les tampons.',lib:'serialport.reset()',pro:'def reset()',cmt:'<p>Remet \xE0 z\xE9ro tous les compteurs et efface les tampons.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['selectJob']={syn:'Charge et execute le fichier de t\xE2che sp\xE9cifi\xE9.',lib:'serialport.selectJob()',pro:'def selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Charge et execute le fichier de t\xE2che sp\xE9cifi\xE9. Le fichier doit avoir \xE9t\xE9 pr\xE9alablement cr\xE9\xE9 en utilisant l\x27interface graphique, ou t\xE9l\xE9charg\xE9 sur le module \xE0 l\x27aide de la fonction <tt>uploadJob()</tt>.</p>',par:{jobfile:'nom du fichier de t\xE2che (fichier sur le module)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['set_RTS']={syn:'Change manuellement l\x27\xE9tat de la ligne RTS.',lib:'serialport.set_RTS()',pro:'def set_RTS(<span id=pn>val</span>)',cmt:'<p>Change manuellement l\x27\xE9tat de la ligne RTS. Cette fonction n\x27a pas d\x27effet lorsque le contr\xF4le du flux par CTS/RTS est actif, car la ligne RTS est alors pilot\xE9e automatiquement.</p>',par:{val:'1 pour activer la ligne RTS, 0 pour la d\xE9sactiver'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['set_currentJob']={syn:'Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'serialport.set_currentJob()',pro:'def set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SerialPort']['set_logicalName']={syn:'Modifie le nom logique du port s\xE9rie.',lib:'serialport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du port s\xE9rie. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port s\xE9rie.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['set_protocol']={syn:'Modifie le type de protocol utilis\xE9 sur la communication s\xE9rie.',lib:'serialport.set_protocol()',pro:'def set_protocol(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de protocol utilis\xE9 sur la communication s\xE9rie. Les valeurs possibles sont \x22Line\x22 pour des messages ASCII s\xE9par\xE9s par des retours de ligne, \x22Frame:[timeout]ms\x22 pour des messages binaires s\xE9par\xE9s par une temporisation, \x22Modbus-ASCII\x22 pour des messages MODBUS en mode ASCII, \x22Modbus-RTU\x22 pour des messages MODBUS en mode RTU, \x22Wiegand-ASCII\x22 pour des messages Wiegand en mode ASCII, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc pour des messages Wiegand en mode octet, \x22Char\x22 pour un flux ASCII continu ou \x22Byte\x22 pour un flux binaire continue. Le suffixe \x22/[wait]ms\x22 peut \xEAtre ajout\xE9 pour r\xE9duire la cadence d\x27\xE9mission de sorte \xE0 ce qu\x27il y ait au minimum le nombre sp\xE9cifi\xE9 de millisecondes d\x27intervalle entre l\x27envoi de chaque byte.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le type de protocol utilis\xE9 sur la communication s\xE9rie'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SerialPort']['set_serialMode']={syn:'Modifie les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22.',lib:'serialport.set_serialMode()',pro:'def set_serialMode(<span id=pn>newval</span>)',cmt:'<p>Modifie les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22. La cha\xEEne contient le taux de transfert, le nombre de bits de donn\xE9es, la parit\xE9 parit\xE9 et le nombre de bits d\x27arr\xEAt. Un suffixe suppl\xE9mentaire optionnel peut \xEAtre inclus pour activer une option de contr\xF4le de flux: \x22CtsRts\x22 pour le contr\xF4le de flux mat\xE9riel, \x22XOnXOff\x22 pour le contr\xF4le de flux logique et \x22Simplex\x22 pour l\x27utilisation du signal RTS pour l\x27acquisition d\x27un bus partag\xE9 (tel qu\x27utilis\xE9 pour certains adaptateurs RS485 par exemple).</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x229600,8N1\x22'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SerialPort']['set_startupJob']={syn:'Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'serialport.set_startupJob()',pro:'def set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SerialPort']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'serialport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['SerialPort']['set_voltageLevel']={syn:'Modifie le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.',lib:'serialport.set_voltageLevel()',pro:'def set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Modifie le niveau de tension utilis\xE9 par le module sur le port s\xE9rie. Les valeurs valides d\xE9pendent du mod\xE8le de module Yoctopuce h\xE9bergeant le port s\xE9rie. Consultez la documentation de votre module pour savoir quelles valeurs sont support\xE9es. Affecter une valeur invalide n\x27aura aucun effet.</p>',par:{newval:'une valeur parmi <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> et <tt>Y_VOLTAGELEVEL_RS485</tt> repr&eacute;sentant le niveau de tension utilis\xE9 par le module sur le port s\xE9rie'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SerialPort']['snoopMessages']={syn:'R\xE9cup\xE8re les messages dans la m\xE9moire tampon du module s\xE9rie (dans les deux directions), \xE0 partir de la position courante.',lib:'serialport.snoopMessages()',pro:'def snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>R\xE9cup\xE8re les messages dans la m\xE9moire tampon du module s\xE9rie (dans les deux directions), \xE0 partir de la position courante. Cette fonction ne compare et ne retourne que les caract\xE8res imprimables. Les protocoles binaires sont g\xE9r\xE9s sous forme de repr\xE9sentation hexad\xE9cimale.</p><p> Tant qu\x27aucun message ad\xE9quat n\x27est trouv\xE9, la fonction attendra, au maximum pour le temps sp\xE9cifi\xE9 en argument (en millisecondes).</p>',par:{maxWait:'le temps maximum d\x27attente pour obtenir un message, tant qu\x27aucun n\x27est trouv\xE9 dans le tampon de r\xE9ception (en millisecondes).'},ret:'un tableau de cha\xEEnes de caract\xE8res contenant les messages trouv\xE9s. Les messages binaires sont convertis automatiquement en repr\xE9sentation hexad\xE9cimale.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SerialPort']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'serialport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['uploadJob']={syn:'Sauvegarde une d\xE9finition de t\xE2che (au format JSON) dans un fichier.',lib:'serialport.uploadJob()',pro:'def uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Sauvegarde une d\xE9finition de t\xE2che (au format JSON) dans un fichier. Le fichier peut ensuite \xEAtre activ\xE9 \xE0 l\x27aide de la m\xE9thode <tt>selectJob()</tt>.</p>',par:{jobfile:'nom du fichier de t\xE2che sur le module',jsonDef:'une cha\xEEne de caract\xE8res contenant la d\xE9finition du job en JSON'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeArray']={syn:'Envoie une s\xE9quence d\x27octets (fournie sous forme d\x27une liste) sur le port s\xE9rie.',lib:'serialport.writeArray()',pro:'def writeArray(<span id=pn>byteList</span>)',cmt:'<p>Envoie une s\xE9quence d\x27octets (fournie sous forme d\x27une liste) sur le port s\xE9rie.</p>',par:{byteList:'la liste d\x27octets \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeBin']={syn:'Envoie un objet binaire tel quel sur le port s\xE9rie.',lib:'serialport.writeBin()',pro:'def writeBin(<span id=pn>buff</span>)',cmt:'<p>Envoie un objet binaire tel quel sur le port s\xE9rie.</p>',par:{buff:'l\x27objet binaire \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeByte']={syn:'Envoie un unique byte sur le port s\xE9rie.',lib:'serialport.writeByte()',pro:'def writeByte(<span id=pn>code</span>)',cmt:'<p>Envoie un unique byte sur le port s\xE9rie.</p>',par:{code:'le byte \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeHex']={syn:'Envoie une s\xE9quence d\x27octets (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie.',lib:'serialport.writeHex()',pro:'def writeHex(<span id=pn>hexString</span>)',cmt:'<p>Envoie une s\xE9quence d\x27octets (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie.</p>',par:{hexString:'la cha\xEEne hexad\xE9cimale \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeLine']={syn:'Envoie une cha\xEEne de caract\xE8res sur le port s\xE9rie, suivie d\x27un saut de ligne (CR LF).',lib:'serialport.writeLine()',pro:'def writeLine(<span id=pn>text</span>)',cmt:'<p>Envoie une cha\xEEne de caract\xE8res sur le port s\xE9rie, suivie d\x27un saut de ligne (CR LF).</p>',par:{text:'la cha\xEEne de caract\xE8res \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeMODBUS']={syn:'Envoie une commande MODBUS (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie.',lib:'serialport.writeMODBUS()',pro:'def writeMODBUS(<span id=pn>hexString</span>)',cmt:'<p>Envoie une commande MODBUS (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie. Le message doit commencer par l\x27adresse de destination. Le CRC (ou LRC) MODBUS est ajout\xE9 automatiquement par la fonction. Cette fonction n\x27attend pas de r\xE9ponse.</p>',par:{hexString:'le message \xE0 envoyer, en hexad\xE9cimal, sans le CRC/LRC'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SerialPort']['writeStr']={syn:'Envoie une cha\xEEne de caract\xE8res telle quelle sur le port s\xE9rie.',lib:'serialport.writeStr()',pro:'def writeStr(<span id=pn>text</span>)',cmt:'<p>Envoie une cha\xEEne de caract\xE8res telle quelle sur le port s\xE9rie.</p>',par:{text:'la cha\xEEne de caract\xE8res \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: SerialPort)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'Interface de la fonction PwmInput',inc:'from yocto_pwminput import *',cmt:'<p>La classe YPwmInput permet de lire et de configurer les capteurs PWM Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet de configurer le param\xE8tre du signal utilis\xE9 pour transmettre l\x27information: le duty cycle, le fr\xE9quence ou la longueur de la pulsation.</p>'}};
doc['PwmInput']['FindPwmInput']={syn:'Permet de retrouver une entr\xE9e PWM d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPwmInput.FindPwmInput()',pro:'def FindPwmInput(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une entr\xE9e PWM d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27entr\xE9e PWM soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPwmInput.isOnline()</tt> pour tester si l\x27entr\xE9e PWM est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27entr\xE9e PWM sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPwmInput</tt> qui permet ensuite de contr\xF4ler l\x27entr\xE9e PWM.'};
doc['PwmInput']['FirstPwmInput']={syn:'Commence l\x27\xE9num\xE9ration des Entr\xE9e PWM accessibles par la librairie.',lib:'YPwmInput.FirstPwmInput()',pro:'def FirstPwmInput()',cmt:'<p>Commence l\x27\xE9num\xE9ration des Entr\xE9e PWM accessibles par la librairie. Utiliser la fonction <tt>YPwmInput.nextPwmInput()</tt> pour it\xE9rer sur les autres Entr\xE9e PWM.</p>',ret:'un pointeur sur un objet <tt>YPwmInput</tt>, correspondant \xE0 la premi\xE8re entr\xE9e PWM accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de Entr\xE9e PWM disponibles.'};
doc['PwmInput']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'pwminput.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['clearCache']={syn:'Invalide le cache.',lib:'pwminput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27entr\xE9e PWM. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['PwmInput']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27entr\xE9e PWM au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwminput.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27entr\xE9e PWM au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27entr\xE9e PWM (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmInput']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'pwminput.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['PwmInput']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27entr\xE9e PWM (pas plus de 6 caract\xE8res).',lib:'pwminput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27entr\xE9e PWM (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27entr\xE9e PWM (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Hz, sous forme de nombre \xE0 virgule.',lib:'pwminput.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Hz, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en Hz, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentValue']={syn:'Retourne la valeur courante de la fonctionnalit\xE9 PwmInput, sous forme de nombre \xE0 virgule.',lib:'pwminput.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur courante de la fonctionnalit\xE9 PwmInput, sous forme de nombre \xE0 virgule. En fonction du r\xE9glage pwmReportMode, cela peut \xEAtre soit la fr\xE9quence en Hz, le duty cycle en %, la longueur d\x27impulsion en ms, etc.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur courante de la fonctionnalit\xE9 PwmInput, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'pwminput.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['PwmInput']['get_debouncePeriod']={syn:'Retourne la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce).',lib:'pwminput.get_debouncePeriod()',pro:'def get_debouncePeriod()',cmt:'<p>Retourne la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce). Les impulsions plus courtes seront ignor\xE9es.</p>',ret:'un entier repr&eacute;sentant la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DEBOUNCEPERIOD_INVALID</tt>.'};
doc['PwmInput']['get_dutyCycle']={syn:'Retourne le duty cycle du PWM, en pour cents.',lib:'pwminput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Retourne le duty cycle du PWM, en pour cents.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le duty cycle du PWM, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmInput']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e PWM.',lib:'pwminput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e PWM. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27entr\xE9e PWM.'};
doc['PwmInput']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e PWM.',lib:'pwminput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27entr\xE9e PWM. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27entr\xE9e PWM.'};
doc['PwmInput']['get_frequency']={syn:'Retourne la fr\xE9quence du PWM en Hz.',lib:'pwminput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Retourne la fr\xE9quence du PWM en Hz.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du PWM en Hz',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27entr\xE9e PWM au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'pwminput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27entr\xE9e PWM au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27entr\xE9e PWM si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27entr\xE9e PWM (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e PWM en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmInput']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pwminput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['PwmInput']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27entr\xE9e PWM, sans r\xE9f\xE9rence au module.',lib:'pwminput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27entr\xE9e PWM, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e PWM (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmInput']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27entr\xE9e PWM au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwminput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27entr\xE9e PWM au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27entr\xE9e PWM (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27entr\xE9e PWM (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmInput']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le PWM depuis le d\xE9marrage du module.',lib:'pwminput.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le PWM depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le PWM depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'pwminput.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_logicalName']={syn:'Retourne le nom logique de l\x27entr\xE9e PWM.',lib:'pwminput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27entr\xE9e PWM.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e PWM.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmInput']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le PWM depuis le d\xE9marrage du module.',lib:'pwminput.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le PWM depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le PWM depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pwminput.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['PwmInput']['get_period']={syn:'Retourne la p\xE9riode du PWM en millisecondes.',lib:'pwminput.get_period()',pro:'def get_period()',cmt:'<p>Retourne la p\xE9riode du PWM en millisecondes.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la p\xE9riode du PWM en millisecondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmInput']['get_pulseCounter']={syn:'Retourne la valeur du compteur d\x27impulsions.',lib:'pwminput.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Retourne la valeur du compteur d\x27impulsions. Ce compteur est en r\xE9alit\xE9 incr\xE9ment\xE9 deux fois par p\xE9riode. Ce compteur est limit\xE9 \xE0 1 milliard.</p>',ret:'un entier repr&eacute;sentant la valeur du compteur d\x27impulsions',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['PwmInput']['get_pulseDuration']={syn:'Retourne la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule.',lib:'pwminput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Retourne la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la longueur d\x27une impulsion du PWM en millisecondes, sous forme d\x27un chiffre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmInput']['get_pulseTimer']={syn:'Retourne le timer du compteur d\x27impulsions (ms).',lib:'pwminput.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le timer du compteur d\x27impulsions (ms).</p>',ret:'un entier repr&eacute;sentant le timer du compteur d\x27impulsions (ms)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['PwmInput']['get_pwmReportMode']={syn:'Retourne le type de param\xE8tre (fr\xE9quence, duty cycle , longueur d\x27impulsion ou nombre de changements d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback.',lib:'pwminput.get_pwmReportMode()',pro:'def get_pwmReportMode()',cmt:'<p>Retourne le type de param\xE8tre (fr\xE9quence, duty cycle , longueur d\x27impulsion ou nombre de changements d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback.</p>',ret:'une valeur parmi <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt>, <tt>Y_PWMREPORTMODE_PWM_STATE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQ_CPS</tt> et <tt>Y_PWMREPORTMODE_PWM_FREQ_CPM</tt> repr&eacute;sentant le type de param\xE8tre (fr\xE9quence, duty cycle , longueur d\x27impulsion ou nombre de changements d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PWMREPORTMODE_INVALID</tt>.'};
doc['PwmInput']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'pwminput.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['PwmInput']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'pwminput.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'pwminput.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['PwmInput']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'pwminput.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['PwmInput']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur retourn\xE9e par get_currentValue et les callback est exprim\xE9e.',lib:'pwminput.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur retourn\xE9e par get_currentValue et les callback est exprim\xE9e. Cette unit\xE9 d\xE9pend du r\xE9glage pwmReportMode mais peut aussi \xEAtre modifi\xE9e arbitrairement</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la valeur retourn\xE9e par get_currentValue et les callback est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['PwmInput']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pwminput.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['PwmInput']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27entr\xE9e PWM est joignable, sans d\xE9clencher d\x27erreur.',lib:'pwminput.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27entr\xE9e PWM est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27entr\xE9e PWM sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27entr\xE9e PWM est joignable, <tt>false</tt> sinon'};
doc['PwmInput']['load']={syn:'Met en cache les valeurs courantes de l\x27entr\xE9e PWM, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pwminput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27entr\xE9e PWM, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'pwminput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['PwmInput']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'pwminput.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwminput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['nextPwmInput']={syn:'Continue l\x27\xE9num\xE9ration des Entr\xE9e PWM commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmInput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Entr\xE9e PWM sont retourn\xE9s.',lib:'pwminput.nextPwmInput()',pro:'def nextPwmInput()',cmt:'<p>Continue l\x27\xE9num\xE9ration des Entr\xE9e PWM commenc\xE9e \xE0 l\x27aide de <tt>yFirstPwmInput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les Entr\xE9e PWM sont retourn\xE9s. Si vous souhaitez retrouver une entr\xE9e PWM sp\xE9cifique, utilisez <tt>PwmInput.findPwmInput()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPwmInput</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['PwmInput']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'pwminput.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PwmInput']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pwminput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PwmInput']['resetCounter']={syn:'R\xE9initialise le compteur d\x27impulsions et son timer.',lib:'pwminput.resetCounter()',pro:'def resetCounter()',cmt:'<p>R\xE9initialise le compteur d\x27impulsions et son timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'pwminput.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_debouncePeriod']={syn:'Modifie la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce).',lib:'pwminput.set_debouncePeriod()',pro:'def set_debouncePeriod(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce). Les impulsions plus courtes seront ignor\xE9es.</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e minimale attendue des impulsion, en ms (p\xE9riode de debounce)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'pwminput.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'pwminput.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_logicalName']={syn:'Modifie le nom logique de l\x27entr\xE9e PWM.',lib:'pwminput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27entr\xE9e PWM. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e PWM.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PwmInput']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'pwminput.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_pwmReportMode']={syn:'Modifie le type de param\xE8tre (fr\xE9quence, duty cycle, longueur d\x27impulsion ou nombre de changement d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback.',lib:'pwminput.set_pwmReportMode()',pro:'def set_pwmReportMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de param\xE8tre (fr\xE9quence, duty cycle, longueur d\x27impulsion ou nombre de changement d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback. Seuls les six digits de droite du nombre de changements d\x27\xE9tat sont transmis, pour les valeurs plus grandes que un million, utiliser get_pulseCounter().</p>',par:{newval:'une valeur parmi <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt>, <tt>Y_PWMREPORTMODE_PWM_STATE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQ_CPS</tt> et <tt>Y_PWMREPORTMODE_PWM_FREQ_CPM</tt> repr&eacute;sentant le type de param\xE8tre (fr\xE9quence, duty cycle, longueur d\x27impulsion ou nombre de changement d\x27\xE9tat) renvoy\xE9 par la fonction get_currentValue et les callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'pwminput.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'pwminput.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle la mesure est donn\xE9e.',lib:'pwminput.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle la mesure est donn\xE9e. C\x27est une simple chaine de caract\xE8res automatiquement initialis\xE9e \xE0 chaque changement de mode. Mais elle peut aussi \xEAtre remplac\xE9e par une cha\xEEne arbitraire.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PwmInput']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pwminput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['PwmInput']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'pwminput.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['PwmInput']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'pwminput.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['PwmInput']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'pwminput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: PwmInput)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'Interface de la fonction SegmentedDisplay',inc:'from yocto_segmenteddisplay import *',cmt:'<p>La classe SegmentedDisplay permet de g\xE9rer des afficheurs \xE0 segments</p>'}};
doc['SegmentedDisplay']['FindSegmentedDisplay']={syn:'Permet de retrouver un afficheur d\x27apr\xE8s un identifiant donn\xE9.',lib:'YSegmentedDisplay.FindSegmentedDisplay()',pro:'def FindSegmentedDisplay(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un afficheur d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27afficheur soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YSegmentedDisplay.isOnline()</tt> pour tester si l\x27afficheur est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27afficheur sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YSegmentedDisplay</tt> qui permet ensuite de contr\xF4ler l\x27afficheur.'};
doc['SegmentedDisplay']['FirstSegmentedDisplay']={syn:'Commence l\x27\xE9num\xE9ration des un afficheur accessibles par la librairie.',lib:'YSegmentedDisplay.FirstSegmentedDisplay()',pro:'def FirstSegmentedDisplay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des un afficheur accessibles par la librairie. Utiliser la fonction <tt>YSegmentedDisplay.nextSegmentedDisplay()</tt> pour it\xE9rer sur les autres un afficheur.</p>',ret:'un pointeur sur un objet <tt>YSegmentedDisplay</tt>, correspondant au premier afficheur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de un afficheur disponibles.'};
doc['SegmentedDisplay']['clearCache']={syn:'Invalide le cache.',lib:'segmenteddisplay.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27afficheur. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['SegmentedDisplay']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27afficheur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'segmenteddisplay.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27afficheur au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27afficheur (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27afficheur (pas plus de 6 caract\xE8res).',lib:'segmenteddisplay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27afficheur (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27afficheur (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SegmentedDisplay']['get_displayedText']={syn:'Retourne le texte actuellement affich\xE9 \xE0 l\x27\xE9cran.',lib:'segmenteddisplay.get_displayedText()',pro:'def get_displayedText()',cmt:'<p>Retourne le texte actuellement affich\xE9 \xE0 l\x27\xE9cran.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le texte actuellement affich\xE9 \xE0 l\x27\xE9cran',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DISPLAYEDTEXT_INVALID</tt>.'};
doc['SegmentedDisplay']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27afficheur.',lib:'segmenteddisplay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27afficheur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27afficheur.'};
doc['SegmentedDisplay']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27afficheur.',lib:'segmenteddisplay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27afficheur. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27afficheur.'};
doc['SegmentedDisplay']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27afficheur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'segmenteddisplay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27afficheur au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27afficheur si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27afficheur (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27afficheur en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'segmenteddisplay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['SegmentedDisplay']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27afficheur, sans r\xE9f\xE9rence au module.',lib:'segmenteddisplay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27afficheur, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27afficheur (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27afficheur au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'segmenteddisplay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27afficheur au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27afficheur (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27afficheur (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_logicalName']={syn:'Retourne le nom logique de l\x27afficheur.',lib:'segmenteddisplay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27afficheur.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27afficheur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'segmenteddisplay.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['SegmentedDisplay']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'segmenteddisplay.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['SegmentedDisplay']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27afficheur est joignable, sans d\xE9clencher d\x27erreur.',lib:'segmenteddisplay.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27afficheur est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27afficheur sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27afficheur est joignable, <tt>false</tt> sinon'};
doc['SegmentedDisplay']['load']={syn:'Met en cache les valeurs courantes de l\x27afficheur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'segmenteddisplay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27afficheur, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SegmentedDisplay']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'segmenteddisplay.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['SegmentedDisplay']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'segmenteddisplay.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SegmentedDisplay']['nextSegmentedDisplay']={syn:'Continue l\x27\xE9num\xE9ration des un afficheur commenc\xE9e \xE0 l\x27aide de <tt>yFirstSegmentedDisplay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les un afficheur sont retourn\xE9s.',lib:'segmenteddisplay.nextSegmentedDisplay()',pro:'def nextSegmentedDisplay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des un afficheur commenc\xE9e \xE0 l\x27aide de <tt>yFirstSegmentedDisplay()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les un afficheur sont retourn\xE9s. Si vous souhaitez retrouver un afficheur sp\xE9cifique, utilisez <tt>SegmentedDisplay.findSegmentedDisplay()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YSegmentedDisplay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['SegmentedDisplay']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'segmenteddisplay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['SegmentedDisplay']['set_displayedText']={syn:'Modifie le texte actuellement affich\xE9 \xE0 l\x27\xE9cran.',lib:'segmenteddisplay.set_displayedText()',pro:'def set_displayedText(<span id=pn>newval</span>)',cmt:'<p>Modifie le texte actuellement affich\xE9 \xE0 l\x27\xE9cran.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le texte actuellement affich\xE9 \xE0 l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SegmentedDisplay']['set_logicalName']={syn:'Modifie le nom logique de l\x27afficheur.',lib:'segmenteddisplay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27afficheur. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27afficheur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SegmentedDisplay']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'segmenteddisplay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['SegmentedDisplay']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'segmenteddisplay.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Interface de la fonction Buzzer',inc:'from yocto_buzzer import *',cmt:'<p>La librairie de programmation Yoctopuce permet de choisir la fr\xE9quence et le volume \xE0 laquelle le buzzer doit sonner. Il est aussi possible de pr\xE9-programmer une s\xE9quence \xE0 jouer.</p>'}};
doc['Buzzer']['FindBuzzer']={syn:'Permet de retrouver un buzzer d\x27apr\xE8s un identifiant donn\xE9.',lib:'YBuzzer.FindBuzzer()',pro:'def FindBuzzer(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un buzzer d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le buzzer soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YBuzzer.isOnline()</tt> pour tester si le buzzer est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le buzzer sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YBuzzer</tt> qui permet ensuite de contr\xF4ler le buzzer.'};
doc['Buzzer']['FirstBuzzer']={syn:'Commence l\x27\xE9num\xE9ration des buzzer accessibles par la librairie.',lib:'YBuzzer.FirstBuzzer()',pro:'def FirstBuzzer()',cmt:'<p>Commence l\x27\xE9num\xE9ration des buzzer accessibles par la librairie. Utiliser la fonction <tt>YBuzzer.nextBuzzer()</tt> pour it\xE9rer sur les autres buzzer.</p>',ret:'un pointeur sur un objet <tt>YBuzzer</tt>, correspondant au premier buzzer accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de buzzer disponibles.'};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Ajoute une transition en fr\xE9quence \xE0 la s\xE9quence \xE0 jouer.',lib:'buzzer.addFreqMoveToPlaySeq()',pro:'def addFreqMoveToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDelay</span>)',cmt:'<p>Ajoute une transition en fr\xE9quence \xE0 la s\xE9quence \xE0 jouer.</p>',par:{freq:'fr\xE9quence d\xE9sir\xE9e \xE0 la fin de la transition, en Hz',msDelay:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['addNotesToPlaySeq']={syn:'Ajoute des notes \xE0 la s\xE9quence \xE0 jouer.',lib:'buzzer.addNotesToPlaySeq()',pro:'def addNotesToPlaySeq(<span id=pn>notes</span>)',cmt:'<p>Ajoute des notes \xE0 la s\xE9quence \xE0 jouer. Les notes sont sp\xE9cifi\xE9es sous forme textuelle, s\xE9par\xE9es par des espaces. La hauteur est donn\xE9e par une lettre de A \xE0 G, selon la tradition anglo-saxonne. La dur\xE9e est donn\xE9e par un chiffre, indiquant le diviseur par rapport \xE0 une ronde: 4 pour une noire, 8 pour une croche, etc. Quelques modifieurs sont support\xE9s: le <tt>#</tt> et le <tt>b</tt> pour alt\xE9rer la hauteur des notes, le <tt>\x27</tt> et la <tt>,</tt> pour octavier vers le haut ou vers le bas, le <tt>.</tt> pour allonger la dur\xE9e.</p>',par:{notes:'notes \xE0 ajouter, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Ajoute une impulsion \xE0 la s\xE9quence \xE0 jouer.',lib:'buzzer.addPulseToPlaySeq()',pro:'def addPulseToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDuration</span>)',cmt:'<p>Ajoute une impulsion \xE0 la s\xE9quence \xE0 jouer.</p>',par:{freq:'fr\xE9quence de l\x27impulsion en Hz',msDuration:'dur\xE9e de l\x27impulsion en millisecondes.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Ajoute une transition en volume \xE0 la s\xE9quence \xE0 jouer.',lib:'buzzer.addVolMoveToPlaySeq()',pro:'def addVolMoveToPlaySeq(<span id=pn>volume</span>, <span id=pn>msDuration</span>)',cmt:'<p>Ajoute une transition en volume \xE0 la s\xE9quence \xE0 jouer. La fr\xE9quence courante reste inchang\xE9e: si elle est \xE0 z\xE9ro, la transition n\x27aura aucun effet.</p>',par:{volume:'volume d\xE9sir\xE9 \xE0 la fin de la transition, en pourcentage.',msDuration:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['clearCache']={syn:'Invalide le cache.',lib:'buzzer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du buzzer. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Buzzer']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du buzzer au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'buzzer.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du buzzer au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le buzzer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Buzzer']['freqMove']={syn:'Fait varier la fr\xE9quence du buzzer pendant un temps donn\xE9.',lib:'buzzer.freqMove()',pro:'def freqMove(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Fait varier la fr\xE9quence du buzzer pendant un temps donn\xE9.</p>',par:{frequency:'fr\xE9quence \xE0 atteindre en hertz, une fr\xE9quence inf\xE9rieure \xE0 25Hz arr\xEAtera le buzzer.',duration:'dur\xE9e de l\x27impulsion en milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['get_advertisedValue']={syn:'Retourne la valeur courante du buzzer (pas plus de 6 caract\xE8res).',lib:'buzzer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du buzzer (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du buzzer (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Buzzer']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du buzzer.',lib:'buzzer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du buzzer. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du buzzer.'};
doc['Buzzer']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du buzzer.',lib:'buzzer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du buzzer. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du buzzer.'};
doc['Buzzer']['get_frequency']={syn:'Retourne la fr\xE9quence du signal envoy\xE9 sur le buzzer/haut parleur.',lib:'buzzer.get_frequency()',pro:'def get_frequency()',cmt:'<p>Retourne la fr\xE9quence du signal envoy\xE9 sur le buzzer/haut parleur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du signal envoy\xE9 sur le buzzer/haut parleur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Buzzer']['get_friendlyName']={syn:'Retourne un identifiant global du buzzer au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'buzzer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du buzzer au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du buzzer si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du buzzer (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le buzzer en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Buzzer']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'buzzer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Buzzer']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du buzzer, sans r\xE9f\xE9rence au module.',lib:'buzzer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du buzzer, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le buzzer (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Buzzer']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du buzzer au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'buzzer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du buzzer au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du buzzer (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le buzzer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Buzzer']['get_logicalName']={syn:'Retourne le nom logique du buzzer.',lib:'buzzer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du buzzer.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du buzzer.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Buzzer']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'buzzer.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Buzzer']['get_playSeqMaxSize']={syn:'Retourne la longueur maximum de la s\xE9quence \xE0 jouer.',lib:'buzzer.get_playSeqMaxSize()',pro:'def get_playSeqMaxSize()',cmt:'<p>Retourne la longueur maximum de la s\xE9quence \xE0 jouer.</p>',ret:'un entier repr&eacute;sentant la longueur maximum de la s\xE9quence \xE0 jouer',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PLAYSEQMAXSIZE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSignature']={syn:'Retourne la signature de la signature de la s\xE9quence \xE0 jouer.',lib:'buzzer.get_playSeqSignature()',pro:'def get_playSeqSignature()',cmt:'<p>Retourne la signature de la signature de la s\xE9quence \xE0 jouer. Les s\xE9quences \xE0 jouer ne pouvant pas \xEAtre relues depuis le module, ce m\xE9canisme peut \xEAtre utilis\xE9 pour d\xE9tecter si une s\xE9quence sp\xE9cifique est d\xE9j\xE0 programm\xE9e.</p>',ret:'un entier repr&eacute;sentant la signature de la signature de la s\xE9quence \xE0 jouer',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PLAYSEQSIGNATURE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSize']={syn:'Retourne la longueur actuelle de la s\xE9quence \xE0 jouer.',lib:'buzzer.get_playSeqSize()',pro:'def get_playSeqSize()',cmt:'<p>Retourne la longueur actuelle de la s\xE9quence \xE0 jouer.</p>',ret:'un entier repr&eacute;sentant la longueur actuelle de la s\xE9quence \xE0 jouer',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PLAYSEQSIZE_INVALID</tt>.'};
doc['Buzzer']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'buzzer.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Buzzer']['get_volume']={syn:'Retourne le volume du signal envoy\xE9 sur le buzzer/haut parleur.',lib:'buzzer.get_volume()',pro:'def get_volume()',cmt:'<p>Retourne le volume du signal envoy\xE9 sur le buzzer/haut parleur.</p>',ret:'un entier repr&eacute;sentant le volume du signal envoy\xE9 sur le buzzer/haut parleur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUME_INVALID</tt>.'};
doc['Buzzer']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le buzzer est joignable, sans d\xE9clencher d\x27erreur.',lib:'buzzer.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le buzzer est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du buzzer sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le buzzer est joignable, <tt>false</tt> sinon'};
doc['Buzzer']['load']={syn:'Met en cache les valeurs courantes du buzzer, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'buzzer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du buzzer, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'buzzer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Buzzer']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'buzzer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['nextBuzzer']={syn:'Continue l\x27\xE9num\xE9ration des buzzer commenc\xE9e \xE0 l\x27aide de <tt>yFirstBuzzer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les buzzer sont retourn\xE9s.',lib:'buzzer.nextBuzzer()',pro:'def nextBuzzer()',cmt:'<p>Continue l\x27\xE9num\xE9ration des buzzer commenc\xE9e \xE0 l\x27aide de <tt>yFirstBuzzer()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les buzzer sont retourn\xE9s. Si vous souhaitez retrouver un buzzer sp\xE9cifique, utilisez <tt>Buzzer.findBuzzer()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YBuzzer</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Buzzer']['oncePlaySeq']={syn:'D\xE9marre l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e, pour une seule ex\xE9cution.',lib:'buzzer.oncePlaySeq()',pro:'def oncePlaySeq()',cmt:'<p>D\xE9marre l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e, pour une seule ex\xE9cution.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['playNotes']={syn:'Joue imm\xE9diatement une s\xE9quence de notes.',lib:'buzzer.playNotes()',pro:'def playNotes(<span id=pn>notes</span>)',cmt:'<p>Joue imm\xE9diatement une s\xE9quence de notes. Les notes sont sp\xE9cifi\xE9es sous forme textuelle, s\xE9par\xE9es par des espaces. La hauteur est donn\xE9e par une lettre de A \xE0 G, selon la tradition anglo-saxonne. La dur\xE9e est donn\xE9e par un chiffre, indiquant le diviseur par rapport \xE0 une ronde: 4 pour une noire, 8 pour une croche, etc. Quelques modifieurs sont support\xE9s: le <tt>#</tt> et le <tt>b</tt> pour alt\xE9rer la hauteur des notes, le <tt>\x27</tt> et la <tt>,</tt> pour octavier vers le haut ou vers le bas, le <tt>.</tt> pour allonger la dur\xE9e.</p>',par:{notes:'notes \xE0 ajouter, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['pulse']={syn:'Active le buzzer pendant un temps donn\xE9.',lib:'buzzer.pulse()',pro:'def pulse(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Active le buzzer pendant un temps donn\xE9.</p>',par:{frequency:'fr\xE9quence de l\x27impulsion, en hertz',duration:'dur\xE9e de l\x27impulsion en milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'buzzer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Buzzer']['resetPlaySeq']={syn:'efface le contenu de la sequence \xE0 jouer et mets la fr\xE9quence \xE0 z\xE9ro.',lib:'buzzer.resetPlaySeq()',pro:'def resetPlaySeq()',cmt:'<p>efface le contenu de la sequence \xE0 jouer et mets la fr\xE9quence \xE0 z\xE9ro.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['set_frequency']={syn:'Modifie la fr\xE9quence du signal envoy\xE9 sur le buzzer/speaker.',lib:'buzzer.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence du signal envoy\xE9 sur le buzzer/speaker. Une fr\xE9quence nulle stoppe le buzzer.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence du signal envoy\xE9 sur le buzzer/speaker'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Buzzer']['set_logicalName']={syn:'Modifie le nom logique du buzzer.',lib:'buzzer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du buzzer. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du buzzer.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'buzzer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Buzzer']['set_volume']={syn:'Modifie le volume du signal envoy\xE9 sur le buzzer/haut parleur.',lib:'buzzer.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Modifie le volume du signal envoy\xE9 sur le buzzer/haut parleur.</p>',par:{newval:'un entier repr&eacute;sentant le volume du signal envoy\xE9 sur le buzzer/haut parleur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Buzzer']['startPlaySeq']={syn:'D\xE9marre l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e.',lib:'buzzer.startPlaySeq()',pro:'def startPlaySeq()',cmt:'<p>D\xE9marre l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e. La s\xE9quence va tourner en boucle jusqu\x27\xE0 ce qu\x27elle soit stopp\xE9e par stopPlaySeq ou un changement explicite. Pour ne jouer qu\x27un seule fois la s\xE9quence, utiliser la m\xE9thode <tt>oncePlaySeq()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['stopPlaySeq']={syn:'Arr\xEAte l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e et mets la fr\xE9quence \xE0 z\xE9ro.',lib:'buzzer.stopPlaySeq()',pro:'def stopPlaySeq()',cmt:'<p>Arr\xEAte l\x27ex\xE9cution de la s\xE9quence \xE0 jouer pr\xE9programm\xE9e et mets la fr\xE9quence \xE0 z\xE9ro.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'buzzer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Buzzer']['volumeMove']={syn:'Fait varier le volume du buzzer pendant un temps donn\xE9, la fr\xE9quence reste inchang\xE9e.',lib:'buzzer.volumeMove()',pro:'def volumeMove(<span id=pn>volume</span>, <span id=pn>duration</span>)',cmt:'<p>Fait varier le volume du buzzer pendant un temps donn\xE9, la fr\xE9quence reste inchang\xE9e.</p>',par:{volume:'volume \xE0 atteindre en %.',duration:'dur\xE9e de la transition en milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Buzzer)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Interface de contr\xF4le pour la mise \xE0 jour de firmware',inc:'from yocto_api import *',cmt:'<p>La classe YFirmwareUpdate permet de contr\xF4ler la mise \xE0 jour du de firmware d\x27un module Yoctopuce. Cette classe ne doit pas \xEAtre instancier directement, mais est retourn\xE9e par la m\xE9thode <tt>updateFirmware</tt> de l\x27un objet YModule.</p>'}};
doc['FirmwareUpdate']['CheckFirmware']={syn:'Teste si le fichier byn est valide pour le module.',lib:'YFirmwareUpdate.CheckFirmware()',pro:'def CheckFirmware(<span id=pn>serial</span>, <span id=pn>path</span>, <span id=pn>minrelease</span>)',cmt:'<p>Teste si le fichier byn est valide pour le module. Il est possible de passer un r\xE9pertoire qui contient plusieurs fichiers byn. Dans ce cas cette m\xE9thode retourne le path du fichier byn compatible le plus r\xE9cent. Cette fonction ignore les firmwares qui sont plus anciens que minrelease.</p>',par:{serial:'le num\xE9ro de s\xE9rie du module \xE0 mettre \xE0 jour',path:'le path sur un fichier byn ou un r\xE9pertoire contenant plusieurs fichiers byn',minrelease:'un entier positif'},ret:'le path du fichier byn \xE0 utiliser, ou une cha\xEEne vide si aucun firmware plus r\xE9cent n\x27est disponible En cas d\x27erreur, retourne une cha\xEEne de caract\xE8re qui comment par \x22error:\x22.'};
doc['FirmwareUpdate']['GetAllBootLoaders']={syn:'Retourne la liste des modules en mode \x22mise \xE0 jour\x22.',lib:'YFirmwareUpdate.GetAllBootLoaders()',pro:'def GetAllBootLoaders()',cmt:'<p>Retourne la liste des modules en mode \x22mise \xE0 jour\x22. Seuls les modules connect\xE9s en USB sont list\xE9s. Pour les modules connect\xE9s \xE0 un YoctoHub, il faut se connecter \xE0 l\x27interface web du YoctoHub.</p>',ret:'un tableau de cha\xEEnes de caract\xE8res contenant les num\xE9ros de s\xE9rie des modules en attente de \x22mise \xE0 jour\x22'};
doc['FirmwareUpdate']['get_progress']={syn:'Retourne l\x27\xE9tat d\x27avancement de la mise \xE0 jour de firmware, sur une \xE9chelle de 0 \xE0 100.',lib:'firmwareupdate.get_progress()',pro:'def get_progress()',cmt:'<p>Retourne l\x27\xE9tat d\x27avancement de la mise \xE0 jour de firmware, sur une \xE9chelle de 0 \xE0 100. A l\x27instanciation de l\x27objet l\x27avancement est nul. Au fur et \xE0 mesure l\x27avancement progresse pour atteindre la valeur 100. Quand la valeur de 100 est retourn\xE9 la mise \xE0 jour s\x27est termin\xE9e avec succ\xE8s. En cas d\x27erreur pendant la mise \xE0 jour une valeur n\xE9gative est retourn\xE9e et la description de l\x27erreur peu \xEAtre obtenu avec la m\xE9thode <tt>get_progressMessage</tt>.</p>',ret:'un nombre entier entre 0 et 100 repr\xE9sentant l\x27avancement de la mise \xE0 jour du firmware, ou un code d\x27erreur n\xE9gatif en cas de probl\xE8me.'};
doc['FirmwareUpdate']['get_progressMessage']={syn:'le dernier message de la mise \xE0 jour de firmware.',lib:'firmwareupdate.get_progressMessage()',pro:'def get_progressMessage()',cmt:'<p>le dernier message de la mise \xE0 jour de firmware. En cas d\x27erreur durant la mise \xE0 jour le message d\x27erreur est retourn\xE9.</p>',ret:'un cha\xEEne de caract\xE8re avec le dernier message, ou le message d\x27erreur si la mise \xE0 jour n\x27a pas r\xE9ussi'};
doc['FirmwareUpdate']['startUpdate']={syn:'D\xE9marre la mise \xE0 jour de firmware.',lib:'firmwareupdate.startUpdate()',pro:'def startUpdate()',cmt:'<p>D\xE9marre la mise \xE0 jour de firmware. La m\xE9thode d\xE9marre en arri\xE8re plan le processus de mise \xE0 jour de firmware. Cet m\xE9thode rend la main imm\xE9diatement. l\x27\xE9tat d\x27avancement de la mise \xE0 jour peut \xEAtre suivit \xE0 l\x27aide des m\xE9thodes <tt>get_progress()</tt> et <tt>get_progressMessage()</tt>.</p>',ret:'un nombre entier entre 0 et 100 repr\xE9sentant l\x27avancement de la mise \xE0 jour du firmware, ou un code d\x27erreur n\xE9gatif en cas de probl\xE8me.',ext:'En cas d\x27erreur, un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'Interface de la fonction GPS',inc:'from yocto_gps import *',cmt:'<p>La fonction Gps permet d\x27extraire les donn\xE9es de positionnement du module GPS. Cette classe permet d\x27obtenir toutes les informations n\xE9cessaires. Cependant, si vous souhaitez d\xE9finir des callbacks sur des changement de position, utilisez plut\xF4t les classes YLatitude et YLongitude.</p>'}};
doc['Gps']['FindGps']={syn:'Permet de retrouver un GPS d\x27apr\xE8s un identifiant donn\xE9.',lib:'YGps.FindGps()',pro:'def FindGps(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un GPS d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le GPS soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YGps.isOnline()</tt> pour tester si le GPS est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le GPS sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YGps</tt> qui permet ensuite de contr\xF4ler le GPS.'};
doc['Gps']['FirstGps']={syn:'Commence l\x27\xE9num\xE9ration des le GPS accessibles par la librairie.',lib:'YGps.FirstGps()',pro:'def FirstGps()',cmt:'<p>Commence l\x27\xE9num\xE9ration des le GPS accessibles par la librairie. Utiliser la fonction <tt>YGps.nextGps()</tt> pour it\xE9rer sur les autres le GPS.</p>',ret:'un pointeur sur un objet <tt>YGps</tt>, correspondant au premier GPS accessible en ligne, ou <tt>null</tt> si il n\x27y a pas du GPS disponibles.'};
doc['Gps']['clearCache']={syn:'Invalide le cache.',lib:'gps.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du GPS. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Gps']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du GPS au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gps.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du GPS au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le GPS (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gps']['get_advertisedValue']={syn:'Retourne la valeur courante du GPS (pas plus de 6 caract\xE8res).',lib:'gps.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du GPS (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du GPS (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gps']['get_altitude']={syn:'Retourne l\x27altitude courante, Attention: la technologie GPS ne permet d\x27obtenir une altitude pr\xE9cise, des erreurs de plusieurs dizaine des m\xE8tres sont courantes.',lib:'gps.get_altitude()',pro:'def get_altitude()',cmt:'<p>Retourne l\x27altitude courante, Attention: la technologie GPS ne permet d\x27obtenir une altitude pr\xE9cise, des erreurs de plusieurs dizaine des m\xE8tres sont courantes.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant l\x27altitude courante, Attention: la technologie GPS ne permet d\x27obtenir une altitude pr\xE9cise, des erreurs de plusieurs dizaine des m\xE8tres sont courantes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ALTITUDE_INVALID</tt>.'};
doc['Gps']['get_coordSystem']={syn:'Retourne le syst\xE8me de repr\xE9sentation utilis\xE9 pour les donn\xE9es de positionnement.',lib:'gps.get_coordSystem()',pro:'def get_coordSystem()',cmt:'<p>Retourne le syst\xE8me de repr\xE9sentation utilis\xE9 pour les donn\xE9es de positionnement.</p>',ret:'une valeur parmi <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> et <tt>Y_COORDSYSTEM_GPS_D</tt> repr&eacute;sentant le syst\xE8me de repr\xE9sentation utilis\xE9 pour les donn\xE9es de positionnement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COORDSYSTEM_INVALID</tt>.'};
doc['Gps']['get_dateTime']={syn:'Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22.',lib:'gps.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Retourne l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27heure courante au format \x22AAAA/MM/JJ hh:mm:ss\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DATETIME_INVALID</tt>.'};
doc['Gps']['get_dilution']={syn:'Retourne la dilution de pr\xE9cision horizontale.',lib:'gps.get_dilution()',pro:'def get_dilution()',cmt:'<p>Retourne la dilution de pr\xE9cision horizontale. Plus ce chiffre est petit, plus la pr\xE9cision est grande.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la dilution de pr\xE9cision horizontale',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DILUTION_INVALID</tt>.'};
doc['Gps']['get_direction']={syn:'Retourne la direction du d\xE9placement en degr\xE9s par rapport au nord vrai (g\xE9ographique).',lib:'gps.get_direction()',pro:'def get_direction()',cmt:'<p>Retourne la direction du d\xE9placement en degr\xE9s par rapport au nord vrai (g\xE9ographique).</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la direction du d\xE9placement en degr\xE9s par rapport au nord vrai (g\xE9ographique)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DIRECTION_INVALID</tt>.'};
doc['Gps']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du GPS.',lib:'gps.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du GPS. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du GPS.'};
doc['Gps']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du GPS.',lib:'gps.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du GPS. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du GPS.'};
doc['Gps']['get_friendlyName']={syn:'Retourne un identifiant global du GPS au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'gps.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du GPS au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du GPS si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du GPS (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le GPS en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gps']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'gps.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Gps']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du GPS, sans r\xE9f\xE9rence au module.',lib:'gps.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du GPS, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le GPS (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gps']['get_groundSpeed']={syn:'Retourne la vitesse au sol actuelle en Km/h.',lib:'gps.get_groundSpeed()',pro:'def get_groundSpeed()',cmt:'<p>Retourne la vitesse au sol actuelle en Km/h.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse au sol actuelle en Km/h',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_GROUNDSPEED_INVALID</tt>.'};
doc['Gps']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du GPS au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'gps.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du GPS au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du GPS (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le GPS (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gps']['get_isFixed']={syn:'Retourne TRUE si le r\xE9cepteur a trouv\xE9 suffisamment de satellites pour fonctionner.',lib:'gps.get_isFixed()',pro:'def get_isFixed()',cmt:'<p>Retourne TRUE si le r\xE9cepteur a trouv\xE9 suffisamment de satellites pour fonctionner.</p>',ret:'soit <tt>Y_ISFIXED_FALSE</tt>, soit <tt>Y_ISFIXED_TRUE</tt>, selon TRUE si le r\xE9cepteur a trouv\xE9 suffisamment de satellites pour fonctionner',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ISFIXED_INVALID</tt>.'};
doc['Gps']['get_latitude']={syn:'Retourne la latitude courante.',lib:'gps.get_latitude()',pro:'def get_latitude()',cmt:'<p>Retourne la latitude courante.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la latitude courante',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LATITUDE_INVALID</tt>.'};
doc['Gps']['get_logicalName']={syn:'Retourne le nom logique du GPS.',lib:'gps.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du GPS.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du GPS.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gps']['get_longitude']={syn:'Retourne la longitude courante.',lib:'gps.get_longitude()',pro:'def get_longitude()',cmt:'<p>Retourne la longitude courante.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la longitude courante',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LONGITUDE_INVALID</tt>.'};
doc['Gps']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'gps.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Gps']['get_satCount']={syn:'Retourne le nombre de satellites visibles.',lib:'gps.get_satCount()',pro:'def get_satCount()',cmt:'<p>Retourne le nombre de satellites visibles.</p>',ret:'un entier repr&eacute;sentant le nombre de satellites visibles',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SATCOUNT_INVALID</tt>.'};
doc['Gps']['get_unixTime']={syn:'Retourne l\x27heure courante au format Unix (nombre de secondes \xE9coul\xE9es depuis le 1er janvier 1970).',lib:'gps.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Retourne l\x27heure courante au format Unix (nombre de secondes \xE9coul\xE9es depuis le 1er janvier 1970).</p>',ret:'un entier repr&eacute;sentant l\x27heure courante au format Unix (nombre de secondes \xE9coul\xE9es depuis le 1er janvier 1970)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['Gps']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'gps.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Gps']['get_utcOffset']={syn:'Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'gps.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Retourne le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone).</p>',ret:'un entier repr&eacute;sentant le nombre de secondes de d\xE9callage entre l\x27heure courante et l\x27heure UTC (time zone)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['Gps']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le GPS est joignable, sans d\xE9clencher d\x27erreur.',lib:'gps.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le GPS est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du GPS sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le GPS est joignable, <tt>false</tt> sinon'};
doc['Gps']['load']={syn:'Met en cache les valeurs courantes du GPS, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'gps.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du GPS, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gps']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'gps.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Gps']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'gps.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gps']['nextGps']={syn:'Continue l\x27\xE9num\xE9ration des le GPS commenc\xE9e \xE0 l\x27aide de <tt>yFirstGps()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le GPS sont retourn\xE9s.',lib:'gps.nextGps()',pro:'def nextGps()',cmt:'<p>Continue l\x27\xE9num\xE9ration des le GPS commenc\xE9e \xE0 l\x27aide de <tt>yFirstGps()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le GPS sont retourn\xE9s. Si vous souhaitez retrouver un GPS sp\xE9cifique, utilisez <tt>Gps.findGps()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YGps</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Gps']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'gps.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Gps']['set_coordSystem']={syn:'Change le syst\xE8me de repr\xE9sentation utilis\xE9 pour les donn\xE9es de positionnement.',lib:'gps.set_coordSystem()',pro:'def set_coordSystem(<span id=pn>newval</span>)',cmt:'<p>Change le syst\xE8me de repr\xE9sentation utilis\xE9 pour les donn\xE9es de positionnement.</p>',par:{newval:'une valeur parmi <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> et <tt>Y_COORDSYSTEM_GPS_D</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gps']['set_logicalName']={syn:'Modifie le nom logique du GPS.',lib:'gps.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du GPS. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du GPS.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Gps']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'gps.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Gps']['set_utcOffset']={syn:'Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone).',lib:'gps.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone). Le d\xE9callage est automatiquement arrondi au quart d\x27heure le plus proche. Si l\x27heure UTC est connue, l\x27heure courante sera automatiquement adapt\xE9e en fonction du d\xE9calage choisi.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de secondes de d\xE9calage entre l\x27heure courante et l\x27heure UTC (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Gps']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'gps.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Gps)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Interface de la fonction Latitude',inc:'from yocto_latitude import *',cmt:'<p>La classe YLatitude permet de lire la latitude sur les capteurs de g\xE9olocalisation Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Latitude']['FindLatitude']={syn:'Permet de retrouver un capteur de latitude d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLatitude.FindLatitude()',pro:'def FindLatitude(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de latitude d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de latitude soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLatitude.isOnline()</tt> pour tester si le capteur de latitude est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de latitude sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLatitude</tt> qui permet ensuite de contr\xF4ler le capteur de latitude.'};
doc['Latitude']['FirstLatitude']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de latitude accessibles par la librairie.',lib:'YLatitude.FirstLatitude()',pro:'def FirstLatitude()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de latitude accessibles par la librairie. Utiliser la fonction <tt>YLatitude.nextLatitude()</tt> pour it\xE9rer sur les autres capteurs de latitude.</p>',ret:'un pointeur sur un objet <tt>YLatitude</tt>, correspondant au premier capteur delatitude accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de latitude disponibles.'};
doc['Latitude']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'latitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Latitude']['clearCache']={syn:'Invalide le cache.',lib:'latitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de latitude. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Latitude']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de latitude au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'latitude.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de latitude au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de latitude (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Latitude']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'latitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Latitude']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de latitude (pas plus de 6 caract\xE8res).',lib:'latitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de latitude (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de latitude (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule.',lib:'latitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentValue']={syn:'Retourne la valeur actuelle de la latitude, en deg/1000, sous forme de nombre \xE0 virgule.',lib:'latitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la latitude, en deg/1000, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la latitude, en deg/1000, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Latitude']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'latitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Latitude']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de latitude.',lib:'latitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de latitude. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de latitude.'};
doc['Latitude']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de latitude.',lib:'latitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de latitude. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de latitude.'};
doc['Latitude']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de latitude au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'latitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de latitude au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de latitude si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de latitude (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de latitude en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Latitude']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'latitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Latitude']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de latitude, sans r\xE9f\xE9rence au module.',lib:'latitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de latitude, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de latitude (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Latitude']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de latitude au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'latitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de latitude au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de latitude (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de latitude (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Latitude']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la latitude depuis le d\xE9marrage du module.',lib:'latitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la latitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la latitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'latitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_logicalName']={syn:'Retourne le nom logique du capteur de latitude.',lib:'latitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de latitude.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de latitude.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Latitude']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la latitude depuis le d\xE9marrage du module.',lib:'latitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la latitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la latitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'latitude.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Latitude']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'latitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Latitude']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'latitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'latitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Latitude']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'latitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Latitude']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la latitude est exprim\xE9e.',lib:'latitude.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la latitude est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la latitude est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Latitude']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'latitude.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Latitude']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de latitude est joignable, sans d\xE9clencher d\x27erreur.',lib:'latitude.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de latitude est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de latitude sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de latitude est joignable, <tt>false</tt> sinon'};
doc['Latitude']['load']={syn:'Met en cache les valeurs courantes du capteur de latitude, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'latitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de latitude, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Latitude']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'latitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Latitude']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'latitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Latitude']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'latitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Latitude']['nextLatitude']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de latitude commenc\xE9e \xE0 l\x27aide de <tt>yFirstLatitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de latitude sont retourn\xE9s.',lib:'latitude.nextLatitude()',pro:'def nextLatitude()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de latitude commenc\xE9e \xE0 l\x27aide de <tt>yFirstLatitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de latitude sont retourn\xE9s. Si vous souhaitez retrouver un capteur de latitude sp\xE9cifique, utilisez <tt>Latitude.findLatitude()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YLatitude</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Latitude']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'latitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Latitude']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'latitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Latitude']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'latitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'latitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'latitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_logicalName']={syn:'Modifie le nom logique du capteur de latitude.',lib:'latitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de latitude. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de latitude.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Latitude']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'latitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'latitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'latitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Latitude']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'latitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Latitude']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'latitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Latitude']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'latitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Latitude']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'latitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Interface de la fonction Longitude',inc:'from yocto_longitude import *',cmt:'<p>La classe YLongitude permet de lire la longitude sur les capteurs de g\xE9olocalisation Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Longitude']['FindLongitude']={syn:'Permet de retrouver un capteur de longitude d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLongitude.FindLongitude()',pro:'def FindLongitude(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de longitude d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de longitude soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLongitude.isOnline()</tt> pour tester si le capteur de longitude est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de longitude sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLongitude</tt> qui permet ensuite de contr\xF4ler le capteur de longitude.'};
doc['Longitude']['FirstLongitude']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de longitude accessibles par la librairie.',lib:'YLongitude.FirstLongitude()',pro:'def FirstLongitude()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de longitude accessibles par la librairie. Utiliser la fonction <tt>YLongitude.nextLongitude()</tt> pour it\xE9rer sur les autres capteurs de longitude.</p>',ret:'un pointeur sur un objet <tt>YLongitude</tt>, correspondant au premier capteur delongitude accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de longitude disponibles.'};
doc['Longitude']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'longitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Longitude']['clearCache']={syn:'Invalide le cache.',lib:'longitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de longitude. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Longitude']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de longitude au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'longitude.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de longitude au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de longitude (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Longitude']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'longitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Longitude']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de longitude (pas plus de 6 caract\xE8res).',lib:'longitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de longitude (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de longitude (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule.',lib:'longitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en deg/1000, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentValue']={syn:'Retourne la valeur actuelle de la longitude, en deg/1000, sous forme de nombre \xE0 virgule.',lib:'longitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la longitude, en deg/1000, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la longitude, en deg/1000, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Longitude']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'longitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Longitude']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de longitude.',lib:'longitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de longitude. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de longitude.'};
doc['Longitude']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de longitude.',lib:'longitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de longitude. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de longitude.'};
doc['Longitude']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de longitude au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'longitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de longitude au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de longitude si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de longitude (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de longitude en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Longitude']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'longitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Longitude']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de longitude, sans r\xE9f\xE9rence au module.',lib:'longitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de longitude, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de longitude (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Longitude']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de longitude au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'longitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de longitude au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de longitude (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de longitude (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Longitude']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la longitude depuis le d\xE9marrage du module.',lib:'longitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la longitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la longitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'longitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_logicalName']={syn:'Retourne le nom logique du capteur de longitude.',lib:'longitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de longitude.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de longitude.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Longitude']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la longitude depuis le d\xE9marrage du module.',lib:'longitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la longitude depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la longitude depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'longitude.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Longitude']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'longitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Longitude']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'longitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'longitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Longitude']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'longitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Longitude']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la longitude est exprim\xE9e.',lib:'longitude.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la longitude est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la longitude est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Longitude']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'longitude.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Longitude']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de longitude est joignable, sans d\xE9clencher d\x27erreur.',lib:'longitude.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de longitude est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de longitude sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de longitude est joignable, <tt>false</tt> sinon'};
doc['Longitude']['load']={syn:'Met en cache les valeurs courantes du capteur de longitude, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'longitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de longitude, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Longitude']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'longitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Longitude']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'longitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Longitude']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'longitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Longitude']['nextLongitude']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de longitude commenc\xE9e \xE0 l\x27aide de <tt>yFirstLongitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de longitude sont retourn\xE9s.',lib:'longitude.nextLongitude()',pro:'def nextLongitude()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de longitude commenc\xE9e \xE0 l\x27aide de <tt>yFirstLongitude()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de longitude sont retourn\xE9s. Si vous souhaitez retrouver un capteur de longitude sp\xE9cifique, utilisez <tt>Longitude.findLongitude()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YLongitude</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Longitude']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'longitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Longitude']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'longitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Longitude']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'longitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'longitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'longitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_logicalName']={syn:'Modifie le nom logique du capteur de longitude.',lib:'longitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de longitude. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de longitude.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Longitude']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'longitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'longitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'longitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Longitude']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'longitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Longitude']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'longitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Longitude']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'longitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Longitude']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'longitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'Interface de la fonction GroundSpeed',inc:'from yocto_groundspeed import *',cmt:'<p>La classe YGroundSpeed permet de lire la vitesse sol sur les capteurs de g\xE9olocalisation Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['GroundSpeed']['FindGroundSpeed']={syn:'Permet de retrouver un capteur de vitesse/sol d\x27apr\xE8s un identifiant donn\xE9.',lib:'YGroundSpeed.FindGroundSpeed()',pro:'def FindGroundSpeed(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de vitesse/sol d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de vitesse/sol soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YGroundSpeed.isOnline()</tt> pour tester si le capteur de vitesse/sol est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de vitesse/sol sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YGroundSpeed</tt> qui permet ensuite de contr\xF4ler le capteur de vitesse/sol.'};
doc['GroundSpeed']['FirstGroundSpeed']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de vitesse/sol accessibles par la librairie.',lib:'YGroundSpeed.FirstGroundSpeed()',pro:'def FirstGroundSpeed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de vitesse/sol accessibles par la librairie. Utiliser la fonction <tt>YGroundSpeed.nextGroundSpeed()</tt> pour it\xE9rer sur les autres capteurs de vitesse/sol.</p>',ret:'un pointeur sur un objet <tt>YGroundSpeed</tt>, correspondant au premier capteur vitesse/sol accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de vitesse/sol disponibles.'};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'groundspeed.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GroundSpeed']['clearCache']={syn:'Invalide le cache.',lib:'groundspeed.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de vitesse/sol. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['GroundSpeed']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de vitesse/sol au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'groundspeed.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de vitesse/sol au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de vitesse/sol (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GroundSpeed']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'groundspeed.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GroundSpeed']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de vitesse/sol (pas plus de 6 caract\xE8res).',lib:'groundspeed.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de vitesse/sol (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de vitesse/sol (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en km/h, sous forme de nombre \xE0 virgule.',lib:'groundspeed.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en km/h, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en km/h, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentValue']={syn:'Retourne la valeur actuelle de la vitesse/sol, en km/h, sous forme de nombre \xE0 virgule.',lib:'groundspeed.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la vitesse/sol, en km/h, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la vitesse/sol, en km/h, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'groundspeed.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['GroundSpeed']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de vitesse/sol.',lib:'groundspeed.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de vitesse/sol. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de vitesse/sol.'};
doc['GroundSpeed']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de vitesse/sol.',lib:'groundspeed.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de vitesse/sol. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de vitesse/sol.'};
doc['GroundSpeed']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de vitesse/sol au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'groundspeed.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de vitesse/sol au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de vitesse/sol si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de vitesse/sol (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de vitesse/sol en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'groundspeed.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['GroundSpeed']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de vitesse/sol, sans r\xE9f\xE9rence au module.',lib:'groundspeed.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de vitesse/sol, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de vitesse/sol (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GroundSpeed']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de vitesse/sol au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'groundspeed.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de vitesse/sol au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de vitesse/sol (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de vitesse/sol (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GroundSpeed']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module.',lib:'groundspeed.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'groundspeed.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_logicalName']={syn:'Retourne le nom logique du capteur de vitesse/sol.',lib:'groundspeed.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de vitesse/sol.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de vitesse/sol.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module.',lib:'groundspeed.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la vitesse/sol depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'groundspeed.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['GroundSpeed']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'groundspeed.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'groundspeed.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'groundspeed.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GroundSpeed']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'groundspeed.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GroundSpeed']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la vitesse/sol est exprim\xE9e.',lib:'groundspeed.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la vitesse/sol est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la vitesse/sol est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['GroundSpeed']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'groundspeed.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['GroundSpeed']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de vitesse/sol est joignable, sans d\xE9clencher d\x27erreur.',lib:'groundspeed.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de vitesse/sol est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de vitesse/sol sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de vitesse/sol est joignable, <tt>false</tt> sinon'};
doc['GroundSpeed']['load']={syn:'Met en cache les valeurs courantes du capteur de vitesse/sol, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'groundspeed.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de vitesse/sol, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GroundSpeed']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'groundspeed.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'groundspeed.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GroundSpeed']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'groundspeed.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GroundSpeed']['nextGroundSpeed']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de vitesse/sol commenc\xE9e \xE0 l\x27aide de <tt>yFirstGroundSpeed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de vitesse/sol sont retourn\xE9s.',lib:'groundspeed.nextGroundSpeed()',pro:'def nextGroundSpeed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de vitesse/sol commenc\xE9e \xE0 l\x27aide de <tt>yFirstGroundSpeed()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de vitesse/sol sont retourn\xE9s. Si vous souhaitez retrouver un capteur de vitesse/sol sp\xE9cifique, utilisez <tt>GroundSpeed.findGroundSpeed()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YGroundSpeed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['GroundSpeed']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'groundspeed.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['GroundSpeed']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'groundspeed.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['GroundSpeed']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'groundspeed.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'groundspeed.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'groundspeed.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_logicalName']={syn:'Modifie le nom logique du capteur de vitesse/sol.',lib:'groundspeed.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de vitesse/sol. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de vitesse/sol.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['GroundSpeed']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'groundspeed.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'groundspeed.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'groundspeed.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['GroundSpeed']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'groundspeed.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['GroundSpeed']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'groundspeed.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'groundspeed.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['GroundSpeed']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'groundspeed.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: GroundSpeed)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'Interface d\x27alimentation de sortie',inc:'from yocto_poweroutput import *',cmt:'<p>La librairie de programmation Yoctopuce permet de contr\xF4ler l\x27alimentation mise a disposition sur certain module tels que le Yocto-Serial</p>'}};
doc['PowerOutput']['FindPowerOutput']={syn:'Permet de retrouver une alimentation d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPowerOutput.FindPowerOutput()',pro:'def FindPowerOutput(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une alimentation d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27alimentation soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPowerOutput.isOnline()</tt> pour tester si l\x27alimentation est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27alimentation sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPowerOutput</tt> qui permet ensuite de contr\xF4ler l\x27alimentation.'};
doc['PowerOutput']['FirstPowerOutput']={syn:'Commence l\x27\xE9num\xE9ration des alimentation accessibles par la librairie.',lib:'YPowerOutput.FirstPowerOutput()',pro:'def FirstPowerOutput()',cmt:'<p>Commence l\x27\xE9num\xE9ration des alimentation accessibles par la librairie. Utiliser la fonction <tt>YPowerOutput.nextPowerOutput()</tt> pour it\xE9rer sur les autres alimentation.</p>',ret:'un pointeur sur un objet <tt>YPowerOutput</tt>, correspondant \xE0 la premiere alimentation accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de alimentation disponibles.'};
doc['PowerOutput']['clearCache']={syn:'Invalide le cache.',lib:'poweroutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27alimentation. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['PowerOutput']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27alimentation au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'poweroutput.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27alimentation au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27alimentation (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerOutput']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27alimentation (pas plus de 6 caract\xE8res).',lib:'poweroutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27alimentation (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27alimentation (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerOutput']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation.',lib:'poweroutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27alimentation.'};
doc['PowerOutput']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation.',lib:'poweroutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27alimentation.'};
doc['PowerOutput']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27alimentation au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'poweroutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27alimentation au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27alimentation si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27alimentation (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerOutput']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'poweroutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['PowerOutput']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27alimentation, sans r\xE9f\xE9rence au module.',lib:'poweroutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27alimentation, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerOutput']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27alimentation au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'poweroutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27alimentation au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27alimentation (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerOutput']['get_logicalName']={syn:'Retourne le nom logique de l\x27alimentation.',lib:'poweroutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27alimentation.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27alimentation.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerOutput']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'poweroutput.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['PowerOutput']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'poweroutput.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['PowerOutput']['get_voltage']={syn:'Retourne le voltage envoy\xE9 sur l\x27alimentation mise \xE0 disposition sur le module.',lib:'poweroutput.get_voltage()',pro:'def get_voltage()',cmt:'<p>Retourne le voltage envoy\xE9 sur l\x27alimentation mise \xE0 disposition sur le module.</p>',ret:'une valeur parmi <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> et <tt>Y_VOLTAGE_OUT5V</tt> repr&eacute;sentant le voltage envoy\xE9 sur l\x27alimentation mise \xE0 disposition sur le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['PowerOutput']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27alimentation est joignable, sans d\xE9clencher d\x27erreur.',lib:'poweroutput.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27alimentation est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27alimentation sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27alimentation est joignable, <tt>false</tt> sinon'};
doc['PowerOutput']['load']={syn:'Met en cache les valeurs courantes de l\x27alimentation, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'poweroutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27alimentation, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerOutput']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'poweroutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['PowerOutput']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'poweroutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerOutput']['nextPowerOutput']={syn:'Continue l\x27\xE9num\xE9ration des alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstPowerOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les alimentation sont retourn\xE9s.',lib:'poweroutput.nextPowerOutput()',pro:'def nextPowerOutput()',cmt:'<p>Continue l\x27\xE9num\xE9ration des alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstPowerOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les alimentation sont retourn\xE9s. Si vous souhaitez retrouver une alimentation sp\xE9cifique, utilisez <tt>PowerOutput.findPowerOutput()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPowerOutput</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['PowerOutput']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'poweroutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PowerOutput']['set_logicalName']={syn:'Modifie le nom logique de l\x27alimentation.',lib:'poweroutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27alimentation. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27alimentation.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerOutput']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'poweroutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['PowerOutput']['set_voltage']={syn:'Modifie le voltage de l\x27alimentation mise \xE0 disposition par le module.',lib:'poweroutput.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Modifie le voltage de l\x27alimentation mise \xE0 disposition par le module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> et <tt>Y_VOLTAGE_OUT5V</tt> repr&eacute;sentant le voltage de l\x27alimentation mise \xE0 disposition par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerOutput']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'poweroutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: PowerOutput)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Interface de la fonction Cellular',inc:'from yocto_cellular import *',cmt:'<p>La fonction YCellular permet de configurer et de contr\xF4ler la configuration du r\xE9seau cellulaire sur les modules Yoctopuce qui en sont dot\xE9s.</p>'}};
doc['Cellular']['FindCellular']={syn:'Permet de retrouver une interface cellulaire d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCellular.FindCellular()',pro:'def FindCellular(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface cellulaire d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27interface cellulaire soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCellular.isOnline()</tt> pour tester si l\x27interface cellulaire est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface cellulaire sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCellular</tt> qui permet ensuite de contr\xF4ler l\x27interface cellulaire.'};
doc['Cellular']['FirstCellular']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire accessibles par la librairie.',lib:'YCellular.FirstCellular()',pro:'def FirstCellular()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire accessibles par la librairie. Utiliser la fonction <tt>YCellular.nextCellular()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau cellulaire.</p>',ret:'un pointeur sur un objet <tt>YCellular</tt>, correspondant \xE0 la premi\xE8re interface cellulaire accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau cellulaire disponibles.'};
doc['Cellular']['_AT']={syn:'Envoie une commande AT au module GSM, et retourne le r\xE9sultat.',lib:'cellular._AT()',pro:'def _AT(<span id=pn>cmd</span>)',cmt:'<p>Envoie une commande AT au module GSM, et retourne le r\xE9sultat. La commande ne s\x27ex\xE9cute que lorsque le module GSM dans un \xE9tat standard, et doit le laisser exactement dans le m\xEAme \xE9tat. N\x27utilisez cette fonction qu\x27avec la plus grande prudence !</p>',par:{cmd:'la commande AT \xE0 ex\xE9cuter, comme par exemple: \x22+CCLK?\x22'},ret:'une cha\xEEne de caract\xE8res contenant le r\xE9sultat de la commande. Les lignes vides sont automatiquement filtr\xE9es du r\xE9sultat.'};
doc['Cellular']['clearCache']={syn:'Invalide le cache.',lib:'cellular.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27interface cellulaire. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Cellular']['clearDataCounters']={syn:'R\xE9initialise les compteurs de donn\xE9es transmises et re\xE7ues.',lib:'cellular.clearDataCounters()',pro:'def clearDataCounters()',cmt:'<p>R\xE9initialise les compteurs de donn\xE9es transmises et re\xE7ues.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface cellulaire au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'cellular.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface cellulaire au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27interface cellulaire (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Cellular']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).',lib:'cellular.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Cellular']['get_airplaneMode']={syn:'Retourne vrai si le mode avion est activ\xE9 (radio d\xE9sactiv\xE9e).',lib:'cellular.get_airplaneMode()',pro:'def get_airplaneMode()',cmt:'<p>Retourne vrai si le mode avion est activ\xE9 (radio d\xE9sactiv\xE9e).</p>',ret:'soit <tt>Y_AIRPLANEMODE_OFF</tt>, soit <tt>Y_AIRPLANEMODE_ON</tt>, selon vrai si le mode avion est activ\xE9 (radio d\xE9sactiv\xE9e)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_AIRPLANEMODE_INVALID</tt>.'};
doc['Cellular']['get_apn']={syn:'Retourne le nom du point d\x27acc\xE8s (APN) \xE0 utiliser, si n\xE9cessaire.',lib:'cellular.get_apn()',pro:'def get_apn()',cmt:'<p>Retourne le nom du point d\x27acc\xE8s (APN) \xE0 utiliser, si n\xE9cessaire. Lorsque l\x27APN est vide, celui propos\xE9 par l\x27op\xE9rateur cellulaire est utilis\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du point d\x27acc\xE8s (APN) \xE0 utiliser, si n\xE9cessaire',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_APN_INVALID</tt>.'};
doc['Cellular']['get_apnSecret']={syn:'Retourne une string opaque si des param\xE8tres d\x27identification sur l\x27APN ont \xE9t\xE9 configur\xE9s dans le module, ou une cha\xEEne vide autrement.',lib:'cellular.get_apnSecret()',pro:'def get_apnSecret()',cmt:'<p>Retourne une string opaque si des param\xE8tres d\x27identification sur l\x27APN ont \xE9t\xE9 configur\xE9s dans le module, ou une cha\xEEne vide autrement. Pour configurer ces param\xE8tres, utilisez la m\xE9thode <tt>set_apnAuth()</tt>.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une string opaque si des param\xE8tres d\x27identification sur l\x27APN ont \xE9t\xE9 configur\xE9s dans le module, ou une cha\xEEne vide autrement',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_APNSECRET_INVALID</tt>.'};
doc['Cellular']['get_availableOperators']={syn:'Retourne la liste des op\xE9rateurs GSM disponibles \xE0 proximit\xE9.',lib:'cellular.get_availableOperators()',pro:'def get_availableOperators()',cmt:'<p>Retourne la liste des op\xE9rateurs GSM disponibles \xE0 proximit\xE9. Cette fonction peut typiquement prendre 30 secondes \xE0 une minute pour rendre la main. Notez qu\x27en g\xE9n\xE9ral une SIM ne permet de se connecter qu\x27\xE0 certains op\xE9rateur, et donc pas forc\xE9ment \xE0 tous ceux list\xE9s par cette fonction.</p>',ret:'une liste de noms d\x27op\xE9rateur.'};
doc['Cellular']['get_cellIdentifier']={syn:'Retourne l\x27identifiant unique de la station de base utilis\xE9e: MCC, MNC, LAC et Cell ID.',lib:'cellular.get_cellIdentifier()',pro:'def get_cellIdentifier()',cmt:'<p>Retourne l\x27identifiant unique de la station de base utilis\xE9e: MCC, MNC, LAC et Cell ID.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27identifiant unique de la station de base utilis\xE9e: MCC, MNC, LAC et Cell ID',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CELLIDENTIFIER_INVALID</tt>.'};
doc['Cellular']['get_cellOperator']={syn:'Retourne le nom de l\x27op\xE9rateur de r\xE9seau cellulaire actuellement utilis\xE9.',lib:'cellular.get_cellOperator()',pro:'def get_cellOperator()',cmt:'<p>Retourne le nom de l\x27op\xE9rateur de r\xE9seau cellulaire actuellement utilis\xE9.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom de l\x27op\xE9rateur de r\xE9seau cellulaire actuellement utilis\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CELLOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_cellType']={syn:'Type de connection cellulaire active.',lib:'cellular.get_cellType()',pro:'def get_cellType()',cmt:'<p>Type de connection cellulaire active.</p>',ret:'une valeur parmi <tt>Y_CELLTYPE_GPRS</tt>, <tt>Y_CELLTYPE_EGPRS</tt>, <tt>Y_CELLTYPE_WCDMA</tt>, <tt>Y_CELLTYPE_HSDPA</tt>, <tt>Y_CELLTYPE_NONE</tt> et <tt>Y_CELLTYPE_CDMA</tt>',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CELLTYPE_INVALID</tt>.'};
doc['Cellular']['get_dataReceived']={syn:'Retourne le nombre d\x27octets re\xE7us jusqu\x27\xE0 pr\xE9sent.',lib:'cellular.get_dataReceived()',pro:'def get_dataReceived()',cmt:'<p>Retourne le nombre d\x27octets re\xE7us jusqu\x27\xE0 pr\xE9sent.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets re\xE7us jusqu\x27\xE0 pr\xE9sent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DATARECEIVED_INVALID</tt>.'};
doc['Cellular']['get_dataSent']={syn:'Retourne le nombre d\x27octets envoy\xE9s jusqu\x27\xE0 pr\xE9sent.',lib:'cellular.get_dataSent()',pro:'def get_dataSent()',cmt:'<p>Retourne le nombre d\x27octets envoy\xE9s jusqu\x27\xE0 pr\xE9sent.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets envoy\xE9s jusqu\x27\xE0 pr\xE9sent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DATASENT_INVALID</tt>.'};
doc['Cellular']['get_enableData']={syn:'Retourne la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9.',lib:'cellular.get_enableData()',pro:'def get_enableData()',cmt:'<p>Retourne la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9. Lorsque le service de donn\xE9e n\x27est pas actif, seules les communications par SMS sont possibles.</p>',ret:'une valeur parmi <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> et <tt>Y_ENABLEDATA_NEUTRALITY</tt> repr&eacute;sentant la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ENABLEDATA_INVALID</tt>.'};
doc['Cellular']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire.',lib:'cellular.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface cellulaire.'};
doc['Cellular']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire.',lib:'cellular.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface cellulaire.'};
doc['Cellular']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27interface cellulaire au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'cellular.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27interface cellulaire au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27interface cellulaire si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27interface cellulaire (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Cellular']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'cellular.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Cellular']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27interface cellulaire, sans r\xE9f\xE9rence au module.',lib:'cellular.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27interface cellulaire, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Cellular']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27interface cellulaire au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'cellular.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27interface cellulaire au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27interface cellulaire (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Cellular']['get_imsi']={syn:'Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.',lib:'cellular.get_imsi()',pro:'def get_imsi()',cmt:'<p>Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_IMSI_INVALID</tt>.'};
doc['Cellular']['get_linkQuality']={syn:'Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.',lib:'cellular.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.</p>',ret:'un entier repr&eacute;sentant la qualit\xE9 de la connection, exprim\xE9e en pourcents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Cellular']['get_lockedOperator']={syn:'Retourne le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser exclusivement, si le choix automatique est d\xE9sactiv\xE9, ou une cha\xEEne vide si la carte SIM s\xE9lectionne automatiquement l\x27op\xE9rateur selon ceux disponibles.',lib:'cellular.get_lockedOperator()',pro:'def get_lockedOperator()',cmt:'<p>Retourne le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser exclusivement, si le choix automatique est d\xE9sactiv\xE9, ou une cha\xEEne vide si la carte SIM s\xE9lectionne automatiquement l\x27op\xE9rateur selon ceux disponibles.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser exclusivement, si le choix automatique est d\xE9sactiv\xE9, ou une cha\xEEne vide si la carte SIM s\xE9lectionne automatiquement l\x27op\xE9rateur selon ceux disponibles',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOCKEDOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface cellulaire.',lib:'cellular.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface cellulaire.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface cellulaire.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Cellular']['get_message']={syn:'Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.',lib:'cellular.get_message()',pro:'def get_message()',cmt:'<p>Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Cellular']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'cellular.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Cellular']['get_pin']={syn:'Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.',lib:'cellular.get_pin()',pro:'def get_pin()',cmt:'<p>Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour acc\xE9der \xE0 la carte SIM, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PIN_INVALID</tt>.'};
doc['Cellular']['get_pingInterval']={syn:'Retourne l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes.',lib:'cellular.get_pingInterval()',pro:'def get_pingInterval()',cmt:'<p>Retourne l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes.</p>',ret:'un entier repr&eacute;sentant l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PINGINTERVAL_INVALID</tt>.'};
doc['Cellular']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'cellular.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Cellular']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27interface cellulaire est joignable, sans d\xE9clencher d\x27erreur.',lib:'cellular.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27interface cellulaire est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27interface cellulaire sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27interface cellulaire est joignable, <tt>false</tt> sinon'};
doc['Cellular']['load']={syn:'Met en cache les valeurs courantes de l\x27interface cellulaire, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'cellular.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27interface cellulaire, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'cellular.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Cellular']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'cellular.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['nextCellular']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire commenc\xE9e \xE0 l\x27aide de <tt>yFirstCellular()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau cellulaire sont retourn\xE9s.',lib:'cellular.nextCellular()',pro:'def nextCellular()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire commenc\xE9e \xE0 l\x27aide de <tt>yFirstCellular()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau cellulaire sont retourn\xE9s. Si vous souhaitez retrouver une interface cellulaire sp\xE9cifique, utilisez <tt>Cellular.findCellular()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YCellular</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Cellular']['quickCellSurvey']={syn:'Retourne la liste d\x27identifiants pour les antennes GSM \xE0 proximit\xE9, telle que requise pour g\xE9olocaliser rapidement le module.',lib:'cellular.quickCellSurvey()',pro:'def quickCellSurvey()',cmt:'<p>Retourne la liste d\x27identifiants pour les antennes GSM \xE0 proximit\xE9, telle que requise pour g\xE9olocaliser rapidement le module. La premi\xE8re antenne list\xE9e est la cellule active, et les suivantes sont les cellules voisines list\xE9e par la cellule active.</p>',ret:'une liste de YCellRecord.'};
doc['Cellular']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'cellular.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Cellular']['sendPUK']={syn:'Envoie le code PUK \xE0 la carte SIM pour la d\xE9bloquer apr\xE8s trois \xE9checs cons\xE9cutifs de code PIN, et \xE9tablit un nouveau code PIN dans la SIM.',lib:'cellular.sendPUK()',pro:'def sendPUK(<span id=pn>puk</span>, <span id=pn>newPin</span>)',cmt:'<p>Envoie le code PUK \xE0 la carte SIM pour la d\xE9bloquer apr\xE8s trois \xE9checs cons\xE9cutifs de code PIN, et \xE9tablit un nouveau code PIN dans la SIM. Seules dix tentatives cons\xE9cutives de d\xE9blocage sont possibles: apr\xE8s dix tentatives infructueuses, la carte SIM sera d\xE9finitivement inutilisable. Apr\xE8s avoir appel\xE9 cette fonction, vous devrez aussi appeler la m\xE9thode <tt>set_pin()</tt> pour indiquer au YoctoHub le nouveau PIN \xE0 utiliser dans le futur.</p>',par:{puk:'code PUK de la carte SIM',newPin:'nouveau code PIN \xE0 configurer dans la carte SIM'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['set_airplaneMode']={syn:'Modifie l\x27\xE9tat du mode avion (radio d\xE9sactiv\xE9e).',lib:'cellular.set_airplaneMode()',pro:'def set_airplaneMode(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du mode avion (radio d\xE9sactiv\xE9e).</p>',par:{newval:'soit <tt>Y_AIRPLANEMODE_OFF</tt>, soit <tt>Y_AIRPLANEMODE_ON</tt>, selon l\x27\xE9tat du mode avion (radio d\xE9sactiv\xE9e)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_apn']={syn:'Retourne le nom du point d\x27acc\xE8s (APN) \xE0 utiliser, si n\xE9cessaire.',lib:'cellular.set_apn()',pro:'def set_apn(<span id=pn>newval</span>)',cmt:'<p>Retourne le nom du point d\x27acc\xE8s (APN) \xE0 utiliser, si n\xE9cessaire. Lorsque l\x27APN est vide, celui propos\xE9 par l\x27op\xE9rateur cellulaire est utilis\xE9e.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_apnAuth']={syn:'Configure les param\xE8tres d\x27identification pour se connecter \xE0 l\x27APN.',lib:'cellular.set_apnAuth()',pro:'def set_apnAuth(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Configure les param\xE8tres d\x27identification pour se connecter \xE0 l\x27APN. Les protocoles PAP et CHAP sont tous deux support\xE9s.</p>',par:{username:'nom d\x27utilisateur',password:'mot de passe'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['set_dataReceived']={syn:'Modifie la valeur du compteur d\x27octets re\xE7us.',lib:'cellular.set_dataReceived()',pro:'def set_dataReceived(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur du compteur d\x27octets re\xE7us.</p>',par:{newval:'un entier repr&eacute;sentant la valeur du compteur d\x27octets re\xE7us'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_dataSent']={syn:'Modifie la valeur du compteur d\x27octets envoy\xE9s.',lib:'cellular.set_dataSent()',pro:'def set_dataSent(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur du compteur d\x27octets envoy\xE9s.</p>',par:{newval:'un entier repr&eacute;sentant la valeur du compteur d\x27octets envoy\xE9s'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_enableData']={syn:'Modifie la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9.',lib:'cellular.set_enableData()',pro:'def set_enableData(<span id=pn>newval</span>)',cmt:'<p>Modifie la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9. Le service peut \xEAtre soit compl\xE8tement d\xE9sactiv\xE9, soit limit\xE9 au r\xE9seau de de l\x27\xE9metteur de la carte SIM, soit \xEAtre activ\xE9 pour tous les r\xE9seaux en partenariat avec la carte SIM (roaming). Attention, l\x27utilisation de donn\xE9es en roaming peut conduire \xE0 des co\xFBts de t\xE9l\xE9communication exhorbitants !</p><p> Lorsque le service de donn\xE9e n\x27est pas actif, seules les communications par SMS sont possibles.</p>',par:{newval:'une valeur parmi <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> et <tt>Y_ENABLEDATA_NEUTRALITY</tt> repr&eacute;sentant la condition dans laquelle le service de donn\xE9es IP (GRPS) doit \xEAtre activ\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_lockedOperator']={syn:'Modifie le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser.',lib:'cellular.set_lockedOperator()',pro:'def set_lockedOperator(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser. Si le nom est une cha\xEEne vide, le choix sera fait automatiquement selon la carte SIM. Sinon, seul l\x27op\xE9rateur choisi sera utilis\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom de l\x27op\xE9rateur de r\xE9seau cellulaire \xE0 utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface cellulaire.',lib:'cellular.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface cellulaire. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface cellulaire.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Cellular']['set_pin']={syn:'Modifie le code PIN utilis\xE9 par le module pour acc\xE9der \xE0 la carte SIM.',lib:'cellular.set_pin()',pro:'def set_pin(<span id=pn>newval</span>)',cmt:'<p>Modifie le code PIN utilis\xE9 par le module pour acc\xE9der \xE0 la carte SIM. Cette fonction ne change pas le code sur la carte SIM elle-m\xEAme, mais uniquement le param\xE8tre utilis\xE9 par le module pour essayer d\x27en obtenir l\x27acc\xE8s. Si le code SIM ne fonctionne pas d\xE8s le premier essai, il sera automatiquement oubli\xE9 et un message \x22Enter SIM PIN\x22 appara\xEEtre dans l\x27attribut \x27message\x27. Il faudra alors appeler \xE0 nouveau cette m\xE9thode avec le bon code PIN. Apr\xE8s trois essais infructueux cons\xE9cutifs le message devient \x22Enter SIM PUK\x22 et il faut alors entrer le code PUK de la carte SIM avec la m\xE9thode <tt>sendPUK</tt>.</p><p> N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module pour que le param\xE8tre soit sauvegard\xE9 dans la flash.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le code PIN utilis\xE9 par le module pour acc\xE9der \xE0 la carte SIM'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_pingInterval']={syn:'Modifie l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes.',lib:'cellular.set_pingInterval()',pro:'def set_pingInterval(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes.</p>',par:{newval:'un entier repr&eacute;sentant l\x27intervalle entre les tests de connectivit\xE9 spontan\xE9s, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Cellular']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'cellular.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Cellular']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'cellular.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Cellular)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'Interface de la fonction AudioOut',inc:'from yocto_audioout import *',cmt:'<p>La librairie de programmation Yoctopuce permet de configurer le volume de la sortie audio.</p>'}};
doc['AudioOut']['FindAudioOut']={syn:'Permet de retrouver une sortie audio d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAudioOut.FindAudioOut()',pro:'def FindAudioOut(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une sortie audio d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la sortie audio soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAudioOut.isOnline()</tt> pour tester si la sortie audio est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la sortie audio sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAudioOut</tt> qui permet ensuite de contr\xF4ler la sortie audio.'};
doc['AudioOut']['FirstAudioOut']={syn:'Commence l\x27\xE9num\xE9ration des sorties audio accessibles par la librairie.',lib:'YAudioOut.FirstAudioOut()',pro:'def FirstAudioOut()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sorties audio accessibles par la librairie. Utiliser la fonction <tt>YAudioOut.nextAudioOut()</tt> pour it\xE9rer sur les autres sorties audio.</p>',ret:'un pointeur sur un objet <tt>YAudioOut</tt>, correspondant \xE0 la premi\xE8re sortie audio accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sorties audio disponibles.'};
doc['AudioOut']['clearCache']={syn:'Invalide le cache.',lib:'audioout.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la sortie audio. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['AudioOut']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie audio au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioout.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie audio au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la sortie audio (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioOut']['get_advertisedValue']={syn:'Retourne la valeur courante de la sortie audio (pas plus de 6 caract\xE8res).',lib:'audioout.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la sortie audio (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la sortie audio (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioOut']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie audio.',lib:'audioout.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie audio. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie audio.'};
doc['AudioOut']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie audio.',lib:'audioout.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie audio. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie audio.'};
doc['AudioOut']['get_friendlyName']={syn:'Retourne un identifiant global de la sortie audio au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'audioout.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la sortie audio au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la sortie audio si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la sortie audio (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie audio en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioOut']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'audioout.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['AudioOut']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la sortie audio, sans r\xE9f\xE9rence au module.',lib:'audioout.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la sortie audio, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie audio (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioOut']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la sortie audio au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioout.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la sortie audio au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la sortie audio (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie audio (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioOut']['get_logicalName']={syn:'Retourne le nom logique de la sortie audio.',lib:'audioout.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la sortie audio.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie audio.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioOut']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'audioout.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['AudioOut']['get_mute']={syn:'Retourne l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.',lib:'audioout.get_mute()',pro:'def get_mute()',cmt:'<p>Retourne l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.</p>',ret:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioOut']['get_noSignalFor']={syn:'Retourne le nombre de secondes sans signal d\xE9tect\xE9.',lib:'audioout.get_noSignalFor()',pro:'def get_noSignalFor()',cmt:'<p>Retourne le nombre de secondes sans signal d\xE9tect\xE9.</p>',ret:'un entier repr&eacute;sentant le nombre de secondes sans signal d\xE9tect\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioOut']['get_signal']={syn:'Retourne l\x27amplitude du courant \xE9mis d\xE9tect\xE9.',lib:'audioout.get_signal()',pro:'def get_signal()',cmt:'<p>Retourne l\x27amplitude du courant \xE9mis d\xE9tect\xE9.</p>',ret:'un entier repr&eacute;sentant l\x27amplitude du courant \xE9mis d\xE9tect\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioOut']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'audioout.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['AudioOut']['get_volume']={syn:'Retourne le volume de la sortie audio, en pour cents.',lib:'audioout.get_volume()',pro:'def get_volume()',cmt:'<p>Retourne le volume de la sortie audio, en pour cents.</p>',ret:'un entier repr&eacute;sentant le volume de la sortie audio, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioOut']['get_volumeRange']={syn:'Retourne la plage de valeurs support\xE9es pour le volume.',lib:'audioout.get_volumeRange()',pro:'def get_volumeRange()',cmt:'<p>Retourne la plage de valeurs support\xE9es pour le volume. La valeur basse de l\x27intervalle correspond au volume minimal audible. Pour couper compl\xE8tement le son, utilisez <tt>set_mute()</tt> et non le <tt>set_volume()</tt>.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de valeurs support\xE9es pour le volume',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioOut']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la sortie audio est joignable, sans d\xE9clencher d\x27erreur.',lib:'audioout.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la sortie audio est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la sortie audio sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la sortie audio est joignable, <tt>false</tt> sinon'};
doc['AudioOut']['load']={syn:'Met en cache les valeurs courantes de la sortie audio, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'audioout.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la sortie audio, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioOut']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'audioout.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['AudioOut']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'audioout.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioOut']['nextAudioOut']={syn:'Continue l\x27\xE9num\xE9ration des sorties audio commenc\xE9e \xE0 l\x27aide de <tt>yFirstAudioOut()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sorties audio sont retourn\xE9s.',lib:'audioout.nextAudioOut()',pro:'def nextAudioOut()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sorties audio commenc\xE9e \xE0 l\x27aide de <tt>yFirstAudioOut()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sorties audio sont retourn\xE9s. Si vous souhaitez retrouver une sortie audio sp\xE9cifique, utilisez <tt>AudioOut.findAudioOut()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YAudioOut</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['AudioOut']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'audioout.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['AudioOut']['set_logicalName']={syn:'Modifie le nom logique de la sortie audio.',lib:'audioout.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la sortie audio. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie audio.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioOut']['set_mute']={syn:'Modifie l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.',lib:'audioout.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si vous d\xE9sirez que le r\xE9glage soit pr\xE9serv\xE9 au prochain red\xE9marrage.</p>',par:{newval:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AudioOut']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'audioout.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['AudioOut']['set_volume']={syn:'Modifie le volume de la sortie audio, en pour cents.',lib:'audioout.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Modifie le volume de la sortie audio, en pour cents.</p>',par:{newval:'un entier repr&eacute;sentant le volume de la sortie audio, en pour cents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AudioOut']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'audioout.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: AudioOut)
//--- (generated code: BluetoothLink)
doc['BluetoothLink']={'':{syn:'Interface de la fonction BluetoothLink',inc:'from yocto_bluetoothlink import *',cmt:'<p>La fonction BluetoothLink permet de configurer et de contr\xF4ler une liaison bluetooth sur les modules Yoctopuce qui en sont dot\xE9s.</p>'}};
doc['BluetoothLink']['FindBluetoothLink']={syn:'Permet de retrouver une interface cellulaire d\x27apr\xE8s un identifiant donn\xE9.',lib:'YBluetoothLink.FindBluetoothLink()',pro:'def FindBluetoothLink(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface cellulaire d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27interface cellulaire soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YBluetoothLink.isOnline()</tt> pour tester si l\x27interface cellulaire est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface cellulaire sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YBluetoothLink</tt> qui permet ensuite de contr\xF4ler l\x27interface cellulaire.'};
doc['BluetoothLink']['FirstBluetoothLink']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire accessibles par la librairie.',lib:'YBluetoothLink.FirstBluetoothLink()',pro:'def FirstBluetoothLink()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire accessibles par la librairie. Utiliser la fonction <tt>YBluetoothLink.nextBluetoothLink()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau cellulaire.</p>',ret:'un pointeur sur un objet <tt>YBluetoothLink</tt>, correspondant \xE0 la premi\xE8re interface cellulaire accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau cellulaire disponibles.'};
doc['BluetoothLink']['clearCache']={syn:'Invalide le cache.',lib:'bluetoothlink.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27interface cellulaire. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['BluetoothLink']['connect']={syn:'Etablit la connection bluetooth avec l\x27appareil distant pr\xE9alablement choisi.',lib:'bluetoothlink.connect()',pro:'def connect()',cmt:'<p>Etablit la connection bluetooth avec l\x27appareil distant pr\xE9alablement choisi.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['BluetoothLink']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface cellulaire au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'bluetoothlink.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface cellulaire au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27interface cellulaire (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['BluetoothLink']['disconnect']={syn:'Interrompt la connection bluetooth avec l\x27appareil distant.',lib:'bluetoothlink.disconnect()',pro:'def disconnect()',cmt:'<p>Interrompt la connection bluetooth avec l\x27appareil distant.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['BluetoothLink']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).',lib:'bluetoothlink.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface cellulaire (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['BluetoothLink']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire.',lib:'bluetoothlink.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface cellulaire.'};
doc['BluetoothLink']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire.',lib:'bluetoothlink.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface cellulaire. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface cellulaire.'};
doc['BluetoothLink']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27interface cellulaire au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'bluetoothlink.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27interface cellulaire au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27interface cellulaire si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27interface cellulaire (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'bluetoothlink.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['BluetoothLink']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27interface cellulaire, sans r\xE9f\xE9rence au module.',lib:'bluetoothlink.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27interface cellulaire, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['BluetoothLink']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27interface cellulaire au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'bluetoothlink.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27interface cellulaire au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27interface cellulaire (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface cellulaire (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['BluetoothLink']['get_linkQuality']={syn:'Retourne la qualit\xE9 du signal bluetooth re\xE7u, en pourcents, ou 0 si aucune connection n\x27est active.',lib:'bluetoothlink.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Retourne la qualit\xE9 du signal bluetooth re\xE7u, en pourcents, ou 0 si aucune connection n\x27est active.</p>',ret:'un entier repr&eacute;sentant la qualit\xE9 du signal bluetooth re\xE7u, en pourcents, ou 0 si aucune connection n\x27est active',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['BluetoothLink']['get_linkState']={syn:'Retourne l\x27\xE9tat du lien bluetooth re\xE7u.',lib:'bluetoothlink.get_linkState()',pro:'def get_linkState()',cmt:'<p>Retourne l\x27\xE9tat du lien bluetooth re\xE7u.</p>',ret:'une valeur parmi <tt>Y_LINKSTATE_DOWN</tt>, <tt>Y_LINKSTATE_FREE</tt>, <tt>Y_LINKSTATE_SEARCH</tt>, <tt>Y_LINKSTATE_EXISTS</tt>, <tt>Y_LINKSTATE_LINKED</tt> et <tt>Y_LINKSTATE_PLAY</tt> repr&eacute;sentant l\x27\xE9tat du lien bluetooth re\xE7u',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LINKSTATE_INVALID</tt>.'};
doc['BluetoothLink']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface cellulaire.',lib:'bluetoothlink.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface cellulaire.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface cellulaire.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'bluetoothlink.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['BluetoothLink']['get_mute']={syn:'Retourne l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.',lib:'bluetoothlink.get_mute()',pro:'def get_mute()',cmt:'<p>Retourne l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.</p>',ret:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MUTE_INVALID</tt>.'};
doc['BluetoothLink']['get_ownAddress']={syn:'Retourne l\x27adresse MAC-48 de l\x27interface bluetooth, unique sur le r\xE9seau bluetooth.',lib:'bluetoothlink.get_ownAddress()',pro:'def get_ownAddress()',cmt:'<p>Retourne l\x27adresse MAC-48 de l\x27interface bluetooth, unique sur le r\xE9seau bluetooth.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse MAC-48 de l\x27interface bluetooth, unique sur le r\xE9seau bluetooth',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OWNADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_pairingPin']={syn:'Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour le pairing, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.',lib:'bluetoothlink.get_pairingPin()',pro:'def get_pairingPin()',cmt:'<p>Retourne une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour le pairing, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant une string opaque si un code PIN a \xE9t\xE9 configur\xE9 dans le module pour le pairing, ou une cha\xEEne vide il n\x27a pas \xE9t\xE9 configur\xE9 ou si la SIM a rejet\xE9 le code indiqu\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PAIRINGPIN_INVALID</tt>.'};
doc['BluetoothLink']['get_preAmplifier']={syn:'Retourne le volume du pr\xE9-amplificateur audio, en pour cents.',lib:'bluetoothlink.get_preAmplifier()',pro:'def get_preAmplifier()',cmt:'<p>Retourne le volume du pr\xE9-amplificateur audio, en pour cents.</p>',ret:'un entier repr&eacute;sentant le volume du pr\xE9-amplificateur audio, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PREAMPLIFIER_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteAddress']={syn:'Retourne l\x27adresse MAC-48 bluetooth de l\x27appareil distant \xE0 connecter.',lib:'bluetoothlink.get_remoteAddress()',pro:'def get_remoteAddress()',cmt:'<p>Retourne l\x27adresse MAC-48 bluetooth de l\x27appareil distant \xE0 connecter.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse MAC-48 bluetooth de l\x27appareil distant \xE0 connecter',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REMOTEADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteName']={syn:'Retourne le nom bluetooth de l\x27appareil distant, si vu sur le r\xE9seau bluetooth.',lib:'bluetoothlink.get_remoteName()',pro:'def get_remoteName()',cmt:'<p>Retourne le nom bluetooth de l\x27appareil distant, si vu sur le r\xE9seau bluetooth.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom bluetooth de l\x27appareil distant, si vu sur le r\xE9seau bluetooth',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REMOTENAME_INVALID</tt>.'};
doc['BluetoothLink']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'bluetoothlink.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['BluetoothLink']['get_volume']={syn:'Retourne le volume de l\x27\xE9couteur connect\xE9, en pour cents.',lib:'bluetoothlink.get_volume()',pro:'def get_volume()',cmt:'<p>Retourne le volume de l\x27\xE9couteur connect\xE9, en pour cents.</p>',ret:'un entier repr&eacute;sentant le volume de l\x27\xE9couteur connect\xE9, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUME_INVALID</tt>.'};
doc['BluetoothLink']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27interface cellulaire est joignable, sans d\xE9clencher d\x27erreur.',lib:'bluetoothlink.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27interface cellulaire est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27interface cellulaire sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27interface cellulaire est joignable, <tt>false</tt> sinon'};
doc['BluetoothLink']['load']={syn:'Met en cache les valeurs courantes de l\x27interface cellulaire, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'bluetoothlink.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27interface cellulaire, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['BluetoothLink']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'bluetoothlink.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['BluetoothLink']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'bluetoothlink.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['BluetoothLink']['nextBluetoothLink']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire commenc\xE9e \xE0 l\x27aide de <tt>yFirstBluetoothLink()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau cellulaire sont retourn\xE9s.',lib:'bluetoothlink.nextBluetoothLink()',pro:'def nextBluetoothLink()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau cellulaire commenc\xE9e \xE0 l\x27aide de <tt>yFirstBluetoothLink()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces r\xE9seau cellulaire sont retourn\xE9s. Si vous souhaitez retrouver une interface cellulaire sp\xE9cifique, utilisez <tt>BluetoothLink.findBluetoothLink()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YBluetoothLink</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['BluetoothLink']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'bluetoothlink.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['BluetoothLink']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface cellulaire.',lib:'bluetoothlink.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface cellulaire. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface cellulaire.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['BluetoothLink']['set_mute']={syn:'Modifie l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio.',lib:'bluetoothlink.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si vous d\xE9sirez que le r\xE9glage soit pr\xE9serv\xE9 au prochain red\xE9marrage.</p>',par:{newval:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de la sortie audio'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['BluetoothLink']['set_pairingPin']={syn:'Modifie le code PIN utilis\xE9 par le module pour le pairing bluetooth.',lib:'bluetoothlink.set_pairingPin()',pro:'def set_pairingPin(<span id=pn>newval</span>)',cmt:'<p>Modifie le code PIN utilis\xE9 par le module pour le pairing bluetooth. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module pour que le param\xE8tre soit sauvegard\xE9 dans la flash.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le code PIN utilis\xE9 par le module pour le pairing bluetooth'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['BluetoothLink']['set_preAmplifier']={syn:'Modifie le volume du pr\xE9-amplificateur audio, en pour cents.',lib:'bluetoothlink.set_preAmplifier()',pro:'def set_preAmplifier(<span id=pn>newval</span>)',cmt:'<p>Modifie le volume du pr\xE9-amplificateur audio, en pour cents.</p>',par:{newval:'un entier repr&eacute;sentant le volume du pr\xE9-amplificateur audio, en pour cents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['BluetoothLink']['set_remoteAddress']={syn:'Modifie l\x27adresse MAC-48 bluetooth d\xE9finissant l\x27appareil distant \xE0 connecter.',lib:'bluetoothlink.set_remoteAddress()',pro:'def set_remoteAddress(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse MAC-48 bluetooth d\xE9finissant l\x27appareil distant \xE0 connecter.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27adresse MAC-48 bluetooth d\xE9finissant l\x27appareil distant \xE0 connecter'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['BluetoothLink']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'bluetoothlink.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['BluetoothLink']['set_volume']={syn:'Modifie le volume de l\x27\xE9couteur connect\xE9, en pour cents.',lib:'bluetoothlink.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Modifie le volume de l\x27\xE9couteur connect\xE9, en pour cents.</p>',par:{newval:'un entier repr&eacute;sentant le volume de l\x27\xE9couteur connect\xE9, en pour cents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['BluetoothLink']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'bluetoothlink.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: BluetoothLink)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'Interface de la fonction AudioIn',inc:'from yocto_audioin import *',cmt:'<p>La librairie de programmation Yoctopuce permet de configurer le gain de l\x27entr\xE9e audio.</p>'}};
doc['AudioIn']['FindAudioIn']={syn:'Permet de retrouver une entr\xE9e audio d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAudioIn.FindAudioIn()',pro:'def FindAudioIn(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une entr\xE9e audio d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la entr\xE9e audio soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAudioIn.isOnline()</tt> pour tester si la entr\xE9e audio est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la entr\xE9e audio sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAudioIn</tt> qui permet ensuite de contr\xF4ler la entr\xE9e audio.'};
doc['AudioIn']['FirstAudioIn']={syn:'Commence l\x27\xE9num\xE9ration des entr\xE9es audio accessibles par la librairie.',lib:'YAudioIn.FirstAudioIn()',pro:'def FirstAudioIn()',cmt:'<p>Commence l\x27\xE9num\xE9ration des entr\xE9es audio accessibles par la librairie. Utiliser la fonction <tt>YAudioIn.nextAudioIn()</tt> pour it\xE9rer sur les autres entr\xE9es audio.</p>',ret:'un pointeur sur un objet <tt>YAudioIn</tt>, correspondant \xE0 la premi\xE8re entr\xE9e audio accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de entr\xE9es audio disponibles.'};
doc['AudioIn']['clearCache']={syn:'Invalide le cache.',lib:'audioin.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la entr\xE9e audio. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['AudioIn']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la entr\xE9e audio au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioin.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la entr\xE9e audio au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la entr\xE9e audio (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioIn']['get_advertisedValue']={syn:'Retourne la valeur courante de la entr\xE9e audio (pas plus de 6 caract\xE8res).',lib:'audioin.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la entr\xE9e audio (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la entr\xE9e audio (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioIn']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la entr\xE9e audio.',lib:'audioin.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la entr\xE9e audio. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la entr\xE9e audio.'};
doc['AudioIn']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la entr\xE9e audio.',lib:'audioin.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la entr\xE9e audio. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la entr\xE9e audio.'};
doc['AudioIn']['get_friendlyName']={syn:'Retourne un identifiant global de la entr\xE9e audio au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'audioin.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la entr\xE9e audio au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la entr\xE9e audio si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la entr\xE9e audio (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la entr\xE9e audio en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioIn']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'audioin.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['AudioIn']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la entr\xE9e audio, sans r\xE9f\xE9rence au module.',lib:'audioin.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la entr\xE9e audio, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la entr\xE9e audio (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioIn']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la entr\xE9e audio au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioin.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la entr\xE9e audio au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la entr\xE9e audio (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la entr\xE9e audio (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioIn']['get_logicalName']={syn:'Retourne le nom logique de la entr\xE9e audio.',lib:'audioin.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la entr\xE9e audio.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la entr\xE9e audio.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioIn']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'audioin.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['AudioIn']['get_mute']={syn:'Retourne l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio.',lib:'audioin.get_mute()',pro:'def get_mute()',cmt:'<p>Retourne l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio.</p>',ret:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioIn']['get_noSignalFor']={syn:'Retourne le nombre de secondes sans signal d\xE9tect\xE9.',lib:'audioin.get_noSignalFor()',pro:'def get_noSignalFor()',cmt:'<p>Retourne le nombre de secondes sans signal d\xE9tect\xE9.</p>',ret:'un entier repr&eacute;sentant le nombre de secondes sans signal d\xE9tect\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioIn']['get_signal']={syn:'Retourne l\x27amplitude du signal d\x27entr\xE9e d\xE9tect\xE9.',lib:'audioin.get_signal()',pro:'def get_signal()',cmt:'<p>Retourne l\x27amplitude du signal d\x27entr\xE9e d\xE9tect\xE9.</p>',ret:'un entier repr&eacute;sentant l\x27amplitude du signal d\x27entr\xE9e d\xE9tect\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioIn']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'audioin.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['AudioIn']['get_volume']={syn:'Retourne le gain de l\x27entr\xE9e audio, en pour cents.',lib:'audioin.get_volume()',pro:'def get_volume()',cmt:'<p>Retourne le gain de l\x27entr\xE9e audio, en pour cents.</p>',ret:'un entier repr&eacute;sentant le gain de l\x27entr\xE9e audio, en pour cents',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioIn']['get_volumeRange']={syn:'Retourne la plage de valeurs support\xE9es pour le volume.',lib:'audioin.get_volumeRange()',pro:'def get_volumeRange()',cmt:'<p>Retourne la plage de valeurs support\xE9es pour le volume. La valeur basse de l\x27intervalle correspond au volume minimal audible. Pour couper compl\xE8tement le son, utilisez <tt>set_mute()</tt> et non le <tt>set_volume()</tt>.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la plage de valeurs support\xE9es pour le volume',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioIn']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la entr\xE9e audio est joignable, sans d\xE9clencher d\x27erreur.',lib:'audioin.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la entr\xE9e audio est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la entr\xE9e audio sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la entr\xE9e audio est joignable, <tt>false</tt> sinon'};
doc['AudioIn']['load']={syn:'Met en cache les valeurs courantes de la entr\xE9e audio, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'audioin.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la entr\xE9e audio, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioIn']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'audioin.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['AudioIn']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'audioin.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioIn']['nextAudioIn']={syn:'Continue l\x27\xE9num\xE9ration des entr\xE9es audio commenc\xE9e \xE0 l\x27aide de <tt>yFirstAudioIn()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les entr\xE9es audio sont retourn\xE9s.',lib:'audioin.nextAudioIn()',pro:'def nextAudioIn()',cmt:'<p>Continue l\x27\xE9num\xE9ration des entr\xE9es audio commenc\xE9e \xE0 l\x27aide de <tt>yFirstAudioIn()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les entr\xE9es audio sont retourn\xE9s. Si vous souhaitez retrouver une entr\xE9e audio sp\xE9cifique, utilisez <tt>AudioIn.findAudioIn()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YAudioIn</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['AudioIn']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'audioin.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['AudioIn']['set_logicalName']={syn:'Modifie le nom logique de la entr\xE9e audio.',lib:'audioin.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la entr\xE9e audio. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la entr\xE9e audio.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AudioIn']['set_mute']={syn:'Modifie l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio.',lib:'audioin.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si vous d\xE9sirez que le r\xE9glage soit pr\xE9serv\xE9 au prochain red\xE9marrage.</p>',par:{newval:'soit <tt>Y_MUTE_FALSE</tt>, soit <tt>Y_MUTE_TRUE</tt>, selon l\x27\xE9tat de la fonction silencieux (mute) de l\x27entr\xE9e audio'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AudioIn']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'audioin.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['AudioIn']['set_volume']={syn:'Modifie le gain de la l\x27entr\xE9e audio, en pour cents.',lib:'audioin.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Modifie le gain de la l\x27entr\xE9e audio, en pour cents.</p>',par:{newval:'un entier repr&eacute;sentant le gain de la l\x27entr\xE9e audio, en pour cents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['AudioIn']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'audioin.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: AudioIn)
//--- (generated code: QuadratureDecoder)
doc['QuadratureDecoder']={'':{syn:'Interface de la fonction QuadratureDecoder',inc:'from yocto_quadraturedecoder import *',cmt:'<p>La classe YQuadratureDecoder permet de d\xE9coder un signal produit par un encodeur en quadrature. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['QuadratureDecoder']['FindQuadratureDecoder']={syn:'Permet de retrouver un d\xE9codeut de quadrature d\x27apr\xE8s un identifiant donn\xE9.',lib:'YQuadratureDecoder.FindQuadratureDecoder()',pro:'def FindQuadratureDecoder(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un d\xE9codeut de quadrature d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le d\xE9codeur de quadrature soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YQuadratureDecoder.isOnline()</tt> pour tester si le d\xE9codeur de quadrature est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le d\xE9codeur de quadrature sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YQuadratureDecoder</tt> qui permet ensuite de contr\xF4ler le d\xE9codeur de quadrature.'};
doc['QuadratureDecoder']['FirstQuadratureDecoder']={syn:'Commence l\x27\xE9num\xE9ration des D\xE9codeur de quadrature accessibles par la librairie.',lib:'YQuadratureDecoder.FirstQuadratureDecoder()',pro:'def FirstQuadratureDecoder()',cmt:'<p>Commence l\x27\xE9num\xE9ration des D\xE9codeur de quadrature accessibles par la librairie. Utiliser la fonction <tt>YQuadratureDecoder.nextQuadratureDecoder()</tt> pour it\xE9rer sur les autres D\xE9codeur de quadrature.</p>',ret:'un pointeur sur un objet <tt>YQuadratureDecoder</tt>, correspondant au premier d\xE9codeur de quadrature PWM accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de D\xE9codeur de quadrature disponibles.'};
doc['QuadratureDecoder']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'quadraturedecoder.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['QuadratureDecoder']['clearCache']={syn:'Invalide le cache.',lib:'quadraturedecoder.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du d\xE9codeur de quadrature. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['QuadratureDecoder']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du d\xE9codeur de quadrature au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'quadraturedecoder.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du d\xE9codeur de quadrature au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le d\xE9codeur de quadrature (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['QuadratureDecoder']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'quadraturedecoder.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_advertisedValue']={syn:'Retourne la valeur courante du d\xE9codeur de quadrature (pas plus de 6 caract\xE8res).',lib:'quadraturedecoder.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du d\xE9codeur de quadrature (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du d\xE9codeur de quadrature (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en pas, sous forme de nombre \xE0 virgule.',lib:'quadraturedecoder.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en pas, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en pas, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentValue']={syn:'Retourne la valeur actuelle de la position, en pas, sous forme de nombre \xE0 virgule.',lib:'quadraturedecoder.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la position, en pas, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la position, en pas, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'quadraturedecoder.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['QuadratureDecoder']['get_decoding']={syn:'Retourne l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature.',lib:'quadraturedecoder.get_decoding()',pro:'def get_decoding()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature.</p>',ret:'soit <tt>Y_DECODING_OFF</tt>, soit <tt>Y_DECODING_ON</tt>, selon l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DECODING_INVALID</tt>.'};
doc['QuadratureDecoder']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du d\xE9codeur de quadrature.',lib:'quadraturedecoder.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du d\xE9codeur de quadrature. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du d\xE9codeur de quadrature.'};
doc['QuadratureDecoder']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du d\xE9codeur de quadrature.',lib:'quadraturedecoder.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du d\xE9codeur de quadrature. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du d\xE9codeur de quadrature.'};
doc['QuadratureDecoder']['get_friendlyName']={syn:'Retourne un identifiant global du d\xE9codeur de quadrature au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'quadraturedecoder.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du d\xE9codeur de quadrature au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du d\xE9codeur de quadrature si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du d\xE9codeur de quadrature (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le d\xE9codeur de quadrature en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'quadraturedecoder.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['QuadratureDecoder']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du d\xE9codeur de quadrature, sans r\xE9f\xE9rence au module.',lib:'quadraturedecoder.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du d\xE9codeur de quadrature, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le d\xE9codeur de quadrature (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du d\xE9codeur de quadrature au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'quadraturedecoder.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du d\xE9codeur de quadrature au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du d\xE9codeur de quadrature (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le d\xE9codeur de quadrature (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la position depuis le d\xE9marrage du module.',lib:'quadraturedecoder.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la position depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la position depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'quadraturedecoder.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logicalName']={syn:'Retourne le nom logique du d\xE9codeur de quadrature.',lib:'quadraturedecoder.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du d\xE9codeur de quadrature.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du d\xE9codeur de quadrature.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la position depuis le d\xE9marrage du module.',lib:'quadraturedecoder.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la position depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la position depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'quadraturedecoder.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['QuadratureDecoder']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'quadraturedecoder.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['QuadratureDecoder']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'quadraturedecoder.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'quadraturedecoder.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['QuadratureDecoder']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'quadraturedecoder.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_speed']={syn:'Retourne la fr\xE9quence des incr\xE9ments, en Hz.',lib:'quadraturedecoder.get_speed()',pro:'def get_speed()',cmt:'<p>Retourne la fr\xE9quence des incr\xE9ments, en Hz.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la fr\xE9quence des incr\xE9ments, en Hz',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SPEED_INVALID</tt>.'};
doc['QuadratureDecoder']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la position est exprim\xE9e.',lib:'quadraturedecoder.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la position est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la position est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['QuadratureDecoder']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'quadraturedecoder.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['QuadratureDecoder']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le d\xE9codeur de quadrature est joignable, sans d\xE9clencher d\x27erreur.',lib:'quadraturedecoder.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le d\xE9codeur de quadrature est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du d\xE9codeur de quadrature sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le d\xE9codeur de quadrature est joignable, <tt>false</tt> sinon'};
doc['QuadratureDecoder']['load']={syn:'Met en cache les valeurs courantes du d\xE9codeur de quadrature, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'quadraturedecoder.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du d\xE9codeur de quadrature, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['QuadratureDecoder']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'quadraturedecoder.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['QuadratureDecoder']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'quadraturedecoder.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['QuadratureDecoder']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'quadraturedecoder.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['QuadratureDecoder']['nextQuadratureDecoder']={syn:'Continue l\x27\xE9num\xE9ration des D\xE9codeur de quadrature commenc\xE9e \xE0 l\x27aide de <tt>yFirstQuadratureDecoder()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les D\xE9codeur de quadrature sont retourn\xE9s.',lib:'quadraturedecoder.nextQuadratureDecoder()',pro:'def nextQuadratureDecoder()',cmt:'<p>Continue l\x27\xE9num\xE9ration des D\xE9codeur de quadrature commenc\xE9e \xE0 l\x27aide de <tt>yFirstQuadratureDecoder()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les D\xE9codeur de quadrature sont retourn\xE9s. Si vous souhaitez retrouver un d\xE9codeut de quadrature sp\xE9cifique, utilisez <tt>QuadratureDecoder.findQuadratureDecoder()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YQuadratureDecoder</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['QuadratureDecoder']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'quadraturedecoder.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['QuadratureDecoder']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'quadraturedecoder.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['QuadratureDecoder']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'quadraturedecoder.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_currentValue']={syn:'Modifie la position actuelle suppos\xE9e par le d\xE9codeur de quadrature.',lib:'quadraturedecoder.set_currentValue()',pro:'def set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la position actuelle suppos\xE9e par le d\xE9codeur de quadrature. L\x27appel \xE0 cette fonction active implitement le d\xE9codeur de quadrature.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la position actuelle suppos\xE9e par le d\xE9codeur de quadrature'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_decoding']={syn:'Modifie l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature.',lib:'quadraturedecoder.set_decoding()',pro:'def set_decoding(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature.</p>',par:{newval:'soit <tt>Y_DECODING_OFF</tt>, soit <tt>Y_DECODING_ON</tt>, selon l\x27\xE9tat d\x27activation du d\xE9codeur de quadrature'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'quadraturedecoder.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'quadraturedecoder.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_logicalName']={syn:'Modifie le nom logique du d\xE9codeur de quadrature.',lib:'quadraturedecoder.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du d\xE9codeur de quadrature. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du d\xE9codeur de quadrature.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['QuadratureDecoder']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'quadraturedecoder.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'quadraturedecoder.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'quadraturedecoder.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['QuadratureDecoder']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'quadraturedecoder.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['QuadratureDecoder']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'quadraturedecoder.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['QuadratureDecoder']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'quadraturedecoder.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['QuadratureDecoder']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'quadraturedecoder.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: QuadratureDecoder)
//--- (generated code: CurrentLoopOutput)
doc['CurrentLoopOutput']={'':{syn:'Interface de la fonction CurrentLoopOutput',inc:'from yocto_currentloopoutput import *',cmt:'<p>La librairie de programmation Yoctopuce permet de changer la valeur de la sortie 4-20mA et \x09 de connaitre l\x27\xE9tat de la boucle de courant.</p>'}};
doc['CurrentLoopOutput']['FindCurrentLoopOutput']={syn:'Permet de retrouver une sortie 4-20mA d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCurrentLoopOutput.FindCurrentLoopOutput()',pro:'def FindCurrentLoopOutput(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une sortie 4-20mA d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la sortie sortie 4-20mA soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCurrentLoopOutput.isOnline()</tt> pour tester si la sortie sortie 4-20mA est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la sortie sortie 4-20mA sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCurrentLoopOutput</tt> qui permet ensuite de contr\xF4ler la sortie sortie 4-20mA.'};
doc['CurrentLoopOutput']['FirstCurrentLoopOutput']={syn:'Commence l\x27\xE9num\xE9ration des sortie 4-20mA accessibles par la librairie.',lib:'YCurrentLoopOutput.FirstCurrentLoopOutput()',pro:'def FirstCurrentLoopOutput()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sortie 4-20mA accessibles par la librairie. Utiliser la fonction <tt>YCurrentLoopOutput.nextCurrentLoopOutput()</tt> pour it\xE9rer sur les autres sortie 4-20mA.</p>',ret:'un pointeur sur un objet <tt>YCurrentLoopOutput</tt>, correspondant \xE0 la premi\xE8re sortie 4-20mA accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sortie 4-20mA disponibles.'};
doc['CurrentLoopOutput']['clearCache']={syn:'Invalide le cache.',lib:'currentloopoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la sortie sortie 4-20mA. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['CurrentLoopOutput']['currentMove']={syn:'D\xE9clenche une transition progressive du courant dans la boucle.',lib:'currentloopoutput.currentMove()',pro:'def currentMove(<span id=pn>mA_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une transition progressive du courant dans la boucle. N\x27importe quel changement explicite de courant annulera tout processus de transition en cours.</p>',par:{mA_target:'nouvelle valeur du courant \xE0 la fin de la transition (nombre flottant, repr\xE9sentant le courant en mA)',ms_duration:'dur\xE9e totale de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CurrentLoopOutput']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie sortie 4-20mA au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'currentloopoutput.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie sortie 4-20mA au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la sortie sortie 4-20mA (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CurrentLoopOutput']['get_advertisedValue']={syn:'Retourne la valeur courante de la sortie sortie 4-20mA (pas plus de 6 caract\xE8res).',lib:'currentloopoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la sortie sortie 4-20mA (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la sortie sortie 4-20mA (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_current']={syn:'Retourne la valeur de consigne pour le courant de la boucle, en mA.',lib:'currentloopoutput.get_current()',pro:'def get_current()',cmt:'<p>Retourne la valeur de consigne pour le courant de la boucle, en mA.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur de consigne pour le courant de la boucle, en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENT_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_currentAtStartUp']={syn:'Retourne le courant dans le boucle au d\xE9marrage du module, en mA.',lib:'currentloopoutput.get_currentAtStartUp()',pro:'def get_currentAtStartUp()',cmt:'<p>Retourne le courant dans le boucle au d\xE9marrage du module, en mA.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le courant dans le boucle au d\xE9marrage du module, en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie sortie 4-20mA.',lib:'currentloopoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie sortie 4-20mA. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie sortie 4-20mA.'};
doc['CurrentLoopOutput']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie sortie 4-20mA.',lib:'currentloopoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie sortie 4-20mA. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie sortie 4-20mA.'};
doc['CurrentLoopOutput']['get_friendlyName']={syn:'Retourne un identifiant global de la sortie sortie 4-20mA au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'currentloopoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la sortie sortie 4-20mA au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la sortie sortie 4-20mA si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la sortie sortie 4-20mA (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie sortie 4-20mA en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'currentloopoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['CurrentLoopOutput']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la sortie sortie 4-20mA, sans r\xE9f\xE9rence au module.',lib:'currentloopoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la sortie sortie 4-20mA, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie sortie 4-20mA (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la sortie sortie 4-20mA au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'currentloopoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la sortie sortie 4-20mA au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la sortie sortie 4-20mA (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie sortie 4-20mA (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_logicalName']={syn:'Retourne le nom logique de la sortie sortie 4-20mA.',lib:'currentloopoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la sortie sortie 4-20mA.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie sortie 4-20mA.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_loopPower']={syn:'Retourne l\x27\xE9tat de l\x27alimentation de la boucle.',lib:'currentloopoutput.get_loopPower()',pro:'def get_loopPower()',cmt:'<p>Retourne l\x27\xE9tat de l\x27alimentation de la boucle. POWEROK: la boucle est aliment\xE9e. NOPWR: la boucle n\x27est pas aliment\xE9. \x09\x09 LOWPWR: la boucle n\x27est pas aliment\xE9 suffisamment pour pouvoir \x09\x09 maintenir le courant demand\xE9 (tension insuffisante)</p>',ret:'une valeur parmi <tt>Y_LOOPPOWER_NOPWR</tt>, <tt>Y_LOOPPOWER_LOWPWR</tt> et <tt>Y_LOOPPOWER_POWEROK</tt> repr&eacute;sentant l\x27\xE9tat de l\x27alimentation de la boucle',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOOPPOWER_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'currentloopoutput.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['CurrentLoopOutput']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'currentloopoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['CurrentLoopOutput']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la sortie sortie 4-20mA est joignable, sans d\xE9clencher d\x27erreur.',lib:'currentloopoutput.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la sortie sortie 4-20mA est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la sortie sortie 4-20mA sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la sortie sortie 4-20mA est joignable, <tt>false</tt> sinon'};
doc['CurrentLoopOutput']['load']={syn:'Met en cache les valeurs courantes de la sortie sortie 4-20mA, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'currentloopoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la sortie sortie 4-20mA, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CurrentLoopOutput']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'currentloopoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['CurrentLoopOutput']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'currentloopoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CurrentLoopOutput']['nextCurrentLoopOutput']={syn:'Continue l\x27\xE9num\xE9ration des sortie 4-20mA commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrentLoopOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sortie 4-20mA sont retourn\xE9s.',lib:'currentloopoutput.nextCurrentLoopOutput()',pro:'def nextCurrentLoopOutput()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sortie 4-20mA commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrentLoopOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sortie 4-20mA sont retourn\xE9s. Si vous souhaitez retrouver une sortie 4-20mA sp\xE9cifique, utilisez <tt>CurrentLoopOutput.findCurrentLoopOutput()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YCurrentLoopOutput</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['CurrentLoopOutput']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'currentloopoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['CurrentLoopOutput']['set_current']={syn:'Modifie le courant dans la boucle, les valeurs admises sont de 3 \xE0 21mA.',lib:'currentloopoutput.set_current()',pro:'def set_current(<span id=pn>newval</span>)',cmt:'<p>Modifie le courant dans la boucle, les valeurs admises sont de 3 \xE0 21mA. \x09 Attention, si la boucle n\x27est pas suffisamment aliment\xE9e, le courant \x09\x09\x09ne pourra pas \xEAtre maintenu et loopPower passera a LOWPWR.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le courant dans la boucle, les valeurs admises sont de 3 \xE0 21mA'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CurrentLoopOutput']['set_currentAtStartUp']={syn:'Modifie la valeur de courant dans la boucle au d\xE9marrage du module.',lib:'currentloopoutput.set_currentAtStartUp()',pro:'def set_currentAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur de courant dans la boucle au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la valeur de courant dans la boucle au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['CurrentLoopOutput']['set_logicalName']={syn:'Modifie le nom logique de la sortie sortie 4-20mA.',lib:'currentloopoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la sortie sortie 4-20mA. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie sortie 4-20mA.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CurrentLoopOutput']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'currentloopoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['CurrentLoopOutput']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'currentloopoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: CurrentLoopOutput)
//--- (generated code: ColorLedCluster)
doc['ColorLedCluster']={'':{syn:'Interface de la fonction ColorLedCluster',inc:'from yocto_colorledcluster import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter un cluster de LED. Contrairement a la classe ColorLed, la classe ColorLedCluster permet de changer modifier plusieurs LEDs \xE0 la fois. Les changements de couleur peuvent \xEAtre fait aussi bien en coordonn\xE9es RGB qu\x27en coordonn\xE9es HSL, les conversions RGB vers HSL \xE9tant faites automatiquement par le module. Ceci permet ais\xE9ment d\x27allumer les LEDs avec une certaine teinte et d\x27en faire progressivement varier la saturation ou la luminosit\xE9.</p>'}};
doc['ColorLedCluster']['FindColorLedCluster']={syn:'Permet de retrouver un cluster de LEDs RGB d\x27apr\xE8s un identifiant donn\xE9.',lib:'YColorLedCluster.FindColorLedCluster()',pro:'def FindColorLedCluster(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un cluster de LEDs RGB d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le cluster de LEDs RGB soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YColorLedCluster.isOnline()</tt> pour tester si le cluster de LEDs RGB est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le cluster de LEDs RGB sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YColorLedCluster</tt> qui permet ensuite de contr\xF4ler le cluster de LEDs RGB.'};
doc['ColorLedCluster']['FirstColorLedCluster']={syn:'Commence l\x27\xE9num\xE9ration des clusters de LEDs RGB accessibles par la librairie.',lib:'YColorLedCluster.FirstColorLedCluster()',pro:'def FirstColorLedCluster()',cmt:'<p>Commence l\x27\xE9num\xE9ration des clusters de LEDs RGB accessibles par la librairie. Utiliser la fonction <tt>YColorLedCluster.nextColorLedCluster()</tt> pour it\xE9rer sur les autres clusters de LEDs RGB.</p>',ret:'un pointeur sur un objet <tt>YColorLedCluster</tt>, correspondant au premier cluster de LEDs RGB accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de clusters de LEDs RGB disponibles.'};
doc['ColorLedCluster']['addHslMoveToBlinkSeq']={syn:'Ajoute \xE0 une s\xE9quence une transition dans l\x27espace HSL.',lib:'colorledcluster.addHslMoveToBlinkSeq()',pro:'def addHslMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Ajoute \xE0 une s\xE9quence une transition dans l\x27espace HSL. Une s\xE9quence est une liste de transitions qui pourra \xEAtre ex\xE9cut\xE9e en boucle par un groupe arbitraire de LEDs. Les s\xE9quences sont persistenteset sont sauv\xE9es dans le m\xE9moire flash du module quand la m\xE9thode <tt>saveBlinkSeq()</tt> est appel\xE9e.</p>',par:{seqIndex:'index de la s\xE9quence.',hslValue:'couleur vis\xE9e (0xHHSSLL)',delay:'dur\xE9e de la transistion en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['addJumpToBlinkSeq']={syn:'Ajoute \xE0 une s\xE9quence un saut vers une autre s\xE9quence.',lib:'colorledcluster.addJumpToBlinkSeq()',pro:'def addJumpToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>linkSeqIndex</span>)',cmt:'<p>Ajoute \xE0 une s\xE9quence un saut vers une autre s\xE9quence. Lorsqu\x27un pixel arrivera \xE0 ce saut, il sera automatiquement reli\xE9 \xE0 la nouvelle s\xE9quence, qu\x27il ex\xE9cutera en commen\xE7ant au d\xE9but.</p>',par:{seqIndex:'index de la s\xE9quence.',linkSeqIndex:'index de la s\xE9quence \xE0 encha\xEEner.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['addMirrorToBlinkSeq']={syn:'Ajoute \xE0 une s\xE9quence une fin en mirroir.',lib:'colorledcluster.addMirrorToBlinkSeq()',pro:'def addMirrorToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Ajoute \xE0 une s\xE9quence une fin en mirroir. Lorsque la s\xE9quence arrivera \xE0 la fin de la derni\xE8re transition, sa vitesse d\x27ex\xE9cution sera automatiquement invers\xE9e de sorte \xE0 ce que la s\xE9quence se rejoue \xE0 l\x27envers, en mirroir. Lorsque la premi\xE8re transition sera compl\xE9t\xE9e \xE0 la fin de l\x27ex\xE9cution \xE0 l\x27envers, la s\xE9quence repartira \xE0 nouveau dans le sens initial.</p>',par:{seqIndex:'index de la s\xE9quence.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['addRgbMoveToBlinkSeq']={syn:'Ajoute \xE0 une s\xE9quence une transition dans l\x27espace RGB.',lib:'colorledcluster.addRgbMoveToBlinkSeq()',pro:'def addRgbMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Ajoute \xE0 une s\xE9quence une transition dans l\x27espace RGB. Une s\xE9quence est une liste de transitions qui pourra \xEAtre ex\xE9cut\xE9e en boucle par un groupe arbitraire de LEDs. Les s\xE9quences sont persistantes et sont sauv\xE9es dans le m\xE9moire flash du module quand la m\xE9thode <tt>saveBlinkSeq()</tt> est appl\xE9e.</p>',par:{seqIndex:'index de la s\xE9quence.',rgbValue:'couleur vis\xE9e (0xRRGGBB)',delay:'dur\xE9e de la transistion en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['addUnlinkToBlinkSeq']={syn:'Ajoute \xE0 une s\xE9quence une commande d\x27arr\xEAt.',lib:'colorledcluster.addUnlinkToBlinkSeq()',pro:'def addUnlinkToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Ajoute \xE0 une s\xE9quence une commande d\x27arr\xEAt. Lorsqu\x27un pixel arrivera \xE0 cette commande d\x27arr\xEAt, il ne la recommencera pas en boucle mais en sera automatiquement d\xE9tach\xE9.</p>',par:{seqIndex:'index de la s\xE9quence.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['clearCache']={syn:'Invalide le cache.',lib:'colorledcluster.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du cluster de LEDs RGB. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['ColorLedCluster']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du cluster de LEDs RGB au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorledcluster.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du cluster de LEDs RGB au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le cluster de LEDs RGB (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLedCluster']['get_activeLedCount']={syn:'Retourne le nombre de LED actuellement g\xE9r\xE9es par le module.',lib:'colorledcluster.get_activeLedCount()',pro:'def get_activeLedCount()',cmt:'<p>Retourne le nombre de LED actuellement g\xE9r\xE9es par le module.</p>',ret:'un entier repr&eacute;sentant le nombre de LED actuellement g\xE9r\xE9es par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ACTIVELEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_advertisedValue']={syn:'Retourne la valeur courante du cluster de LEDs RGB (pas plus de 6 caract\xE8res).',lib:'colorledcluster.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du cluster de LEDs RGB (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du cluster de LEDs RGB (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxCount']={syn:'Retourne le nombre maximum de s\xE9quences mis \xE0 disposition par le module.',lib:'colorledcluster.get_blinkSeqMaxCount()',pro:'def get_blinkSeqMaxCount()',cmt:'<p>Retourne le nombre maximum de s\xE9quences mis \xE0 disposition par le module.</p>',ret:'un entier repr&eacute;sentant le nombre maximum de s\xE9quences mis \xE0 disposition par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKSEQMAXCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxSize']={syn:'Retourne la longueur maximum d\x27une sequence.',lib:'colorledcluster.get_blinkSeqMaxSize()',pro:'def get_blinkSeqMaxSize()',cmt:'<p>Retourne la longueur maximum d\x27une sequence.</p>',ret:'un entier repr&eacute;sentant la longueur maximum d\x27une sequence',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqSignatures']={syn:'Retourne une liste de signatures 32 bits pour les s\xE9quences de clignotement.',lib:'colorledcluster.get_blinkSeqSignatures()',pro:'def get_blinkSeqSignatures(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste de signatures 32 bits pour les s\xE9quences de clignotement. Les s\xE9quences de clignotement ne pouvant pas \xEAtre relues du module, ce m\xE9canisme peut \xEAtre utilis\xE9 pour d\xE9tecter si une s\xE9quence sp\xE9cifique est d\xE9j\xE0 programm\xE9e.</p>',par:{seqIndex:'index de la premi\xE8re s\xE9quence qui doit \xEAtre retourn\xE9e',count:'nombre de s\xE9quences qui doivent \xEAtre retourn\xE9es'},ret:'une liste d\x27entiers 32 bits',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_blinkSeqState']={syn:'Retourne une liste d\x27entiers indiquant si les s\xE9quences sont d\xE9marr\xE9es ou pas.',lib:'colorledcluster.get_blinkSeqState()',pro:'def get_blinkSeqState(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste d\x27entiers indiquant si les s\xE9quences sont d\xE9marr\xE9es ou pas.</p>',par:{seqIndex:'index de la premi\xE8re s\xE9quence qui doit \xEAtre retourn\xE9e',count:'nombre de s\xE9quences qui doivent \xEAtre retourn\xE9es'},ret:'une liste d\x27entiers, 0 pour les s\xE9quences arr\xEAt\xE9es et 1 pour les s\xE9quences d\xE9marr\xE9es.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_blinkSeqStateAtPowerOn']={syn:'Retourne une liste d\x27entiers indiquant l\x27\xE9tat du flag pilotant le d\xE9marrage de la s\xE9quence \xE0 la mise sous tension du module.',lib:'colorledcluster.get_blinkSeqStateAtPowerOn()',pro:'def get_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste d\x27entiers indiquant l\x27\xE9tat du flag pilotant le d\xE9marrage de la s\xE9quence \xE0 la mise sous tension du module.</p>',par:{seqIndex:'index de la premi\xE8re s\xE9quence qui doit \xEAtre retourn\xE9e',count:'nombre de s\xE9quences qui doivent \xEAtre retourn\xE9es'},ret:'une liste d\x27entiers, 0 pour les s\xE9quences arr\xEAt\xE9es et 1 pour les s\xE9quences d\xE9marr\xE9es.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_blinkSeqStateSpeed']={syn:'Retourne une liste d\x27entiers donnant la vitesse de chaque s\xE9quence.',lib:'colorledcluster.get_blinkSeqStateSpeed()',pro:'def get_blinkSeqStateSpeed(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste d\x27entiers donnant la vitesse de chaque s\xE9quence.</p>',par:{seqIndex:'index de la premi\xE8re s\xE9quence dont le vitesse doit \xEAtre retourn\xE9e',count:'nombre de s\xE9quences \xE0 traiter'},ret:'une liste d\x27entiers, 0 pour les s\xE9quences arr\xEAt\xE9es et 1 pour les s\xE9quences d\xE9marr\xE9es.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du cluster de LEDs RGB.',lib:'colorledcluster.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du cluster de LEDs RGB. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du cluster de LEDs RGB.'};
doc['ColorLedCluster']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du cluster de LEDs RGB.',lib:'colorledcluster.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du cluster de LEDs RGB. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du cluster de LEDs RGB.'};
doc['ColorLedCluster']['get_friendlyName']={syn:'Retourne un identifiant global du cluster de LEDs RGB au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'colorledcluster.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du cluster de LEDs RGB au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du cluster de LEDs RGB si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du cluster de LEDs RGB (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le cluster de LEDs RGB en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'colorledcluster.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['ColorLedCluster']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du cluster de LEDs RGB, sans r\xE9f\xE9rence au module.',lib:'colorledcluster.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du cluster de LEDs RGB, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le cluster de LEDs RGB (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLedCluster']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du cluster de LEDs RGB au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorledcluster.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du cluster de LEDs RGB au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du cluster de LEDs RGB (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le cluster de LEDs RGB (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLedCluster']['get_ledType']={syn:'Retourne le type de LEDs RGB actuellement g\xE9r\xE9es par le module.',lib:'colorledcluster.get_ledType()',pro:'def get_ledType()',cmt:'<p>Retourne le type de LEDs RGB actuellement g\xE9r\xE9es par le module.</p>',ret:'soit <tt>Y_LEDTYPE_RGB</tt>, soit <tt>Y_LEDTYPE_RGBW</tt>, selon le type de LEDs RGB actuellement g\xE9r\xE9es par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LEDTYPE_INVALID</tt>.'};
doc['ColorLedCluster']['get_linkedSeqArray']={syn:'Retourne une liste d\x27index de s\xE9quence for chaque LED RGB.',lib:'colorledcluster.get_linkedSeqArray()',pro:'def get_linkedSeqArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste d\x27index de s\xE9quence for chaque LED RGB. Le premier entier correspond \xE0 l\x27index de la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre retourn\xE9e',count:'nombre de LEDs qui doivent \xEAtre retourn\xE9es'},ret:'une liste d\x27entiers correspondant \xE0 des index de s\xE9quence.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_logicalName']={syn:'Retourne le nom logique du cluster de LEDs RGB.',lib:'colorledcluster.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du cluster de LEDs RGB.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du cluster de LEDs RGB.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_maxLedCount']={syn:'Retourne le nombre maximum de LEDs g\xE9rables par le module.',lib:'colorledcluster.get_maxLedCount()',pro:'def get_maxLedCount()',cmt:'<p>Retourne le nombre maximum de LEDs g\xE9rables par le module.</p>',ret:'un entier repr&eacute;sentant le nombre maximum de LEDs g\xE9rables par le module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXLEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'colorledcluster.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['ColorLedCluster']['get_rgbColorArray']={syn:'Retourne une liste de couleurs RGB 24 bits contenant l\x27\xE9tat des LEDs RGB, tel quel.',lib:'colorledcluster.get_rgbColorArray()',pro:'def get_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste de couleurs RGB 24 bits contenant l\x27\xE9tat des LEDs RGB, tel quel. Le premier entier correspond \xE0 la couleur RGB de la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre retourn\xE9e',count:'nombre de LEDs qui doivent \xEAtre retourn\xE9es'},ret:'une liste de couleurs 24bit avec les composantes RGB des LEDs choisies, au format 0xRRGGBB.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_rgbColorArrayAtPowerOn']={syn:'Retourne une liste de couleurs RGB 24 bits contenant la couleur des LEDs RGB au d\xE9marrage.',lib:'colorledcluster.get_rgbColorArrayAtPowerOn()',pro:'def get_rgbColorArrayAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne une liste de couleurs RGB 24 bits contenant la couleur des LEDs RGB au d\xE9marrage. Le premier entier correspond \xE0 la couleur RGB de d\xE9marrage de la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre retourn\xE9e',count:'nombre de LEDs qui doivent \xEAtre retourn\xE9es'},ret:'une liste de couleurs 24bit avec les composantes RGB des LEDs choisies, au format 0xRRGGBB.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['ColorLedCluster']['get_rgbColorBuffer']={syn:'Retourne un objet binaire contenant l\x27\xE9tat des LEDs RGB, tel quel.',lib:'colorledcluster.get_rgbColorBuffer()',pro:'def get_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Retourne un objet binaire contenant l\x27\xE9tat des LEDs RGB, tel quel. Les trois premiers octets correspondent aux composantes RGB de la premi\xE8re LED choisie, les trois octets suivants \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre retourn\xE9e',count:'nombre de LEDs qui doivent \xEAtre retourn\xE9es'},ret:'un objet binaire avec les composantes RGB des LEDs choisies.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un objet binaire vide.'};
doc['ColorLedCluster']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'colorledcluster.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['ColorLedCluster']['hslArrayOfs_move']={syn:'Configure une transition HSL vers une liste de couleurs HSL, pixel par pixel.',lib:'colorledcluster.hslArrayOfs_move()',pro:'def hslArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Configure une transition HSL vers une liste de couleurs HSL, pixel par pixel. Le premier entier correspond \xE0 la couleur RGB finale pour la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',hslList:'la liste de valeurs HSL (24 bits) finales d\xE9sir\xE9es, au format 0xHHSSLL',delay:'dur\xE9e de la transition en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['hslArray_move']={syn:'Configure une transition HSL vers une liste de couleurs HSL, pixel par pixel.',lib:'colorledcluster.hslArray_move()',pro:'def hslArray_move(<span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Configure une transition HSL vers une liste de couleurs HSL, pixel par pixel. Le premier entier correspond \xE0 la couleur RGB finale pour la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{hslList:'la liste de valeurs HSL (24 bits) finales d\xE9sir\xE9es, au format 0xHHSSLL',delay:'dur\xE9e de la transition en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['hsl_move']={syn:'Permet de faire passer un groupe de LED adjacentes de la couleur courante \xE0 une autre, de mani\xE8re continue et ind\xE9pendante.',lib:'colorledcluster.hsl_move()',pro:'def hsl_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Permet de faire passer un groupe de LED adjacentes de la couleur courante \xE0 une autre, de mani\xE8re continue et ind\xE9pendante. La transition se fait dans l\x27espace HSL. En HSL, la teinte \xE9tant une valeur circulaire (0..360\xB0) il y a toujours deux mani\xE8res d\x27op\xE9rer la transition: en augmentant ou en diminuant le teinte. Le module optera pour la transition passant par le chemin le plus court. dans le cas d\x27une diff\xE9rence d\x27exactement 180\xB0, il optera pour la transition qui augmente la valeur de la teinte.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',hslValue:'nouvelle couleur (0xHHSSLL)',delay:'dur\xE9e de la transistion enms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le cluster de LEDs RGB est joignable, sans d\xE9clencher d\x27erreur.',lib:'colorledcluster.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le cluster de LEDs RGB est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du cluster de LEDs RGB sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le cluster de LEDs RGB est joignable, <tt>false</tt> sinon'};
doc['ColorLedCluster']['linkLedToBlinkSeq']={syn:'Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence.',lib:'colorledcluster.linkLedToBlinkSeq()',pro:'def linkLedToBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence. Ces LEDs commenceront \xE0 ex\xE9cuter la s\xE9quence d\xE8s que son ex\xE9cution sera lanc\xE9 \xE0 l\x27aide de startBlinkSeq. Il est possible d\x27induire un d\xE9calage dans l\x27ex\xE9cution \xE0 l\x27aide du param\xE8tre offset. On peut ainsi cr\xE9er plusieurs groupes de LEDs qui ex\xE9cutent la m\xEAme s\xE9quence mais de mani\xE8re d\xE9cal\xE9e. Une LED ne peut \xEAtre affect\xE9e qu\x27\xE0 une seule s\xE9quence \xE0 la fois.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',seqIndex:'index de la s\xE9quence.',offset:'d\xE9calage dans l\x27ex\xE9cution de la s\xE9quence en ms'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['linkLedToBlinkSeqAtPowerOn']={syn:'Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence, au d\xE9marrage du module.',lib:'colorledcluster.linkLedToBlinkSeqAtPowerOn()',pro:'def linkLedToBlinkSeqAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence, au d\xE9marrage du module. Ne pas oublier de configurer le d\xE9marrage automatique de la s\xE9quence et d\x27appeler <tt>saveLedsConfigAtPowerOn()</tt>. Il est possible d\x27induire un d\xE9calage dans l\x27ex\xE9cution \xE0 l\x27aide du param\xE8tre offset. On peut ainsi cr\xE9er plusieurs groupes de LEDs qui ex\xE9cutent la m\xEAme s\xE9quence mais de mani\xE8re d\xE9cal\xE9e. Une LED ne peut \xEAtre affect\xE9e qu\x27\xE0 une seule s\xE9quence \xE0 la fois.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',seqIndex:'index de la s\xE9quence.',offset:'d\xE9calage dans l\x27ex\xE9cution de la s\xE9quence en ms'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['linkLedToPeriodicBlinkSeq']={syn:'Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence.',lib:'colorledcluster.linkLedToPeriodicBlinkSeq()',pro:'def linkLedToPeriodicBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>periods</span>)',cmt:'<p>Lie un groupe de LEDs adjacentes \xE0 une s\xE9quence. Ces LEDs commenceront \xE0 ex\xE9cuter la s\xE9quence d\xE8s que son ex\xE9cution sera lanc\xE9 \xE0 l\x27aide de startBlinkSeq. Cette fonction pr\xE9calcule un d\xE9calage entre les LEDs de sorte \xE0 ce que le nombre choisi de p\xE9riodes de la s\xE9quence soit visible sur le groupe de LEDs (effet d\x27onde).</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',seqIndex:'index de la s\xE9quence.',periods:'nombre de p\xE9riodes \xE0 r\xE9partir entre les LEDs.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['load']={syn:'Met en cache les valeurs courantes du cluster de LEDs RGB, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'colorledcluster.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du cluster de LEDs RGB, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'colorledcluster.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['ColorLedCluster']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'colorledcluster.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['nextColorLedCluster']={syn:'Continue l\x27\xE9num\xE9ration des clusters de LEDs RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLedCluster()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les clusters de LEDs RGB sont retourn\xE9s.',lib:'colorledcluster.nextColorLedCluster()',pro:'def nextColorLedCluster()',cmt:'<p>Continue l\x27\xE9num\xE9ration des clusters de LEDs RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLedCluster()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les clusters de LEDs RGB sont retourn\xE9s. Si vous souhaitez retrouver un cluster de LEDs RGB sp\xE9cifique, utilisez <tt>ColorLedCluster.findColorLedCluster()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YColorLedCluster</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['ColorLedCluster']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'colorledcluster.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['ColorLedCluster']['resetBlinkSeq']={syn:'Stoppe l\x27ex\xE9cution et efface le contenu d\x27une s\xE9quence.',lib:'colorledcluster.resetBlinkSeq()',pro:'def resetBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stoppe l\x27ex\xE9cution et efface le contenu d\x27une s\xE9quence. Les LEDs li\xE9es \xE0 cette s\xE9quence ne seront plus mises \xE0 jour.</p>',par:{seqIndex:'index de la s\xE9quence \xE0 r\xE9initialiser.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['rgbArrayOfs_move']={syn:'Configure une transition RGB vers une liste de couleurs RGB, pixel par pixel.',lib:'colorledcluster.rgbArrayOfs_move()',pro:'def rgbArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Configure une transition RGB vers une liste de couleurs RGB, pixel par pixel. Le premier entier correspond \xE0 la couleur RGB finale pour la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',rgbList:'la liste de valeurs RGB (24 bits) finales d\xE9sir\xE9es, au format 0xRRGGBB',delay:'dur\xE9e de la transition en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['rgbArray_move']={syn:'Configure une transition RGB vers une liste de couleurs RGB, pixel par pixel.',lib:'colorledcluster.rgbArray_move()',pro:'def rgbArray_move(<span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Configure une transition RGB vers une liste de couleurs RGB, pixel par pixel. Le premier entier correspond \xE0 la couleur RGB finale pour la premi\xE8re LED, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{rgbList:'la liste de valeurs RGB (24 bits) finales d\xE9sir\xE9es, au format 0xRRGGBB',delay:'dur\xE9e de la transition en ms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['rgb_move']={syn:'Permet de faire passer un groupe de LED adjacentes de la couleur courante \xE0 une autre, de mani\xE8re continue et ind\xE9pendante.',lib:'colorledcluster.rgb_move()',pro:'def rgb_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Permet de faire passer un groupe de LED adjacentes de la couleur courante \xE0 une autre, de mani\xE8re continue et ind\xE9pendante. La transition se fait dans l\x27espace RGB.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',rgbValue:'nouvelle couleur (0xRRGGBB)',delay:'dur\xE9e de la transistion enms.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['saveBlinkSeq']={syn:'Sauve la configuration d\x27une s\xE9quence.',lib:'colorledcluster.saveBlinkSeq()',pro:'def saveBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Sauve la configuration d\x27une s\xE9quence. Attention, seul les param\xE8tres de la s\xE9quence sont sauv\xE9s. Pour sauver le choix de s\xE9quence des LEDs il faut appeler la m\xE9thode <tt>saveLedsConfigAtPowerOn()</tt>.</p>',par:{seqIndex:'index de la s\xE9quence \xE0 lancer.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['saveLedsConfigAtPowerOn']={syn:'Sauve la configuration de d\xE9marrage des LEDs.',lib:'colorledcluster.saveLedsConfigAtPowerOn()',pro:'def saveLedsConfigAtPowerOn()',cmt:'<p>Sauve la configuration de d\xE9marrage des LEDs. Cela inclut la couleur de d\xE9marrage ou le choix de s\xE9quence de d\xE9marrage pour toutes les LEDs. Attention, si des LEDs sont li\xE9es \xE0 une s\xE9quence il faut appeler la m\xE9thode <tt>saveBlinkSeq()</tt> en plus pour sauver la d\xE9finition de la s\xE9quence.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_activeLedCount']={syn:'Modifie le nombre de LED actuellement g\xE9r\xE9es par le module.',lib:'colorledcluster.set_activeLedCount()',pro:'def set_activeLedCount(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de LED actuellement g\xE9r\xE9es par le module.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de LED actuellement g\xE9r\xE9es par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLedCluster']['set_blinkSeqSpeed']={syn:'Change la vitesse d\x27ex\xE9cution d\x27une s\xE9quence, en pour mille.',lib:'colorledcluster.set_blinkSeqSpeed()',pro:'def set_blinkSeqSpeed(<span id=pn>seqIndex</span>, <span id=pn>speed</span>)',cmt:'<p>Change la vitesse d\x27ex\xE9cution d\x27une s\xE9quence, en pour mille. La vitesse d\x27ex\xE9cution naturelle est de 1000 pour mille. En configurant une vitesse inf\xE9rieure, on peut jouer la s\xE9quence au ralenti. Une vitesse n\xE9gative permet m\xEAme de jouer la s\xE9quence \xE0 l\x27envers.</p>',par:{seqIndex:'index de la s\xE9quence \xE0 lancer.',speed:'vitesse d\x27ex\xE9cution de la s\xE9quence (-1000...1000).'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_blinkSeqStateAtPowerOn']={syn:'Configure une s\xE9quence pour qu\x27elle d\xE9marre automatiquement au d\xE9marrage du module.',lib:'colorledcluster.set_blinkSeqStateAtPowerOn()',pro:'def set_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>autostart</span>)',cmt:'<p>Configure une s\xE9quence pour qu\x27elle d\xE9marre automatiquement au d\xE9marrage du module. Attention, la dur\xE9e totale d\x27une s\xE9quence doit \xEAtre non nulle pour pouvoir \xEAtre lanc\xE9e. N\x27oubliez pas d\x27appeler <tt>saveBlinkSeq()</tt> pour sauvegarder la modification dans la m\xE9moire flash du module.</p>',par:{seqIndex:'index de la s\xE9quence concern\xE9e.',autostart:'0 pour que la s\xE9quence soit arr\xEAt\xE9e et 1 pour qu\x27elle d\xE9marre.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_hslColor']={syn:'Modifie la couleur courante d\x27un groupe de LED cons\xE9cutives en utilisant une couleur HSL .',lib:'colorledcluster.set_hslColor()',pro:'def set_hslColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Modifie la couleur courante d\x27un groupe de LED cons\xE9cutives en utilisant une couleur HSL . L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xHHSSLL.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',hslValue:'nouvelle couleur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_hslColorArray']={syn:'Envoie des couleurs HSL 24 bits (fournie sous forme d\x27une liste d\x27entiers) sur l\x27affichage LED HSL.',lib:'colorledcluster.set_hslColorArray()',pro:'def set_hslColorArray(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>)',cmt:'<p>Envoie des couleurs HSL 24 bits (fournie sous forme d\x27une liste d\x27entiers) sur l\x27affichage LED HSL. Le premier entier correspond \xE0 la couleur HSL de la LED indiqu\xE9e en argument, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',hslList:'la liste de valeurs HSL (24 bits) \xE0 envoyer, au format 0xHHSSLL'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_hslColorAtPowerOn']={syn:'Modifie la couleur au d\xE9marrage d\x27un groupe de LED cons\xE9cutives en utilisant une couleur HSL.',lib:'colorledcluster.set_hslColorAtPowerOn()',pro:'def set_hslColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Modifie la couleur au d\xE9marrage d\x27un groupe de LED cons\xE9cutives en utilisant une couleur HSL. L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xHHSSLL. N\x27oubliez pas d\x27appeler <tt>saveLedsConfigAtPowerOn()</tt> pour sauvegarder la modification dans la m\xE9moire flash du module.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',hslValue:'nouvelle couleur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_hslColorBuffer']={syn:'Envoie un objet binaire tel quel sur l\x27affichage LED HSL.',lib:'colorledcluster.set_hslColorBuffer()',pro:'def set_hslColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Envoie un objet binaire tel quel sur l\x27affichage LED HSL. Les trois premiers octets correspondent aux composantes HSL de la LED indiqu\xE9e en argument, les trois octets suivants \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',buff:'l\x27objet binaire \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_ledType']={syn:'Modifie le type de LEDs RGB actuellement g\xE9r\xE9es par le module.',lib:'colorledcluster.set_ledType()',pro:'def set_ledType(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de LEDs RGB actuellement g\xE9r\xE9es par le module.</p>',par:{newval:'soit <tt>Y_LEDTYPE_RGB</tt>, soit <tt>Y_LEDTYPE_RGBW</tt>, selon le type de LEDs RGB actuellement g\xE9r\xE9es par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['ColorLedCluster']['set_logicalName']={syn:'Modifie le nom logique du cluster de LEDs RGB.',lib:'colorledcluster.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du cluster de LEDs RGB. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du cluster de LEDs RGB.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_rgbColor']={syn:'Modifie la couleur courante d\x27un groupe de LED cons\xE9cutives en utilisant une couleur RGB (Rouge Vert Bleu).',lib:'colorledcluster.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Modifie la couleur courante d\x27un groupe de LED cons\xE9cutives en utilisant une couleur RGB (Rouge Vert Bleu). L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xRRGGBB.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',rgbValue:'nouvelle couleur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_rgbColorArray']={syn:'Envoie des couleurs RGB 24 bits (fournie sous forme d\x27une liste d\x27entiers) sur l\x27affichage LED RGB.',lib:'colorledcluster.set_rgbColorArray()',pro:'def set_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>)',cmt:'<p>Envoie des couleurs RGB 24 bits (fournie sous forme d\x27une liste d\x27entiers) sur l\x27affichage LED RGB. Le premier entier correspond \xE0 la couleur RGB de la LED indiqu\xE9e en argument, l\x27entier suivant \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',rgbList:'la liste de valeurs RGB (24 bits) \xE0 envoyer, au format 0xRRGGBB'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_rgbColorAtPowerOn']={syn:'Modifie la couleur au d\xE9marrage d\x27un groupe de LED cons\xE9cutives en utilisant une couleur RGB (Rouge Vert Bleu).',lib:'colorledcluster.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Modifie la couleur au d\xE9marrage d\x27un groupe de LED cons\xE9cutives en utilisant une couleur RGB (Rouge Vert Bleu). L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xRRGGBB. N\x27oubliez pas d\x27appeler <tt>saveLedsConfigAtPowerOn()</tt> pour sauvegarder la modification dans la m\xE9moire flash du module.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LED cons\xE9cutives affect\xE9s.',rgbValue:'nouvelle couleur.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_rgbColorBuffer']={syn:'Envoie un objet binaire tel quel sur l\x27affichage LED RGB.',lib:'colorledcluster.set_rgbColorBuffer()',pro:'def set_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Envoie un objet binaire tel quel sur l\x27affichage LED RGB. Les trois premiers octets correspondent aux composantes RGB de la LED indiqu\xE9e en argument, les trois octets suivants \xE0 la LED suivante, etc.</p>',par:{ledIndex:'index de la premi\xE8re LED qui doit \xEAtre modifi\xE9e',buff:'l\x27objet binaire \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'colorledcluster.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['ColorLedCluster']['startBlinkSeq']={syn:'D\xE9marre l\x27ex\xE9cution d\x27une s\xE9quence : toutes les LED li\xE9es \xE0 cette s\xE9quence vont commencer \xE0 l\x27ex\xE9cuter en boucle.',lib:'colorledcluster.startBlinkSeq()',pro:'def startBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>D\xE9marre l\x27ex\xE9cution d\x27une s\xE9quence : toutes les LED li\xE9es \xE0 cette s\xE9quence vont commencer \xE0 l\x27ex\xE9cuter en boucle. Attention, la dur\xE9e totale d\x27une s\xE9quence doit \xEAtre non nulle pour pouvoir \xEAtre lanc\xE9e.</p>',par:{seqIndex:'index de la s\xE9quence \xE0 lancer.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['stopBlinkSeq']={syn:'Stoppe l\x27ex\xE9cution d\x27une s\xE9quence.',lib:'colorledcluster.stopBlinkSeq()',pro:'def stopBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stoppe l\x27ex\xE9cution d\x27une s\xE9quence. Si la s\xE9quence est red\xE9marr\xE9e l\x27ex\xE9cution repartira du d\xE9but.</p>',par:{seqIndex:'index de la s\xE9quence \xE0 stopper.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['unlinkLedFromBlinkSeq']={syn:'D\xE9lie un groupe de LEDs adjacentes d\x27une s\xE9quence.',lib:'colorledcluster.unlinkLedFromBlinkSeq()',pro:'def unlinkLedFromBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>D\xE9lie un groupe de LEDs adjacentes d\x27une s\xE9quence.</p>',par:{ledIndex:'index de la premi\xE8re LED affect\xE9e.',count:'nombre de LEDs cons\xE9cutives affect\xE9es.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLedCluster']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'colorledcluster.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: ColorLedCluster)
//--- (generated code: SpiPort)
doc['SpiPort']={'':{syn:'Interface de la fonction SpiPort',inc:'from yocto_spiport import *',cmt:'<p>La fonction SpiPort permet de piloter enti\xE8rement un module d\x27interface SPI Yoctopuce, pour envoyer et recevoir des donn\xE9es et configurer les param\xE8tres de transmission (vitesse, nombre de bits, parit\xE9, contr\xF4le de flux et protocole). Notez que les interfaces SPI Yoctopuce ne sont pas des visibles comme des ports COM virtuels. Ils sont faits pour \xEAtre utilis\xE9s comme tous les autres modules Yoctopuce.</p>'}};
doc['SpiPort']['FindSpiPort']={syn:'Permet de retrouver une port SPI d\x27apr\xE8s un identifiant donn\xE9.',lib:'YSpiPort.FindSpiPort()',pro:'def FindSpiPort(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une port SPI d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le port SPI soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YSpiPort.isOnline()</tt> pour tester si le port SPI est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port SPI sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YSpiPort</tt> qui permet ensuite de contr\xF4ler le port SPI.'};
doc['SpiPort']['FirstSpiPort']={syn:'Commence l\x27\xE9num\xE9ration des le port SPI accessibles par la librairie.',lib:'YSpiPort.FirstSpiPort()',pro:'def FirstSpiPort()',cmt:'<p>Commence l\x27\xE9num\xE9ration des le port SPI accessibles par la librairie. Utiliser la fonction <tt>YSpiPort.nextSpiPort()</tt> pour it\xE9rer sur les autres le port SPI.</p>',ret:'un pointeur sur un objet <tt>YSpiPort</tt>, correspondant au premier port SPI accessible en ligne, ou <tt>null</tt> si il n\x27y a pas du port SPI disponibles.'};
doc['SpiPort']['clearCache']={syn:'Invalide le cache.',lib:'spiport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du port SPI. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['SpiPort']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port SPI au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'spiport.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du port SPI au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le port SPI (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SpiPort']['get_advertisedValue']={syn:'Retourne la valeur courante du port SPI (pas plus de 6 caract\xE8res).',lib:'spiport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port SPI (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port SPI (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SpiPort']['get_currentJob']={syn:'Retourne le nom du fichier de t\xE2ches actif en ce moment.',lib:'spiport.get_currentJob()',pro:'def get_currentJob()',cmt:'<p>Retourne le nom du fichier de t\xE2ches actif en ce moment.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du fichier de t\xE2ches actif en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SpiPort']['get_errCount']={syn:'Retourne le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'spiport.get_errCount()',pro:'def get_errCount()',cmt:'<p>Retourne le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27erreurs de communication d\xE9tect\xE9es depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port SPI.',lib:'spiport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port SPI. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port SPI.'};
doc['SpiPort']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port SPI.',lib:'spiport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du port SPI. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du port SPI.'};
doc['SpiPort']['get_friendlyName']={syn:'Retourne un identifiant global du port SPI au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'spiport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du port SPI au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du port SPI si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du port SPI (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port SPI en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SpiPort']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'spiport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['SpiPort']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du port SPI, sans r\xE9f\xE9rence au module.',lib:'spiport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du port SPI, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port SPI (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SpiPort']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du port SPI au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'spiport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du port SPI au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du port SPI (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le port SPI (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SpiPort']['get_lastMsg']={syn:'Retourne le dernier message re\xE7u (pour les protocoles de type Line, Frame).',lib:'spiport.get_lastMsg()',pro:'def get_lastMsg()',cmt:'<p>Retourne le dernier message re\xE7u (pour les protocoles de type Line, Frame).</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le dernier message re\xE7u (pour les protocoles de type Line, Frame)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SpiPort']['get_logicalName']={syn:'Retourne le nom logique du port SPI.',lib:'spiport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du port SPI.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port SPI.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SpiPort']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'spiport.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['SpiPort']['get_protocol']={syn:'Retourne le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res.',lib:'spiport.get_protocol()',pro:'def get_protocol()',cmt:'<p>Retourne le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res. Les valeurs possibles sont \x22Line\x22 pour des messages ASCII s\xE9par\xE9s par des retours de ligne, \x22Frame:[timeout]ms\x22 pour des messages binaires s\xE9par\xE9s par une temporisation, \x22Char\x22 pour un flux ASCII continu ou \x22Byte\x22 pour un flux binaire continue.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le type de protocole utilis\xE9 sur la communication s\xE9rie, sous forme d\x27une cha\xEEne de caract\xE8res',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SpiPort']['get_rxCount']={syn:'Retourne le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'spiport.get_rxCount()',pro:'def get_rxCount()',cmt:'<p>Retourne le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_rxMsgCount']={syn:'Retourne le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'spiport.get_rxMsgCount()',pro:'def get_rxMsgCount()',cmt:'<p>Retourne le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de messages re\xE7us depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_shiftSampling']={syn:'Retourne vrai si la ligne SDI est d\xE9phas\xE9e par rapport \xE0 la ligne SDO.',lib:'spiport.get_shiftSampling()',pro:'def get_shiftSampling()',cmt:'<p>Retourne vrai si la ligne SDI est d\xE9phas\xE9e par rapport \xE0 la ligne SDO.</p>',ret:'soit <tt>Y_SHIFTSAMPLING_OFF</tt>, soit <tt>Y_SHIFTSAMPLING_ON</tt>, selon vrai si la ligne SDI est d\xE9phas\xE9e par rapport \xE0 la ligne SDO',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SHIFTSAMPLING_INVALID</tt>.'};
doc['SpiPort']['get_spiMode']={syn:'Retourne les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22.',lib:'spiport.get_spiMode()',pro:'def get_spiMode()',cmt:'<p>Retourne les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22. La cha\xEEne contient le taux de transfert d\xE9sir\xE9, le mode SPI (entre 0 et 3) et l\x27ordre des bits.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SPIMODE_INVALID</tt>.'};
doc['SpiPort']['get_ssPolarity']={syn:'Retourne la polarit\xE9 de la ligne Slave Select (SS).',lib:'spiport.get_ssPolarity()',pro:'def get_ssPolarity()',cmt:'<p>Retourne la polarit\xE9 de la ligne Slave Select (SS).</p>',ret:'soit <tt>Y_SSPOLARITY_ACTIVE_LOW</tt>, soit <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, selon la polarit\xE9 de la ligne Slave Select (SS)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SSPOLARITY_INVALID</tt>.'};
doc['SpiPort']['get_startupJob']={syn:'Retourne le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'spiport.get_startupJob()',pro:'def get_startupJob()',cmt:'<p>Retourne le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du fichier de t\xE2ches \xE0 ex\xE9cuter au d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SpiPort']['get_txCount']={syn:'Retourne le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'spiport.get_txCount()',pro:'def get_txCount()',cmt:'<p>Retourne le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27octets transmis depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_txMsgCount']={syn:'Retourne le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro.',lib:'spiport.get_txMsgCount()',pro:'def get_txMsgCount()',cmt:'<p>Retourne le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro.</p>',ret:'un entier repr&eacute;sentant le nombre de messages envoy\xE9s depuis la derni\xE8re mise \xE0 z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'spiport.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['SpiPort']['get_voltageLevel']={syn:'Retourne le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.',lib:'spiport.get_voltageLevel()',pro:'def get_voltageLevel()',cmt:'<p>Retourne le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.</p>',ret:'une valeur parmi <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> et <tt>Y_VOLTAGELEVEL_RS485</tt> repr&eacute;sentant le niveau de tension utilis\xE9 par le module sur le port s\xE9rie',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SpiPort']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le port SPI est joignable, sans d\xE9clencher d\x27erreur.',lib:'spiport.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le port SPI est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du port SPI sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le port SPI est joignable, <tt>false</tt> sinon'};
doc['SpiPort']['load']={syn:'Met en cache les valeurs courantes du port SPI, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'spiport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du port SPI, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'spiport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['SpiPort']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'spiport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['nextSpiPort']={syn:'Continue l\x27\xE9num\xE9ration des le port SPI commenc\xE9e \xE0 l\x27aide de <tt>yFirstSpiPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le port SPI sont retourn\xE9s.',lib:'spiport.nextSpiPort()',pro:'def nextSpiPort()',cmt:'<p>Continue l\x27\xE9num\xE9ration des le port SPI commenc\xE9e \xE0 l\x27aide de <tt>yFirstSpiPort()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les le port SPI sont retourn\xE9s. Si vous souhaitez retrouver une port SPI sp\xE9cifique, utilisez <tt>SpiPort.findSpiPort()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YSpiPort</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['SpiPort']['queryLine']={syn:'Envoie un message sous forme de ligne de texte sur le port s\xE9rie, et lit la r\xE9ponse re\xE7ue.',lib:'spiport.queryLine()',pro:'def queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Envoie un message sous forme de ligne de texte sur le port s\xE9rie, et lit la r\xE9ponse re\xE7ue. Cette fonction est pr\xE9vue pour \xEAtre utilis\xE9e lorsque le module est configur\xE9 en protocole \x27Line\x27.</p>',par:{query:'le message \xE0 envoyer (sans le retour de chariot)',maxWait:'le temps maximum d\x27attente pour obtenir une r\xE9ponse (en millisecondes).'},ret:'la premi\xE8re ligne de texte re\xE7ue apr\xE8s l\x27envoi du message. Les lignes suivantes peuvent \xEAtre obtenues avec des appels \xE0 readLine ou readMessages.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readArray']={syn:'Lit le contenu du tampon de r\xE9ception sous forme de liste d\x27octets, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readArray()',pro:'def readArray(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme de liste d\x27octets, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de bytes \xE0 lire'},ret:'une liste de bytes avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readBin']={syn:'Lit le contenu du tampon de r\xE9ception sous forme d\x27objet binaire, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readBin()',pro:'def readBin(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme d\x27objet binaire, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de bytes \xE0 lire'},ret:'un objet binaire avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readByte']={syn:'Lit le prochain byte dans le tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readByte()',pro:'def readByte()',cmt:'<p>Lit le prochain byte dans le tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, ou si aucun octet n\x27est disponible pour l\x27instant, la fonction retourne YAPI_NO_MORE_DATA.</p>',ret:'le prochain byte',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readHex']={syn:'Lit le contenu du tampon de r\xE9ception sous forme hexad\xE9cimale, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readHex()',pro:'def readHex(<span id=pn>nBytes</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme hexad\xE9cimale, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nBytes:'le nombre maximal d\x27octets \xE0 lire'},ret:'une cha\xEEne de caract\xE8re avec le contenu du tampon de r\xE9ception, encod\xE9 en hexad\xE9cimal',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readLine']={syn:'Lit la prochaine ligne (ou le prochain message) du tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readLine()',pro:'def readLine()',cmt:'<p>Lit la prochaine ligne (ou le prochain message) du tampon de r\xE9ception, \xE0 partir de la position courante dans le flux de donn\xE9e. Cette fonction est destin\xE9e \xE0 \xEAtre utilis\xE9e lorsque le module est configur\xE9 pour un protocole bas\xE9 message, comme en mode \x27Line\x27 ou en protocole \x27Frame\x27.</p><p> Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction retournera la plus ancienne ligne disponible et d\xE9placera le pointeur de position juste apr\xE8s. Si aucune nouvelle ligne enti\xE8re n\x27est disponible, la fonction retourne un cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8re avec une ligne de texte',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['readMessages']={syn:'Cherche les messages entrants dans le tampon de r\xE9ception correspondant \xE0 un format donn\xE9, \xE0 partir de la position courante.',lib:'spiport.readMessages()',pro:'def readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Cherche les messages entrants dans le tampon de r\xE9ception correspondant \xE0 un format donn\xE9, \xE0 partir de la position courante. Cette fonction ne compare et ne retourne que les caract\xE8res imprimables. Les protocoles binaires sont g\xE9r\xE9s sous forme de repr\xE9sentation hexad\xE9cimale.</p><p> La recherche retourne tous les messages trouv\xE9s qui correspondent au format. Tant qu\x27aucun message ad\xE9quat n\x27est trouv\xE9, la fonction attendra, au maximum pour le temps sp\xE9cifi\xE9 en argument (en millisecondes).</p>',par:{pattern:'une expression r\xE9guli\xE8re limit\xE9e d\xE9crivant le format de message d\xE9sir\xE9, ou une cha\xEEne vide si aucun filtrage des messages n\x27est d\xE9sir\xE9. Pour les protocoles binaires, le format est appliqu\xE9 \xE0 la repr\xE9sentation hexad\xE9cimale du message.',maxWait:'le temps maximum d\x27attente pour obtenir un message, tant qu\x27aucun n\x27est trouv\xE9 dans le tampon de r\xE9ception (en millisecondes).'},ret:'un tableau de cha\xEEnes de caract\xE8res contenant les messages trouv\xE9s. Les messages binaires sont convertis automatiquement en repr\xE9sentation hexad\xE9cimale.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un tableau vide.'};
doc['SpiPort']['readStr']={syn:'Lit le contenu du tampon de r\xE9ception sous forme de string, \xE0 partir de la position courante dans le flux de donn\xE9e.',lib:'spiport.readStr()',pro:'def readStr(<span id=pn>nChars</span>)',cmt:'<p>Lit le contenu du tampon de r\xE9ception sous forme de string, \xE0 partir de la position courante dans le flux de donn\xE9e. Si le contenu \xE0 la position n\x27est plus disponible dans le tampon de r\xE9ception, la fonction ne retournera que les donn\xE9es disponibles.</p>',par:{nChars:'le nombre maximum de caract\xE8res \xE0 lire'},ret:'une cha\xEEne de caract\xE8re avec le contenu du tampon de r\xE9ception.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['read_avail']={syn:'Retourne le nombre de bytes pr\xEAts \xE0 \xEAtre lus dans le tampon de r\xE9ception, depuis la position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.',lib:'spiport.read_avail()',pro:'def read_avail()',cmt:'<p>Retourne le nombre de bytes pr\xEAts \xE0 \xEAtre lus dans le tampon de r\xE9ception, depuis la position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.</p>',ret:'le nombre d\x27octets pr\xEAts \xE0 \xEAtre lus'};
doc['SpiPort']['read_seek']={syn:'Change le pointeur de position courante dans le flux de donn\xE9e \xE0 la valeur sp\xE9cifi\xE9e.',lib:'spiport.read_seek()',pro:'def read_seek(<span id=pn>absPos</span>)',cmt:'<p>Change le pointeur de position courante dans le flux de donn\xE9e \xE0 la valeur sp\xE9cifi\xE9e. Cette fonction n\x27a pas d\x27effet sur le module, elle ne fait que changer la valeur stock\xE9e dans l\x27objet d\x27API qui sera utilis\xE9e pour les prochaines operations de lecture.</p>',par:{absPos:'index de position absolue pour les op\xE9rations de lecture suivantes.'},ret:'rien du tout.'};
doc['SpiPort']['read_tell']={syn:'Retourne la valeur actuelle du pointeur de position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.',lib:'spiport.read_tell()',pro:'def read_tell()',cmt:'<p>Retourne la valeur actuelle du pointeur de position courante dans le flux de donn\xE9e utilis\xE9 par l\x27objet d\x27API.</p>',ret:'l\x27index de position absolue pour les prochaines op\xE9rations de lecture.'};
doc['SpiPort']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'spiport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['SpiPort']['reset']={syn:'Remet \xE0 z\xE9ro tous les compteurs et efface les tampons.',lib:'spiport.reset()',pro:'def reset()',cmt:'<p>Remet \xE0 z\xE9ro tous les compteurs et efface les tampons.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['selectJob']={syn:'Charge et execute le fichier de t\xE2che sp\xE9cifi\xE9.',lib:'spiport.selectJob()',pro:'def selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Charge et execute le fichier de t\xE2che sp\xE9cifi\xE9. Le fichier doit avoir \xE9t\xE9 pr\xE9alablement cr\xE9\xE9 en utilisant l\x27interface graphique, ou t\xE9l\xE9charg\xE9 sur le module \xE0 l\x27aide de la fonction <tt>uploadJob()</tt>.</p>',par:{jobfile:'nom du fichier de t\xE2che (fichier sur le module)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['set_SS']={syn:'Change manuellement l\x27\xE9tat de la ligne SS.',lib:'spiport.set_SS()',pro:'def set_SS(<span id=pn>val</span>)',cmt:'<p>Change manuellement l\x27\xE9tat de la ligne SS. Cette fonction n\x27a pas d\x27effet lorsque la gestion automatique de la ligne SS est activ\xE9e.</p>',par:{val:'1 pour activer la ligne SS, 0 pour la d\xE9sactiver.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['set_currentJob']={syn:'Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'spiport.set_currentJob()',pro:'def set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_logicalName']={syn:'Modifie le nom logique du port SPI.',lib:'spiport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du port SPI. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port SPI.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['set_protocol']={syn:'Modifie le type de protocol utilis\xE9 sur la communication s\xE9rie.',lib:'spiport.set_protocol()',pro:'def set_protocol(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de protocol utilis\xE9 sur la communication s\xE9rie. Les valeurs possibles sont \x22Line\x22 pour des messages ASCII s\xE9par\xE9s par des retours de ligne, \x22Frame:[timeout]ms\x22 pour des messages binaires s\xE9par\xE9s par une temporisation, \x22Char\x22 pour un flux ASCII continu ou \x22Byte\x22 pour un flux binaire continue. Le suffixe \x22/[wait]ms\x22 peut \xEAtre ajout\xE9 pour r\xE9duire la cadence d\x27\xE9mission de sorte \xE0 ce qu\x27il y ait au minimum le nombre sp\xE9cifi\xE9 de millisecondes d\x27intervalle entre l\x27envoi de chaque byte.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le type de protocol utilis\xE9 sur la communication s\xE9rie'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_shiftSampling']={syn:'Modifie le d\xE9phasage de l\x27\xE9chanillonage de SDI par rapport \xE0 SDO.',lib:'spiport.set_shiftSampling()',pro:'def set_shiftSampling(<span id=pn>newval</span>)',cmt:'<p>Modifie le d\xE9phasage de l\x27\xE9chanillonage de SDI par rapport \xE0 SDO. Lorsque le d\xE9phasage est d\xE9sactiv\xE9, SDI est lu au milieu de la phase du cycle de sortie de la ligne SDO. Lorsqu\x27il est activ\xE9, SDI est lu \xE0 la fin du cycle de sortie de SDO.</p>',par:{newval:'soit <tt>Y_SHIFTSAMPLING_OFF</tt>, soit <tt>Y_SHIFTSAMPLING_ON</tt>, selon le d\xE9phasage de l\x27\xE9chanillonage de SDI par rapport \xE0 SDO'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_spiMode']={syn:'Modifie les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22.',lib:'spiport.set_spiMode()',pro:'def set_spiMode(<span id=pn>newval</span>)',cmt:'<p>Modifie les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22. La cha\xEEne contient le taux de transfert d\xE9sir\xE9, le mode SPI (entre 0 et 3) et l\x27ordre des bits.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant les param\xE8tres de communication du port, sous forme d\x27une cha\xEEne de caract\xE8res du type \x22125000,0,msb\x22'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_ssPolarity']={syn:'Modifie la polarit\xE9 de la ligne Slave Select (SS).',lib:'spiport.set_ssPolarity()',pro:'def set_ssPolarity(<span id=pn>newval</span>)',cmt:'<p>Modifie la polarit\xE9 de la ligne Slave Select (SS).</p>',par:{newval:'soit <tt>Y_SSPOLARITY_ACTIVE_LOW</tt>, soit <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, selon la polarit\xE9 de la ligne Slave Select (SS)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_startupJob']={syn:'Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module.',lib:'spiport.set_startupJob()',pro:'def set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant le nom du job \xE0 ex\xE9cuter au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'spiport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['SpiPort']['set_voltageLevel']={syn:'Modifie le niveau de tension utilis\xE9 par le module sur le port s\xE9rie.',lib:'spiport.set_voltageLevel()',pro:'def set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Modifie le niveau de tension utilis\xE9 par le module sur le port s\xE9rie. Les valeurs valides d\xE9pendent du mod\xE8le de module Yoctopuce h\xE9bergeant le port s\xE9rie. Consultez la documentation de votre module pour savoir quelles valeurs sont support\xE9es. Affecter une valeur invalide n\x27aura aucun effet.</p>',par:{newval:'une valeur parmi <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> et <tt>Y_VOLTAGELEVEL_RS485</tt> repr&eacute;sentant le niveau de tension utilis\xE9 par le module sur le port s\xE9rie'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['SpiPort']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'spiport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['uploadJob']={syn:'Sauvegarde une d\xE9finition de t\xE2che (au format JSON) dans un fichier.',lib:'spiport.uploadJob()',pro:'def uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Sauvegarde une d\xE9finition de t\xE2che (au format JSON) dans un fichier. Le fichier peut ensuite \xEAtre activ\xE9 \xE0 l\x27aide de la m\xE9thode <tt>selectJob()</tt>.</p>',par:{jobfile:'nom du fichier de t\xE2che sur le module',jsonDef:'une cha\xEEne de caract\xE8res contenant la d\xE9finition du job en JSON'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeArray']={syn:'Envoie une s\xE9quence d\x27octets (fournie sous forme d\x27une liste) sur le port s\xE9rie.',lib:'spiport.writeArray()',pro:'def writeArray(<span id=pn>byteList</span>)',cmt:'<p>Envoie une s\xE9quence d\x27octets (fournie sous forme d\x27une liste) sur le port s\xE9rie.</p>',par:{byteList:'la liste d\x27octets \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeBin']={syn:'Envoie un objet binaire tel quel sur le port s\xE9rie.',lib:'spiport.writeBin()',pro:'def writeBin(<span id=pn>buff</span>)',cmt:'<p>Envoie un objet binaire tel quel sur le port s\xE9rie.</p>',par:{buff:'l\x27objet binaire \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeByte']={syn:'Envoie un unique byte sur le port s\xE9rie.',lib:'spiport.writeByte()',pro:'def writeByte(<span id=pn>code</span>)',cmt:'<p>Envoie un unique byte sur le port s\xE9rie.</p>',par:{code:'le byte \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeHex']={syn:'Envoie une s\xE9quence d\x27octets (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie.',lib:'spiport.writeHex()',pro:'def writeHex(<span id=pn>hexString</span>)',cmt:'<p>Envoie une s\xE9quence d\x27octets (fournie sous forme de cha\xEEne hexad\xE9cimale) sur le port s\xE9rie.</p>',par:{hexString:'la cha\xEEne hexad\xE9cimale \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeLine']={syn:'Envoie une cha\xEEne de caract\xE8res sur le port s\xE9rie, suivie d\x27un saut de ligne (CR LF).',lib:'spiport.writeLine()',pro:'def writeLine(<span id=pn>text</span>)',cmt:'<p>Envoie une cha\xEEne de caract\xE8res sur le port s\xE9rie, suivie d\x27un saut de ligne (CR LF).</p>',par:{text:'la cha\xEEne de caract\xE8res \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['SpiPort']['writeStr']={syn:'Envoie une cha\xEEne de caract\xE8res telle quelle sur le port s\xE9rie.',lib:'spiport.writeStr()',pro:'def writeStr(<span id=pn>text</span>)',cmt:'<p>Envoie une cha\xEEne de caract\xE8res telle quelle sur le port s\xE9rie.</p>',par:{text:'la cha\xEEne de caract\xE8res \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: SpiPort)
//--- (generated code: MessageBox)
doc['MessageBox']={'':{syn:'Interface de la fonction MessageBox',inc:'from yocto_messagebox import *',cmt:'<p>La fonction YMessageBox permet de recevoir et d\x27envoyer des messages SMS \xE0 l\x27aide des modules Yoctopuce dot\xE9s de connectivit\xE9 cellulaire.</p>'}};
doc['MessageBox']['FindMessageBox']={syn:'Permet de retrouver une interface de messagerie d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMessageBox.FindMessageBox()',pro:'def FindMessageBox(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface de messagerie d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27interface de messagerie soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMessageBox.isOnline()</tt> pour tester si l\x27interface de messagerie est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface de messagerie sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMessageBox</tt> qui permet ensuite de contr\xF4ler l\x27interface de messagerie.'};
doc['MessageBox']['FirstMessageBox']={syn:'Commence l\x27\xE9num\xE9ration des interfaces de messagerie accessibles par la librairie.',lib:'YMessageBox.FirstMessageBox()',pro:'def FirstMessageBox()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces de messagerie accessibles par la librairie. Utiliser la fonction <tt>YMessageBox.nextMessageBox()</tt> pour it\xE9rer sur les autres interfaces de messagerie.</p>',ret:'un pointeur sur un objet <tt>YMessageBox</tt>, correspondant \xE0 la premi\xE8re interface de messagerie accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces de messagerie disponibles.'};
doc['MessageBox']['clearCache']={syn:'Invalide le cache.',lib:'messagebox.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27interface de messagerie. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['MessageBox']['clearPduCounters']={syn:'R\xE9initialise les compteurs d\x27unit\xE9s SMS transmises et re\xE7ues.',lib:'messagebox.clearPduCounters()',pro:'def clearPduCounters()',cmt:'<p>R\xE9initialise les compteurs d\x27unit\xE9s SMS transmises et re\xE7ues.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface de messagerie au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'messagebox.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27interface de messagerie au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27interface de messagerie (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MessageBox']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface de messagerie (pas plus de 6 caract\xE8res).',lib:'messagebox.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface de messagerie (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface de messagerie (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MessageBox']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface de messagerie.',lib:'messagebox.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface de messagerie. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface de messagerie.'};
doc['MessageBox']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface de messagerie.',lib:'messagebox.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27interface de messagerie. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27interface de messagerie.'};
doc['MessageBox']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27interface de messagerie au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'messagebox.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27interface de messagerie au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27interface de messagerie si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27interface de messagerie (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface de messagerie en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MessageBox']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'messagebox.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['MessageBox']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27interface de messagerie, sans r\xE9f\xE9rence au module.',lib:'messagebox.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27interface de messagerie, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface de messagerie (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MessageBox']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27interface de messagerie au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'messagebox.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27interface de messagerie au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27interface de messagerie (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27interface de messagerie (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MessageBox']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface de messagerie.',lib:'messagebox.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface de messagerie.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface de messagerie.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MessageBox']['get_messages']={syn:'Retourne la liste des messages re\xE7us et non effac\xE9s.',lib:'messagebox.get_messages()',pro:'def get_messages()',cmt:'<p>Retourne la liste des messages re\xE7us et non effac\xE9s. Cette fonction d\xE9code automatiquement les SMS concat\xE9n\xE9s.</p>',ret:'une liste d\x27objets YSms.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['MessageBox']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'messagebox.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['MessageBox']['get_pduReceived']={syn:'Retourne le nombre d\x27unit\xE9s SMS re\xE7ues jusqu\x27\xE0 pr\xE9sent.',lib:'messagebox.get_pduReceived()',pro:'def get_pduReceived()',cmt:'<p>Retourne le nombre d\x27unit\xE9s SMS re\xE7ues jusqu\x27\xE0 pr\xE9sent.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27unit\xE9s SMS re\xE7ues jusqu\x27\xE0 pr\xE9sent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PDURECEIVED_INVALID</tt>.'};
doc['MessageBox']['get_pduSent']={syn:'Retourne le nombre d\x27unit\xE9s SMS envoy\xE9es jusqu\x27\xE0 pr\xE9sent.',lib:'messagebox.get_pduSent()',pro:'def get_pduSent()',cmt:'<p>Retourne le nombre d\x27unit\xE9s SMS envoy\xE9es jusqu\x27\xE0 pr\xE9sent.</p>',ret:'un entier repr&eacute;sentant le nombre d\x27unit\xE9s SMS envoy\xE9es jusqu\x27\xE0 pr\xE9sent',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PDUSENT_INVALID</tt>.'};
doc['MessageBox']['get_slotsCount']={syn:'Retourne le nombre total de positions de stockage dans la carte SIM.',lib:'messagebox.get_slotsCount()',pro:'def get_slotsCount()',cmt:'<p>Retourne le nombre total de positions de stockage dans la carte SIM.</p>',ret:'un entier repr&eacute;sentant le nombre total de positions de stockage dans la carte SIM',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SLOTSCOUNT_INVALID</tt>.'};
doc['MessageBox']['get_slotsInUse']={syn:'Retourne le nombre de positions de stockage utilis\xE9es.',lib:'messagebox.get_slotsInUse()',pro:'def get_slotsInUse()',cmt:'<p>Retourne le nombre de positions de stockage utilis\xE9es.</p>',ret:'un entier repr&eacute;sentant le nombre de positions de stockage utilis\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SLOTSINUSE_INVALID</tt>.'};
doc['MessageBox']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'messagebox.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['MessageBox']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27interface de messagerie est joignable, sans d\xE9clencher d\x27erreur.',lib:'messagebox.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27interface de messagerie est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27interface de messagerie sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27interface de messagerie est joignable, <tt>false</tt> sinon'};
doc['MessageBox']['load']={syn:'Met en cache les valeurs courantes de l\x27interface de messagerie, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'messagebox.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27interface de messagerie, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'messagebox.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['MessageBox']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'messagebox.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['newMessage']={syn:'Cr\xE9e un nouveau message SMS vide, qui pourra ensuite \xEAtre librement param\xE9tr\xE9 puis envoy\xE9.',lib:'messagebox.newMessage()',pro:'def newMessage(<span id=pn>recipient</span>)',cmt:'<p>Cr\xE9e un nouveau message SMS vide, qui pourra ensuite \xEAtre librement param\xE9tr\xE9 puis envoy\xE9.</p>',par:{recipient:'une cha\xEEne de caract\xE8res contenant le num\xE9ro de t\xE9l\xE9phone, du destinataire, soit au format national, soit au format international commen\xE7ant par un signe plus'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['nextMessageBox']={syn:'Continue l\x27\xE9num\xE9ration des interfaces de messagerie commenc\xE9e \xE0 l\x27aide de <tt>yFirstMessageBox()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces de messagerie sont retourn\xE9s.',lib:'messagebox.nextMessageBox()',pro:'def nextMessageBox()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces de messagerie commenc\xE9e \xE0 l\x27aide de <tt>yFirstMessageBox()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les interfaces de messagerie sont retourn\xE9s. Si vous souhaitez retrouver une interface de messagerie sp\xE9cifique, utilisez <tt>MessageBox.findMessageBox()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMessageBox</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['MessageBox']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'messagebox.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MessageBox']['sendFlashMessage']={syn:'Envoie un SMS \x22Flash\x22, aussi appel\xE9 message de classe 0.',lib:'messagebox.sendFlashMessage()',pro:'def sendFlashMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Envoie un SMS \x22Flash\x22, aussi appel\xE9 message de classe 0. Les messages flash s\x27affichent directement sur l\x27\xE9cran du t\xE9l\xE9phone du destinataire, et ne sont en principe pas sauv\xE9s sur la carte SIM. Cette fonction est capable d\x27envoyer des messages de plus de 160 caract\xE8res, \xE0 l\x27aide de la technique de concat\xE9nation de SMS. Les caract\xE8res accentu\xE9s de l\x27alphabet ISO-latin sont support\xE9s. Pour envoyer des messages avec des caract\xE8res unicodes plus sp\xE9ciaux tels que des caract\xE8res asiatiques et des \xE9motic\xF4nes, cr\xE9ez un message avec la m\xE9thode <tt>newMessage</tt> et d\xE9finissez son contenu avec la m\xE9thode <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'une cha\xEEne de caract\xE8res contenant le num\xE9ro de t\xE9l\xE9phone, du destinataire, soit au format national, soit au format international commen\xE7ant par un signe plus',message:'le texte du message \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['sendTextMessage']={syn:'Envoie un SMS textuel, avec les param\xE8tres standards.',lib:'messagebox.sendTextMessage()',pro:'def sendTextMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Envoie un SMS textuel, avec les param\xE8tres standards. Cette fonction est capable d\x27envoyer des messages de plus de 160 caract\xE8res, \xE0 l\x27aide de la technique de concat\xE9nation de SMS. Les caract\xE8res accentu\xE9s de l\x27alphabet ISO-latin sont support\xE9s. Pour envoyer des messages avec des caract\xE8res unicodes plus sp\xE9ciaux tels que des caract\xE8res asiatiques et des \xE9motic\xF4nes, cr\xE9ez un message avec la m\xE9thode <tt>newMessage</tt> et d\xE9finissez son contenu avec les m\xE9thodes <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'une cha\xEEne de caract\xE8res contenant le num\xE9ro de t\xE9l\xE9phone, du destinataire, soit au format national, soit au format international commen\xE7ant par un signe plus',message:'le texte du message \xE0 envoyer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface de messagerie.',lib:'messagebox.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface de messagerie. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface de messagerie.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MessageBox']['set_pduReceived']={syn:'Modifie la valeur du compteur d\x27unit\xE9s SMS re\xE7ues.',lib:'messagebox.set_pduReceived()',pro:'def set_pduReceived(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur du compteur d\x27unit\xE9s SMS re\xE7ues.</p>',par:{newval:'un entier repr&eacute;sentant la valeur du compteur d\x27unit\xE9s SMS re\xE7ues'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MessageBox']['set_pduSent']={syn:'Modifie la valeur du compteur d\x27unit\xE9s SMS envoy\xE9es.',lib:'messagebox.set_pduSent()',pro:'def set_pduSent(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur du compteur d\x27unit\xE9s SMS envoy\xE9es.</p>',par:{newval:'un entier repr&eacute;sentant la valeur du compteur d\x27unit\xE9s SMS envoy\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MessageBox']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'messagebox.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['MessageBox']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'messagebox.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: MessageBox)
//--- (generated code: StepperMotor)
doc['StepperMotor']={'':{syn:'Interface de la fonction StepperMotor',inc:'from yocto_steppermotor import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter un moteur pas \xE0 pas.</p>'}};
doc['StepperMotor']['FindStepperMotor']={syn:'Permet de retrouver un moteur pas \xE0 pas d\x27apr\xE8s un identifiant donn\xE9.',lib:'YStepperMotor.FindStepperMotor()',pro:'def FindStepperMotor(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un moteur pas \xE0 pas d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le moteur pas \xE0 pas soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YStepperMotor.isOnline()</tt> pour tester si le moteur pas \xE0 pas est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le moteur pas \xE0 pas sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YStepperMotor</tt> qui permet ensuite de contr\xF4ler le moteur pas \xE0 pas.'};
doc['StepperMotor']['FirstStepperMotor']={syn:'Commence l\x27\xE9num\xE9ration des moteur pas \xE0 pas accessibles par la librairie.',lib:'YStepperMotor.FirstStepperMotor()',pro:'def FirstStepperMotor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des moteur pas \xE0 pas accessibles par la librairie. Utiliser la fonction <tt>YStepperMotor.nextStepperMotor()</tt> pour it\xE9rer sur les autres moteur pas \xE0 pas.</p>',ret:'un pointeur sur un objet <tt>YStepperMotor</tt>, correspondant au premier moteur pas \xE0 pas accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de moteur pas \xE0 pas disponibles.'};
doc['StepperMotor']['abortAndBrake']={syn:'Stoppe le moteur en douceur d\xE8s que possible, sans attendre la fin de la commande actuelle.',lib:'steppermotor.abortAndBrake()',pro:'def abortAndBrake()',cmt:'<p>Stoppe le moteur en douceur d\xE8s que possible, sans attendre la fin de la commande actuelle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['abortAndHiZ']={syn:'Rel\xE2che le contr\xF4le du moteur imm\xE9diatement, sans attendre la fin de la commande actuelle.',lib:'steppermotor.abortAndHiZ()',pro:'def abortAndHiZ()',cmt:'<p>Rel\xE2che le contr\xF4le du moteur imm\xE9diatement, sans attendre la fin de la commande actuelle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['alertStepDir']={syn:'Avance le moteur d\x27un pas dans le sens choisi en ignorant les fins de courses, m\xEAme si le syst\xE8me est encore en alerte (interrupteur de fin de course enclanch\xE9).',lib:'steppermotor.alertStepDir()',pro:'def alertStepDir(<span id=pn>dir</span>)',cmt:'<p>Avance le moteur d\x27un pas dans le sens choisi en ignorant les fins de courses, m\xEAme si le syst\xE8me est encore en alerte (interrupteur de fin de course enclanch\xE9). Attention, utilisez cette fonction avec prudence car elle peut entra\xEEner des d\xE9gats m\xE9caniques !</p>',par:{dir:'La valeur +1 ou -1, selon la direction d\xE9sir\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['alertStepOut']={syn:'Avance le moteur d\x27un pas dans le sens inverse du mouvement en cours lors de la derni\xE8re alerte.',lib:'steppermotor.alertStepOut()',pro:'def alertStepOut()',cmt:'<p>Avance le moteur d\x27un pas dans le sens inverse du mouvement en cours lors de la derni\xE8re alerte. L\x27avance est possible m\xEAme si le syst\xE8me est encore en alerte (interrupteur de fin de course enclanch\xE9). Attention, utilisez cette fonction avec prudence car elle peut entra\xEEner des d\xE9gats m\xE9caniques !</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['changeSpeed']={syn:'Lance a moteur \xE0 une vitesse sp\xE9cifique.',lib:'steppermotor.changeSpeed()',pro:'def changeSpeed(<span id=pn>speed</span>)',cmt:'<p>Lance a moteur \xE0 une vitesse sp\xE9cifique. Le temps apr\xE8s lequel la vitesse sera atteinte d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration configur\xE9s pour le moteur.</p>',par:{speed:'vitesse d\xE9sir\xE9e, en pas par seconde. La vitesse minimale non-nulle est de 0.001 impulsion par seconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['clearCache']={syn:'Invalide le cache.',lib:'steppermotor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du moteur pas \xE0 pas. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['StepperMotor']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moteur pas \xE0 pas au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'steppermotor.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du moteur pas \xE0 pas au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le moteur pas \xE0 pas (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['StepperMotor']['emergencyStop']={syn:'Stoppe le moteur en urgence, sans autre pr\xE9caution.',lib:'steppermotor.emergencyStop()',pro:'def emergencyStop()',cmt:'<p>Stoppe le moteur en urgence, sans autre pr\xE9caution.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['findHomePosition']={syn:'Lance le moteur en arri\xE8re \xE0 la vitesse sp\xE9cifi\xE9e, pour chercher l\x27origine de l\x27axe.',lib:'steppermotor.findHomePosition()',pro:'def findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Lance le moteur en arri\xE8re \xE0 la vitesse sp\xE9cifi\xE9e, pour chercher l\x27origine de l\x27axe.</p>',par:{speed:'vitesse d\xE9sir\xE9e, en pas par seconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['get_advertisedValue']={syn:'Retourne la valeur courante du moteur pas \xE0 pas (pas plus de 6 caract\xE8res).',lib:'steppermotor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du moteur pas \xE0 pas (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du moteur pas \xE0 pas (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['StepperMotor']['get_auxSignal']={syn:'Retourne la valeur actuelle du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire.',lib:'steppermotor.get_auxSignal()',pro:'def get_auxSignal()',cmt:'<p>Retourne la valeur actuelle du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire.</p>',ret:'un entier repr&eacute;sentant la valeur actuelle du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_AUXSIGNAL_INVALID</tt>.'};
doc['StepperMotor']['get_diags']={syn:'Retourne l\x27\xE9tat d\xE9atill\xE9 du contr\xF4leur de moteur pas-\xE0-pas (bitmap).',lib:'steppermotor.get_diags()',pro:'def get_diags()',cmt:'<p>Retourne l\x27\xE9tat d\xE9atill\xE9 du contr\xF4leur de moteur pas-\xE0-pas (bitmap).</p>',ret:'un entier repr&eacute;sentant l\x27\xE9tat d\xE9atill\xE9 du contr\xF4leur de moteur pas-\xE0-pas (bitmap)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DIAGS_INVALID</tt>.'};
doc['StepperMotor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur pas \xE0 pas.',lib:'steppermotor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur pas \xE0 pas. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moteur pas \xE0 pas.'};
doc['StepperMotor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur pas \xE0 pas.',lib:'steppermotor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du moteur pas \xE0 pas. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du moteur pas \xE0 pas.'};
doc['StepperMotor']['get_friendlyName']={syn:'Retourne un identifiant global du moteur pas \xE0 pas au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'steppermotor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du moteur pas \xE0 pas au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du moteur pas \xE0 pas si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du moteur pas \xE0 pas (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur pas \xE0 pas en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['StepperMotor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'steppermotor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['StepperMotor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du moteur pas \xE0 pas, sans r\xE9f\xE9rence au module.',lib:'steppermotor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du moteur pas \xE0 pas, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur pas \xE0 pas (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['StepperMotor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du moteur pas \xE0 pas au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'steppermotor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du moteur pas \xE0 pas au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du moteur pas \xE0 pas (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le moteur pas \xE0 pas (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['StepperMotor']['get_logicalName']={syn:'Retourne le nom logique du moteur pas \xE0 pas.',lib:'steppermotor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du moteur pas \xE0 pas.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moteur pas \xE0 pas.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['StepperMotor']['get_maxAccel']={syn:'Retourne l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2.',lib:'steppermotor.get_maxAccel()',pro:'def get_maxAccel()',cmt:'<p>Retourne l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXACCEL_INVALID</tt>.'};
doc['StepperMotor']['get_maxSpeed']={syn:'Retourne la vitesse maximale du moteur, mesur\xE9e en pas par seconde.',lib:'steppermotor.get_maxSpeed()',pro:'def get_maxSpeed()',cmt:'<p>Retourne la vitesse maximale du moteur, mesur\xE9e en pas par seconde.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse maximale du moteur, mesur\xE9e en pas par seconde',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'steppermotor.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['StepperMotor']['get_motorState']={syn:'Retourne l\x27\xE9tat de fonctionnement du moteur.',lib:'steppermotor.get_motorState()',pro:'def get_motorState()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement du moteur.</p>',ret:'une valeur parmi <tt>Y_MOTORSTATE_ABSENT</tt>, <tt>Y_MOTORSTATE_ALERT</tt>, <tt>Y_MOTORSTATE_HI_Z</tt>, <tt>Y_MOTORSTATE_STOP</tt>, <tt>Y_MOTORSTATE_RUN</tt> et <tt>Y_MOTORSTATE_BATCH</tt> repr&eacute;sentant l\x27\xE9tat de fonctionnement du moteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MOTORSTATE_INVALID</tt>.'};
doc['StepperMotor']['get_overcurrent']={syn:'Retourne le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA.',lib:'steppermotor.get_overcurrent()',pro:'def get_overcurrent()',cmt:'<p>Retourne le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA.</p>',ret:'un entier repr&eacute;sentant le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['StepperMotor']['get_pullinSpeed']={syn:'Retourne la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde.',lib:'steppermotor.get_pullinSpeed()',pro:'def get_pullinSpeed()',cmt:'<p>Retourne la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULLINSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_speed']={syn:'Retourne la vitesse actuelle du moteur, mesur\xE9e en pas par seconde.',lib:'steppermotor.get_speed()',pro:'def get_speed()',cmt:'<p>Retourne la vitesse actuelle du moteur, mesur\xE9e en pas par seconde. Pour changer cette vitesse, utilisez la m\xE9thode <tt>changeSpeed()</tt>.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la vitesse actuelle du moteur, mesur\xE9e en pas par seconde',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SPEED_INVALID</tt>.'};
doc['StepperMotor']['get_stepPos']={syn:'Retourne la position logique actuelle du moteur, mesur\xE9e en pas.',lib:'steppermotor.get_stepPos()',pro:'def get_stepPos()',cmt:'<p>Retourne la position logique actuelle du moteur, mesur\xE9e en pas. La valeur peut \xEAtre fractionnaire lorsque le micro-stepping est utilis\xE9.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la position logique actuelle du moteur, mesur\xE9e en pas',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STEPPOS_INVALID</tt>.'};
doc['StepperMotor']['get_stepping']={syn:'Retourne le type de stepping utilis\xE9 pour piloter le moteur.',lib:'steppermotor.get_stepping()',pro:'def get_stepping()',cmt:'<p>Retourne le type de stepping utilis\xE9 pour piloter le moteur.</p>',ret:'une valeur parmi <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> et <tt>Y_STEPPING_FULLSTEP</tt> repr&eacute;sentant le type de stepping utilis\xE9 pour piloter le moteur',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_STEPPING_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrRun']={syn:'Retourne la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA.',lib:'steppermotor.get_tCurrRun()',pro:'def get_tCurrRun()',cmt:'<p>Retourne la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA.</p>',ret:'un entier repr&eacute;sentant la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TCURRRUN_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrStop']={syn:'Retourne la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA.',lib:'steppermotor.get_tCurrStop()',pro:'def get_tCurrStop()',cmt:'<p>Retourne la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA.</p>',ret:'un entier repr&eacute;sentant la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TCURRSTOP_INVALID</tt>.'};
doc['StepperMotor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'steppermotor.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['StepperMotor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le moteur pas \xE0 pas est joignable, sans d\xE9clencher d\x27erreur.',lib:'steppermotor.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le moteur pas \xE0 pas est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du moteur pas \xE0 pas sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le moteur pas \xE0 pas est joignable, <tt>false</tt> sinon'};
doc['StepperMotor']['load']={syn:'Met en cache les valeurs courantes du moteur pas \xE0 pas, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'steppermotor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du moteur pas \xE0 pas, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'steppermotor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['StepperMotor']['moveRel']={syn:'Contr\xF4le le moteur pour atteindre une position relative donn\xE9e.',lib:'steppermotor.moveRel()',pro:'def moveRel(<span id=pn>relPos</span>)',cmt:'<p>Contr\xF4le le moteur pour atteindre une position relative donn\xE9e. Le temps n\xE9cessaire pour atteindre la position d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration et de vitesse maximale configur\xE9s pour le moteur.</p>',par:{relPos:'position relative d\xE9sir\xE9e, en pas depuis la position actuelle.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['moveRelSlow']={syn:'Contr\xF4le le moteur pour atteindre une position relative donn\xE9e, sans d\xE9passer la vitesse sp\xE9cifi\xE9e.',lib:'steppermotor.moveRelSlow()',pro:'def moveRelSlow(<span id=pn>relPos</span>, <span id=pn>maxSpeed</span>)',cmt:'<p>Contr\xF4le le moteur pour atteindre une position relative donn\xE9e, sans d\xE9passer la vitesse sp\xE9cifi\xE9e. Le temps n\xE9cessaire pour atteindre la position d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration configur\xE9s pour le moteur.</p>',par:{relPos:'position relative d\xE9sir\xE9e, en pas depuis la position actuelle.',maxSpeed:'vitesse maximal \xE0 ne pas d\xE9passer d\xE9sir\xE9e, en pas par seconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['moveTo']={syn:'Contr\xF4le le moteur pour atteindre une position absolue donn\xE9e.',lib:'steppermotor.moveTo()',pro:'def moveTo(<span id=pn>absPos</span>)',cmt:'<p>Contr\xF4le le moteur pour atteindre une position absolue donn\xE9e. Le temps n\xE9cessaire pour atteindre la position d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration et de vitesse maximale configur\xE9s pour le moteur.</p>',par:{absPos:'position absolue d\xE9sir\xE9e, en pas depuis l\x27origine.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'steppermotor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['nextStepperMotor']={syn:'Continue l\x27\xE9num\xE9ration des moteur pas \xE0 pas commenc\xE9e \xE0 l\x27aide de <tt>yFirstStepperMotor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les moteur pas \xE0 pas sont retourn\xE9s.',lib:'steppermotor.nextStepperMotor()',pro:'def nextStepperMotor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des moteur pas \xE0 pas commenc\xE9e \xE0 l\x27aide de <tt>yFirstStepperMotor()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les moteur pas \xE0 pas sont retourn\xE9s. Si vous souhaitez retrouver un moteur pas \xE0 pas sp\xE9cifique, utilisez <tt>StepperMotor.findStepperMotor()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YStepperMotor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['StepperMotor']['pause']={syn:'Garde le moteur dans le m\xEAme \xE9tat pour la dur\xE9e sp\xE9cifi\xE9e, avant d\x27ex\xE9cuter la commande suivante.',lib:'steppermotor.pause()',pro:'def pause(<span id=pn>waitMs</span>)',cmt:'<p>Garde le moteur dans le m\xEAme \xE9tat pour la dur\xE9e sp\xE9cifi\xE9e, avant d\x27ex\xE9cuter la commande suivante.</p>',par:{waitMs:'temps d\x27attente, en milliseconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'steppermotor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['StepperMotor']['reset']={syn:'R\xE9initialise le controlleur et quittance toutes les alertes.',lib:'steppermotor.reset()',pro:'def reset()',cmt:'<p>R\xE9initialise le controlleur et quittance toutes les alertes.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['set_auxSignal']={syn:'Modifie la valeur du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire.',lib:'steppermotor.set_auxSignal()',pro:'def set_auxSignal(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire. Les valeurs valides d\xE9pendent de la configuration du type de signal utilis\xE9 sur la sortie auxiliaire.</p>',par:{newval:'un entier repr&eacute;sentant la valeur du signal g\xE9n\xE9r\xE9 sur la sortie auxiliaire'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_logicalName']={syn:'Modifie le nom logique du moteur pas \xE0 pas.',lib:'steppermotor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du moteur pas \xE0 pas. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du moteur pas \xE0 pas.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['StepperMotor']['set_maxAccel']={syn:'Modifie l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2.',lib:'steppermotor.set_maxAccel()',pro:'def set_maxAccel(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant l\x27acc\xE9l\xE9ration maximale du moteur, mesur\xE9e en pas par seconde^2'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_maxSpeed']={syn:'Modifie la vitesse maximale du moteur, mesur\xE9e en pas par seconde.',lib:'steppermotor.set_maxSpeed()',pro:'def set_maxSpeed(<span id=pn>newval</span>)',cmt:'<p>Modifie la vitesse maximale du moteur, mesur\xE9e en pas par seconde.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la vitesse maximale du moteur, mesur\xE9e en pas par seconde'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_overcurrent']={syn:'Modifie le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA.',lib:'steppermotor.set_overcurrent()',pro:'def set_overcurrent(<span id=pn>newval</span>)',cmt:'<p>Modifie le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA.</p>',par:{newval:'un entier repr&eacute;sentant le seuil de d\xE9clenchement de la s\xE9curit\xE9 de d\xE9passement de courant, mesur\xE9 en mA'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_pullinSpeed']={syn:'Modifie la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde.',lib:'steppermotor.set_pullinSpeed()',pro:'def set_pullinSpeed(<span id=pn>newval</span>)',cmt:'<p>Modifie la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la vitesse du moteur atteignable directement depuis l\x27arr\xEAt, mesur\xE9e en pas par seconde'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_stepPos']={syn:'Modifie la position logique actuelle du moteur, mesur\xE9e en pas.',lib:'steppermotor.set_stepPos()',pro:'def set_stepPos(<span id=pn>newval</span>)',cmt:'<p>Modifie la position logique actuelle du moteur, mesur\xE9e en pas. Cette commande ne d\xE9clanche pas de mouvement du moteur, elle sert uniquement \xE0 configurer l\x27origine du compteur de position. La partie fractionnaire, d\xE9pendant de la position physique du rotor, n\x27est pas modifi\xE9e. Pour d\xE9clancher un mouvement, utilisez la m\xE9thode <tt>moveTo()</tt> ou la m\xE9thode <tt>moveRel()</tt>.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la position logique actuelle du moteur, mesur\xE9e en pas'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_stepping']={syn:'Modifie le type de stepping utilis\xE9 pour piloter le moteur.',lib:'steppermotor.set_stepping()',pro:'def set_stepping(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de stepping utilis\xE9 pour piloter le moteur.</p>',par:{newval:'une valeur parmi <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> et <tt>Y_STEPPING_FULLSTEP</tt> repr&eacute;sentant le type de stepping utilis\xE9 pour piloter le moteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_tCurrRun']={syn:'Modifie la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA.',lib:'steppermotor.set_tCurrRun()',pro:'def set_tCurrRun(<span id=pn>newval</span>)',cmt:'<p>Modifie la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA.</p>',par:{newval:'un entier repr&eacute;sentant la limite de courant pour la r\xE9gulation de torque en mouvement, mesur\xE9e en mA'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_tCurrStop']={syn:'Modifie la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA.',lib:'steppermotor.set_tCurrStop()',pro:'def set_tCurrStop(<span id=pn>newval</span>)',cmt:'<p>Modifie la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA.</p>',par:{newval:'un entier repr&eacute;sentant la limite de courant pour la r\xE9gulation de torque \xE0 l\x27arr\xEAt, mesur\xE9e en mA'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['StepperMotor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'steppermotor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['StepperMotor']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'steppermotor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: StepperMotor)
//--- (generated code: Proximity)
doc['Proximity']={'':{syn:'Interface de la fonction Proximity',inc:'from yocto_proximity import *',cmt:'<p>La classe YProximity permet d\x27utiliser et de configurer les capteurs de proximit\xE9 Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet d\x27effectuer facilement une calibration lin\xE9aire \xE0 un point pour compenser l\x27effet d\x27une vitre ou d\x27un filtre plac\xE9 devant le capteur.</p>'}};
doc['Proximity']['FindProximity']={syn:'Permet de retrouver un capteur de proximit\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YProximity.FindProximity()',pro:'def FindProximity(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de proximit\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de proximit\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YProximity.isOnline()</tt> pour tester si le capteur de proximit\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de proximit\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YProximity</tt> qui permet ensuite de contr\xF4ler le capteur de proximit\xE9.'};
doc['Proximity']['FirstProximity']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de proximit\xE9 accessibles par la librairie.',lib:'YProximity.FirstProximity()',pro:'def FirstProximity()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de proximit\xE9 accessibles par la librairie. Utiliser la fonction <tt>YProximity.nextProximity()</tt> pour it\xE9rer sur les autres capteurs de proximit\xE9.</p>',ret:'un pointeur sur un objet <tt>YProximity</tt>, correspondant au premier capteur de proximit\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de proximit\xE9 disponibles.'};
doc['Proximity']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'proximity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['clearCache']={syn:'Invalide le cache.',lib:'proximity.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de proximit\xE9. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Proximity']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de proximit\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'proximity.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de proximit\xE9 au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de proximit\xE9 (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Proximity']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'proximity.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Proximity']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de proximit\xE9 (pas plus de 6 caract\xE8res).',lib:'proximity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de proximit\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de proximit\xE9 (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'proximity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentValue']={syn:'Retourne la valeur actuelle de la d\xE9tection de proximit\xE9, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'proximity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la d\xE9tection de proximit\xE9, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la d\xE9tection de proximit\xE9, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Proximity']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'proximity.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Proximity']['get_detectionHysteresis']={syn:'Retourne l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).',lib:'proximity.get_detectionHysteresis()',pro:'def get_detectionHysteresis()',cmt:'<p>Retourne l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).</p>',ret:'un entier repr&eacute;sentant l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DETECTIONHYSTERESIS_INVALID</tt>.'};
doc['Proximity']['get_detectionThreshold']={syn:'Retourne le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).',lib:'proximity.get_detectionThreshold()',pro:'def get_detectionThreshold()',cmt:'<p>Retourne le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).</p>',ret:'un entier repr&eacute;sentant le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DETECTIONTHRESHOLD_INVALID</tt>.'};
doc['Proximity']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de proximit\xE9.',lib:'proximity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de proximit\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de proximit\xE9.'};
doc['Proximity']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de proximit\xE9.',lib:'proximity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de proximit\xE9. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de proximit\xE9.'};
doc['Proximity']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de proximit\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'proximity.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de proximit\xE9 au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de proximit\xE9 si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de proximit\xE9 (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de proximit\xE9 en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Proximity']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'proximity.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Proximity']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de proximit\xE9, sans r\xE9f\xE9rence au module.',lib:'proximity.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de proximit\xE9, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de proximit\xE9 (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Proximity']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de proximit\xE9 au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'proximity.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de proximit\xE9 au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de proximit\xE9 (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de proximit\xE9 (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Proximity']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module.',lib:'proximity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_isPresent']={syn:'Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (valeur de d\xE9tection inf\xE9rieure au seuil <tt>threshold</tt>), et faux sinon.',lib:'proximity.get_isPresent()',pro:'def get_isPresent()',cmt:'<p>Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (valeur de d\xE9tection inf\xE9rieure au seuil <tt>threshold</tt>), et faux sinon.</p>',ret:'soit <tt>Y_ISPRESENT_FALSE</tt>, soit <tt>Y_ISPRESENT_TRUE</tt>, selon vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (valeur de d\xE9tection inf\xE9rieure au seuil <tt>threshold</tt>), et faux sinon',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ISPRESENT_INVALID</tt>.'};
doc['Proximity']['get_lastTimeApproached']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de absent \xE0 pr\xE9sent).',lib:'proximity.get_lastTimeApproached()',pro:'def get_lastTimeApproached()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de absent \xE0 pr\xE9sent).</p>',ret:'un entier repr&eacute;sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de absent \xE0 pr\xE9sent)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTTIMEAPPROACHED_INVALID</tt>.'};
doc['Proximity']['get_lastTimeRemoved']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de pr\xE9sent \xE0 absent).',lib:'proximity.get_lastTimeRemoved()',pro:'def get_lastTimeRemoved()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de pr\xE9sent \xE0 absent).</p>',ret:'un entier repr&eacute;sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re d\xE9tection observ\xE9e (transition de pr\xE9sent \xE0 absent)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LASTTIMEREMOVED_INVALID</tt>.'};
doc['Proximity']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'proximity.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_logicalName']={syn:'Retourne le nom logique du capteur de proximit\xE9.',lib:'proximity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de proximit\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de proximit\xE9.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Proximity']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module.',lib:'proximity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la d\xE9tection de proximit\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'proximity.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Proximity']['get_presenceMinTime']={syn:'Retourne la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e.',lib:'proximity.get_presenceMinTime()',pro:'def get_presenceMinTime()',cmt:'<p>Retourne la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e. Une pr\xE9sence de dur\xE9e inf\xE9rieure est consid\xE9r\xE9e comme un bruit ou un rebond (faux positif).</p>',ret:'un entier repr&eacute;sentant la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PRESENCEMINTIME_INVALID</tt>.'};
doc['Proximity']['get_proximityReportMode']={syn:'Retourne le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback.',lib:'proximity.get_proximityReportMode()',pro:'def get_proximityReportMode()',cmt:'<p>Retourne le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback.</p>',ret:'une valeur parmi <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> et <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> repr&eacute;sentant le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PROXIMITYREPORTMODE_INVALID</tt>.'};
doc['Proximity']['get_pulseCounter']={syn:'Retourne la valeur du compteur d\x27impulsions.',lib:'proximity.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Retourne la valeur du compteur d\x27impulsions. La valeur est cod\xE9e sur 32 bits. En cas de d\xE9passement de capacit\xE9 (>=2^32), le compteur repart \xE0 z\xE9ro. Le compteur peut \xEAtre r\xE9initialis\xE9 en appelant la m\xE9thode resetCounter().</p>',ret:'un entier repr&eacute;sentant la valeur du compteur d\x27impulsions',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['Proximity']['get_pulseTimer']={syn:'Retourne le timer du compteur d\x27impulsions (ms).',lib:'proximity.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Retourne le timer du compteur d\x27impulsions (ms).</p>',ret:'un entier repr&eacute;sentant le timer du compteur d\x27impulsions (ms)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Proximity']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'proximity.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Proximity']['get_removalMinTime']={syn:'Retourne la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e.',lib:'proximity.get_removalMinTime()',pro:'def get_removalMinTime()',cmt:'<p>Retourne la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e. Une absence de dur\xE9e inf\xE9rieure est consid\xE9r\xE9e comme un bruit ou un rebond (faux positif).</p>',ret:'un entier repr&eacute;sentant la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REMOVALMINTIME_INVALID</tt>.'};
doc['Proximity']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'proximity.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'proximity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Proximity']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'proximity.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Proximity']['get_signalValue']={syn:'Retourne la valeur actuelle du mesur\xE9 par le capteur de proximit\xE9.',lib:'proximity.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Retourne la valeur actuelle du mesur\xE9 par le capteur de proximit\xE9.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du mesur\xE9 par le capteur de proximit\xE9',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Proximity']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la d\xE9tection de proximit\xE9 est exprim\xE9e.',lib:'proximity.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la d\xE9tection de proximit\xE9 est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la d\xE9tection de proximit\xE9 est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Proximity']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'proximity.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Proximity']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de proximit\xE9 est joignable, sans d\xE9clencher d\x27erreur.',lib:'proximity.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de proximit\xE9 est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de proximit\xE9 sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de proximit\xE9 est joignable, <tt>false</tt> sinon'};
doc['Proximity']['load']={syn:'Met en cache les valeurs courantes du capteur de proximit\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'proximity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de proximit\xE9, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'proximity.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Proximity']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'proximity.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'proximity.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['nextProximity']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de proximit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstProximity()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de proximit\xE9 sont retourn\xE9s.',lib:'proximity.nextProximity()',pro:'def nextProximity()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de proximit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstProximity()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de proximit\xE9 sont retourn\xE9s. Si vous souhaitez retrouver un capteur de proximit\xE9 sp\xE9cifique, utilisez <tt>Proximity.findProximity()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YProximity</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Proximity']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'proximity.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Proximity']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'proximity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Proximity']['resetCounter']={syn:'R\xE9initialise le compteur d\x27impulsions et son timer.',lib:'proximity.resetCounter()',pro:'def resetCounter()',cmt:'<p>R\xE9initialise le compteur d\x27impulsions et son timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'proximity.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_detectionHysteresis']={syn:'Modifie l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).',lib:'proximity.set_detectionHysteresis()',pro:'def set_detectionHysteresis(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).</p>',par:{newval:'un entier repr&eacute;sentant l\x27hysteresis utilis\xE9e pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_detectionThreshold']={syn:'Modifie le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).',lib:'proximity.set_detectionThreshold()',pro:'def set_detectionThreshold(<span id=pn>newval</span>)',cmt:'<p>Modifie le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off).</p>',par:{newval:'un entier repr&eacute;sentant le seuil utilis\xE9 pour d\xE9terminer l\x27\xE9tat logique de la d\xE9tection de proximit\xE9, lorsqu\x27on la traite comme une entr\xE9e binaire (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'proximity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'proximity.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_logicalName']={syn:'Modifie le nom logique du capteur de proximit\xE9.',lib:'proximity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de proximit\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de proximit\xE9.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Proximity']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'proximity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_presenceMinTime']={syn:'Modifie la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e.',lib:'proximity.set_presenceMinTime()',pro:'def set_presenceMinTime(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e. Une pr\xE9sence de dur\xE9e inf\xE9rieure est consid\xE9r\xE9e comme un bruit ou un rebond (faux positif).</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e minimale durant laquelle la pr\xE9sence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_proximityReportMode']={syn:'Modifie le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback.',lib:'proximity.set_proximityReportMode()',pro:'def set_proximityReportMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback. Seuls les six digits de droite du nombre de changements d\x27\xE9tat sont transmis, pour les valeurs plus grandes que un million, utiliser get_pulseCounter().</p>',par:{newval:'une valeur parmi <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> et <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> repr&eacute;sentant le type de param\xE8tre (valeur du capteur, pr\xE9sence ou compteur d\x27impulsion) renvoy\xE9 par la fonction get_currentValue et les callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_removalMinTime']={syn:'Modifie la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e.',lib:'proximity.set_removalMinTime()',pro:'def set_removalMinTime(<span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e. Une absence de dur\xE9e inf\xE9rieure est consid\xE9r\xE9e comme un bruit ou un rebond (faux positif).</p>',par:{newval:'un entier repr&eacute;sentant la dur\xE9e minimale durant laquelle l\x27absence doit \xEAtre d\xE9tect\xE9e avant d\x27\xEAtre signal\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'proximity.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'proximity.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Proximity']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'proximity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Proximity']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'proximity.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Proximity']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'proximity.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Proximity']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'proximity.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Proximity)
//--- (generated code: MultiAxisController)
doc['MultiAxisController']={'':{syn:'Interface de la fonction MultiAxisController',inc:'from yocto_multiaxiscontroller import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter un moteur pas \xE0 pas.</p>'}};
doc['MultiAxisController']['FindMultiAxisController']={syn:'Permet de retrouver un contr\xF4leur multi-axe d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMultiAxisController.FindMultiAxisController()',pro:'def FindMultiAxisController(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4leur multi-axe d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le contr\xF4leur multi-axe soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMultiAxisController.isOnline()</tt> pour tester si le contr\xF4leur multi-axe est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4leur multi-axe sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMultiAxisController</tt> qui permet ensuite de contr\xF4ler le contr\xF4leur multi-axe.'};
doc['MultiAxisController']['FirstMultiAxisController']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-axe accessibles par la librairie.',lib:'YMultiAxisController.FirstMultiAxisController()',pro:'def FirstMultiAxisController()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-axe accessibles par la librairie. Utiliser la fonction <tt>YMultiAxisController.nextMultiAxisController()</tt> pour it\xE9rer sur les autres contr\xF4leur multi-axe.</p>',ret:'un pointeur sur un objet <tt>YMultiAxisController</tt>, correspondant au premier contr\xF4leur multi-axe accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4leur multi-axe disponibles.'};
doc['MultiAxisController']['abortAndBrake']={syn:'Stoppe le moteur en douceur d\xE8s que possible, sans attendre la fin de la commande actuelle.',lib:'multiaxiscontroller.abortAndBrake()',pro:'def abortAndBrake()',cmt:'<p>Stoppe le moteur en douceur d\xE8s que possible, sans attendre la fin de la commande actuelle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['abortAndHiZ']={syn:'Rel\xE2che le contr\xF4le du moteur imm\xE9diatement, sans attendre la fin de la commande actuelle.',lib:'multiaxiscontroller.abortAndHiZ()',pro:'def abortAndHiZ()',cmt:'<p>Rel\xE2che le contr\xF4le du moteur imm\xE9diatement, sans attendre la fin de la commande actuelle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['clearCache']={syn:'Invalide le cache.',lib:'multiaxiscontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du contr\xF4leur multi-axe. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['MultiAxisController']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-axe au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multiaxiscontroller.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-axe au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le contr\xF4leur multi-axe (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiAxisController']['emergencyStop']={syn:'Stoppe le moteur en urgence, sans autre pr\xE9caution.',lib:'multiaxiscontroller.emergencyStop()',pro:'def emergencyStop()',cmt:'<p>Stoppe le moteur en urgence, sans autre pr\xE9caution.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['findHomePosition']={syn:'Lance tous les moteur en arri\xE8re aux vitesses sp\xE9cifi\xE9es, pour chercher les origines des axes.',lib:'multiaxiscontroller.findHomePosition()',pro:'def findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Lance tous les moteur en arri\xE8re aux vitesses sp\xE9cifi\xE9es, pour chercher les origines des axes.</p>',par:{speed:'vitesse d\xE9sir\xE9e pour chaque axe, en pas par seconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4leur multi-axe (pas plus de 6 caract\xE8res).',lib:'multiaxiscontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4leur multi-axe (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4leur multi-axe (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiAxisController']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-axe.',lib:'multiaxiscontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-axe. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-axe.'};
doc['MultiAxisController']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-axe.',lib:'multiaxiscontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-axe. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-axe.'};
doc['MultiAxisController']['get_friendlyName']={syn:'Retourne un identifiant global du contr\xF4leur multi-axe au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'multiaxiscontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du contr\xF4leur multi-axe au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du contr\xF4leur multi-axe si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du contr\xF4leur multi-axe (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-axe en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'multiaxiscontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['MultiAxisController']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-axe, sans r\xE9f\xE9rence au module.',lib:'multiaxiscontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-axe, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-axe (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiAxisController']['get_globalState']={syn:'Retourne l\x27\xE9tat de fonctionnement global de l\x27ensemble des moteurs.',lib:'multiaxiscontroller.get_globalState()',pro:'def get_globalState()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement global de l\x27ensemble des moteurs.</p>',ret:'une valeur parmi <tt>Y_GLOBALSTATE_ABSENT</tt>, <tt>Y_GLOBALSTATE_ALERT</tt>, <tt>Y_GLOBALSTATE_HI_Z</tt>, <tt>Y_GLOBALSTATE_STOP</tt>, <tt>Y_GLOBALSTATE_RUN</tt> et <tt>Y_GLOBALSTATE_BATCH</tt> repr&eacute;sentant l\x27\xE9tat de fonctionnement global de l\x27ensemble des moteurs',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_GLOBALSTATE_INVALID</tt>.'};
doc['MultiAxisController']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-axe au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'multiaxiscontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-axe au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du contr\xF4leur multi-axe (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-axe (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiAxisController']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4leur multi-axe.',lib:'multiaxiscontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4leur multi-axe.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-axe.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'multiaxiscontroller.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['MultiAxisController']['get_nAxis']={syn:'Retourne le nombre de contr\xF4leurs \xE0 synchroniser.',lib:'multiaxiscontroller.get_nAxis()',pro:'def get_nAxis()',cmt:'<p>Retourne le nombre de contr\xF4leurs \xE0 synchroniser.</p>',ret:'un entier repr&eacute;sentant le nombre de contr\xF4leurs \xE0 synchroniser',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NAXIS_INVALID</tt>.'};
doc['MultiAxisController']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'multiaxiscontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['MultiAxisController']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-axe est joignable, sans d\xE9clencher d\x27erreur.',lib:'multiaxiscontroller.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-axe est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du contr\xF4leur multi-axe sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le contr\xF4leur multi-axe est joignable, <tt>false</tt> sinon'};
doc['MultiAxisController']['load']={syn:'Met en cache les valeurs courantes du contr\xF4leur multi-axe, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'multiaxiscontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du contr\xF4leur multi-axe, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'multiaxiscontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['MultiAxisController']['moveRel']={syn:'Contr\xF4le les moteurs de mani\xE8re synchrone pour atteindre une position relative donn\xE9e.',lib:'multiaxiscontroller.moveRel()',pro:'def moveRel(<span id=pn>relPos</span>)',cmt:'<p>Contr\xF4le les moteurs de mani\xE8re synchrone pour atteindre une position relative donn\xE9e. Le temps n\xE9cessaire pour atteindre la position d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration et de vitesse maximale les plus faibles pour l\x27ensemble des moteurs. La position finale est atteinte pour tous les axes au m\xEAme moment.</p>',par:{relPos:'position relative d\xE9sir\xE9e, en pas depuis la position actuelle.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['moveTo']={syn:'Contr\xF4le les moteurs de mani\xE8re synchrone pour atteindre une position absolue donn\xE9e.',lib:'multiaxiscontroller.moveTo()',pro:'def moveTo(<span id=pn>absPos</span>)',cmt:'<p>Contr\xF4le les moteurs de mani\xE8re synchrone pour atteindre une position absolue donn\xE9e. Le temps n\xE9cessaire pour atteindre la position d\xE9pend des param\xE8tres d\x27acc\xE9l\xE9ration et de vitesse maximale les plus faibles pour l\x27ensemble des moteurs. La position finale est atteinte pour tous les axes au m\xEAme moment.</p>',par:{absPos:'position absolue d\xE9sir\xE9e, en pas depuis chaque origine.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multiaxiscontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['nextMultiAxisController']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-axe commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiAxisController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-axe sont retourn\xE9s.',lib:'multiaxiscontroller.nextMultiAxisController()',pro:'def nextMultiAxisController()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-axe commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiAxisController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-axe sont retourn\xE9s. Si vous souhaitez retrouver un contr\xF4leur multi-axe sp\xE9cifique, utilisez <tt>MultiAxisController.findMultiAxisController()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMultiAxisController</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['MultiAxisController']['pause']={syn:'Garde le moteur dans le m\xEAme \xE9tat pour la dur\xE9e sp\xE9cifi\xE9e, avant d\x27ex\xE9cuter la commande suivante.',lib:'multiaxiscontroller.pause()',pro:'def pause(<span id=pn>waitMs</span>)',cmt:'<p>Garde le moteur dans le m\xEAme \xE9tat pour la dur\xE9e sp\xE9cifi\xE9e, avant d\x27ex\xE9cuter la commande suivante.</p>',par:{waitMs:'temps d\x27attente, en milliseconde.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'multiaxiscontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MultiAxisController']['reset']={syn:'R\xE9initialise tous les controlleurs et quittance toutes les alertes.',lib:'multiaxiscontroller.reset()',pro:'def reset()',cmt:'<p>R\xE9initialise tous les controlleurs et quittance toutes les alertes.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4leur multi-axe.',lib:'multiaxiscontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4leur multi-axe. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-axe.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiAxisController']['set_nAxis']={syn:'Modifie le nombre de contr\xF4leurs \xE0 synchroniser.',lib:'multiaxiscontroller.set_nAxis()',pro:'def set_nAxis(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de contr\xF4leurs \xE0 synchroniser.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de contr\xF4leurs \xE0 synchroniser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiAxisController']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'multiaxiscontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['MultiAxisController']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multiaxiscontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: MultiAxisController)
//--- (generated code: RangeFinder)
doc['RangeFinder']={'':{syn:'Interface de la fonction RangeFinder',inc:'from yocto_rangefinder import *',cmt:'<p>La classe YRangeFinder permet d\x27utiliser et de configurer les capteurs de distance Yoctopuce. Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es. De plus, elle permet d\x27effectuer facilement une calibration lin\xE9aire \xE0 un point pour compenser l\x27effet d\x27une vitre ou d\x27un filtre plac\xE9 devant le capteur.</p>'}};
doc['RangeFinder']['FindRangeFinder']={syn:'Permet de retrouver un capteur de distance d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRangeFinder.FindRangeFinder()',pro:'def FindRangeFinder(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de distance d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de distance soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRangeFinder.isOnline()</tt> pour tester si le capteur de distance est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de distance sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRangeFinder</tt> qui permet ensuite de contr\xF4ler le capteur de distance.'};
doc['RangeFinder']['FirstRangeFinder']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de distance accessibles par la librairie.',lib:'YRangeFinder.FirstRangeFinder()',pro:'def FirstRangeFinder()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de distance accessibles par la librairie. Utiliser la fonction <tt>YRangeFinder.nextRangeFinder()</tt> pour it\xE9rer sur les autres capteurs de distance.</p>',ret:'un pointeur sur un objet <tt>YRangeFinder</tt>, correspondant au premier capteur de distance accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de distance disponibles.'};
doc['RangeFinder']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'rangefinder.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['cancelCoverGlassCalibrations']={syn:'Annule l\x27effet des calibrations effectu\xE9es pr\xE9c\xE9demment pour compenser une vitre de protection, et r\xE9tablit les param\xE8tres d\x27usine.',lib:'rangefinder.cancelCoverGlassCalibrations()',pro:'def cancelCoverGlassCalibrations()',cmt:'<p>Annule l\x27effet des calibrations effectu\xE9es pr\xE9c\xE9demment pour compenser une vitre de protection, et r\xE9tablit les param\xE8tres d\x27usine. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['clearCache']={syn:'Invalide le cache.',lib:'rangefinder.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de distance. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['RangeFinder']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de distance au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'rangefinder.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de distance au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de distance (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RangeFinder']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'rangefinder.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['RangeFinder']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de distance (pas plus de 6 caract\xE8res).',lib:'rangefinder.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de distance (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de distance (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mm, sous forme de nombre \xE0 virgule.',lib:'rangefinder.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mm, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en mm, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentTemperature']={syn:'Retourne la temp\xE9rature actuelle du capteur, sous forme de nombre \xE0 virgule.',lib:'rangefinder.get_currentTemperature()',pro:'def get_currentTemperature()',cmt:'<p>Retourne la temp\xE9rature actuelle du capteur, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la temp\xE9rature actuelle du capteur, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTTEMPERATURE_INVALID</tt>.'};
doc['RangeFinder']['get_currentValue']={syn:'Retourne la valeur actuelle de la distance, en mm, sous forme de nombre \xE0 virgule.',lib:'rangefinder.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la distance, en mm, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la distance, en mm, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'rangefinder.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['RangeFinder']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de distance.',lib:'rangefinder.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de distance. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de distance.'};
doc['RangeFinder']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de distance.',lib:'rangefinder.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de distance. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de distance.'};
doc['RangeFinder']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de distance au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'rangefinder.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de distance au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de distance si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de distance (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de distance en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RangeFinder']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'rangefinder.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['RangeFinder']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de distance, sans r\xE9f\xE9rence au module.',lib:'rangefinder.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de distance, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de distance (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RangeFinder']['get_hardwareCalibrationTemperature']={syn:'Retourne la temp\xE9rature \xE0 laquelle la derni\xE8re calibration a \xE9t\xE9 effectu\xE9e.',lib:'rangefinder.get_hardwareCalibrationTemperature()',pro:'def get_hardwareCalibrationTemperature()',cmt:'<p>Retourne la temp\xE9rature \xE0 laquelle la derni\xE8re calibration a \xE9t\xE9 effectu\xE9e. Cette fonction permet de d\xE9terminer si une nouvelle calibration par rapport \xE0 la temp\xE9rature ambiante est n\xE9cessaire.</p>',ret:'une temp\xE9rature, sous forme de nombre \xE0 virgule. En cas d\x27erreur, d\xE9clenche une exception ou retourne YAPI_INVALID_DOUBLE.'};
doc['RangeFinder']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de distance au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'rangefinder.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de distance au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de distance (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de distance (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RangeFinder']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la distance depuis le d\xE9marrage du module.',lib:'rangefinder.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la distance depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la distance depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'rangefinder.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_logicalName']={syn:'Retourne le nom logique du capteur de distance.',lib:'rangefinder.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de distance.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de distance.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RangeFinder']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la distance depuis le d\xE9marrage du module.',lib:'rangefinder.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la distance depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la distance depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'rangefinder.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['RangeFinder']['get_rangeFinderMode']={syn:'Retourne le mode de fonctionnement du capteur de distance.',lib:'rangefinder.get_rangeFinderMode()',pro:'def get_rangeFinderMode()',cmt:'<p>Retourne le mode de fonctionnement du capteur de distance. Le choix du mode permet de favoriser la pr\xE9cision, la vitesse, ou la distance maximale d\xE9tectable.</p>',ret:'une valeur parmi <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> et <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> repr&eacute;sentant le mode de fonctionnement du capteur de distance',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RANGEFINDERMODE_INVALID</tt>.'};
doc['RangeFinder']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'rangefinder.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['RangeFinder']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'rangefinder.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'rangefinder.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['RangeFinder']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'rangefinder.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['RangeFinder']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la distance est exprim\xE9e.',lib:'rangefinder.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la distance est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la distance est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['RangeFinder']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'rangefinder.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['RangeFinder']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de distance est joignable, sans d\xE9clencher d\x27erreur.',lib:'rangefinder.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de distance est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de distance sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de distance est joignable, <tt>false</tt> sinon'};
doc['RangeFinder']['load']={syn:'Met en cache les valeurs courantes du capteur de distance, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'rangefinder.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de distance, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'rangefinder.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['RangeFinder']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'rangefinder.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'rangefinder.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['nextRangeFinder']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de distance commenc\xE9e \xE0 l\x27aide de <tt>yFirstRangeFinder()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de distance sont retourn\xE9s.',lib:'rangefinder.nextRangeFinder()',pro:'def nextRangeFinder()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de distance commenc\xE9e \xE0 l\x27aide de <tt>yFirstRangeFinder()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de distance sont retourn\xE9s. Si vous souhaitez retrouver un capteur de distance sp\xE9cifique, utilisez <tt>RangeFinder.findRangeFinder()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YRangeFinder</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['RangeFinder']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'rangefinder.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['RangeFinder']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'rangefinder.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['RangeFinder']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'rangefinder.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'rangefinder.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'rangefinder.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_logicalName']={syn:'Modifie le nom logique du capteur de distance.',lib:'rangefinder.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de distance. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de distance.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'rangefinder.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_rangeFinderMode']={syn:'Modifie le mode de fonctionnement du capteur de distance, permettant ainsi de mettre la priorit\xE9 sur la pr\xE9cision, la vitesse ou la distance maximale d\xE9tectable.',lib:'rangefinder.set_rangeFinderMode()',pro:'def set_rangeFinderMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de fonctionnement du capteur de distance, permettant ainsi de mettre la priorit\xE9 sur la pr\xE9cision, la vitesse ou la distance maximale d\xE9tectable.</p>',par:{newval:'une valeur parmi <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> et <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> repr&eacute;sentant le mode de fonctionnement du capteur de distance, permettant ainsi de mettre la priorit\xE9 sur la pr\xE9cision, la vitesse ou la distance maximale d\xE9tectable'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'rangefinder.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'rangefinder.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle la distance mesur\xE9e est exprim\xE9e.',lib:'rangefinder.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle la distance mesur\xE9e est exprim\xE9e. Cette unit\xE9 est une cha\xEEne de charact\xE8re qui peut \xEAtre <tt>\x22</tt> ou <tt>mm</tt>. Toute autre valeur sera ignor\xE9e. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. Attention: si une calibration sp\xE9cifique est d\xE9finie pour la fonction rangeFinder un changement d\x27unit\xE9 a toutes les chances de la fausser.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['RangeFinder']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'rangefinder.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['RangeFinder']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'rangefinder.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['RangeFinder']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'rangefinder.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['RangeFinder']['triggerOffsetCalibration']={syn:'Lance la calibration mat\xE9rielle d\x27offset du capteur de distance.',lib:'rangefinder.triggerOffsetCalibration()',pro:'def triggerOffsetCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Lance la calibration mat\xE9rielle d\x27offset du capteur de distance. Cette fonction fait partie de la proc\xE9dure de calibration pour tenir compte de la pr\xE9sence d\x27une vitre de protection devant le capteur. R\xE9f\xE9rez-vous au chapitre de la documentation concernant la calibration pour compenser l\x27effet d\x27une vitre pour les d\xE9tails sur la marche \xE0 suivre exacte.</p>',par:{targetDist:'distance r\xE9elle de la cible, en mm ou en pouce selon l\x27unit\xE9 configur\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['triggerSpadCalibration']={syn:'Lance la calibration des d\xE9tecteurs de photons.',lib:'rangefinder.triggerSpadCalibration()',pro:'def triggerSpadCalibration()',cmt:'<p>Lance la calibration des d\xE9tecteurs de photons. Cette fonction fait partie de la proc\xE9dure de calibration pour tenir compte de la pr\xE9sence d\x27une vitre de protection devant le capteur. R\xE9f\xE9rez-vous au chapitre de la documentation concernant la calibration pour compenser l\x27effet d\x27une vitre pour les d\xE9tails sur la marche \xE0 suivre exacte.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['triggerTemperatureCalibration']={syn:'Lance une calibration par rapport \xE0 la temp\xE9rature ambiante.',lib:'rangefinder.triggerTemperatureCalibration()',pro:'def triggerTemperatureCalibration()',cmt:'<p>Lance une calibration par rapport \xE0 la temp\xE9rature ambiante. Cette calibration ne n\xE9cessite aucune interaction physique avec le capteur. Elle est effectu\xE9e automatiquement au d\xE9marrage du module, mais il est recommand\xE9 de la relancer si la variation de temp\xE9rature depuis la derni\xE8re calibration d\xE9passe 8\xB0C.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['triggerXTalkCalibration']={syn:'Lance la calibration mat\xE9rielle d\x27interf\xE9rence de r\xE9flexion du capteur de distance.',lib:'rangefinder.triggerXTalkCalibration()',pro:'def triggerXTalkCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Lance la calibration mat\xE9rielle d\x27interf\xE9rence de r\xE9flexion du capteur de distance. Cette fonction fait partie de la proc\xE9dure de calibration pour tenir compte de la pr\xE9sence d\x27une vitre de protection devant le capteur. R\xE9f\xE9rez-vous au chapitre de la documentation concernant la calibration pour compenser l\x27effet d\x27une vitre pour les d\xE9tails sur la marche \xE0 suivre exacte.</p>',par:{targetDist:'distance r\xE9elle de la cible, en mm ou en pouce selon l\x27unit\xE9 configur\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['RangeFinder']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'rangefinder.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: RangeFinder)
//--- (generated code: DaisyChain)
doc['DaisyChain']={'':{syn:'Interface de la fonction DaisyChain',inc:'from yocto_daisychain import *',cmt:'<p>L\x27interface YDaisyChain permet de contr\xF4ler le bon fonctionnement du lien de cha\xEEnage direct entre modules, sans passer par un hub.</p>'}};
doc['DaisyChain']['FindDaisyChain']={syn:'Permet de retrouver une cha\xEEne de modules d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDaisyChain.FindDaisyChain()',pro:'def FindDaisyChain(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une cha\xEEne de modules d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la cha\xEEne de modules soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDaisyChain.isOnline()</tt> pour tester si la cha\xEEne de modules est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la cha\xEEne de modules sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDaisyChain</tt> qui permet ensuite de contr\xF4ler la cha\xEEne de modules.'};
doc['DaisyChain']['FirstDaisyChain']={syn:'Commence l\x27\xE9num\xE9ration des cha\xEEnes de module accessibles par la librairie.',lib:'YDaisyChain.FirstDaisyChain()',pro:'def FirstDaisyChain()',cmt:'<p>Commence l\x27\xE9num\xE9ration des cha\xEEnes de module accessibles par la librairie. Utiliser la fonction <tt>YDaisyChain.nextDaisyChain()</tt> pour it\xE9rer sur les autres cha\xEEnes de module.</p>',ret:'un pointeur sur un objet <tt>YDaisyChain</tt>, correspondant \xE0 la premi\xE8re cha\xEEne de modules accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de cha\xEEnes de module disponibles.'};
doc['DaisyChain']['clearCache']={syn:'Invalide le cache.',lib:'daisychain.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la cha\xEEne de modules. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['DaisyChain']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la cha\xEEne de modules au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'daisychain.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la cha\xEEne de modules au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la cha\xEEne de modules (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DaisyChain']['get_advertisedValue']={syn:'Retourne la valeur courante de la cha\xEEne de modules (pas plus de 6 caract\xE8res).',lib:'daisychain.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la cha\xEEne de modules (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la cha\xEEne de modules (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DaisyChain']['get_childCount']={syn:'Retourne le nombre de sous-modules actuellement d\xE9tect\xE9s.',lib:'daisychain.get_childCount()',pro:'def get_childCount()',cmt:'<p>Retourne le nombre de sous-modules actuellement d\xE9tect\xE9s.</p>',ret:'un entier repr&eacute;sentant le nombre de sous-modules actuellement d\xE9tect\xE9s',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_daisyState']={syn:'Retourne l\x27\xE9tat du lien de cha\xEEnage.',lib:'daisychain.get_daisyState()',pro:'def get_daisyState()',cmt:'<p>Retourne l\x27\xE9tat du lien de cha\xEEnage.</p>',ret:'une valeur parmi <tt>Y_DAISYSTATE_READY</tt>, <tt>Y_DAISYSTATE_IS_CHILD</tt>, <tt>Y_DAISYSTATE_FIRMWARE_MISMATCH</tt>, <tt>Y_DAISYSTATE_CHILD_MISSING</tt> et <tt>Y_DAISYSTATE_CHILD_LOST</tt> repr&eacute;sentant l\x27\xE9tat du lien de cha\xEEnage',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_DAISYSTATE_INVALID</tt>.'};
doc['DaisyChain']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la cha\xEEne de modules.',lib:'daisychain.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la cha\xEEne de modules. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la cha\xEEne de modules.'};
doc['DaisyChain']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la cha\xEEne de modules.',lib:'daisychain.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la cha\xEEne de modules. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la cha\xEEne de modules.'};
doc['DaisyChain']['get_friendlyName']={syn:'Retourne un identifiant global de la cha\xEEne de modules au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'daisychain.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la cha\xEEne de modules au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la cha\xEEne de modules si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la cha\xEEne de modules (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la cha\xEEne de modules en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DaisyChain']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'daisychain.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DaisyChain']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la cha\xEEne de modules, sans r\xE9f\xE9rence au module.',lib:'daisychain.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la cha\xEEne de modules, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la cha\xEEne de modules (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DaisyChain']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la cha\xEEne de modules au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'daisychain.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la cha\xEEne de modules au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la cha\xEEne de modules (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la cha\xEEne de modules (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DaisyChain']['get_logicalName']={syn:'Retourne le nom logique de la cha\xEEne de modules.',lib:'daisychain.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la cha\xEEne de modules.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la cha\xEEne de modules.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DaisyChain']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'daisychain.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DaisyChain']['get_requiredChildCount']={syn:'Retourne le nombre de sous-modules attendus en fonctionnement normal.',lib:'daisychain.get_requiredChildCount()',pro:'def get_requiredChildCount()',cmt:'<p>Retourne le nombre de sous-modules attendus en fonctionnement normal.</p>',ret:'un entier repr&eacute;sentant le nombre de sous-modules attendus en fonctionnement normal',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REQUIREDCHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'daisychain.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DaisyChain']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la cha\xEEne de modules est joignable, sans d\xE9clencher d\x27erreur.',lib:'daisychain.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la cha\xEEne de modules est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la cha\xEEne de modules sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la cha\xEEne de modules est joignable, <tt>false</tt> sinon'};
doc['DaisyChain']['load']={syn:'Met en cache les valeurs courantes de la cha\xEEne de modules, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'daisychain.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la cha\xEEne de modules, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DaisyChain']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'daisychain.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['DaisyChain']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'daisychain.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DaisyChain']['nextDaisyChain']={syn:'Continue l\x27\xE9num\xE9ration des cha\xEEnes de module commenc\xE9e \xE0 l\x27aide de <tt>yFirstDaisyChain()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les cha\xEEnes de module sont retourn\xE9s.',lib:'daisychain.nextDaisyChain()',pro:'def nextDaisyChain()',cmt:'<p>Continue l\x27\xE9num\xE9ration des cha\xEEnes de module commenc\xE9e \xE0 l\x27aide de <tt>yFirstDaisyChain()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les cha\xEEnes de module sont retourn\xE9s. Si vous souhaitez retrouver une cha\xEEne de modules sp\xE9cifique, utilisez <tt>DaisyChain.findDaisyChain()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YDaisyChain</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DaisyChain']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'daisychain.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DaisyChain']['set_logicalName']={syn:'Modifie le nom logique de la cha\xEEne de modules.',lib:'daisychain.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la cha\xEEne de modules. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la cha\xEEne de modules.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DaisyChain']['set_requiredChildCount']={syn:'Modifie le nombre de sous-modules attendus en fonctionnement normal.',lib:'daisychain.set_requiredChildCount()',pro:'def set_requiredChildCount(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de sous-modules attendus en fonctionnement normal. Si la valeur est nulle, aucune exigence n\x27est pos\xE9e. Si elle est non-nulle, le nombre de sous-modules d\xE9tect\xE9 est v\xE9rifi\xE9 au d\xE9marrage. Le status passe alors en erreur si le nombre de sous-modules ne correspond pas.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de sous-modules attendus en fonctionnement normal'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['DaisyChain']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'daisychain.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['DaisyChain']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'daisychain.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DaisyChain)
//--- (generated code: VoltageOutput)
doc['VoltageOutput']={'':{syn:'Interface de la fonction VoltageOutput',inc:'from yocto_voltageoutput import *',cmt:'<p>La librairie de programmation Yoctopuce permet de changer la valeur de la sortie de tension.</p>'}};
doc['VoltageOutput']['FindVoltageOutput']={syn:'Permet de retrouver une sortie de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoltageOutput.FindVoltageOutput()',pro:'def FindVoltageOutput(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une sortie de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que la sortie de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoltageOutput.isOnline()</tt> pour tester si la sortie de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la sortie de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoltageOutput</tt> qui permet ensuite de contr\xF4ler la sortie de tension.'};
doc['VoltageOutput']['FirstVoltageOutput']={syn:'Commence l\x27\xE9num\xE9ration des sortie de tension accessibles par la librairie.',lib:'YVoltageOutput.FirstVoltageOutput()',pro:'def FirstVoltageOutput()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sortie de tension accessibles par la librairie. Utiliser la fonction <tt>YVoltageOutput.nextVoltageOutput()</tt> pour it\xE9rer sur les autres sortie de tension.</p>',ret:'un pointeur sur un objet <tt>YVoltageOutput</tt>, correspondant \xE0 la premi\xE8re sortie de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sortie de tension disponibles.'};
doc['VoltageOutput']['clearCache']={syn:'Invalide le cache.',lib:'voltageoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de la sortie de tension. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['VoltageOutput']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltageoutput.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de la sortie de tension au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la sortie de tension (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VoltageOutput']['get_advertisedValue']={syn:'Retourne la valeur courante de la sortie de tension (pas plus de 6 caract\xE8res).',lib:'voltageoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la sortie de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la sortie de tension (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VoltageOutput']['get_currentVoltage']={syn:'Retourne la tension de sortie, en V.',lib:'voltageoutput.get_currentVoltage()',pro:'def get_currentVoltage()',cmt:'<p>Retourne la tension de sortie, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la tension de sortie, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVOLTAGE_INVALID</tt>.'};
doc['VoltageOutput']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie de tension.',lib:'voltageoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie de tension.'};
doc['VoltageOutput']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie de tension.',lib:'voltageoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la sortie de tension. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la sortie de tension.'};
doc['VoltageOutput']['get_friendlyName']={syn:'Retourne un identifiant global de la sortie de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'voltageoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de la sortie de tension au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la sortie de tension si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la sortie de tension (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie de tension en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voltageoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['VoltageOutput']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la sortie de tension, sans r\xE9f\xE9rence au module.',lib:'voltageoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la sortie de tension, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie de tension (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VoltageOutput']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la sortie de tension au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltageoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la sortie de tension au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la sortie de tension (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la sortie de tension (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VoltageOutput']['get_logicalName']={syn:'Retourne le nom logique de la sortie de tension.',lib:'voltageoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de la sortie de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie de tension.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voltageoutput.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['VoltageOutput']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voltageoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['VoltageOutput']['get_voltageAtStartUp']={syn:'Retourne la tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V.',lib:'voltageoutput.get_voltageAtStartUp()',pro:'def get_voltageAtStartUp()',cmt:'<p>Retourne la tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['VoltageOutput']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la sortie de tension est joignable, sans d\xE9clencher d\x27erreur.',lib:'voltageoutput.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la sortie de tension est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la sortie de tension sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la sortie de tension est joignable, <tt>false</tt> sinon'};
doc['VoltageOutput']['load']={syn:'Met en cache les valeurs courantes de la sortie de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voltageoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la sortie de tension, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VoltageOutput']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'voltageoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['VoltageOutput']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voltageoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VoltageOutput']['nextVoltageOutput']={syn:'Continue l\x27\xE9num\xE9ration des sortie de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltageOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sortie de tension sont retourn\xE9s.',lib:'voltageoutput.nextVoltageOutput()',pro:'def nextVoltageOutput()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sortie de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltageOutput()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les sortie de tension sont retourn\xE9s. Si vous souhaitez retrouver une sortie de tension sp\xE9cifique, utilisez <tt>VoltageOutput.findVoltageOutput()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YVoltageOutput</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['VoltageOutput']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voltageoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['VoltageOutput']['set_currentVoltage']={syn:'Modifie la tension de sortie, en V.',lib:'voltageoutput.set_currentVoltage()',pro:'def set_currentVoltage(<span id=pn>newval</span>)',cmt:'<p>Modifie la tension de sortie, en V. Les valeurs admises sont de 0 \xE0 10V.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la tension de sortie, en V'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['VoltageOutput']['set_logicalName']={syn:'Modifie le nom logique de la sortie de tension.',lib:'voltageoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la sortie de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la sortie de tension.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VoltageOutput']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voltageoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['VoltageOutput']['set_voltageAtStartUp']={syn:'Modifie la valeur de tension au d\xE9marrage du module.',lib:'voltageoutput.set_voltageAtStartUp()',pro:'def set_voltageAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur de tension au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la valeur de tension au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['VoltageOutput']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'voltageoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VoltageOutput']['voltageMove']={syn:'D\xE9clenche une transition progressive de la tension de sortie.',lib:'voltageoutput.voltageMove()',pro:'def voltageMove(<span id=pn>V_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une transition progressive de la tension de sortie. N\x27importe quel changement explicite de tension annulera tout processus de transition en cours.</p>',par:{V_target:'nouvelle valeur de tension \xE0 la fin de la transition (nombre flottant, repr\xE9sentant la tension en V)',ms_duration:'dur\xE9e totale de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: VoltageOutput)
//--- (generated code: WeighScale)
doc['WeighScale']={'':{syn:'Interface de la fonction WeighScale',inc:'from yocto_weighscale import *',cmt:'<p>La classe YWeighScale permet d\x27obtenir une mesure de poids \xE0 partir d\x27une cellule de poids ratiom\xE9trique. Elle permet de contr\xF4ler le mode d\x27excitation de la cellule, pour \xE9viter les d\xE9rives li\xE9es aux changements de temp\xE9rature de l\x27\xE9lectronique, et d\x27appliquer automatiquement une correction suppl\xE9mentaire en fonction de la temp\xE9rature pour compenser la d\xE9rive de la cellule de poids elle-m\xEAme.</p>'}};
doc['WeighScale']['FindWeighScale']={syn:'Permet de retrouver un capteur de poids d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWeighScale.FindWeighScale()',pro:'def FindWeighScale(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de poids d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de poids soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWeighScale.isOnline()</tt> pour tester si le capteur de poids est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de poids sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWeighScale</tt> qui permet ensuite de contr\xF4ler le capteur de poids.'};
doc['WeighScale']['FirstWeighScale']={syn:'Commence l\x27\xE9num\xE9ration des capteur de poids accessibles par la librairie.',lib:'YWeighScale.FirstWeighScale()',pro:'def FirstWeighScale()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteur de poids accessibles par la librairie. Utiliser la fonction <tt>YWeighScale.nextWeighScale()</tt> pour it\xE9rer sur les autres capteur de poids.</p>',ret:'un pointeur sur un objet <tt>YWeighScale</tt>, correspondant au premier capteur de poids accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteur de poids disponibles.'};
doc['WeighScale']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'weighscale.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['clearCache']={syn:'Invalide le cache.',lib:'weighscale.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de poids. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['WeighScale']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de poids au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'weighscale.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de poids au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de poids (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WeighScale']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'weighscale.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['WeighScale']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de poids (pas plus de 6 caract\xE8res).',lib:'weighscale.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de poids (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de poids (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WeighScale']['get_compTempAvg']={syn:'Retourne la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique.',lib:'weighscale.get_compTempAvg()',pro:'def get_compTempAvg()',cmt:'<p>Retourne la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['WeighScale']['get_compTempChg']={syn:'Retourne la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique.',lib:'weighscale.get_compTempChg()',pro:'def get_compTempChg()',cmt:'<p>Retourne la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['WeighScale']['get_compensation']={syn:'Retourne la valeur de la compensation thermique courante.',lib:'weighscale.get_compensation()',pro:'def get_compensation()',cmt:'<p>Retourne la valeur de la compensation thermique courante.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur de la compensation thermique courante',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['WeighScale']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'weighscale.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['WeighScale']['get_currentValue']={syn:'Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'weighscale.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'weighscale.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['WeighScale']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids.',lib:'weighscale.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de poids.'};
doc['WeighScale']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids.',lib:'weighscale.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de poids.'};
doc['WeighScale']['get_excitation']={syn:'Retourne la m\xE9thode d\x27excitation de la cellule de poids.',lib:'weighscale.get_excitation()',pro:'def get_excitation()',cmt:'<p>Retourne la m\xE9thode d\x27excitation de la cellule de poids.</p>',ret:'une valeur parmi <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> et <tt>Y_EXCITATION_AC</tt> repr&eacute;sentant la m\xE9thode d\x27excitation de la cellule de poids',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_EXCITATION_INVALID</tt>.'};
doc['WeighScale']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de poids au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'weighscale.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de poids au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de poids si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de poids (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WeighScale']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'weighscale.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['WeighScale']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de poids, sans r\xE9f\xE9rence au module.',lib:'weighscale.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de poids, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WeighScale']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de poids au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'weighscale.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de poids au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de poids (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WeighScale']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'weighscale.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'weighscale.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_logicalName']={syn:'Retourne le nom logique du capteur de poids.',lib:'weighscale.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de poids.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de poids.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WeighScale']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'weighscale.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'weighscale.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['WeighScale']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'weighscale.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['WeighScale']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'weighscale.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'weighscale.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['WeighScale']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'weighscale.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['WeighScale']['get_tempAvgAdaptRatio']={syn:'Retourne le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille.',lib:'weighscale.get_tempAvgAdaptRatio()',pro:'def get_tempAvgAdaptRatio()',cmt:'<p>Retourne le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille. Le but de ce taux d\x27adaptation est de mod\xE9liser l\x27inertie thermique de la cellule de charge. La temp\xE9rature moyenne de compensation est adapt\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la temp\xE9rature moyenne de compensation actuelle. Le taux d\x27adaptation standard est de 0.2 pour mille, et le taux maximal est de 65 pour mille.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TEMPAVGADAPTRATIO_INVALID</tt>.'};
doc['WeighScale']['get_tempChgAdaptRatio']={syn:'Retourne le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille.',lib:'weighscale.get_tempChgAdaptRatio()',pro:'def get_tempChgAdaptRatio()',cmt:'<p>Retourne le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille. La variation de temp\xE9rature est recalcul\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la valeur actuelle de temp\xE9rature de compensation des variations. Le taux d\x27adaptation standard est de 0.6 pour mille, et le taux maximal est de 65 pour mille.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TEMPCHGADAPTRATIO_INVALID</tt>.'};
doc['WeighScale']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.',lib:'weighscale.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la measure est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['WeighScale']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'weighscale.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['WeighScale']['get_zeroTracking']={syn:'Retourne la valeur seuil pour le suivi continu du z\xE9ro.',lib:'weighscale.get_zeroTracking()',pro:'def get_zeroTracking()',cmt:'<p>Retourne la valeur seuil pour le suivi continu du z\xE9ro. Lorsque ce seuil est sup\xE9rieure \xE0 z\xE9ro, les mesures inf\xE9rieures \xE0 cette valeur sont automatiquement ignor\xE9es et le z\xE9ro est continuellement compens\xE9 en cons\xE9quence.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur seuil pour le suivi continu du z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['WeighScale']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de poids est joignable, sans d\xE9clencher d\x27erreur.',lib:'weighscale.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de poids est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de poids sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de poids est joignable, <tt>false</tt> sinon'};
doc['WeighScale']['load']={syn:'Met en cache les valeurs courantes du capteur de poids, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'weighscale.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de poids, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'weighscale.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['WeighScale']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'weighscale.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['loadOffsetAvgCompensationTable']={syn:'R\xE9cup\xE8re la table de compensation de l\x27offset de poids en fonction de la temp\xE9rature moyenn\xE9e pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_offsetAvgCompensationTable</tt>.',lib:'weighscale.loadOffsetAvgCompensationTable()',pro:'def loadOffsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>R\xE9cup\xE8re la table de compensation de l\x27offset de poids en fonction de la temp\xE9rature moyenn\xE9e pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_offsetAvgCompensationTable</tt>. La correction de poids est faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les diff\xE9rentes temp\xE9ratures moyenn\xE9es pour lesquelles une correction d\x27offset est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, qui sera rempli par la fonction avec la correction d\x27offset appliqu\xE9e pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['loadOffsetChgCompensationTable']={syn:'R\xE9cup\xE8re la table de compensation en temp\xE9rature de l\x27offset de poids en fonction de la variation de temp\xE9rature pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_offsetChgCompensationTable</tt>.',lib:'weighscale.loadOffsetChgCompensationTable()',pro:'def loadOffsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>R\xE9cup\xE8re la table de compensation en temp\xE9rature de l\x27offset de poids en fonction de la variation de temp\xE9rature pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_offsetChgCompensationTable</tt>. La correction de poids est faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les diff\xE9rentes variations de temp\xE9rature pour lesquelles une correction d\x27offset est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, qui sera rempli par la fonction avec la correction d\x27offset appliqu\xE9e pour chacun des points de variation de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['loadSpanAvgCompensationTable']={syn:'R\xE9cup\xE8re la table de compensation en temp\xE9rature de l\x27amplitude de poids en fonction de la temp\xE9rature moyenn\xE9e pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_spanAvgCompensationTable</tt>.',lib:'weighscale.loadSpanAvgCompensationTable()',pro:'def loadSpanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>R\xE9cup\xE8re la table de compensation en temp\xE9rature de l\x27amplitude de poids en fonction de la temp\xE9rature moyenn\xE9e pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_spanAvgCompensationTable</tt>. La correction de poids est faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les diff\xE9rentes temp\xE9ratures moyenn\xE9es pour lesquelles une correction d\x27amplitude est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, qui sera rempli par la fonction avec la correction d\x27amplitude appliqu\xE9e pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['loadSpanChgCompensationTable']={syn:'R\xE9cup\xE8re la table de compensation de l\x27amplitude de poids en fonction de la variation de temp\xE9rature, pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_spanChgCompensationTable</tt>.',lib:'weighscale.loadSpanChgCompensationTable()',pro:'def loadSpanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>R\xE9cup\xE8re la table de compensation de l\x27amplitude de poids en fonction de la variation de temp\xE9rature, pr\xE9c\xE9demment enregistr\xE9e \xE0 l\x27aide de la fonction <tt>set_spanChgCompensationTable</tt>. La correction de poids est faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les diff\xE9rentes variations de temp\xE9rature pour lesquelles une correction d\x27amplitude est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, qui sera rempli par la fonction avec la correction d\x27amplitude appliqu\xE9e pour chacun des points de variation de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'weighscale.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['nextWeighScale']={syn:'Continue l\x27\xE9num\xE9ration des capteur de poids commenc\xE9e \xE0 l\x27aide de <tt>yFirstWeighScale()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteur de poids sont retourn\xE9s.',lib:'weighscale.nextWeighScale()',pro:'def nextWeighScale()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteur de poids commenc\xE9e \xE0 l\x27aide de <tt>yFirstWeighScale()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteur de poids sont retourn\xE9s. Si vous souhaitez retrouver un capteur de poids sp\xE9cifique, utilisez <tt>WeighScale.findWeighScale()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YWeighScale</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['WeighScale']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'weighscale.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WeighScale']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'weighscale.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['WeighScale']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'weighscale.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_excitation']={syn:'Modifie la m\xE9thode d\x27excitation de la cellule de poids.',lib:'weighscale.set_excitation()',pro:'def set_excitation(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode d\x27excitation de la cellule de poids.</p>',par:{newval:'une valeur parmi <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> et <tt>Y_EXCITATION_AC</tt> repr&eacute;sentant la m\xE9thode d\x27excitation de la cellule de poids'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'weighscale.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'weighscale.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_logicalName']={syn:'Modifie le nom logique du capteur de poids.',lib:'weighscale.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de poids. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de poids.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'weighscale.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_offsetAvgCompensationTable']={syn:'Enregistre la table de compensation de l\x27offset de poids en fonction de la temp\xE9rature moyenn\xE9e, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la temp\xE9rature moyenn\xE9e.',lib:'weighscale.set_offsetAvgCompensationTable()',pro:'def set_offsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Enregistre la table de compensation de l\x27offset de poids en fonction de la temp\xE9rature moyenn\xE9e, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la temp\xE9rature moyenn\xE9e. La correction de poids sera faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, correspondant aux diff\xE9rentes temp\xE9ratures moyenn\xE9es pour lesquelles une correction d\x27offset est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, correspondant \xE0 la correction d\x27offset \xE0 appliquer pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['set_offsetChgCompensationTable']={syn:'Enregistre la table de compensation de l\x27offset de poids en fonction de la variation de temp\xE9rature, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la variation de la temp\xE9rature.',lib:'weighscale.set_offsetChgCompensationTable()',pro:'def set_offsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Enregistre la table de compensation de l\x27offset de poids en fonction de la variation de temp\xE9rature, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la variation de la temp\xE9rature. La correction de poids sera faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, correspondant aux diff\xE9rentes variations de temp\xE9rature pour lesquelles une correction d\x27offset est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, correspondant \xE0 la correction d\x27offset \xE0 appliquer pour chacun des points de variation de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'weighscale.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'weighscale.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_spanAvgCompensationTable']={syn:'Enregistre la table de compensation en temp\xE9rature de l\x27amplitude du poids en fonction de la temp\xE9rature moyenn\xE9e, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la temp\xE9rature moyenn\xE9e de compensation.',lib:'weighscale.set_spanAvgCompensationTable()',pro:'def set_spanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Enregistre la table de compensation en temp\xE9rature de l\x27amplitude du poids en fonction de la temp\xE9rature moyenn\xE9e, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la temp\xE9rature moyenn\xE9e de compensation. La correction de poids sera faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, correspondant aux diff\xE9rentes temp\xE9ratures moyenn\xE9es pour lesquelles une correction d\x27amplitude est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, correspondant \xE0 la correction d\x27amplitude (en pour cents) \xE0 appliquer pour chacun des points de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['set_spanChgCompensationTable']={syn:'Enregistre la table de compensation de l\x27amplitude du poids en fonction de la variation de temp\xE9rature, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la variation de temp\xE9rature.',lib:'weighscale.set_spanChgCompensationTable()',pro:'def set_spanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Enregistre la table de compensation de l\x27amplitude du poids en fonction de la variation de temp\xE9rature, afin de pouvoir corriger automatiquement le poids mesur\xE9 sur la base de la variation de temp\xE9rature. La correction de poids sera faite par interpolation lin\xE9aire entre les points sp\xE9cifi\xE9s.</p>',par:{tempValues:'tableau de nombres flottants, correspondant aux diff\xE9rentes variation de temp\xE9rature pour lesquelles une correction d\x27amplitude est sp\xE9cifi\xE9e.',compValues:'tableau de nombres flottants, correspondant \xE0 la correction d\x27amplitude (en pour cents) \xE0 appliquer pour chacun des points de variation de temp\xE9rature, index par index.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['set_tempAvgAdaptRatio']={syn:'Modifie le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille.',lib:'weighscale.set_tempAvgAdaptRatio()',pro:'def set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Modifie le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille. Le but de ce taux d\x27adaptation est de mod\xE9liser l\x27inertie thermique de la cellule de charge. La temp\xE9rature moyenne de compensation est adapt\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la temp\xE9rature moyenne de compensation actuelle. Le taux d\x27adaptation standard est de 0.2 pour mille, et le taux maximal est de 65 pour mille.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_tempChgAdaptRatio']={syn:'Modifie le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille.',lib:'weighscale.set_tempChgAdaptRatio()',pro:'def set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Modifie le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille. La variation de temp\xE9rature est recalcul\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la valeur actuelle de temp\xE9rature de compensation des variations. Le taux d\x27adaptation standard est de 0.6 pour mille, et le taux maximal est de 65 pour mille.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle le poids est exprim\xE9.',lib:'weighscale.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle le poids est exprim\xE9. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'weighscale.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['WeighScale']['set_zeroTracking']={syn:'Modifie la valeur seuil pour le suivi continu du z\xE9ro.',lib:'weighscale.set_zeroTracking()',pro:'def set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur seuil pour le suivi continu du z\xE9ro. Lorsque ce seuil est sup\xE9rieure \xE0 z\xE9ro, les mesures inf\xE9rieures \xE0 cette valeur sont automatiquement ignor\xE9es et le z\xE9ro est continuellement compens\xE9 en cons\xE9quence.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la valeur seuil pour le suivi continu du z\xE9ro'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['WeighScale']['setupSpan']={syn:'Configure le facteur de poids et l\x27amplitude maximale de la cellule de poids (stock\xE9s dans le genericSensor correspondant) de sorte \xE0 ce que le signal actuel corresponde au poids de r\xE9f\xE9rence sp\xE9cifi\xE9.',lib:'weighscale.setupSpan()',pro:'def setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configure le facteur de poids et l\x27amplitude maximale de la cellule de poids (stock\xE9s dans le genericSensor correspondant) de sorte \xE0 ce que le signal actuel corresponde au poids de r\xE9f\xE9rence sp\xE9cifi\xE9.</p>',par:{currWeight:'poids de r\xE9f\xE9rence actuellement sur la cellule de charge.',maxWeight:'poids maximum qui sera utilis\xE9 sur la cellule de charge.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'weighscale.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['WeighScale']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'weighscale.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['WeighScale']['tare']={syn:'Adapte le biais de mesure de la cellule de poids (stock\xE9 dans le genericSensor correspondant) de sorte \xE0 ce que le signal actuel corresponde \xE0 un poids nul.',lib:'weighscale.tare()',pro:'def tare()',cmt:'<p>Adapte le biais de mesure de la cellule de poids (stock\xE9 dans le genericSensor correspondant) de sorte \xE0 ce que le signal actuel corresponde \xE0 un poids nul.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['WeighScale']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'weighscale.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: WeighScale)
//--- (generated code: PowerSupply)
doc['PowerSupply']={'':{syn:'Interface de la fonction PowerSupply',inc:'from yocto_powersupply import *',cmt:'<p>La librairie de programmation Yoctopuce permet de changer la consigne de la sortie de tension, la limite de courant et d\x27activer ou d\xE9sactiver la sortie.</p>'}};
doc['PowerSupply']['FindPowerSupply']={syn:'Permet de retrouver une alimentation r\xE9gul\xE9e d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPowerSupply.FindPowerSupply()',pro:'def FindPowerSupply(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver une alimentation r\xE9gul\xE9e d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que l\x27alimentation r\xE9gul\xE9e soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPowerSupply.isOnline()</tt> pour tester si l\x27alimentation r\xE9gul\xE9e est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27alimentation r\xE9gul\xE9e sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPowerSupply</tt> qui permet ensuite de contr\xF4ler l\x27alimentation r\xE9gul\xE9e.'};
doc['PowerSupply']['FirstPowerSupply']={syn:'Commence l\x27\xE9num\xE9ration des alimentation r\xE9gul\xE9e accessibles par la librairie.',lib:'YPowerSupply.FirstPowerSupply()',pro:'def FirstPowerSupply()',cmt:'<p>Commence l\x27\xE9num\xE9ration des alimentation r\xE9gul\xE9e accessibles par la librairie. Utiliser la fonction <tt>YPowerSupply.nextPowerSupply()</tt> pour it\xE9rer sur les autres alimentation r\xE9gul\xE9e.</p>',ret:'un pointeur sur un objet <tt>YPowerSupply</tt>, correspondant \xE0 la premi\xE8re alimentation r\xE9gul\xE9e accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de alimentation r\xE9gul\xE9e disponibles.'};
doc['PowerSupply']['clearCache']={syn:'Invalide le cache.',lib:'powersupply.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes de l\x27alimentation r\xE9gul\xE9e. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['PowerSupply']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27alimentation r\xE9gul\xE9e au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'powersupply.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance de l\x27alimentation r\xE9gul\xE9e au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant l\x27alimentation r\xE9gul\xE9e (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerSupply']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27alimentation r\xE9gul\xE9e (pas plus de 6 caract\xE8res).',lib:'powersupply.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27alimentation r\xE9gul\xE9e (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27alimentation r\xE9gul\xE9e (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerSupply']['get_currentAtStartUp']={syn:'Retourne la limite de courant s\xE9lectionn\xE9e au d\xE9marrage du module, en mA.',lib:'powersupply.get_currentAtStartUp()',pro:'def get_currentAtStartUp()',cmt:'<p>Retourne la limite de courant s\xE9lectionn\xE9e au d\xE9marrage du module, en mA.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la limite de courant s\xE9lectionn\xE9e au d\xE9marrage du module, en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_currentLimit']={syn:'Retourne la limite de courant, en mA.',lib:'powersupply.get_currentLimit()',pro:'def get_currentLimit()',cmt:'<p>Retourne la limite de courant, en mA.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la limite de courant, en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTLIMIT_INVALID</tt>.'};
doc['PowerSupply']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e.',lib:'powersupply.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e.'};
doc['PowerSupply']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e.',lib:'powersupply.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de l\x27alimentation r\xE9gul\xE9e.'};
doc['PowerSupply']['get_friendlyName']={syn:'Retourne un identifiant global de l\x27alimentation r\xE9gul\xE9e au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'powersupply.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global de l\x27alimentation r\xE9gul\xE9e au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de l\x27alimentation r\xE9gul\xE9e si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de l\x27alimentation r\xE9gul\xE9e (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation r\xE9gul\xE9e en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerSupply']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'powersupply.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['PowerSupply']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de l\x27alimentation r\xE9gul\xE9e, sans r\xE9f\xE9rence au module.',lib:'powersupply.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de l\x27alimentation r\xE9gul\xE9e, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation r\xE9gul\xE9e (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerSupply']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de l\x27alimentation r\xE9gul\xE9e au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'powersupply.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de l\x27alimentation r\xE9gul\xE9e au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de l\x27alimentation r\xE9gul\xE9e (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant l\x27alimentation r\xE9gul\xE9e (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerSupply']['get_inputVoltage']={syn:'Retourne la tension d\x27entr\xE9e mesur\xE9e, en V.',lib:'powersupply.get_inputVoltage()',pro:'def get_inputVoltage()',cmt:'<p>Retourne la tension d\x27entr\xE9e mesur\xE9e, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la tension d\x27entr\xE9e mesur\xE9e, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_INPUTVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_ldoTemperature']={syn:'Retourne la temp\xE9rature du LDO, en degr\xE9s Celsius.',lib:'powersupply.get_ldoTemperature()',pro:'def get_ldoTemperature()',cmt:'<p>Retourne la temp\xE9rature du LDO, en degr\xE9s Celsius.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la temp\xE9rature du LDO, en degr\xE9s Celsius',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LDOTEMPERATURE_INVALID</tt>.'};
doc['PowerSupply']['get_logicalName']={syn:'Retourne le nom logique de l\x27alimentation r\xE9gul\xE9e.',lib:'powersupply.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27alimentation r\xE9gul\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27alimentation r\xE9gul\xE9e.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerSupply']['get_measuredCurrent']={syn:'Retourne le courant mesur\xE9 en sortie, en mA.',lib:'powersupply.get_measuredCurrent()',pro:'def get_measuredCurrent()',cmt:'<p>Retourne le courant mesur\xE9 en sortie, en mA.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le courant mesur\xE9 en sortie, en mA',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MEASUREDCURRENT_INVALID</tt>.'};
doc['PowerSupply']['get_measuredVoltage']={syn:'Retourne la tension de sortie mesur\xE9e, en V.',lib:'powersupply.get_measuredVoltage()',pro:'def get_measuredVoltage()',cmt:'<p>Retourne la tension de sortie mesur\xE9e, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la tension de sortie mesur\xE9e, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MEASUREDVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'powersupply.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['PowerSupply']['get_powerOutput']={syn:'Retourne l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation.',lib:'powersupply.get_powerOutput()',pro:'def get_powerOutput()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation.</p>',ret:'soit <tt>Y_POWEROUTPUT_OFF</tt>, soit <tt>Y_POWEROUTPUT_ON</tt>, selon l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_POWEROUTPUT_INVALID</tt>.'};
doc['PowerSupply']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'powersupply.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['PowerSupply']['get_vInt']={syn:'Retourne la tension interne, en V.',lib:'powersupply.get_vInt()',pro:'def get_vInt()',cmt:'<p>Retourne la tension interne, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la tension interne, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VINT_INVALID</tt>.'};
doc['PowerSupply']['get_voltageAtStartUp']={syn:'Retourne la consigne de tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V.',lib:'powersupply.get_voltageAtStartUp()',pro:'def get_voltageAtStartUp()',cmt:'<p>Retourne la consigne de tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la consigne de tension s\xE9lectionn\xE9e au d\xE9marrage du module, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSense']={syn:'Retourne le point de contr\xF4le de la tension de sortie.',lib:'powersupply.get_voltageSense()',pro:'def get_voltageSense()',cmt:'<p>Retourne le point de contr\xF4le de la tension de sortie.</p>',ret:'soit <tt>Y_VOLTAGESENSE_INT</tt>, soit <tt>Y_VOLTAGESENSE_EXT</tt>, selon le point de contr\xF4le de la tension de sortie',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGESENSE_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSetPoint']={syn:'Retourne la consigne de tension, en V.',lib:'powersupply.get_voltageSetPoint()',pro:'def get_voltageSetPoint()',cmt:'<p>Retourne la consigne de tension, en V.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la consigne de tension, en V',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_VOLTAGESETPOINT_INVALID</tt>.'};
doc['PowerSupply']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant l\x27alimentation r\xE9gul\xE9e est joignable, sans d\xE9clencher d\x27erreur.',lib:'powersupply.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant l\x27alimentation r\xE9gul\xE9e est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de l\x27alimentation r\xE9gul\xE9e sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si l\x27alimentation r\xE9gul\xE9e est joignable, <tt>false</tt> sinon'};
doc['PowerSupply']['load']={syn:'Met en cache les valeurs courantes de l\x27alimentation r\xE9gul\xE9e, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'powersupply.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de l\x27alimentation r\xE9gul\xE9e, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerSupply']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'powersupply.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['PowerSupply']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'powersupply.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerSupply']['nextPowerSupply']={syn:'Continue l\x27\xE9num\xE9ration des alimentation r\xE9gul\xE9e commenc\xE9e \xE0 l\x27aide de <tt>yFirstPowerSupply()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les alimentation r\xE9gul\xE9e sont retourn\xE9s.',lib:'powersupply.nextPowerSupply()',pro:'def nextPowerSupply()',cmt:'<p>Continue l\x27\xE9num\xE9ration des alimentation r\xE9gul\xE9e commenc\xE9e \xE0 l\x27aide de <tt>yFirstPowerSupply()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les alimentation r\xE9gul\xE9e sont retourn\xE9s. Si vous souhaitez retrouver une alimentation r\xE9gul\xE9e sp\xE9cifique, utilisez <tt>PowerSupply.findPowerSupply()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YPowerSupply</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['PowerSupply']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'powersupply.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['PowerSupply']['set_currentAtStartUp']={syn:'Modifie la limite de courant au d\xE9marrage du module.',lib:'powersupply.set_currentAtStartUp()',pro:'def set_currentAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Modifie la limite de courant au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la limite de courant au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['set_currentLimit']={syn:'Modifie la limite de courant, en mA.',lib:'powersupply.set_currentLimit()',pro:'def set_currentLimit(<span id=pn>newval</span>)',cmt:'<p>Modifie la limite de courant, en mA.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la limite de courant, en mA'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['set_logicalName']={syn:'Modifie le nom logique de l\x27alimentation r\xE9gul\xE9e.',lib:'powersupply.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27alimentation r\xE9gul\xE9e. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27alimentation r\xE9gul\xE9e.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['PowerSupply']['set_powerOutput']={syn:'Modifie l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation.',lib:'powersupply.set_powerOutput()',pro:'def set_powerOutput(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation.</p>',par:{newval:'soit <tt>Y_POWEROUTPUT_OFF</tt>, soit <tt>Y_POWEROUTPUT_ON</tt>, selon l\x27\xE9tat d\x27activation de la sortie de l\x27alimentation'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'powersupply.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['PowerSupply']['set_voltageAtStartUp']={syn:'Modifie la valeur de consigne de tension au d\xE9marrage du module.',lib:'powersupply.set_voltageAtStartUp()',pro:'def set_voltageAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur de consigne de tension au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module sinon la modification n\x27aura aucun effet.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la valeur de consigne de tension au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['set_voltageSense']={syn:'Modifie le point de contr\xF4le de la tension.',lib:'powersupply.set_voltageSense()',pro:'def set_voltageSense(<span id=pn>newval</span>)',cmt:'<p>Modifie le point de contr\xF4le de la tension.</p>',par:{newval:'soit <tt>Y_VOLTAGESENSE_INT</tt>, soit <tt>Y_VOLTAGESENSE_EXT</tt>, selon le point de contr\xF4le de la tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['set_voltageSetPoint']={syn:'Modifie la consigne de tension, en V.',lib:'powersupply.set_voltageSetPoint()',pro:'def set_voltageSetPoint(<span id=pn>newval</span>)',cmt:'<p>Modifie la consigne de tension, en V.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la consigne de tension, en V'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['PowerSupply']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'powersupply.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: PowerSupply)
//--- (generated code: MultiCellWeighScale)
doc['MultiCellWeighScale']={'':{syn:'Interface de la fonction MultiCellWeighScale',inc:'from yocto_multicellweighscale import *',cmt:'<p>La classe YMultiCellWeighScale permet d\x27obtenir une mesure de poids \xE0 partir d\x27un groupe de cellules de poids ratiom\xE9trique. Elle permet de contr\xF4ler globalement le mode d\x27excitation des cellules, pour \xE9viter les d\xE9rives li\xE9es aux changements de temp\xE9rature de l\x27\xE9lectronique, et d\x27appliquer automatiquement une correction suppl\xE9mentaire en fonction de la temp\xE9rature pour compenser la d\xE9rive des cellules de poids elles-m\xEAmes.</p>'}};
doc['MultiCellWeighScale']['FindMultiCellWeighScale']={syn:'Permet de retrouver un capteur de poids multi-cellule d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMultiCellWeighScale.FindMultiCellWeighScale()',pro:'def FindMultiCellWeighScale(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de poids multi-cellule d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de poids multi-cellule soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMultiCellWeighScale.isOnline()</tt> pour tester si le capteur de poids multi-cellule est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de poids multi-cellule sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMultiCellWeighScale</tt> qui permet ensuite de contr\xF4ler le capteur de poids multi-cellule.'};
doc['MultiCellWeighScale']['FirstMultiCellWeighScale']={syn:'Commence l\x27\xE9num\xE9ration des capteur de poids multi-cellule accessibles par la librairie.',lib:'YMultiCellWeighScale.FirstMultiCellWeighScale()',pro:'def FirstMultiCellWeighScale()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteur de poids multi-cellule accessibles par la librairie. Utiliser la fonction <tt>YMultiCellWeighScale.nextMultiCellWeighScale()</tt> pour it\xE9rer sur les autres capteur de poids multi-cellule.</p>',ret:'un pointeur sur un objet <tt>YMultiCellWeighScale</tt>, correspondant au premier capteur de poids multi-cellule accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteur de poids multi-cellule disponibles.'};
doc['MultiCellWeighScale']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'multicellweighscale.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['clearCache']={syn:'Invalide le cache.',lib:'multicellweighscale.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de poids multi-cellule. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['MultiCellWeighScale']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de poids multi-cellule au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multicellweighscale.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de poids multi-cellule au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de poids multi-cellule (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiCellWeighScale']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'multicellweighscale.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de poids multi-cellule (pas plus de 6 caract\xE8res).',lib:'multicellweighscale.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de poids multi-cellule (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de poids multi-cellule (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_cellCount']={syn:'Retourne le nombre de cellules de poids utilis\xE9es.',lib:'multicellweighscale.get_cellCount()',pro:'def get_cellCount()',cmt:'<p>Retourne le nombre de cellules de poids utilis\xE9es.</p>',ret:'un entier repr&eacute;sentant le nombre de cellules de poids utilis\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CELLCOUNT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempAvg']={syn:'Retourne la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique.',lib:'multicellweighscale.get_compTempAvg()',pro:'def get_compTempAvg()',cmt:'<p>Retourne la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la temp\xE9rature moyenn\xE9e utilis\xE9e actuellement pour la compensation thermique',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempChg']={syn:'Retourne la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique.',lib:'multicellweighscale.get_compTempChg()',pro:'def get_compTempChg()',cmt:'<p>Retourne la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la variation actuelle de la temp\xE9rature, utilis\xE9e pour la compensation thermique',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compensation']={syn:'Retourne la valeur de la compensation thermique courante.',lib:'multicellweighscale.get_compensation()',pro:'def get_compensation()',cmt:'<p>Retourne la valeur de la compensation thermique courante.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur de la compensation thermique courante',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'multicellweighscale.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentValue']={syn:'Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.',lib:'multicellweighscale.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle de la measure, en l\x27unit\xE9 sp\xE9cifi\xE9e, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'multicellweighscale.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['MultiCellWeighScale']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids multi-cellule.',lib:'multicellweighscale.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids multi-cellule. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de poids multi-cellule.'};
doc['MultiCellWeighScale']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids multi-cellule.',lib:'multicellweighscale.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de poids multi-cellule. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de poids multi-cellule.'};
doc['MultiCellWeighScale']['get_excitation']={syn:'Retourne la m\xE9thode d\x27excitation de la cellule de poids.',lib:'multicellweighscale.get_excitation()',pro:'def get_excitation()',cmt:'<p>Retourne la m\xE9thode d\x27excitation de la cellule de poids.</p>',ret:'une valeur parmi <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> et <tt>Y_EXCITATION_AC</tt> repr&eacute;sentant la m\xE9thode d\x27excitation de la cellule de poids',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_EXCITATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de poids multi-cellule au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'multicellweighscale.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de poids multi-cellule au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de poids multi-cellule si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de poids multi-cellule (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids multi-cellule en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'multicellweighscale.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['MultiCellWeighScale']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de poids multi-cellule, sans r\xE9f\xE9rence au module.',lib:'multicellweighscale.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de poids multi-cellule, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids multi-cellule (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de poids multi-cellule au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'multicellweighscale.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de poids multi-cellule au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de poids multi-cellule (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de poids multi-cellule (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'multicellweighscale.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'multicellweighscale.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logicalName']={syn:'Retourne le nom logique du capteur de poids multi-cellule.',lib:'multicellweighscale.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de poids multi-cellule.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de poids multi-cellule.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module.',lib:'multicellweighscale.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour la measure depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'multicellweighscale.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['MultiCellWeighScale']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'multicellweighscale.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['MultiCellWeighScale']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'multicellweighscale.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'multicellweighscale.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'multicellweighscale.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_tempAvgAdaptRatio']={syn:'Retourne le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille.',lib:'multicellweighscale.get_tempAvgAdaptRatio()',pro:'def get_tempAvgAdaptRatio()',cmt:'<p>Retourne le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille. Le but de ce taux d\x27adaptation est de mod\xE9liser l\x27inertie thermique de la cellule de charge. La temp\xE9rature moyenne de compensation est adapt\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la temp\xE9rature moyenne de compensation actuelle. Le taux d\x27adaptation standard est de 0.2 pour mille, et le taux maximal est de 65 pour mille.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TEMPAVGADAPTRATIO_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_tempChgAdaptRatio']={syn:'Retourne le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille.',lib:'multicellweighscale.get_tempChgAdaptRatio()',pro:'def get_tempChgAdaptRatio()',cmt:'<p>Retourne le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille. La variation de temp\xE9rature est recalcul\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la valeur actuelle de temp\xE9rature de compensation des variations. Le taux d\x27adaptation standard est de 0.6 pour mille, et le taux maximal est de 65 pour mille.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_TEMPCHGADAPTRATIO_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.',lib:'multicellweighscale.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la measure est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle la measure est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'multicellweighscale.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['MultiCellWeighScale']['get_zeroTracking']={syn:'Retourne la valeur seuil pour le suivi continu du z\xE9ro.',lib:'multicellweighscale.get_zeroTracking()',pro:'def get_zeroTracking()',cmt:'<p>Retourne la valeur seuil pour le suivi continu du z\xE9ro. Lorsque ce seuil est sup\xE9rieure \xE0 z\xE9ro, les mesures inf\xE9rieures \xE0 cette valeur sont automatiquement ignor\xE9es et le z\xE9ro est continuellement compens\xE9 en cons\xE9quence.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur seuil pour le suivi continu du z\xE9ro',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['MultiCellWeighScale']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de poids multi-cellule est joignable, sans d\xE9clencher d\x27erreur.',lib:'multicellweighscale.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de poids multi-cellule est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de poids multi-cellule sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de poids multi-cellule est joignable, <tt>false</tt> sinon'};
doc['MultiCellWeighScale']['load']={syn:'Met en cache les valeurs courantes du capteur de poids multi-cellule, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'multicellweighscale.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de poids multi-cellule, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'multicellweighscale.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['MultiCellWeighScale']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'multicellweighscale.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multicellweighscale.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['nextMultiCellWeighScale']={syn:'Continue l\x27\xE9num\xE9ration des capteur de poids multi-cellule commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiCellWeighScale()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteur de poids multi-cellule sont retourn\xE9s.',lib:'multicellweighscale.nextMultiCellWeighScale()',pro:'def nextMultiCellWeighScale()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteur de poids multi-cellule commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiCellWeighScale()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteur de poids multi-cellule sont retourn\xE9s. Si vous souhaitez retrouver un capteur de poids multi-cellule sp\xE9cifique, utilisez <tt>MultiCellWeighScale.findMultiCellWeighScale()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMultiCellWeighScale</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['MultiCellWeighScale']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'multicellweighscale.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MultiCellWeighScale']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'multicellweighscale.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MultiCellWeighScale']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'multicellweighscale.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_cellCount']={syn:'Modifie le nombre de cellules de poids utilis\xE9es.',lib:'multicellweighscale.set_cellCount()',pro:'def set_cellCount(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de cellules de poids utilis\xE9es.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de cellules de poids utilis\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_excitation']={syn:'Modifie la m\xE9thode d\x27excitation de la cellule de poids.',lib:'multicellweighscale.set_excitation()',pro:'def set_excitation(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode d\x27excitation de la cellule de poids.</p>',par:{newval:'une valeur parmi <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> et <tt>Y_EXCITATION_AC</tt> repr&eacute;sentant la m\xE9thode d\x27excitation de la cellule de poids'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'multicellweighscale.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'multicellweighscale.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_logicalName']={syn:'Modifie le nom logique du capteur de poids multi-cellule.',lib:'multicellweighscale.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de poids multi-cellule. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de poids multi-cellule.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'multicellweighscale.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'multicellweighscale.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'multicellweighscale.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_tempAvgAdaptRatio']={syn:'Modifie le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille.',lib:'multicellweighscale.set_tempAvgAdaptRatio()',pro:'def set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Modifie le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille. Le but de ce taux d\x27adaptation est de mod\xE9liser l\x27inertie thermique de la cellule de charge. La temp\xE9rature moyenne de compensation est adapt\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la temp\xE9rature moyenne de compensation actuelle. Le taux d\x27adaptation standard est de 0.2 pour mille, et le taux maximal est de 65 pour mille.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la temp\xE9rature moyenne, en pour mille'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_tempChgAdaptRatio']={syn:'Modifie le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille.',lib:'multicellweighscale.set_tempChgAdaptRatio()',pro:'def set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Modifie le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille. La variation de temp\xE9rature est recalcul\xE9e toutes les 10 secondes, en appliquant ce taux d\x27adaptation \xE0 la diff\xE9rence entre la temp\xE9rature ambiante mesur\xE9e et la valeur actuelle de temp\xE9rature de compensation des variations. Le taux d\x27adaptation standard est de 0.6 pour mille, et le taux maximal est de 65 pour mille.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant le taux d\x27adaptation pour le calcul de la variation de temp\xE9rature, en pour mille'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_unit']={syn:'Change l\x27unit\xE9 dans laquelle le poids est exprim\xE9.',lib:'multicellweighscale.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Change l\x27unit\xE9 dans laquelle le poids est exprim\xE9. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'multicellweighscale.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['MultiCellWeighScale']['set_zeroTracking']={syn:'Modifie la valeur seuil pour le suivi continu du z\xE9ro.',lib:'multicellweighscale.set_zeroTracking()',pro:'def set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Modifie la valeur seuil pour le suivi continu du z\xE9ro. Lorsque ce seuil est sup\xE9rieure \xE0 z\xE9ro, les mesures inf\xE9rieures \xE0 cette valeur sont automatiquement ignor\xE9es et le z\xE9ro est continuellement compens\xE9 en cons\xE9quence.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la valeur seuil pour le suivi continu du z\xE9ro'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiCellWeighScale']['setupSpan']={syn:'Configure le facteur de poids et l\x27amplitude maximale des cellules de poids (stock\xE9s dans les genericSensors correspondants) de sorte \xE0 ce que le signal actuel corresponde au poids de r\xE9f\xE9rence sp\xE9cifi\xE9.',lib:'multicellweighscale.setupSpan()',pro:'def setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configure le facteur de poids et l\x27amplitude maximale des cellules de poids (stock\xE9s dans les genericSensors correspondants) de sorte \xE0 ce que le signal actuel corresponde au poids de r\xE9f\xE9rence sp\xE9cifi\xE9.</p>',par:{currWeight:'poids de r\xE9f\xE9rence actuellement sur la cellule de charge.',maxWeight:'poids maximum qui sera utilis\xE9 sur la cellule de charge.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'multicellweighscale.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['MultiCellWeighScale']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'multicellweighscale.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['MultiCellWeighScale']['tare']={syn:'Adapte le biais de mesure des cellules de poids (stock\xE9 dans les genericSensors correspondants) de sorte \xE0 ce que le signal actuel corresponde \xE0 un poids nul.',lib:'multicellweighscale.tare()',pro:'def tare()',cmt:'<p>Adapte le biais de mesure des cellules de poids (stock\xE9 dans les genericSensors correspondants) de sorte \xE0 ce que le signal actuel corresponde \xE0 un poids nul.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiCellWeighScale']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multicellweighscale.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: MultiCellWeighScale)
//--- (generated code: MultiSensorController)
doc['MultiSensorController']={'':{syn:'Interface de la fonction MultiSensorController',inc:'from yocto_multisensorcontroller import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter un moteur pas \xE0 pas.</p>'}};
doc['MultiSensorController']['FindMultiSensorController']={syn:'Permet de retrouver un contr\xF4leur multi-capteurs d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMultiSensorController.FindMultiSensorController()',pro:'def FindMultiSensorController(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4leur multi-capteurs d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le contr\xF4leur multi-capteurs soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMultiSensorController.isOnline()</tt> pour tester si le contr\xF4leur multi-capteurs est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4leur multi-capteurs sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMultiSensorController</tt> qui permet ensuite de contr\xF4ler le contr\xF4leur multi-capteurs.'};
doc['MultiSensorController']['FirstMultiSensorController']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs accessibles par la librairie.',lib:'YMultiSensorController.FirstMultiSensorController()',pro:'def FirstMultiSensorController()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs accessibles par la librairie. Utiliser la fonction <tt>YMultiSensorController.nextMultiSensorController()</tt> pour it\xE9rer sur les autres contr\xF4leur multi-capteurs.</p>',ret:'un pointeur sur un objet <tt>YMultiSensorController</tt>, correspondant au premier contr\xF4leur multi-capteur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4leur multi-capteurs disponibles.'};
doc['MultiSensorController']['clearCache']={syn:'Invalide le cache.',lib:'multisensorcontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du contr\xF4leur multi-capteurs. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['MultiSensorController']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-capteurs au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multisensorcontroller.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-capteurs au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le contr\xF4leur multi-capteurs (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiSensorController']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).',lib:'multisensorcontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiSensorController']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs.',lib:'multisensorcontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-capteurs.'};
doc['MultiSensorController']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs.',lib:'multisensorcontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-capteurs.'};
doc['MultiSensorController']['get_friendlyName']={syn:'Retourne un identifiant global du contr\xF4leur multi-capteurs au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'multisensorcontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du contr\xF4leur multi-capteurs au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du contr\xF4leur multi-capteurs si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du contr\xF4leur multi-capteurs (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiSensorController']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'multisensorcontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['MultiSensorController']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs, sans r\xE9f\xE9rence au module.',lib:'multisensorcontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiSensorController']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-capteurs au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'multisensorcontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-capteurs au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiSensorController']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4leur multi-capteurs.',lib:'multisensorcontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4leur multi-capteurs.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-capteurs.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiSensorController']['get_maintenanceMode']={syn:'Retourne vrai si le module est en mode maintenance.',lib:'multisensorcontroller.get_maintenanceMode()',pro:'def get_maintenanceMode()',cmt:'<p>Retourne vrai si le module est en mode maintenance.</p>',ret:'soit <tt>Y_MAINTENANCEMODE_FALSE</tt>, soit <tt>Y_MAINTENANCEMODE_TRUE</tt>, selon vrai si le module est en mode maintenance',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAINTENANCEMODE_INVALID</tt>.'};
doc['MultiSensorController']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'multisensorcontroller.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['MultiSensorController']['get_nSensors']={syn:'Retourne le nombre de capteurs \xE0 interroger.',lib:'multisensorcontroller.get_nSensors()',pro:'def get_nSensors()',cmt:'<p>Retourne le nombre de capteurs \xE0 interroger.</p>',ret:'un entier repr&eacute;sentant le nombre de capteurs \xE0 interroger',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NSENSORS_INVALID</tt>.'};
doc['MultiSensorController']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'multisensorcontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['MultiSensorController']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-capteurs est joignable, sans d\xE9clencher d\x27erreur.',lib:'multisensorcontroller.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-capteurs est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du contr\xF4leur multi-capteurs sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le contr\xF4leur multi-capteurs est joignable, <tt>false</tt> sinon'};
doc['MultiSensorController']['load']={syn:'Met en cache les valeurs courantes du contr\xF4leur multi-capteurs, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'multisensorcontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du contr\xF4leur multi-capteurs, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensorController']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'multisensorcontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['MultiSensorController']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multisensorcontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensorController']['nextMultiSensorController']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiSensorController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-capteurs sont retourn\xE9s.',lib:'multisensorcontroller.nextMultiSensorController()',pro:'def nextMultiSensorController()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiSensorController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-capteurs sont retourn\xE9s. Si vous souhaitez retrouver un contr\xF4leur multi-capteurs sp\xE9cifique, utilisez <tt>MultiSensorController.findMultiSensorController()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMultiSensorController</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['MultiSensorController']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'multisensorcontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MultiSensorController']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4leur multi-capteurs.',lib:'multisensorcontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4leur multi-capteurs. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-capteurs.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensorController']['set_maintenanceMode']={syn:'Modifie l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs.',lib:'multisensorcontroller.set_maintenanceMode()',pro:'def set_maintenanceMode(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs.</p>',par:{newval:'soit <tt>Y_MAINTENANCEMODE_FALSE</tt>, soit <tt>Y_MAINTENANCEMODE_TRUE</tt>, selon l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiSensorController']['set_nSensors']={syn:'Modifie le nombre de capteurs \xE0 interroger.',lib:'multisensorcontroller.set_nSensors()',pro:'def set_nSensors(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de capteurs \xE0 interroger. Les adresses de tous les capteurs doivent avoir \xE9t\xE9 correctement configur\xE9es. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. Il est recommand\xE9 de forcer le module \xE0 red\xE9marrer \xE0 l\x27aide de <tt>module->reboot()</tt> apr\xE8s avoir modifi\xE9 (et sauv\xE9)ce r\xE9glage.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de capteurs \xE0 interroger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiSensorController']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'multisensorcontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['MultiSensorController']['setupAddress']={syn:'Configure l\x27adresse I2C de l\x27unique capteur branch\xE9 au module.',lib:'multisensorcontroller.setupAddress()',pro:'def setupAddress(<span id=pn>addr</span>)',cmt:'<p>Configure l\x27adresse I2C de l\x27unique capteur branch\xE9 au module. Il est recommand\xE9 de mettre le mode en mode maintenance avant de manipuler les adresses des capteurs. Cette m\xE9thode n\x27est destin\xE9e \xE0 \xEAtre utilis\xE9e qu\x27avec un seul capteur connect\xE9, si plusieurs senseurs sont connect\xE9s l\x27effet de cette commande est ind\xE9termin\xE9. Notez que votre module s\x27attend probablement \xE0 trouver une chaine de capteurs avec des adresses bien pr\xE9cises. Vous trouvez dans le documentation du modules quels adresses peuvent \xEAtre utilis\xE9s.</p>',par:{addr:'nouvelle address du capteur connect\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensorController']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multisensorcontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: MultiSensorController)
//--- (generated code: MultiSensController)
doc['MultiSensController']={'':{syn:'Interface de la fonction MultiSensController',inc:'from yocto_multisenscontroller import *',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter un moteur pas \xE0 pas.</p>'}};
doc['MultiSensController']['FindMultiSensController']={syn:'Permet de retrouver un contr\xF4leur multi-capteurs d\x27apr\xE8s un identifiant donn\xE9.',lib:'YMultiSensController.FindMultiSensController()',pro:'def FindMultiSensController(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4leur multi-capteurs d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le contr\xF4leur multi-capteurs soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YMultiSensController.isOnline()</tt> pour tester si le contr\xF4leur multi-capteurs est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4leur multi-capteurs sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YMultiSensController</tt> qui permet ensuite de contr\xF4ler le contr\xF4leur multi-capteurs.'};
doc['MultiSensController']['FirstMultiSensController']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs accessibles par la librairie.',lib:'YMultiSensController.FirstMultiSensController()',pro:'def FirstMultiSensController()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs accessibles par la librairie. Utiliser la fonction <tt>YMultiSensController.nextMultiSensController()</tt> pour it\xE9rer sur les autres contr\xF4leur multi-capteurs.</p>',ret:'un pointeur sur un objet <tt>YMultiSensController</tt>, correspondant au premier contr\xF4leur multi-capteur accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4leur multi-capteurs disponibles.'};
doc['MultiSensController']['clearCache']={syn:'Invalide le cache.',lib:'multisenscontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du contr\xF4leur multi-capteurs. Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['MultiSensController']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-capteurs au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multisenscontroller.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du contr\xF4leur multi-capteurs au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le contr\xF4leur multi-capteurs (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiSensController']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).',lib:'multisenscontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4leur multi-capteurs (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiSensController']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs.',lib:'multisenscontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-capteurs.'};
doc['MultiSensController']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs.',lib:'multisenscontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du contr\xF4leur multi-capteurs. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du contr\xF4leur multi-capteurs.'};
doc['MultiSensController']['get_friendlyName']={syn:'Retourne un identifiant global du contr\xF4leur multi-capteurs au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'multisenscontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du contr\xF4leur multi-capteurs au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du contr\xF4leur multi-capteurs si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du contr\xF4leur multi-capteurs (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiSensController']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'multisenscontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['MultiSensController']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs, sans r\xE9f\xE9rence au module.',lib:'multisenscontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiSensController']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-capteurs au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'multisenscontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du contr\xF4leur multi-capteurs au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du contr\xF4leur multi-capteurs (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le contr\xF4leur multi-capteurs (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiSensController']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4leur multi-capteurs.',lib:'multisenscontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4leur multi-capteurs.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-capteurs.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiSensController']['get_maintenanceMode']={syn:'Retourne vrai si le module est en mode maintenance.',lib:'multisenscontroller.get_maintenanceMode()',pro:'def get_maintenanceMode()',cmt:'<p>Retourne vrai si le module est en mode maintenance.</p>',ret:'soit <tt>Y_MAINTENANCEMODE_FALSE</tt>, soit <tt>Y_MAINTENANCEMODE_TRUE</tt>, selon vrai si le module est en mode maintenance',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAINTENANCEMODE_INVALID</tt>.'};
doc['MultiSensController']['get_maxSensors']={syn:'Retourne le nombre maximum de capteurs qu\x27il est possible de configurer sur ce module.',lib:'multisenscontroller.get_maxSensors()',pro:'def get_maxSensors()',cmt:'<p>Retourne le nombre maximum de capteurs qu\x27il est possible de configurer sur ce module.</p>',ret:'un entier repr&eacute;sentant le nombre maximum de capteurs qu\x27il est possible de configurer sur ce module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_MAXSENSORS_INVALID</tt>.'};
doc['MultiSensController']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'multisenscontroller.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['MultiSensController']['get_nSensors']={syn:'Retourne le nombre de capteurs \xE0 interroger.',lib:'multisenscontroller.get_nSensors()',pro:'def get_nSensors()',cmt:'<p>Retourne le nombre de capteurs \xE0 interroger.</p>',ret:'un entier repr&eacute;sentant le nombre de capteurs \xE0 interroger',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_NSENSORS_INVALID</tt>.'};
doc['MultiSensController']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'multisenscontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['MultiSensController']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-capteurs est joignable, sans d\xE9clencher d\x27erreur.',lib:'multisenscontroller.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le contr\xF4leur multi-capteurs est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du contr\xF4leur multi-capteurs sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le contr\xF4leur multi-capteurs est joignable, <tt>false</tt> sinon'};
doc['MultiSensController']['load']={syn:'Met en cache les valeurs courantes du contr\xF4leur multi-capteurs, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'multisenscontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du contr\xF4leur multi-capteurs, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensController']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'multisenscontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['MultiSensController']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multisenscontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensController']['nextMultiSensController']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiSensController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-capteurs sont retourn\xE9s.',lib:'multisenscontroller.nextMultiSensController()',pro:'def nextMultiSensController()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4leur multi-capteurs commenc\xE9e \xE0 l\x27aide de <tt>yFirstMultiSensController()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les contr\xF4leur multi-capteurs sont retourn\xE9s. Si vous souhaitez retrouver un contr\xF4leur multi-capteurs sp\xE9cifique, utilisez <tt>MultiSensController.findMultiSensController()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YMultiSensController</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['MultiSensController']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'multisenscontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['MultiSensController']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4leur multi-capteurs.',lib:'multisenscontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4leur multi-capteurs. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4leur multi-capteurs.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensController']['set_maintenanceMode']={syn:'Modifie l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs.',lib:'multisenscontroller.set_maintenanceMode()',pro:'def set_maintenanceMode(<span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs.</p>',par:{newval:'soit <tt>Y_MAINTENANCEMODE_FALSE</tt>, soit <tt>Y_MAINTENANCEMODE_TRUE</tt>, selon l\x27\xE9tat de fonctionnement du module pour le mettre en mode maintenance, ce qui arr\xEAte l\x27interrogation des capteurs et \xE9vite que le module ne red\xE9marre automatiquement si il n\x27arrive pas \xE0 communiquer avec l\x27un des capteurs'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiSensController']['set_nSensors']={syn:'Modifie le nombre de capteurs \xE0 interroger.',lib:'multisenscontroller.set_nSensors()',pro:'def set_nSensors(<span id=pn>newval</span>)',cmt:'<p>Modifie le nombre de capteurs \xE0 interroger. Les adresses de tous les capteurs doivent avoir \xE9t\xE9 correctement configur\xE9es. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. Il est recommand\xE9 de forcer le module \xE0 red\xE9marrer \xE0 l\x27aide de <tt>module->reboot()</tt> apr\xE8s avoir modifi\xE9 (et sauv\xE9)ce r\xE9glage.</p>',par:{newval:'un entier repr&eacute;sentant le nombre de capteurs \xE0 interroger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['MultiSensController']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'multisenscontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['MultiSensController']['setupAddress']={syn:'Configure l\x27adresse I2C de l\x27unique capteur branch\xE9 au module.',lib:'multisenscontroller.setupAddress()',pro:'def setupAddress(<span id=pn>addr</span>)',cmt:'<p>Configure l\x27adresse I2C de l\x27unique capteur branch\xE9 au module. Il est recommand\xE9 de mettre le mode en mode maintenance avant de manipuler les adresses des capteurs. Cette m\xE9thode n\x27est destin\xE9e \xE0 \xEAtre utilis\xE9e qu\x27avec un seul capteur connect\xE9, si plusieurs senseurs sont connect\xE9s l\x27effet de cette commande est ind\xE9termin\xE9. Notez que votre module s\x27attend probablement \xE0 trouver une chaine de capteurs avec des adresses bien pr\xE9cises. Vous trouvez dans le documentation du modules quels adresses peuvent \xEAtre utilis\xE9s.</p>',par:{addr:'nouvelle address du capteur connect\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['MultiSensController']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'multisenscontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: MultiSensController)
//--- (generated code: Tvoc)
doc['Tvoc']={'':{syn:'Interface de la fonction Tvoc',inc:'from yocto_tvoc import *',cmt:'<p>La classe YTvoc permet de lire et de configurer les capteurs de composants organiques volatiles Yoctopuce (total). Elle h\xE9rite de la class YSensor toutes les fonctions de base des capteurs Yoctopuce: lecture de mesures, callbacks, enregistreur de donn\xE9es.</p>'}};
doc['Tvoc']['FindTvoc']={syn:'Permet de retrouver un capteur de Compos\xE9s Organiques Volatils (total) d\x27apr\xE8s un identifiant donn\xE9.',lib:'YTvoc.FindTvoc()',pro:'def FindTvoc(<span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de Compos\xE9s Organiques Volatils (total) d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul></p><p> Cette fonction n\x27exige pas que le capteur de Compos\xE9s Organiques Volatils (total) soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YTvoc.isOnline()</tt> pour tester si le capteur de Compos\xE9s Organiques Volatils (total) est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p><p> Si un appel \xE0 la m\xE9thode is_online() de cet objet renvoie FAUX alors que vous \xEAtes s\xFBr que le module correspondant est bien branch\xE9, v\xE9rifiez que vous n\x27avez pas oubli\xE9 d\x27appeler registerHub() \xE0 l\x27initialisation de de l\x27application.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de Compos\xE9s Organiques Volatils (total) sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YTvoc</tt> qui permet ensuite de contr\xF4ler le capteur de Compos\xE9s Organiques Volatils (total).'};
doc['Tvoc']['FirstTvoc']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils (total) accessibles par la librairie.',lib:'YTvoc.FirstTvoc()',pro:'def FirstTvoc()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils (total) accessibles par la librairie. Utiliser la fonction <tt>YTvoc.nextTvoc()</tt> pour it\xE9rer sur les autres capteurs de Compos\xE9s Organiques Volatils (total).</p>',ret:'un pointeur sur un objet <tt>YTvoc</tt>, correspondant au premier capteur de Compos\xE9s Organiques Volatils (total) accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de Compos\xE9s Organiques Volatils (total) disponibles.'};
doc['Tvoc']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'tvoc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support@yoctopuce.com.</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tvoc']['clearCache']={syn:'Invalide le cache.',lib:'tvoc.clearCache()',pro:'def clearCache()',cmt:'<p>Invalide le cache. Invalide le cache des valeurs courantes du capteur de Compos\xE9s Organiques Volatils (total). Force le prochain appel \xE0 une m\xE9thode get_xxx() ou loadxxx() pour charger les les donn\xE9es depuis le module.</p>'};
doc['Tvoc']['describe']={syn:'Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tvoc.describe()',pro:'def describe()',cmt:'<p>Retourne un court texte d\xE9crivant de mani\xE8re non-ambig\xFCe l\x27instance du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le capteur de Compos\xE9s Organiques Volatils (total) (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tvoc']['get_advMode']={syn:'Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'tvoc.get_advMode()',pro:'def get_advMode()',cmt:'<p>Retourne le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',ret:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Tvoc']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (total) (pas plus de 6 caract\xE8res).',lib:'tvoc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (total) (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de Compos\xE9s Organiques Volatils (total) (pas plus de 6 caract\xE8res).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tvoc']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppb, sous forme de nombre \xE0 virgule.',lib:'tvoc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppb, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration), en ppb, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tvoc']['get_currentValue']={syn:'Retourne la valeur actuelle du taux de TVOC estim\xE9, en ppb, sous forme de nombre \xE0 virgule.',lib:'tvoc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Retourne la valeur actuelle du taux de TVOC estim\xE9, en ppb, sous forme de nombre \xE0 virgule.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur actuelle du taux de TVOC estim\xE9, en ppb, sous forme de nombre \xE0 virgule',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_dataLogger']={syn:'Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur.',lib:'tvoc.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Retourne l\x27objet YDataLogger du module qui h\xE9berge le senseur. Cette m\xE9thode retourne un objet de la classe YDataLogger qui permet de contr\xF4ler les param\xE8tres globaux de l\x27enregistreur de donn\xE9es. L\x27objet retourn\xE9 ne doit pas \xEAtre lib\xE9r\xE9.</p>',ret:'un objet de classe YDataLogger ou null en cas d\x27erreur.'};
doc['Tvoc']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total).',lib:'tvoc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total). Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total).'};
doc['Tvoc']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total).',lib:'tvoc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total). Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du capteur de Compos\xE9s Organiques Volatils (total).'};
doc['Tvoc']['get_friendlyName']={syn:'Retourne un identifiant global du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'tvoc.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Retourne un identifiant global du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et du capteur de Compos\xE9s Organiques Volatils (total) si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (total) (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils (total) en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tvoc']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'tvoc.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>.',ext:'Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Tvoc']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (total), sans r\xE9f\xE9rence au module.',lib:'tvoc.get_functionId()',pro:'def get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (total), sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils (total) (ex: <tt>relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tvoc']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>SERIAL.FUNCTIONID</tt>.',lib:'tvoc.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique du capteur de Compos\xE9s Organiques Volatils (total) au format <tt>SERIAL.FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel du capteur de Compos\xE9s Organiques Volatils (total) (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant le capteur de Compos\xE9s Organiques Volatils (total) (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tvoc']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module.',lib:'tvoc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_highestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur maximale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_logFrequency']={syn:'Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.',lib:'tvoc.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Retourne la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger, ou \x22OFF\x22 si les mesures ne sont pas stock\xE9es dans la m\xE9moire de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tvoc']['get_logicalName']={syn:'Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils (total).',lib:'tvoc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils (total).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils (total).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tvoc']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module.',lib:'tvoc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module. Peut \xEAtre r\xE9initialis\xE9 \xE0 une valeur arbitraire gr\xE2ce \xE0 set_lowestValue().</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la valeur minimale observ\xE9e pour le taux de TVOC estim\xE9 depuis le d\xE9marrage du module',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'tvoc.get_module()',pro:'def get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Tvoc']['get_recordedData']={syn:'Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9.',lib:'tvoc.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retourne un objet DataSet repr\xE9sentant des mesures de ce capteur pr\xE9c\xE9demment enregistr\xE9es \xE0 l\x27aide du DataLogger, pour l\x27intervalle de temps sp\xE9cifi\xE9. Veuillez vous r\xE9f\xE9rer \xE0 la documentation de la classe DataSet pour plus plus d\x27informations sur la mani\xE8re d\x27obtenir un aper\xE7u des mesures pour la p\xE9riode, et comment charger progressivement une grande quantit\xE9 de mesures depuis le dataLogger.</p><p> Cette m\xE9thode ne fonctionne que si le module utilise un firmware r\xE9cent, car les objets DataSet ne sont pas support\xE9s par les firmwares ant\xE9rieurs \xE0 la r\xE9vision 13000.</p>',par:{startTime:'le d\xE9but de l\x27intervalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite sur le d\xE9but des mesures.',endTime:'la find de l\x27intercalle de mesure d\xE9sir\xE9, c\x27est \xE0 dire en nombre de secondes depuis le 1er janvier 1970 UTC. La valeur 0 peut \xEAtre utilis\xE9e pour ne poser aucune limite de fin.'},ret:'une instance de YDataSet, dont les m\xE9thodes permettent de d\x27acc\xE9der aux donn\xE9es historiques souhait\xE9es.'};
doc['Tvoc']['get_reportFrequency']={syn:'Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.',lib:'tvoc.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Retourne la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es, ou \x22OFF\x22 si les notifications p\xE9riodiques sont d\xE9sactiv\xE9es pour cette fonction',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tvoc']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'tvoc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision num\xE9rique de la repr\xE9sentation des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tvoc']['get_sensorState']={syn:'Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.',lib:'tvoc.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Retourne le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment.</p>',ret:'un entier repr&eacute;sentant le code d\x27\xE9tat du capteur, qui vaut z\xE9ro lorsqu\x27une mesure actuelle est disponible, ou un code positif si le capteur n\x27est pas en mesure de fournir une valeur en ce moment',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Tvoc']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle le taux de TVOC estim\xE9 est exprim\xE9e.',lib:'tvoc.get_unit()',pro:'def get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle le taux de TVOC estim\xE9 est exprim\xE9e.</p>',ret:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant l\x27unit\xE9 dans laquelle le taux de TVOC estim\xE9 est exprim\xE9e',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Tvoc']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'tvoc.get_userData()',pro:'def get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Tvoc']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant le capteur de Compos\xE9s Organiques Volatils (total) est joignable, sans d\xE9clencher d\x27erreur.',lib:'tvoc.isOnline()',pro:'def isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant le capteur de Compos\xE9s Organiques Volatils (total) est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache du capteur de Compos\xE9s Organiques Volatils (total) sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le capteur de Compos\xE9s Organiques Volatils (total) est joignable, <tt>false</tt> sinon'};
doc['Tvoc']['load']={syn:'Met en cache les valeurs courantes du capteur de Compos\xE9s Organiques Volatils (total), avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'tvoc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du capteur de Compos\xE9s Organiques Volatils (total), avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tvoc']['loadAttribute']={syn:'Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.',lib:'tvoc.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Retourne la valeur actuelle d\x27un attribut sp\xE9cifique de la fonction, sous forme de texte, le plus rapidement possible mais sans passer par le cache.</p>',par:{attrName:'le nom de l\x27attribut d\xE9sir\xE9'},ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur actuelle de l\x27attribut.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un cha\xEEne vide.'};
doc['Tvoc']['loadCalibrationPoints']={syn:'R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.',lib:'tvoc.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>R\xE9cup\xE8re les points de correction de mesure pr\xE9c\xE9demment enregistr\xE9s \xE0 l\x27aide de la m\xE9thode <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs brutes des points de correction.',refValues:'tableau de nombres flottants, qui sera rempli par la fonction avec les valeurs d\xE9sir\xE9es des points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tvoc']['muteValueCallbacks']={syn:'D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'tvoc.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>D\xE9sactive l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Vous pouvez utiliser cette fonction pour \xE9conomiser la bande passante et le CPU sur les machines de faible puissance, ou pour \xE9viter le d\xE9clanchement de callbacks HTTP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tvoc']['nextTvoc']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils (total) commenc\xE9e \xE0 l\x27aide de <tt>yFirstTvoc()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de Compos\xE9s Organiques Volatils (total) sont retourn\xE9s.',lib:'tvoc.nextTvoc()',pro:'def nextTvoc()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils (total) commenc\xE9e \xE0 l\x27aide de <tt>yFirstTvoc()</tt> Attention, vous ne pouvez faire aucune supposition sur l\x27ordre dans lequel les capteurs de Compos\xE9s Organiques Volatils (total) sont retourn\xE9s. Si vous souhaitez retrouver un capteur de Compos\xE9s Organiques Volatils (total) sp\xE9cifique, utilisez <tt>Tvoc.findTvoc()</tt> avec un hardwareID ou un nom logique.</p>',ret:'un pointeur sur un objet <tt>YTvoc</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Tvoc']['registerTimedReportCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique.',lib:'tvoc.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque notification p\xE9riodique. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callbacks peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callbacks ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et un objet YMeasure d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Tvoc']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'tvoc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Tvoc']['set_advMode']={syn:'Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).',lib:'tvoc.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Modifie le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue).</p>',par:{newval:'une valeur parmi <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> et <tt>Y_ADVMODE_PERIOD_MAX</tt> repr&eacute;sentant le mode de calcul de la valeur publi\xE9e jusqu\x27au hub parent (advertisedValue)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'tvoc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_highestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_logFrequency']={syn:'Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger.',lib:'tvoc.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence d\x27enregistrement des mesures dans le datalogger. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver l\x27enregistrement des mesures de cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence d\x27enregistrement des mesures dans le datalogger'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_logicalName']={syn:'Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils (total).',lib:'tvoc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils (total). Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils (total).'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27appel se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Tvoc']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'tvoc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e. Utile pour r\xE9initialiser la valeur renvoy\xE9e par get_lowestValue().</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_reportFrequency']={syn:'Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es.',lib:'tvoc.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Modifie la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es. La fr\xE9quence peut \xEAtre sp\xE9cifi\xE9e en mesures par secondes, en mesures par minutes (par exemple \x2215/m\x22) ou en mesures par heure (par exemple \x224/h\x22). Pour d\xE9sactiver les notifications p\xE9riodiques pour cette fonction, utilisez la valeur \x22OFF\x22.</p>',par:{newval:'une cha&icirc;ne de caract&egrave;res repr&eacute;sentant la fr\xE9quence de notification p\xE9riodique des valeurs mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_resolution']={syn:'Modifie la r\xE9solution des valeurs physique mesur\xE9es.',lib:'tvoc.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9solution des valeurs physique mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de l\x27affichage des mesures. Elle ne change pas la pr\xE9cision de la mesure elle-m\xEAme.</p>',par:{newval:'une valeur num&eacute;rique repr&eacute;sentant la r\xE9solution des valeurs physique mesur\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op&eacute;ration se d&eacute;roule sans erreur.',ext:'En cas d\x27erreur, d&eacute;clenche une exception ou retourne un code d\x27erreur n&eacute;gatif.'};
doc['Tvoc']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'tvoc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Tvoc']['startDataLogger']={syn:'D\xE9marre l\x27enregistreur de donn\xE9es du module.',lib:'tvoc.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>D\xE9marre l\x27enregistreur de donn\xE9es du module. Attention, l\x27enregistreur ne sauvera les mesures de ce capteur que si la fr\xE9quence d\x27enregistrement (logFrequency) n\x27est pas sur \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Tvoc']['stopDataLogger']={syn:'Arr\xEAte l\x27enregistreur de donn\xE9es du module.',lib:'tvoc.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Arr\xEAte l\x27enregistreur de donn\xE9es du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.'};
doc['Tvoc']['unmuteValueCallbacks']={syn:'R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent.',lib:'tvoc.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>R\xE9active l\x27envoi de chaque changement de la valeur publi\xE9e au hub parent. Cette fonction annule un pr\xE9c\xE9dent appel \xE0 <tt>muteValueCallbacks()</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Tvoc)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

