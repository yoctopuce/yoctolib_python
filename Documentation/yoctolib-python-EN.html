<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-x-EN.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : gray;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

hr
 { margin-top: 0;
   margin-bottom: 1px;
   border-width: 3px;
 }

img.expandColapse
 { vertical-align: middle;
 }

img.noExpand
 { visibility: hidden;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

.center
{ text-align:center;
}

.funcHeader
{ color: navy;
  text-decoration:none;
  font-size:25px;
  margin-botton:20px;
  font-weight:bold;
}

.subHeader
{ color: navy;
  text-decoration:none;
  font-size:18px;
  margin-botton:15px;
  font-weight:bold;
}

span#pn, td.pn { color: black; }
span#int, td.int { color: #000099; }
span#obj, td.obj { color: #008040; }
span#dbl, td.dbl { color: #804600; }
span#str, td.str { color: #800080; }
span#arr, td.arr { color: #800080; }
span#bool, td.bool { color: #196719; }

tt { color: #000099; }

tt a
{ text-decoration:none;
  font-weight:bold;
}

td.pn
{ vertical-align:top;
  font-weight:bold;
}

span.paramAndRet
{ font-weight:bold;
  color: navy;
}

table
{ font-size:14px; }

span.prototype
{ margin-left:10px;
  margin-right:10px;
  padding-top:5px;
  padding-bottom:5px;
  padding-left:5px;
  padding-right:5px;
  font-weight:bold;
  background-color: #f8f8f8;
  -moz-border-radius: 5px;
  -webkit-border-top-left-radius: 5px;
  -webkit-border-top-right-radius: 5px;
  -webkit-border-bottom-right-radius: 5px;
  -webkit-border-bottom-left-radius: 5px;
}

p.protolabel
{ border-top:1px  solid #f0f0f0; }

P.protoretval
{ margin-left:20px;}

.paramtable
{ margin-left:20px; margin-top:0px;}

P.protoretval
{ margin-left:20px;}

input
{ border :  1px solid gray;
  border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
}

td#langdt
{ vertical-align:bottom;
  text-align:right;
  color:#404040;
}

td#version
{ text-align:right;
  font-size:12px;
  color:gray;
}

p.methodlist
{ border-top:1px solid #e0e0e0;
  margin-left:20px;
}

a.protoindex
{ text-decoration:none;
  font-weight:bold;
  color:black;
}

span.synlist
{ margin-left:20px;
  display:block;
}

p.include
{ font-weight:bold;
  color:black;
  margin-left:20px;
}

.noicon
{ display: block; }

.property
{ display: block;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAF/SURBVDiNlZO9S0JRGMZ/99xL3C0XC/qAcuhrVISW1nBobuoPaHBzcRFviw6OTja1VktLlNHaoqIFJpJoEQ1SEBkNCXpOw7W6mt7wmc55v57zHJ5X4w+sKcAPXR/g6QXfQG8ARbCendXa7/FIh3IIRACkxlAoBXoBbrNw3AXQHc07wBqoEc0AmgZqFqbnwVuGijLsRDkELPRz7VkAzebHc6ejOrHY5fnBwfWjnZWLsLoJnBk9zQGQQ/jilhA6kcj6Ujq9tX1z09wvlZrvPYogJArC/rBRmkHKLqnU1V0+/1Td3Q2u9sv59AvAN1pzP5RCDYR8AuSkW5NpGiIa3VgOBudWMpl8dSDtMdwZ96xa7fXBNI2JcPj08Ff/N4QyQLRAeocN0LS45UYAsiWAhnuRG0RdAEXbYeNCKWiXhO1tvTD+AD0HyRdhX26zoO6d6X/0N4AL+NmFioLpMnhNUDO2SUY9W8+BdgKWhL5t/EbCC59+bIM51lnUoV2C5Iuz+gv6RYOR1pworgAAAABJRU5ErkJggg==);
  background-repeat: no-repeat;
  padding-left: 20px;
}

.method, .static
{ display: block;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAAAAAAAAPlDu38AAAAJcEhZcwAADsQAAA7EAZUrDhsAAAGnSURBVHicnVM9SytRED17tzA2+UKjSIpkK7UzYmFjKdpKFo0RsREstBDzA7YQ/QEBsTRFEBMVC0E0jWDlmg+QREQxgiiGaJHI4/Heg9x9d966EqM+1IG7zM7HmTlz50pokAg0zx8gwFFThNNJNgOocMhFDmRXoZXr418AVCTkduSHANZrgL8BNoEMgSWnyyjsJ5GsvQBQsgf5CfHjwydEArsuoRAnEEYGqmwlL5YX5nvU7o7GJLKRz+yE+9vQNUg6I87UthVoszc5givDIV+/12XZSCcb+ero9M1hqZXRwBo5n8ROD6cSwfEWxd3s8tptk+sjodzG2dFrGpJk4FeAickqje3uRFKZG/3uYnp3dGzmIBy6zdxfbs7u6W9nAYWJ6o73BrWmbqd+PP58okP6ezGiuJN9NGnOa4gOxLbokP7BbRhMfKr4pkjgVZpBEd8WdkUAWXPDviZmzu8cM3dbTn8VQIasR7H88LzKqngHnWEDkv9TjQvabrC4Bo3/uwXa6RLO40LV/0eHfAzs2Ep+9RotofWkDaMl4c/PWVSp0MCIM7VdH/8X8mKjE5TTcYYAAAAASUVORK5CYII=);
  background-repeat: no-repeat;
  padding-left: 20px;
}

.sourcecode
{ color: #666;
  background-color: #F8F8F8;
  border: 1px solid #DDD;
  text-align: left;
  border-radius: 10px;
  margin-left: 5px;
  margin-right: 5px;
  padding:10px 5px;
  font-family: 'Courier New', courier, sans-serif;
  margin-bottom: 0px;
}

P.illustration
{ text-align : center;
  font-style : italic;
  font-size  : 12px;
}
</style>
<SCRIPT type="text/JavaScript">
var WinW;
var WinH;
var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";
var marginSize=250;
var resizeCallBacks= new Array();
var doc = new Array();

//--- (generated code: Module)
var Language='Python';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var ShowIcons=false;
var MethodTypes={'static': 'Static methods', 'property':'Properties', 'method':'Methods'};
var MethodExtra={'static': 'This class should not be instantiated manually. Instead, use the static methods below to obtain objects referring to your desired devices.',
    'property':'Properties are the most effective way to interact with Yoctopuce devices. They can safely be read at any time, and will never cause any I/O delay as their value is updated automatically by a background thread.',
    'method':'Methods provide access to all features of this class. However be aware that invoking these methods may in some cases cause I/O delays and rise exceptions.'};
var sub={'YAPI_SUCCESS':'YAPI.SUCCESS','YAPI_NOT_INITIALIZED':'YAPI.NOT_INITIALIZED','YAPI_INVALID_ARGUMENT':'YAPI.INVALID_ARGUMENT','YAPI_NOT_SUPPORTED':'YAPI.NOT_SUPPORTED','YAPI_DEVICE_NOT_FOUND':'YAPI.DEVICE_NOT_FOUND','YAPI_VERSION_MISMATCH':'YAPI.VERSION_MISMATCH','YAPI_DEVICE_BUSY':'YAPI.DEVICE_BUSY','YAPI_TIMEOUT':'YAPI.TIMEOUT','YAPI_IO_ERROR':'YAPI.IO_ERROR','YAPI_NO_MORE_DATA':'YAPI.NO_MORE_DATA','YAPI_EXHAUSTED':'YAPI.EXHAUSTED','YAPI_DOUBLE_ACCES':'YAPI.DOUBLE_ACCES','YAPI_UNAUTHORIZED':'YAPI.UNAUTHORIZED','YAPI_RTC_NOT_READY':'YAPI.RTC_NOT_READY','YAPI_FILE_NOT_FOUND':'YAPI.FILE_NOT_FOUND','YAPI_SSL_ERROR':'YAPI.SSL_ERROR','YAPI_RFID_SOFT_ERROR':'YAPI.RFID_SOFT_ERROR','YAPI_RFID_HARD_ERROR':'YAPI.RFID_HARD_ERROR','YAPI_BUFFER_TOO_SMALL':'YAPI.BUFFER_TOO_SMALL','YAPI_DNS_ERROR':'YAPI.DNS_ERROR','YAPI_SSL_UNK_CERT':'YAPI.SSL_UNK_CERT','YAPI_UNCONFIGURED':'YAPI.UNCONFIGURED','null':'None','true':'True','false':'False'};
doc['Module']={'':{syn:'Global parameters control interface for all Yoctopuce devices',inc:'from yocto_api import *',cmt:'<p>The <tt>YModule</tt> class can be used with all Yoctopuce USB devices. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}
,'FindModule':{syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule.FindModule()',pro:'FindModule(<span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'}
,'FirstModule':{syn:'Starts the enumeration of modules currently accessible.',lib:'YModule.FirstModule()',pro:'FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'}
,'addFileToHTTPCallback':{syn:'Adds a file to the uploaded data at the next HTTP callback.',lib:'%.addFileToHTTPCallback()',pro:'addFileToHTTPCallback(<span id=pn>filename</span>)',cmt:'<p>Adds a file to the uploaded data at the next HTTP callback. This function only affects the next HTTP callback and only works in HTTP callback mode.</p>',par:{filename:'the name of the file to upload at the next HTTP callback'},ret:'nothing.'}
,'checkFirmware':{syn:'Tests whether the byn file is valid for this module.',lib:'%.checkFirmware()',pro:'checkFirmware(<span id=pn>path</span>, <span id=pn>onlynew</span>)',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate <tt>.byn</tt> file. If the parameter <tt>onlynew</tt> is true, the function discards firmwares that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:'the path of the byn file to use or a empty string if no byn files matches the requirement',ext:'On failure, throws an exception or returns a string that start with \x22error:\x22.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a descriptive text that identifies the module.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'}
,'download':{syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'%.download()',pro:'download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'}
,'functionBaseType':{syn:'Retrieves the base type of the <i>n</i>th function on the module.',lib:'%.functionBaseType()',pro:'functionBaseType(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the base type of the <i>n</i>th function on the module. For instance, the base type of all measuring functions is \x22Sensor\x22.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the base type of the function',ext:'On failure, throws an exception or returns an empty string.'}
,'functionCount':{syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'%.functionCount()',pro:'functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'}
,'functionId':{syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'%.functionId()',pro:'functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'}
,'functionName':{syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'%.functionName()',pro:'functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'}
,'functionType':{syn:'Retrieves the type of the <i>n</i>th function on the module.',lib:'%.functionType()',pro:'functionType(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the type of the <i>n</i>th function on the module. Yoctopuce functions type names match their class names without the <i>Y</i> prefix, for instance <i>Relay</i>, <i>Temperature</i> etc..</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the type of the function.',ext:'On failure, throws an exception or returns an empty string.'}
,'functionValue':{syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'%.functionValue()',pro:'functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'}
,'get_allSettings':{syn:'Returns all the settings and uploaded files of the module.',lib:'%.get_allSettings()',pro:'get_allSettings()',cmt:'<p>Returns all the settings and uploaded files of the module. Useful to backup all the logical names, calibrations parameters, and uploaded files of a device.</p>',ret:'a binary buffer with all the settings.',ext:'On failure, throws an exception or returns an binary object of size 0.'}
,'get_beacon':{syn:'Returns the state of the localization beacon.',lib:'%.get_beacon()',pro:'get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>YModule.BEACON_OFF</tt> or <tt>YModule.BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>YModule.BEACON_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with this module object.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occurred while using this module object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with this module object.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using this module object'}
,'get_firmwareRelease':{syn:'Returns the version of the firmware embedded in the module.',lib:'%.get_firmwareRelease()',pro:'get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>YModule.FIRMWARERELEASE_INVALID</tt>.'}
,'get_functionIds':{syn:'Retrieve all hardware identifier that match the type passed in argument.',lib:'%.get_functionIds()',pro:'get_functionIds(<span id=pn>funType</span>)',cmt:'<p>Retrieve all hardware identifier that match the type passed in argument.</p>',par:{funType:'The type of function (Relay, LightSensor, Voltage,...)'},ret:'an array of strings.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the module.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'}
,'get_icon2d':{syn:'Returns the icon of the module.',lib:'%.get_icon2d()',pro:'get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns an empty content.'}
,'get_lastLogs':{syn:'Returns a string with last logs of the module.',lib:'%.get_lastLogs()',pro:'get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the module.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>YModule.LOGICALNAME_INVALID</tt>.'}
,'get_luminosity':{syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'%.get_luminosity()',pro:'get_luminosity()',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>YModule.LUMINOSITY_INVALID</tt>.'}
,'get_parentHub':{syn:'Returns the serial number of the YoctoHub on which this module is connected.',lib:'%.get_parentHub()',pro:'get_parentHub()',cmt:'<p>Returns the serial number of the YoctoHub on which this module is connected. If the module is connected by USB, or if the module is the root YoctoHub, an empty string is returned.</p>',ret:'a string with the serial number of the YoctoHub or an empty string'}
,'get_persistentSettings':{syn:'Returns the current state of persistent module settings.',lib:'%.get_persistentSettings()',pro:'get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>YModule.PERSISTENTSETTINGS_LOADED</tt>, <tt>YModule.PERSISTENTSETTINGS_SAVED</tt> and <tt>YModule.PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>YModule.PERSISTENTSETTINGS_INVALID</tt>.'}
,'get_productId':{syn:'Returns the USB device identifier of the module.',lib:'%.get_productId()',pro:'get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>YModule.PRODUCTID_INVALID</tt>.'}
,'get_productName':{syn:'Returns the commercial name of the module, as set by the factory.',lib:'%.get_productName()',pro:'get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>YModule.PRODUCTNAME_INVALID</tt>.'}
,'get_productRelease':{syn:'Returns the release number of the module hardware, preprogrammed at the factory.',lib:'%.get_productRelease()',pro:'get_productRelease()',cmt:'<p>Returns the release number of the module hardware, preprogrammed at the factory. The original hardware release returns value 1, revision B returns value 2, etc.</p>',ret:'an integer corresponding to the release number of the module hardware, preprogrammed at the factory',ext:'On failure, throws an exception or returns <tt>YModule.PRODUCTRELEASE_INVALID</tt>.'}
,'get_rebootCountdown':{syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'%.get_rebootCountdown()',pro:'get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>YModule.REBOOTCOUNTDOWN_INVALID</tt>.'}
,'get_serialNumber':{syn:'Returns the serial number of the module, as set by the factory.',lib:'%.get_serialNumber()',pro:'get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>YModule.SERIALNUMBER_INVALID</tt>.'}
,'get_subDevices':{syn:'Returns a list of all the modules that are plugged into the current module.',lib:'%.get_subDevices()',pro:'get_subDevices()',cmt:'<p>Returns a list of all the modules that are plugged into the current module. This method only makes sense when called for a YoctoHub/VirtualHub. Otherwise, an empty array will be returned.</p>',ret:'an array of strings containing the sub modules.'}
,'get_upTime':{syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'%.get_upTime()',pro:'get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>YModule.UPTIME_INVALID</tt>.'}
,'get_url':{syn:'Returns the URL used to access the module.',lib:'%.get_url()',pro:'get_url()',cmt:'<p>Returns the URL used to access the module. If the module is connected by USB, the string \x27usb\x27 is returned.</p>',ret:'a string with the URL of the module.'}
,'get_usbCurrent':{syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'%.get_usbCurrent()',pro:'get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>YModule.USBCURRENT_INVALID</tt>.'}
,'get_userData':{syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'%.get_userData()',pro:'get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'}
,'get_userVar':{syn:'Returns the value previously stored in this attribute.',lib:'%.get_userVar()',pro:'get_userVar()',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:'On failure, throws an exception or returns <tt>YModule.USERVAR_INVALID</tt>.'}
,'hasFunction':{syn:'Tests if the device includes a specific function.',lib:'%.hasFunction()',pro:'hasFunction(<span id=pn>funcId</span>)',cmt:'<p>Tests if the device includes a specific function. This method takes a function identifier and returns a boolean.</p>',par:{funcId:'the requested function identifier'},ret:'true if the device has the function identifier'}
,'isOnline':{syn:'Checks if the module is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':{syn:'Indicates whether changes to the module are prohibited or allowed.',lib:'%.isReadOnly()',pro:'isReadOnly()',cmt:'<p>Indicates whether changes to the module are prohibited or allowed. Returns <tt>true</tt> if the module is blocked by an admin password or if the module is not available.</p>',ret:'<tt>true</tt> if the module is write-protected or not online.'}
,'load':{syn:'Preloads the module cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'log':{syn:'Adds a text message to the device logs.',lib:'%.log()',pro:'log(<span id=pn>text</span>)',cmt:'<p>Adds a text message to the device logs. This function is useful in particular to trace the execution of HTTP callbacks. If a newline is desired after the message, it must be included in the string.</p>',par:{text:'the string to append to the logs.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'nextModule':{syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'%.nextModule()',pro:'nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>. Caution: You can\x27t make any assumption about the returned modules order. \x09 If you want to find a specific module, use <tt>Module.findModule()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'}
,'reboot':{syn:'Schedules a simple module reboot after the given number of seconds.',lib:'%.reboot()',pro:'reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerBeaconCallback':{syn:'Register a callback function, to be called when the localization beacon of the module has been changed.',lib:'%.registerBeaconCallback()',pro:'registerBeaconCallback(<span id=pn>callback</span>)',cmt:'<p>Register a callback function, to be called when the localization beacon of the module has been changed. The callback function should take two arguments: the YModule object of which the beacon has changed, and an integer describing the new beacon state.</p>',par:{callback:'The callback function to call, or <tt>null</tt> to unregister a previously registered callback.'}}
,'registerConfigChangeCallback':{syn:'Register a callback function, to be called when a persistent settings in a device configuration has been changed (e.g.',lib:'%.registerConfigChangeCallback()',pro:'registerConfigChangeCallback(<span id=pn>callback</span>)',cmt:'<p>Register a callback function, to be called when a persistent settings in a device configuration has been changed (e.g. change of unit, etc).</p>',par:{callback:'a procedure taking a YModule parameter, or <tt>null</tt> to unregister a previously registered callback.'}}
,'registerLogCallback':{syn:'Registers a device log callback function.',lib:'%.registerLogCallback()',pro:'registerLogCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a device log callback function. This callback will be called each time that a module sends a new log message. Mostly useful to debug a Yoctopuce module.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the module object that emitted the log message, and the character string containing the log. On failure, throws an exception or returns a negative error code.'}}
,'revertFromFlash':{syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'%.revertFromFlash()',pro:'revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'saveToFlash':{syn:'Saves current settings in the nonvolatile memory of the module.',lib:'%.saveToFlash()',pro:'saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_allSettings':{syn:'Restores all the settings of the device.',lib:'%.set_allSettings()',pro:'set_allSettings(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_allSettingsAndFiles':{syn:'Restores all the settings and uploaded files to the module.',lib:'%.set_allSettingsAndFiles()',pro:'set_allSettingsAndFiles(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings and uploaded files to the module. This method is useful to restore all the logical names and calibrations parameters, uploaded files etc. of a device from a backup. Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_beacon':{syn:'Turns on or off the module localization beacon.',lib:'%.set_beacon()',pro:'set_beacon(<span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>YModule.BEACON_OFF</tt> or <tt>YModule.BEACON_ON</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the module.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_luminosity':{syn:'Changes the luminosity of the module informative leds.',lib:'%.set_luminosity()',pro:'set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':{syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'%.set_userData()',pro:'set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}}
,'set_userVar':{syn:'Stores a 32 bit value in the device RAM.',lib:'%.set_userVar()',pro:'set_userVar(<span id=pn>newval</span>)',cmt:'<p>Stores a 32 bit value in the device RAM. This attribute is at programmer disposal, should he need to store a state variable. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerConfigChangeCallback':{syn:'Triggers a configuration change callback, to check if they are supported or not.',lib:'%.triggerConfigChangeCallback()',pro:'triggerConfigChangeCallback()',cmt:'<p>Triggers a configuration change callback, to check if they are supported or not.</p>'}
,'triggerFirmwareUpdate':{syn:'Schedules a module reboot into special firmware update mode.',lib:'%.triggerFirmwareUpdate()',pro:'triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'updateFirmware':{syn:'Prepares a firmware update of the module.',lib:'%.updateFirmware()',pro:'updateFirmware(<span id=pn>path</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'}
,'updateFirmwareEx':{syn:'Prepares a firmware update of the module.',lib:'%.updateFirmwareEx()',pro:'updateFirmwareEx(<span id=pn>path</span>, <span id=pn>force</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.',force:'true to force the firmware update even if some prerequisites appear not to be met'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'}
};
var dm = doc.Module;
//--- (end of generated code: Module)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface.',inc:'from yocto_module import *',cmt:'<p>The <tt>YSensor</tt> class is the parent class for all Yoctopuce sensor types. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provides a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The <tt>YAnButton</tt> class is the only analog input which does not inherit from <tt>YSensor</tt>.</p>'}
,'FindSensor':{syn:'Retrieves a sensor for a given identifier.',lib:'YSensor.FindSensor()',pro:'FindSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSensor.isOnline()</tt> to test if the sensor is indeed online at a given time. In case of ambiguity when looking for a sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the sensor, for instance <tt>MyDevice.</tt>.'},ret:'a <tt>YSensor</tt> object allowing you to drive the sensor.'}
,'FirstSensor':{syn:'Starts the enumeration of sensors currently accessible.',lib:'YSensor.FirstSensor()',pro:'FirstSensor()',cmt:'<p>Starts the enumeration of sensors currently accessible. Use the method <tt>YSensor.nextSensor()</tt> to iterate on next sensors.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to the first sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':{syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'%.calibrateFromPoints()',pro:'calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YSensor.ADVMODE_IMMEDIATE</tt>, <tt>YSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YSensor.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YSensor.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YSensor.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':{syn:'Returns the <tt>YDatalogger</tt> object of the device hosting the sensor.',lib:'%.get_dataLogger()',pro:'get_dataLogger()',cmt:'<p>Returns the <tt>YDatalogger</tt> object of the device hosting the sensor. This method returns an object that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an <tt>YDatalogger</tt> object, or null on error.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':{syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'%.get_functionDescriptor()',pro:'get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y$CLASSNAME$.FUNCTIONDESCRIPTOR_INVALID</tt>.'}
,'get_functionId':{syn:'Returns the hardware identifier of the sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSensor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSensor.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YSensor.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YSensor.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:'On failure, throws an exception or returns <tt>YSensor.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YSensor.LOWESTVALUE_INVALID</tt>.'}
,'get_module':{syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'%.get_module()',pro:'get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'}
,'get_recordedData':{syn:'Retrieves a <tt>YDataSet</tt> object holding historical data for this sensor, for a specified time interval.',lib:'%.get_recordedData()',pro:'get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a <tt>YDataSet</tt> object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the <tt>YDataSet</tt> class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as <tt>YDataSet</tt> objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of <tt>YDataSet</tt>, providing access to historical data. Past measures can be loaded progressively using methods from the <tt>YDataSet</tt> object.'}
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YSensor.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YSensor.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YSensor.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':{syn:'Returns the serial number of the module, as set by the factory.',lib:'%.get_serialNumber()',pro:'get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory.',ext:'On failure, throws an exception or returns YFunction.SERIALNUMBER_INVALID.'}
,'get_unit':{syn:'Returns the measuring unit for the measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>YSensor.UNIT_INVALID</tt>.'}
,'get_userData':{syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'%.get_userData()',pro:'get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'}
,'isOnline':{syn:'Checks if the sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the sensor is currently reachable, without raising any error. If there is a cached value for the sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the sensor.</p>',ret:'<tt>true</tt> if the sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':{syn:'Indicates whether changes to the function are prohibited or allowed.',lib:'%.isReadOnly()',pro:'isReadOnly()',cmt:'<p>Indicates whether changes to the function are prohibited or allowed. Returns <tt>true</tt> if the function is blocked by an admin password or if the function is not available.</p>',ret:'<tt>true</tt> if the function is write-protected or not online.'}
,'isSensorReady':{syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'%.isSensorReady()',pro:'isSensorReady()',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'}
,'load':{syn:'Preloads the sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':{syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'%.loadAttribute()',pro:'loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'}
,'loadCalibrationPoints':{syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'%.loadCalibrationPoints()',pro:'loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':{syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'%.muteValueCallbacks()',pro:'muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'nextSensor':{syn:'Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.',lib:'%.nextSensor()',pro:'nextSensor()',cmt:'<p>Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>. Caution: You can\x27t make any assumption about the returned sensors order. If you want to find a specific a sensor, use <tt>Sensor.findSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to a sensor currently online, or a <tt>null</tt> pointer if there are no more sensors to enumerate.'}
,'registerTimedReportCallback':{syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'%.registerTimedReportCallback()',pro:'registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an <tt>YMeasure</tt> object describing the new advertised value.'}}
,'registerValueCallback':{syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'%.registerValueCallback()',pro:'registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YSensor.ADVMODE_IMMEDIATE</tt>, <tt>YSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':{syn:'Changes the recorded maximal value observed.',lib:'%.set_highestValue()',pro:'set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logFrequency':{syn:'Changes the datalogger recording frequency for this function.',lib:'%.set_logFrequency()',pro:'set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22. Note that setting the datalogger recording frequency to a greater value than the sensor native sampling frequency is useless, and even counterproductive: those two frequencies are not related. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':{syn:'Changes the recorded minimal value observed.',lib:'%.set_lowestValue()',pro:'set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':{syn:'Changes the timed value notification frequency for this function.',lib:'%.set_reportFrequency()',pro:'set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22. Note that setting the timed value notification frequency to a greater value than the sensor native sampling frequency is unless, and even counterproductive: those two frequencies are not related. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_resolution':{syn:'Changes the resolution of the measured physical values.',lib:'%.set_resolution()',pro:'set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':{syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'%.set_userData()',pro:'set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}}
,'startDataLogger':{syn:'Starts the data logger on the device.',lib:'%.startDataLogger()',pro:'startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.'}
,'stopDataLogger':{syn:'Stops the datalogger on the device.',lib:'%.stopDataLogger()',pro:'stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.'}
,'unmuteValueCallbacks':{syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'%.unmuteValueCallbacks()',pro:'unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
var ds = doc.Sensor;
//--- (end of generated code: Sensor)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer control interface, available for instance in the Yocto-3D-V2 or the Yocto-Inclinometer',inc:'from yocto_accelerometer import *',cmt:'<p>The <tt>YAccelerometer</tt> class allows you to read and configure Yoctopuce accelerometers. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the possibility to access x, y and z components of the acceleration vector separately.</p>'}
,'FindAccelerometer':{syn:'Retrieves an accelerometer for a given identifier.',lib:'YAccelerometer.FindAccelerometer()',pro:'FindAccelerometer(<span id=pn>func</span>)',cmt:'<p>Retrieves an accelerometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the accelerometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAccelerometer.isOnline()</tt> to test if the accelerometer is indeed online at a given time. In case of ambiguity when looking for an accelerometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the accelerometer, for instance <tt>Y3DMK002.accelerometer</tt>.'},ret:'a <tt>YAccelerometer</tt> object allowing you to drive the accelerometer.'}
,'FirstAccelerometer':{syn:'Starts the enumeration of accelerometers currently accessible.',lib:'YAccelerometer.FirstAccelerometer()',pro:'FirstAccelerometer()',cmt:'<p>Starts the enumeration of accelerometers currently accessible. Use the method <tt>YAccelerometer.nextAccelerometer()</tt> to iterate on next accelerometers.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to the first accelerometer currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the accelerometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the accelerometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YAccelerometer.ADVMODE_IMMEDIATE</tt>, <tt>YAccelerometer.ADVMODE_PERIOD_AVG</tt>, <tt>YAccelerometer.ADVMODE_PERIOD_MIN</tt> and <tt>YAccelerometer.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YAccelerometer.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YAccelerometer.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the measure update frequency, measured in Hz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz.</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz',ext:'On failure, throws an exception or returns <tt>YAccelerometer.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAccelerometer.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAccelerometer.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the accelerometer.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the accelerometer object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the accelerometer.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the accelerometer object'}
,'get_friendlyName':{syn:'Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the accelerometer if they are defined, otherwise the serial number of the module and the hardware identifier of the accelerometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the accelerometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAccelerometer.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the accelerometer, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the accelerometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the accelerometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAccelerometer.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the accelerometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the accelerometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAccelerometer.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>YAccelerometer.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YAccelerometer.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the accelerometer.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:'On failure, throws an exception or returns <tt>YAccelerometer.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>YAccelerometer.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YAccelerometer.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YAccelerometer.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YAccelerometer.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the acceleration.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:'On failure, throws an exception or returns <tt>YAccelerometer.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_xValue':{syn:'Returns the X component of the acceleration, as a floating point number.',lib:'%.get_xValue()',pro:'get_xValue()',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAccelerometer.XVALUE_INVALID</tt>.'}
,'get_yValue':{syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'%.get_yValue()',pro:'get_yValue()',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAccelerometer.YVALUE_INVALID</tt>.'}
,'get_zValue':{syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'%.get_zValue()',pro:'get_zValue()',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAccelerometer.ZVALUE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the accelerometer is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the accelerometer is currently reachable, without raising any error. If there is a cached value for the accelerometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the accelerometer.</p>',ret:'<tt>true</tt> if the accelerometer can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the accelerometer cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the accelerometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextAccelerometer':{syn:'Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.',lib:'%.nextAccelerometer()',pro:'nextAccelerometer()',cmt:'<p>Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>. Caution: You can\x27t make any assumption about the returned accelerometers order. If you want to find a specific an accelerometer, use <tt>Accelerometer.findAccelerometer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to an accelerometer currently online, or a <tt>null</tt> pointer if there are no more accelerometers to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YAccelerometer.ADVMODE_IMMEDIATE</tt>, <tt>YAccelerometer.ADVMODE_PERIOD_AVG</tt>, <tt>YAccelerometer.ADVMODE_PERIOD_MIN</tt> and <tt>YAccelerometer.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the measure update frequency, measured in Hz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz. When the frequency is lower, the device performs averaging. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the accelerometer.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the accelerometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Accelerometer)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altimeter control interface, available for instance in the Yocto-Altimeter-V2 or the Yocto-GPS-V2',inc:'from yocto_altitude import *',cmt:'<p>The <tt>YAltitude</tt> class allows you to read and configure Yoctopuce altimeters. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}
,'FindAltitude':{syn:'Retrieves an altimeter for a given identifier.',lib:'YAltitude.FindAltitude()',pro:'FindAltitude(<span id=pn>func</span>)',cmt:'<p>Retrieves an altimeter for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the altimeter is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAltitude.isOnline()</tt> to test if the altimeter is indeed online at a given time. In case of ambiguity when looking for an altimeter by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the altimeter, for instance <tt>YALTIMK2.altitude</tt>.'},ret:'a <tt>YAltitude</tt> object allowing you to drive the altimeter.'}
,'FirstAltitude':{syn:'Starts the enumeration of altimeters currently accessible.',lib:'YAltitude.FirstAltitude()',pro:'FirstAltitude()',cmt:'<p>Starts the enumeration of altimeters currently accessible. Use the method <tt>YAltitude.nextAltitude()</tt> to iterate on next altimeters.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to the first altimeter currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the altimeter attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the altimeter (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YAltitude.ADVMODE_IMMEDIATE</tt>, <tt>YAltitude.ADVMODE_PERIOD_AVG</tt>, <tt>YAltitude.ADVMODE_PERIOD_MIN</tt> and <tt>YAltitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YAltitude.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YAltitude.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAltitude.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>YAltitude.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the altimeter.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the altimeter object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the altimeter.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the altimeter object'}
,'get_friendlyName':{syn:'Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the altimeter if they are defined, otherwise the serial number of the module and the hardware identifier of the altimeter (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the altimeter using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAltitude.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the altimeter, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the altimeter, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the altimeter (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAltitude.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the altimeter (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the altimeter (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAltitude.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>YAltitude.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YAltitude.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the altimeter.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:'On failure, throws an exception or returns <tt>YAltitude.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>YAltitude.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_qnh':{syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'%.get_qnh()',pro:'get_qnh()',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH). Applicable to barometric altimeters only.</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:'On failure, throws an exception or returns <tt>YAltitude.QNH_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YAltitude.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YAltitude.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YAltitude.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_technology':{syn:'Returns the technology used by the sesnor to compute altitude.',lib:'%.get_technology()',pro:'get_technology()',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:'On failure, throws an exception or returns <tt>YAltitude.TECHNOLOGY_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the altitude.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:'On failure, throws an exception or returns <tt>YAltitude.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the altimeter is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the altimeter is currently reachable, without raising any error. If there is a cached value for the altimeter in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the altimeter.</p>',ret:'<tt>true</tt> if the altimeter can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the altimeter cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the altimeter cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextAltitude':{syn:'Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.',lib:'%.nextAltitude()',pro:'nextAltitude()',cmt:'<p>Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>. Caution: You can\x27t make any assumption about the returned altimeters order. If you want to find a specific an altimeter, use <tt>Altitude.findAltitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to an altimeter currently online, or a <tt>null</tt> pointer if there are no more altimeters to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YAltitude.ADVMODE_IMMEDIATE</tt>, <tt>YAltitude.ADVMODE_PERIOD_AVG</tt>, <tt>YAltitude.ADVMODE_PERIOD_MIN</tt> and <tt>YAltitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentValue':{syn:'Changes the current estimated altitude.',lib:'%.set_currentValue()',pro:'set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current estimated altitude. This allows one to compensate for ambient pressure variations and to work in relative mode. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the altimeter.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the altimeter. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_qnh':{syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'%.set_qnh()',pro:'set_qnh(<span id=pn>newval</span>)',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions. Applicable to barometric altimeters only. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Altitude)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'Analog input control interface, available for instance in the Yocto-Buzzer, the Yocto-Knob, the Yocto-MaxiBuzzer or the Yocto-MaxiDisplay',inc:'from yocto_anbutton import *',cmt:'<p>The <tt>YAnButton</tt> class provide access to basic resistive inputs. Such inputs can be used to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}
,'FindAnButton':{syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton.FindAnButton()',pro:'FindAnButton(<span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the analog input, for instance <tt>YBUZZER2.anButton1</tt>.'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'}
,'FirstAnButton':{syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton.FirstAnButton()',pro:'FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the analog input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the analog input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YAnButton.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_analogCalibration':{syn:'Tells if a calibration process is currently ongoing.',lib:'%.get_analogCalibration()',pro:'get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>YAnButton.ANALOGCALIBRATION_OFF</tt> or <tt>YAnButton.ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>YAnButton.ANALOGCALIBRATION_INVALID</tt>.'}
,'get_calibratedValue':{syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'%.get_calibratedValue()',pro:'get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>YAnButton.CALIBRATEDVALUE_INVALID</tt>.'}
,'get_calibrationMax':{syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'%.get_calibrationMax()',pro:'get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>YAnButton.CALIBRATIONMAX_INVALID</tt>.'}
,'get_calibrationMin':{syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'%.get_calibrationMin()',pro:'get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>YAnButton.CALIBRATIONMIN_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the analog input.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the analog input object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the analog input.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the analog input object'}
,'get_friendlyName':{syn:'Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the analog input if they are defined, otherwise the serial number of the module and the hardware identifier of the analog input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the analog input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAnButton.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the analog input, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the analog input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the analog input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAnButton.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the analog input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the analog input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAnButton.HARDWAREID_INVALID</tt>.'}
,'get_inputType':{syn:'Returns the decoding method applied to the input (analog or multiplexed binary switches).',lib:'%.get_inputType()',pro:'get_inputType()',cmt:'<p>Returns the decoding method applied to the input (analog or multiplexed binary switches).</p>',ret:'a value among <tt>YAnButton.INPUTTYPE_ANALOG_FAST</tt>, <tt>YAnButton.INPUTTYPE_DIGITAL4</tt>, <tt>YAnButton.INPUTTYPE_ANALOG_SMOOTH</tt> and <tt>YAnButton.INPUTTYPE_DIGITAL_FAST</tt> corresponding to the decoding method applied to the input (analog or multiplexed binary switches)',ext:'On failure, throws an exception or returns <tt>YAnButton.INPUTTYPE_INVALID</tt>.'}
,'get_isPressed':{syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'%.get_isPressed()',pro:'get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>YAnButton.ISPRESSED_FALSE</tt> or <tt>YAnButton.ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>YAnButton.ISPRESSED_INVALID</tt>.'}
,'get_lastTimePressed':{syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'%.get_lastTimePressed()',pro:'get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:'On failure, throws an exception or returns <tt>YAnButton.LASTTIMEPRESSED_INVALID</tt>.'}
,'get_lastTimeReleased':{syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'%.get_lastTimeReleased()',pro:'get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:'On failure, throws an exception or returns <tt>YAnButton.LASTTIMERELEASED_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the analog input.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:'On failure, throws an exception or returns <tt>YAnButton.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_pulseCounter':{syn:'Returns the pulse counter value.',lib:'%.get_pulseCounter()',pro:'get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>YAnButton.PULSECOUNTER_INVALID</tt>.'}
,'get_pulseTimer':{syn:'Returns the timer of the pulses counter (ms).',lib:'%.get_pulseTimer()',pro:'get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>YAnButton.PULSETIMER_INVALID</tt>.'}
,'get_rawValue':{syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'%.get_rawValue()',pro:'get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>YAnButton.RAWVALUE_INVALID</tt>.'}
,'get_sensitivity':{syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'%.get_sensitivity()',pro:'get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>YAnButton.SENSITIVITY_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the analog input is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the analog input is currently reachable, without raising any error. If there is a cached value for the analog input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the analog input.</p>',ret:'<tt>true</tt> if the analog input can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the analog input cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the analog input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextAnButton':{syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'%.nextAnButton()',pro:'nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>. Caution: You can\x27t make any assumption about the returned analog inputs order. If you want to find a specific an analog input, use <tt>AnButton.findAnButton()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'resetCounter':{syn:'Returns the pulse counter value as well as its timer.',lib:'%.resetCounter()',pro:'resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_analogCalibration':{syn:'Starts or stops the calibration process.',lib:'%.set_analogCalibration()',pro:'set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>YAnButton.ANALOGCALIBRATION_OFF</tt> or <tt>YAnButton.ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_calibrationMax':{syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'%.set_calibrationMax()',pro:'set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_calibrationMin':{syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'%.set_calibrationMin()',pro:'set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_inputType':{syn:'Changes the decoding method applied to the input (analog or multiplexed binary switches).',lib:'%.set_inputType()',pro:'set_inputType(<span id=pn>newval</span>)',cmt:'<p>Changes the decoding method applied to the input (analog or multiplexed binary switches). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YAnButton.INPUTTYPE_ANALOG_FAST</tt>, <tt>YAnButton.INPUTTYPE_DIGITAL4</tt>, <tt>YAnButton.INPUTTYPE_ANALOG_SMOOTH</tt> and <tt>YAnButton.INPUTTYPE_DIGITAL_FAST</tt> corresponding to the decoding method applied to the input (analog or multiplexed binary switches)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the analog input.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_sensitivity':{syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'%.set_sensitivity()',pro:'set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: AnButton)
//--- (generated code: ArithmeticSensor)
doc['ArithmeticSensor']={'':{syn:'Arithmetic sensor control interface, available for instance in the Yocto-MaxiMicroVolt-Rx',inc:'from yocto_arithmeticsensor import *',cmt:'<p>The <tt>YArithmeticSensor</tt> class allows some Yoctopuce devices to compute in real-time values based on an arithmetic formula involving one or more measured signals as well as the temperature. As for any physical sensor, the computed values can be read by callback and stored in the built-in datalogger.</p>'}
,'FindArithmeticSensor':{syn:'Retrieves an arithmetic sensor for a given identifier.',lib:'YArithmeticSensor.FindArithmeticSensor()',pro:'FindArithmeticSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves an arithmetic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the arithmetic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YArithmeticSensor.isOnline()</tt> to test if the arithmetic sensor is indeed online at a given time. In case of ambiguity when looking for an arithmetic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the arithmetic sensor, for instance <tt>RXUVOLT1.arithmeticSensor1</tt>.'},ret:'a <tt>YArithmeticSensor</tt> object allowing you to drive the arithmetic sensor.'}
,'FirstArithmeticSensor':{syn:'Starts the enumeration of arithmetic sensors currently accessible.',lib:'YArithmeticSensor.FirstArithmeticSensor()',pro:'FirstArithmeticSensor()',cmt:'<p>Starts the enumeration of arithmetic sensors currently accessible. Use the method <tt>YArithmeticSensor.nextArithmeticSensor()</tt> to iterate on next arithmetic sensors.</p>',ret:'a pointer to a <tt>YArithmeticSensor</tt> object, corresponding to the first arithmetic sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the arithmetic sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'defineAuxiliaryFunction':{syn:'Defines a auxiliary function by means of a table of reference points.',lib:'%.defineAuxiliaryFunction()',pro:'defineAuxiliaryFunction(<span id=pn>name</span>, <span id=pn>inputValues</span>, <span id=pn>outputValues</span>)',cmt:'<p>Defines a auxiliary function by means of a table of reference points. Intermediate values will be interpolated between specified reference points. The reference points are given as pairs of floating point numbers. The auxiliary function will be available for use by all ArithmeticSensor objects of the device. Up to nine auxiliary function can be defined in a device, each containing up to 96 reference points.</p>',par:{name:'auxiliary function name, up to 16 characters.',inputValues:'array of floating point numbers, corresponding to the function input value.',outputValues:'array of floating point numbers, corresponding to the output value desired for each of the input value, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'defineExpression':{syn:'Defines the arithmetic function by means of an algebraic expression.',lib:'%.defineExpression()',pro:'defineExpression(<span id=pn>expr</span>, <span id=pn>descr</span>)',cmt:'<p>Defines the arithmetic function by means of an algebraic expression. The expression may include references to device sensors, by their physical or logical name, to usual math functions and to auxiliary functions defined separately.</p>',par:{expr:'the algebraic expression defining the function.',descr:'short informative description of the expression.'},ret:'the current expression value if the call succeeds.',ext:'On failure, throws an exception or returns YAPI_INVALID_DOUBLE.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the arithmetic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the arithmetic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the arithmetic sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YArithmeticSensor.ADVMODE_IMMEDIATE</tt>, <tt>YArithmeticSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YArithmeticSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YArithmeticSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the arithmetic sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the arithmetic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the arithmetic sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_description':{syn:'Returns a short informative description of the formula.',lib:'%.get_description()',pro:'get_description()',cmt:'<p>Returns a short informative description of the formula.</p>',ret:'a string corresponding to a short informative description of the formula',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.DESCRIPTION_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the arithmetic sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the arithmetic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the arithmetic sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the arithmetic sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the arithmetic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the arithmetic sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the arithmetic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the arithmetic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the arithmetic sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the arithmetic sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the arithmetic sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the arithmetic sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the arithmetic sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the arithmetic sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the arithmetic sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the arithmetic sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the arithmetic sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the arithmetic sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the arithmetic sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the arithmetic sensor.</p>',ret:'a string corresponding to the logical name of the arithmetic sensor.',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>YArithmeticSensor.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the arithmetic sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the arithmetic sensor is currently reachable, without raising any error. If there is a cached value for the arithmetic sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the arithmetic sensor.</p>',ret:'<tt>true</tt> if the arithmetic sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the arithmetic sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the arithmetic sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadAuxiliaryFunction':{syn:'Retrieves the reference points table defining an auxiliary function previously configured using the <tt>defineAuxiliaryFunction</tt> function.',lib:'%.loadAuxiliaryFunction()',pro:'loadAuxiliaryFunction(<span id=pn>name</span>, <span id=pn>inputValues</span>, <span id=pn>outputValues</span>)',cmt:'<p>Retrieves the reference points table defining an auxiliary function previously configured using the <tt>defineAuxiliaryFunction</tt> function.</p>',par:{name:'auxiliary function name, up to 16 characters.',inputValues:'array of floating point numbers, that is filled by the function with all the function reference input value.',outputValues:'array of floating point numbers, that is filled by the function output value for each of the input value, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'loadExpression':{syn:'Retrieves the algebraic expression defining the arithmetic function, as previously configured using the <tt>defineExpression</tt> function.',lib:'%.loadExpression()',pro:'loadExpression()',cmt:'<p>Retrieves the algebraic expression defining the arithmetic function, as previously configured using the <tt>defineExpression</tt> function.</p>',ret:'a string containing the mathematical expression.',ext:'On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextArithmeticSensor':{syn:'Continues the enumeration of arithmetic sensors started using <tt>yFirstArithmeticSensor()</tt>.',lib:'%.nextArithmeticSensor()',pro:'nextArithmeticSensor()',cmt:'<p>Continues the enumeration of arithmetic sensors started using <tt>yFirstArithmeticSensor()</tt>. Caution: You can\x27t make any assumption about the returned arithmetic sensors order. If you want to find a specific an arithmetic sensor, use <tt>ArithmeticSensor.findArithmeticSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YArithmeticSensor</tt> object, corresponding to an arithmetic sensor currently online, or a <tt>null</tt> pointer if there are no more arithmetic sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YArithmeticSensor.ADVMODE_IMMEDIATE</tt>, <tt>YArithmeticSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YArithmeticSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YArithmeticSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the arithmetic sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the arithmetic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the arithmetic sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_unit':{syn:'Changes the measuring unit for the arithmetic sensor.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the arithmetic sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the arithmetic sensor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: ArithmeticSensor)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'Audio input control interface',inc:'from yocto_audioin import *',cmt:'<p>The <tt>YAudioIn</tt> class allows you to configure the volume of an audio input.</p>'}
,'FindAudioIn':{syn:'Retrieves an audio input for a given identifier.',lib:'YAudioIn.FindAudioIn()',pro:'FindAudioIn(<span id=pn>func</span>)',cmt:'<p>Retrieves an audio input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioIn.isOnline()</tt> to test if the audio input is indeed online at a given time. In case of ambiguity when looking for an audio input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio input, for instance <tt>MyDevice.audioIn1</tt>.'},ret:'a <tt>YAudioIn</tt> object allowing you to drive the audio input.'}
,'FirstAudioIn':{syn:'Starts the enumeration of audio inputs currently accessible.',lib:'YAudioIn.FirstAudioIn()',pro:'FirstAudioIn()',cmt:'<p>Starts the enumeration of audio inputs currently accessible. Use the method <tt>YAudioIn.nextAudioIn()</tt> to iterate on next audio inputs.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to the first audio input currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the audio input (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the audio input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YAudioIn.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the audio input.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio input object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the audio input.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio input object'}
,'get_friendlyName':{syn:'Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio input if they are defined, otherwise the serial number of the module and the hardware identifier of the audio input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioIn.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the audio input, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the audio input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioIn.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioIn.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the audio input.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the audio input.</p>',ret:'a string corresponding to the logical name of the audio input.',ext:'On failure, throws an exception or returns <tt>YAudioIn.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_mute':{syn:'Returns the state of the mute function.',lib:'%.get_mute()',pro:'get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>YAudioIn.MUTE_FALSE</tt> or <tt>YAudioIn.MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>YAudioIn.MUTE_INVALID</tt>.'}
,'get_noSignalFor':{syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'%.get_noSignalFor()',pro:'get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>YAudioIn.NOSIGNALFOR_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signal':{syn:'Returns the detected input signal level.',lib:'%.get_signal()',pro:'get_signal()',cmt:'<p>Returns the detected input signal level.</p>',ret:'an integer corresponding to the detected input signal level',ext:'On failure, throws an exception or returns <tt>YAudioIn.SIGNAL_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_volume':{syn:'Returns audio input gain, in per cents.',lib:'%.get_volume()',pro:'get_volume()',cmt:'<p>Returns audio input gain, in per cents.</p>',ret:'an integer corresponding to audio input gain, in per cents',ext:'On failure, throws an exception or returns <tt>YAudioIn.VOLUME_INVALID</tt>.'}
,'get_volumeRange':{syn:'Returns the supported volume range.',lib:'%.get_volumeRange()',pro:'get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>YAudioIn.VOLUMERANGE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the audio input is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the audio input is currently reachable, without raising any error. If there is a cached value for the audio input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio input.</p>',ret:'<tt>true</tt> if the audio input can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the audio input cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextAudioIn':{syn:'Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>.',lib:'%.nextAudioIn()',pro:'nextAudioIn()',cmt:'<p>Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>. Caution: You can\x27t make any assumption about the returned audio inputs order. If you want to find a specific an audio input, use <tt>AudioIn.findAudioIn()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to an audio input currently online, or a <tt>null</tt> pointer if there are no more audio inputs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the audio input.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio input.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_mute':{syn:'Changes the state of the mute function.',lib:'%.set_mute()',pro:'set_mute(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>YAudioIn.MUTE_FALSE</tt> or <tt>YAudioIn.MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_volume':{syn:'Changes audio input gain, in per cents.',lib:'%.set_volume()',pro:'set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes audio input gain, in per cents. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to audio input gain, in per cents'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: AudioIn)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'Audio output control interface',inc:'from yocto_audioout import *',cmt:'<p>The <tt>YAudioOut</tt> class allows you to configure the volume of an audio output.</p>'}
,'FindAudioOut':{syn:'Retrieves an audio output for a given identifier.',lib:'YAudioOut.FindAudioOut()',pro:'FindAudioOut(<span id=pn>func</span>)',cmt:'<p>Retrieves an audio output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioOut.isOnline()</tt> to test if the audio output is indeed online at a given time. In case of ambiguity when looking for an audio output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio output, for instance <tt>MyDevice.audioOut1</tt>.'},ret:'a <tt>YAudioOut</tt> object allowing you to drive the audio output.'}
,'FirstAudioOut':{syn:'Starts the enumeration of audio outputs currently accessible.',lib:'YAudioOut.FirstAudioOut()',pro:'FirstAudioOut()',cmt:'<p>Starts the enumeration of audio outputs currently accessible. Use the method <tt>YAudioOut.nextAudioOut()</tt> to iterate on next audio outputs.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to the first audio output currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the audio output (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the audio output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YAudioOut.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the audio output.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio output object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the audio output.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio output object'}
,'get_friendlyName':{syn:'Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio output if they are defined, otherwise the serial number of the module and the hardware identifier of the audio output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioOut.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the audio output, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the audio output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioOut.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YAudioOut.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the audio output.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the audio output.</p>',ret:'a string corresponding to the logical name of the audio output.',ext:'On failure, throws an exception or returns <tt>YAudioOut.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_mute':{syn:'Returns the state of the mute function.',lib:'%.get_mute()',pro:'get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>YAudioOut.MUTE_FALSE</tt> or <tt>YAudioOut.MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>YAudioOut.MUTE_INVALID</tt>.'}
,'get_noSignalFor':{syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'%.get_noSignalFor()',pro:'get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>YAudioOut.NOSIGNALFOR_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signal':{syn:'Returns the detected output current level.',lib:'%.get_signal()',pro:'get_signal()',cmt:'<p>Returns the detected output current level.</p>',ret:'an integer corresponding to the detected output current level',ext:'On failure, throws an exception or returns <tt>YAudioOut.SIGNAL_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_volume':{syn:'Returns audio output volume, in per cents.',lib:'%.get_volume()',pro:'get_volume()',cmt:'<p>Returns audio output volume, in per cents.</p>',ret:'an integer corresponding to audio output volume, in per cents',ext:'On failure, throws an exception or returns <tt>YAudioOut.VOLUME_INVALID</tt>.'}
,'get_volumeRange':{syn:'Returns the supported volume range.',lib:'%.get_volumeRange()',pro:'get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>YAudioOut.VOLUMERANGE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the audio output is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the audio output is currently reachable, without raising any error. If there is a cached value for the audio output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio output.</p>',ret:'<tt>true</tt> if the audio output can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the audio output cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextAudioOut':{syn:'Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>.',lib:'%.nextAudioOut()',pro:'nextAudioOut()',cmt:'<p>Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>. Caution: You can\x27t make any assumption about the returned audio outputs order. If you want to find a specific an audio output, use <tt>AudioOut.findAudioOut()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to an audio output currently online, or a <tt>null</tt> pointer if there are no more audio outputs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the audio output.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio output.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_mute':{syn:'Changes the state of the mute function.',lib:'%.set_mute()',pro:'set_mute(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>YAudioOut.MUTE_FALSE</tt> or <tt>YAudioOut.MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_volume':{syn:'Changes audio output volume, in per cents.',lib:'%.set_volume()',pro:'set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes audio output volume, in per cents. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to audio output volume, in per cents'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: AudioOut)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer control interface, available for instance in the Yocto-Buzzer, the Yocto-MaxiBuzzer or the Yocto-MaxiKnob',inc:'from yocto_buzzer import *',cmt:'<p>The <tt>YBuzzer</tt> class allows you to drive a buzzer. You can choose the frequency and the volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}
,'FindBuzzer':{syn:'Retrieves a buzzer for a given identifier.',lib:'YBuzzer.FindBuzzer()',pro:'FindBuzzer(<span id=pn>func</span>)',cmt:'<p>Retrieves a buzzer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the buzzer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBuzzer.isOnline()</tt> to test if the buzzer is indeed online at a given time. In case of ambiguity when looking for a buzzer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the buzzer, for instance <tt>YBUZZER2.buzzer</tt>.'},ret:'a <tt>YBuzzer</tt> object allowing you to drive the buzzer.'}
,'FirstBuzzer':{syn:'Starts the enumeration of buzzers currently accessible.',lib:'YBuzzer.FirstBuzzer()',pro:'FirstBuzzer()',cmt:'<p>Starts the enumeration of buzzers currently accessible. Use the method <tt>YBuzzer.nextBuzzer()</tt> to iterate on next buzzers.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to the first buzzer currently online, or a <tt>null</tt> pointer if there are none.'}
,'addFreqMoveToPlaySeq':{syn:'Adds a new frequency transition to the playing sequence.',lib:'%.addFreqMoveToPlaySeq()',pro:'addFreqMoveToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDelay</span>)',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'addNotesToPlaySeq':{syn:'Adds notes to the playing sequence.',lib:'%.addNotesToPlaySeq()',pro:'addNotesToPlaySeq(<span id=pn>notes</span>)',cmt:'<p>Adds notes to the playing sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'addPulseToPlaySeq':{syn:'Adds a pulse to the playing sequence.',lib:'%.addPulseToPlaySeq()',pro:'addPulseToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'addVolMoveToPlaySeq':{syn:'Adds a new volume transition to the playing sequence.',lib:'%.addVolMoveToPlaySeq()',pro:'addVolMoveToPlaySeq(<span id=pn>volume</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the buzzer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the buzzer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'freqMove':{syn:'Makes the buzzer frequency change over a period of time.',lib:'%.freqMove()',pro:'freqMove(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YBuzzer.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the buzzer.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the buzzer object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the buzzer.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the buzzer object'}
,'get_frequency':{syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'%.get_frequency()',pro:'get_frequency()',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>YBuzzer.FREQUENCY_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the buzzer if they are defined, otherwise the serial number of the module and the hardware identifier of the buzzer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the buzzer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YBuzzer.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the buzzer, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the buzzer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the buzzer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YBuzzer.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the buzzer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the buzzer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YBuzzer.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the buzzer.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:'On failure, throws an exception or returns <tt>YBuzzer.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_playSeqMaxSize':{syn:'Returns the maximum length of the playing sequence.',lib:'%.get_playSeqMaxSize()',pro:'get_playSeqMaxSize()',cmt:'<p>Returns the maximum length of the playing sequence.</p>',ret:'an integer corresponding to the maximum length of the playing sequence',ext:'On failure, throws an exception or returns <tt>YBuzzer.PLAYSEQMAXSIZE_INVALID</tt>.'}
,'get_playSeqSignature':{syn:'Returns the playing sequence signature.',lib:'%.get_playSeqSignature()',pro:'get_playSeqSignature()',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:'On failure, throws an exception or returns <tt>YBuzzer.PLAYSEQSIGNATURE_INVALID</tt>.'}
,'get_playSeqSize':{syn:'Returns the current length of the playing sequence.',lib:'%.get_playSeqSize()',pro:'get_playSeqSize()',cmt:'<p>Returns the current length of the playing sequence.</p>',ret:'an integer corresponding to the current length of the playing sequence',ext:'On failure, throws an exception or returns <tt>YBuzzer.PLAYSEQSIZE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_volume':{syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'%.get_volume()',pro:'get_volume()',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>YBuzzer.VOLUME_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the buzzer is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the buzzer is currently reachable, without raising any error. If there is a cached value for the buzzer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the buzzer.</p>',ret:'<tt>true</tt> if the buzzer can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the buzzer cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the buzzer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextBuzzer':{syn:'Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.',lib:'%.nextBuzzer()',pro:'nextBuzzer()',cmt:'<p>Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>. Caution: You can\x27t make any assumption about the returned buzzers order. If you want to find a specific a buzzer, use <tt>Buzzer.findBuzzer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to a buzzer currently online, or a <tt>null</tt> pointer if there are no more buzzers to enumerate.'}
,'oncePlaySeq':{syn:'Starts the preprogrammed playing sequence and run it once only.',lib:'%.oncePlaySeq()',pro:'oncePlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence and run it once only.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'playNotes':{syn:'Immediately play a note sequence.',lib:'%.playNotes()',pro:'playNotes(<span id=pn>notes</span>)',cmt:'<p>Immediately play a note sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'pulse':{syn:'Activates the buzzer for a short duration.',lib:'%.pulse()',pro:'pulse(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'reloadPlaySeq':{syn:'Reloads the preprogrammed playing sequence from the flash memory.',lib:'%.reloadPlaySeq()',pro:'reloadPlaySeq()',cmt:'<p>Reloads the preprogrammed playing sequence from the flash memory.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'resetPlaySeq':{syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'%.resetPlaySeq()',pro:'resetPlaySeq()',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'savePlaySeq':{syn:'Saves the preprogrammed playing sequence to flash memory.',lib:'%.savePlaySeq()',pro:'savePlaySeq()',cmt:'<p>Saves the preprogrammed playing sequence to flash memory.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'set_frequency':{syn:'Changes the frequency of the signal sent to the buzzer.',lib:'%.set_frequency()',pro:'set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the buzzer.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the buzzer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_volume':{syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'%.set_volume()',pro:'set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'startPlaySeq':{syn:'Starts the preprogrammed playing sequence.',lib:'%.startPlaySeq()',pro:'startPlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change. To play the sequence only once, use <tt>oncePlaySeq()</tt>.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'stopPlaySeq':{syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'%.stopPlaySeq()',pro:'stopPlaySeq()',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'volumeMove':{syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'%.volumeMove()',pro:'volumeMove(<span id=pn>volume</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Buzzer)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CO2 sensor control interface, available for instance in the Yocto-CO2-V2',inc:'from yocto_carbondioxide import *',cmt:'<p>The <tt>YCarbonDioxide</tt> class allows you to read and configure Yoctopuce CO2 sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to perform manual calibration if required.</p>'}
,'FindCarbonDioxide':{syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor, for instance <tt>YCO2MK02.carbonDioxide</tt>.'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'}
,'FirstCarbonDioxide':{syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the CO2 sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the CO2 sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_abcPeriod':{syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'%.get_abcPeriod()',pro:'get_abcPeriod()',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.ABCPERIOD_INVALID</tt>.'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YCarbonDioxide.ADVMODE_IMMEDIATE</tt>, <tt>YCarbonDioxide.ADVMODE_PERIOD_AVG</tt>, <tt>YCarbonDioxide.ADVMODE_PERIOD_MIN</tt> and <tt>YCarbonDioxide.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the CO2 sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the CO2 sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the CO2 sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the CO2 sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the CO2 sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the CO2 sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the CO2 sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the CO2 sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the CO2 sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the CO2 sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the CO2 sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the CO2 sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the CO2 sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the CO2 concentration.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:'On failure, throws an exception or returns <tt>YCarbonDioxide.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the CO2 sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the CO2 sensor is currently reachable, without raising any error. If there is a cached value for the CO2 sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the CO2 sensor.</p>',ret:'<tt>true</tt> if the CO2 sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the CO2 sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the CO2 sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextCarbonDioxide':{syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'%.nextCarbonDioxide()',pro:'nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>. Caution: You can\x27t make any assumption about the returned CO2 sensors order. If you want to find a specific a CO2 sensor, use <tt>CarbonDioxide.findCarbonDioxide()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_abcPeriod':{syn:'Changes Automatic Baseline Calibration period, in hours.',lib:'%.set_abcPeriod()',pro:'set_abcPeriod(<span id=pn>newval</span>)',cmt:'<p>Changes Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400 ppm CO2), set the period to -1. For the Yocto-CO2-V2, the only possible values are 24 and -1. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to Automatic Baseline Calibration period, in hours'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YCarbonDioxide.ADVMODE_IMMEDIATE</tt>, <tt>YCarbonDioxide.ADVMODE_PERIOD_AVG</tt>, <tt>YCarbonDioxide.ADVMODE_PERIOD_MIN</tt> and <tt>YCarbonDioxide.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the CO2 sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'triggerBaselineCalibration':{syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'%.triggerBaselineCalibration()',pro:'triggerBaselineCalibration()',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if automatic baseline calibration is disabled, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400 ppm for at least two minutes.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerForcedCalibration':{syn:'Triggers a forced calibration of the sensor at a given CO2 level, specified between 400ppm and 2000ppm.',lib:'%.triggerForcedCalibration()',pro:'triggerForcedCalibration(<span id=pn>refVal</span>)',cmt:'<p>Triggers a forced calibration of the sensor at a given CO2 level, specified between 400ppm and 2000ppm. Before invoking this command, the sensor must have been maintained within the specified CO2 density during at least two minutes.</p>',par:{refVal:'reference CO2 density for the calibration'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerZeroCalibration':{syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air - for use with first generation Yocto-CO2 only.',lib:'%.triggerZeroCalibration()',pro:'triggerZeroCalibration()',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air - for use with first generation Yocto-CO2 only. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: CellRecord)
doc['CellRecord']={'':{syn:'Cellular antenna description, returned by <tt>cellular.quickCellSurvey</tt> method',inc:'from yocto_cellular import *',cmt:'<p><tt>YCellRecord</tt> objects are used to describe a wireless network. These objects are used in particular in conjunction with the <tt>YCellular</tt> class.</p>'}
,'get_cellId':{syn:'Returns the Cell ID.',lib:'%.get_cellId()',pro:'get_cellId()',cmt:'<p>Returns the Cell ID. The Cell ID is a unique identifier for each base transmission station within a LAC.</p>',ret:'an integer corresponding to the Cell Id.'}
,'get_cellOperator':{syn:'Returns the name of the the cell operator, as received from the network.',lib:'%.get_cellOperator()',pro:'get_cellOperator()',cmt:'<p>Returns the name of the the cell operator, as received from the network.</p>',ret:'a string with the name of the the cell operator.'}
,'get_locationAreaCode':{syn:'Returns the Location Area Code (LAC).',lib:'%.get_locationAreaCode()',pro:'get_locationAreaCode()',cmt:'<p>Returns the Location Area Code (LAC). The LAC is a unique identifier for each place within a country.</p>',ret:'an integer corresponding to the Location Area Code (LAC).'}
,'get_mobileCountryCode':{syn:'Returns the Mobile Country Code (MCC).',lib:'%.get_mobileCountryCode()',pro:'get_mobileCountryCode()',cmt:'<p>Returns the Mobile Country Code (MCC). The MCC is a unique identifier for each country.</p>',ret:'an integer corresponding to the Mobile Country Code (MCC).'}
,'get_mobileNetworkCode':{syn:'Returns the Mobile Network Code (MNC).',lib:'%.get_mobileNetworkCode()',pro:'get_mobileNetworkCode()',cmt:'<p>Returns the Mobile Network Code (MNC). The MNC is a unique identifier for each phone operator within a country.</p>',ret:'an integer corresponding to the Mobile Network Code (MNC).'}
,'get_signalStrength':{syn:'Returns the signal strength, measured in dBm.',lib:'%.get_signalStrength()',pro:'get_signalStrength()',cmt:'<p>Returns the signal strength, measured in dBm.</p>',ret:'an integer corresponding to the signal strength.'}
,'get_timingAdvance':{syn:'Returns the Timing Advance (TA).',lib:'%.get_timingAdvance()',pro:'get_timingAdvance()',cmt:'<p>Returns the Timing Advance (TA). The TA corresponds to the time necessary for the signal to reach the base station from the device. Each increment corresponds about to 550m of distance.</p>',ret:'an integer corresponding to the Timing Advance (TA).'}
};
//--- (end of generated code: CellRecord)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular interface control interface, available for instance in the YoctoHub-GSM-2G, the YoctoHub-GSM-3G-EU, the YoctoHub-GSM-3G-NA or the YoctoHub-GSM-4G',inc:'from yocto_cellular import *',cmt:'<p>The <tt>YCellular</tt> class provides control over cellular network parameters and status for devices that are GSM-enabled. Note that TCP/IP parameters are configured separately, using class <tt>YNetwork</tt>.</p>'}
,'FindCellular':{syn:'Retrieves a cellular interface for a given identifier.',lib:'YCellular.FindCellular()',pro:'FindCellular(<span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCellular.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the cellular interface, for instance <tt>YHUBGSM1.cellular</tt>.'},ret:'a <tt>YCellular</tt> object allowing you to drive the cellular interface.'}
,'FirstCellular':{syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YCellular.FirstCellular()',pro:'FirstCellular()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YCellular.nextCellular()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'}
,'_AT':{syn:'Sends an AT command to the GSM module and returns the command output.',lib:'%._AT()',pro:'_AT(<span id=pn>cmd</span>)',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the cellular interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'clearDataCounters':{syn:'Clear the transmitted data counters.',lib:'%.clearDataCounters()',pro:'clearDataCounters()',cmt:'<p>Clear the transmitted data counters.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'decodePLMN':{syn:'Returns the cell operator brand for a given MCC/MNC pair (DEPRECATED).',lib:'%.decodePLMN()',pro:'decodePLMN(<span id=pn>mccmnc</span>)',cmt:'<p>Returns the cell operator brand for a given MCC/MNC pair (DEPRECATED).</p>',par:{mccmnc:'a string starting with a MCC code followed by a MNC code,'},ret:'a string containing the corresponding cell operator brand name.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YCellular.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_airplaneMode':{syn:'Returns true if the airplane mode is active (radio turned off).',lib:'%.get_airplaneMode()',pro:'get_airplaneMode()',cmt:'<p>Returns true if the airplane mode is active (radio turned off).</p>',ret:'either <tt>YCellular.AIRPLANEMODE_OFF</tt> or <tt>YCellular.AIRPLANEMODE_ON</tt>, according to true if the airplane mode is active (radio turned off)',ext:'On failure, throws an exception or returns <tt>YCellular.AIRPLANEMODE_INVALID</tt>.'}
,'get_apn':{syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'%.get_apn()',pro:'get_apn()',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:'On failure, throws an exception or returns <tt>YCellular.APN_INVALID</tt>.'}
,'get_apnSecret':{syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'%.get_apnSecret()',pro:'get_apnSecret()',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>YCellular.APNSECRET_INVALID</tt>.'}
,'get_availableOperators':{syn:'Returns the list detected cell operators in the neighborhood.',lib:'%.get_availableOperators()',pro:'get_availableOperators()',cmt:'<p>Returns the list detected cell operators in the neighborhood. This function will typically take between 30 seconds to 1 minute to return. Note that any SIM card can usually only connect to specific operators. All networks returned by this function might therefore not be available for connection.</p>',ret:'a list of string (cell operator names).'}
,'get_cellIdentifier':{syn:'Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.',lib:'%.get_cellIdentifier()',pro:'get_cellIdentifier()',cmt:'<p>Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.</p>',ret:'a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID',ext:'On failure, throws an exception or returns <tt>YCellular.CELLIDENTIFIER_INVALID</tt>.'}
,'get_cellOperator':{syn:'Returns the name of the cell operator currently in use.',lib:'%.get_cellOperator()',pro:'get_cellOperator()',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:'On failure, throws an exception or returns <tt>YCellular.CELLOPERATOR_INVALID</tt>.'}
,'get_cellType':{syn:'Active cellular connection type.',lib:'%.get_cellType()',pro:'get_cellType()',cmt:'<p>Active cellular connection type.</p>',ret:'a value among <tt>YCellular.CELLTYPE_GPRS</tt>, <tt>YCellular.CELLTYPE_EGPRS</tt>, <tt>YCellular.CELLTYPE_WCDMA</tt>, <tt>YCellular.CELLTYPE_HSDPA</tt>, <tt>YCellular.CELLTYPE_NONE</tt>, <tt>YCellular.CELLTYPE_CDMA</tt>, <tt>YCellular.CELLTYPE_LTE_M</tt>, <tt>YCellular.CELLTYPE_NB_IOT</tt> and <tt>YCellular.CELLTYPE_EC_GSM_IOT</tt>',ext:'On failure, throws an exception or returns <tt>YCellular.CELLTYPE_INVALID</tt>.'}
,'get_communicationProfiles':{syn:'Returns the list available radio communication profiles, as a string array (YoctoHub-GSM-4G only).',lib:'%.get_communicationProfiles()',pro:'get_communicationProfiles()',cmt:'<p>Returns the list available radio communication profiles, as a string array (YoctoHub-GSM-4G only). Each string is a made of a numerical ID, followed by a colon, followed by the profile description.</p>',ret:'a list of string describing available radio communication profiles.'}
,'get_dataReceived':{syn:'Returns the number of bytes received so far.',lib:'%.get_dataReceived()',pro:'get_dataReceived()',cmt:'<p>Returns the number of bytes received so far.</p>',ret:'an integer corresponding to the number of bytes received so far',ext:'On failure, throws an exception or returns <tt>YCellular.DATARECEIVED_INVALID</tt>.'}
,'get_dataSent':{syn:'Returns the number of bytes sent so far.',lib:'%.get_dataSent()',pro:'get_dataSent()',cmt:'<p>Returns the number of bytes sent so far.</p>',ret:'an integer corresponding to the number of bytes sent so far',ext:'On failure, throws an exception or returns <tt>YCellular.DATASENT_INVALID</tt>.'}
,'get_enableData':{syn:'Returns the condition for enabling IP data services (GPRS).',lib:'%.get_enableData()',pro:'get_enableData()',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>YCellular.ENABLEDATA_HOMENETWORK</tt>, <tt>YCellular.ENABLEDATA_ROAMING</tt>, <tt>YCellular.ENABLEDATA_NEVER</tt> and <tt>YCellular.ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:'On failure, throws an exception or returns <tt>YCellular.ENABLEDATA_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the cellular interface.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'}
,'get_friendlyName':{syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCellular.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCellular.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCellular.HARDWAREID_INVALID</tt>.'}
,'get_imsi':{syn:'Returns the International Mobile Subscriber Identity (MSI) that uniquely identifies the SIM card.',lib:'%.get_imsi()',pro:'get_imsi()',cmt:'<p>Returns the International Mobile Subscriber Identity (MSI) that uniquely identifies the SIM card. The first 3 digits represent the mobile country code (MCC), which is followed by the mobile network code (MNC), either 2-digit (European standard) or 3-digit (North American standard)</p>',ret:'a string corresponding to the International Mobile Subscriber Identity (MSI) that uniquely identifies the SIM card',ext:'On failure, throws an exception or returns <tt>YCellular.IMSI_INVALID</tt>.'}
,'get_linkQuality':{syn:'Returns the link quality, expressed in percent.',lib:'%.get_linkQuality()',pro:'get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>YCellular.LINKQUALITY_INVALID</tt>.'}
,'get_lockedOperator':{syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'%.get_lockedOperator()',pro:'get_lockedOperator()',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:'On failure, throws an exception or returns <tt>YCellular.LOCKEDOPERATOR_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the cellular interface.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>YCellular.LOGICALNAME_INVALID</tt>.'}
,'get_message':{syn:'Returns the latest status message from the wireless interface.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>YCellular.MESSAGE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_pin':{syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'%.get_pin()',pro:'get_pin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>YCellular.PIN_INVALID</tt>.'}
,'get_pingInterval':{syn:'Returns the automated connectivity check interval, in seconds.',lib:'%.get_pingInterval()',pro:'get_pingInterval()',cmt:'<p>Returns the automated connectivity check interval, in seconds.</p>',ret:'an integer corresponding to the automated connectivity check interval, in seconds',ext:'On failure, throws an exception or returns <tt>YCellular.PINGINTERVAL_INVALID</tt>.'}
,'get_radioConfig':{syn:'Returns the type of protocol used over the serial line, as a string.',lib:'%.get_radioConfig()',pro:'get_radioConfig()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>YCellular.RADIOCONFIG_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextCellular':{syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.',lib:'%.nextCellular()',pro:'nextCellular()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>. Caution: You can\x27t make any assumption about the returned cellular interfaces order. If you want to find a specific a cellular interface, use <tt>Cellular.findCellular()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'}
,'quickCellSurvey':{syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'%.quickCellSurvey()',pro:'quickCellSurvey()',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighbor cells reported by the serving cell.</p>',ret:'a list of <tt>YCellRecords</tt>.'}
,'registerValueCallback':ds.registerValueCallback
,'sendPUK':{syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and set up a new PIN into the SIM card.',lib:'%.sendPUK()',pro:'sendPUK(<span id=pn>puk</span>, <span id=pn>newPin</span>)',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and set up a new PIN into the SIM card. Only ten consecutive tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_airplaneMode':{syn:'Changes the activation state of airplane mode (radio turned off).',lib:'%.set_airplaneMode()',pro:'set_airplaneMode(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of airplane mode (radio turned off).</p>',par:{newval:'either <tt>YCellular.AIRPLANEMODE_OFF</tt> or <tt>YCellular.AIRPLANEMODE_ON</tt>, according to the activation state of airplane mode (radio turned off)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_apn':{syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'%.set_apn()',pro:'set_apn(<span id=pn>newval</span>)',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_apnAuth':{syn:'Configure authentication parameters to connect to the APN.',lib:'%.set_apnAuth()',pro:'set_apnAuth(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_dataReceived':{syn:'Changes the value of the incoming data counter.',lib:'%.set_dataReceived()',pro:'set_dataReceived(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming data counter.</p>',par:{newval:'an integer corresponding to the value of the incoming data counter'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_dataSent':{syn:'Changes the value of the outgoing data counter.',lib:'%.set_dataSent()',pro:'set_dataSent(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing data counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing data counter'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enableData':{syn:'Changes the condition for enabling IP data services (GPRS).',lib:'%.set_enableData()',pro:'set_enableData(<span id=pn>newval</span>)',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs !</p><p> When data services are disabled, SMS are the only mean of communication. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YCellular.ENABLEDATA_HOMENETWORK</tt>, <tt>YCellular.ENABLEDATA_ROAMING</tt>, <tt>YCellular.ENABLEDATA_NEVER</tt> and <tt>YCellular.ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lockedOperator':{syn:'Changes the name of the cell operator to be used.',lib:'%.set_lockedOperator()',pro:'set_lockedOperator(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the cellular interface.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pin':{syn:'Changes the PIN code used by the module to access the SIM card.',lib:'%.set_pin()',pro:'set_pin(<span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pingInterval':{syn:'Changes the automated connectivity check interval, in seconds.',lib:'%.set_pingInterval()',pro:'set_pingInterval(<span id=pn>newval</span>)',cmt:'<p>Changes the automated connectivity check interval, in seconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the automated connectivity check interval, in seconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_radioConfig':{syn:'Changes the type of protocol used over the serial line.',lib:'%.set_radioConfig()',pro:'set_radioConfig(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Cellular)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'RGB LED control interface, available for instance in the Yocto-Color-V2, the Yocto-MaxiBuzzer or the Yocto-PowerColor',inc:'from yocto_colorled import *',cmt:'<p>The <tt>ColorLed</tt> class allows you to drive a color LED. The color can be specified using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}
,'FindColorLed':{syn:'Retrieves an RGB LED for a given identifier.',lib:'YColorLed.FindColorLed()',pro:'FindColorLed(<span id=pn>func</span>)',cmt:'<p>Retrieves an RGB LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB LED is indeed online at a given time. In case of ambiguity when looking for an RGB LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED, for instance <tt>YRGBLED2.colorLed1</tt>.'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB LED.'}
,'FirstColorLed':{syn:'Starts the enumeration of RGB LEDs currently accessible.',lib:'YColorLed.FirstColorLed()',pro:'FirstColorLed()',cmt:'<p>Starts the enumeration of RGB LEDs currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB LEDs.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB LED currently online, or a <tt>null</tt> pointer if there are none.'}
,'addHslMoveToBlinkSeq':{syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'%.addHslMoveToBlinkSeq()',pro:'addHslMoveToBlinkSeq(<span id=pn>HSLcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'addRgbMoveToBlinkSeq':{syn:'Adds a new transition to the blinking sequence, the move is performed in the RGB space.',lib:'%.addRgbMoveToBlinkSeq()',pro:'addRgbMoveToBlinkSeq(<span id=pn>RGBcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Adds a new transition to the blinking sequence, the move is performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the RGB LED (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YColorLed.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_blinkSeqMaxSize':{syn:'Returns the maximum length of the blinking sequence.',lib:'%.get_blinkSeqMaxSize()',pro:'get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of the blinking sequence.</p>',ret:'an integer corresponding to the maximum length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>YColorLed.BLINKSEQMAXSIZE_INVALID</tt>.'}
,'get_blinkSeqSignature':{syn:'Returns the blinking sequence signature.',lib:'%.get_blinkSeqSignature()',pro:'get_blinkSeqSignature()',cmt:'<p>Returns the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer corresponding to the blinking sequence signature',ext:'On failure, throws an exception or returns <tt>YColorLed.BLINKSEQSIGNATURE_INVALID</tt>.'}
,'get_blinkSeqSize':{syn:'Returns the current length of the blinking sequence.',lib:'%.get_blinkSeqSize()',pro:'get_blinkSeqSize()',cmt:'<p>Returns the current length of the blinking sequence.</p>',ret:'an integer corresponding to the current length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>YColorLed.BLINKSEQSIZE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the RGB LED.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the RGB LED.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED object'}
,'get_friendlyName':{syn:'Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLed.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the RGB LED, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLed.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLed.HARDWAREID_INVALID</tt>.'}
,'get_hslColor':{syn:'Returns the current HSL color of the LED.',lib:'%.get_hslColor()',pro:'get_hslColor()',cmt:'<p>Returns the current HSL color of the LED.</p>',ret:'an integer corresponding to the current HSL color of the LED',ext:'On failure, throws an exception or returns <tt>YColorLed.HSLCOLOR_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the RGB LED.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED.</p>',ret:'a string corresponding to the logical name of the RGB LED.',ext:'On failure, throws an exception or returns <tt>YColorLed.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_rgbColor':{syn:'Returns the current RGB color of the LED.',lib:'%.get_rgbColor()',pro:'get_rgbColor()',cmt:'<p>Returns the current RGB color of the LED.</p>',ret:'an integer corresponding to the current RGB color of the LED',ext:'On failure, throws an exception or returns <tt>YColorLed.RGBCOLOR_INVALID</tt>.'}
,'get_rgbColorAtPowerOn':{syn:'Returns the configured color to be displayed when the module is turned on.',lib:'%.get_rgbColorAtPowerOn()',pro:'get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>YColorLed.RGBCOLORATPOWERON_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'hslMove':{syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'%.hslMove()',pro:'hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'isOnline':{syn:'Checks if the RGB LED is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the RGB LED is currently reachable, without raising any error. If there is a cached value for the RGB LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED.</p>',ret:'<tt>true</tt> if the RGB LED can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the RGB LED cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextColorLed':{syn:'Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>.',lib:'%.nextColorLed()',pro:'nextColorLed()',cmt:'<p>Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>. Caution: You can\x27t make any assumption about the returned RGB LEDs order. If you want to find a specific an RGB LED, use <tt>ColorLed.findColorLed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB LED currently online, or a <tt>null</tt> pointer if there are no more RGB LEDs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'resetBlinkSeq':{syn:'Resets the preprogrammed blinking sequence.',lib:'%.resetBlinkSeq()',pro:'resetBlinkSeq()',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'rgbMove':{syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'%.rgbMove()',pro:'rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'saveLedsConfigAtPowerOn':{syn:'Saves the LEDs power-on configuration.',lib:'%.saveLedsConfigAtPowerOn()',pro:'saveLedsConfigAtPowerOn()',cmt:'<p>Saves the LEDs power-on configuration. Warning: this method is not supported by Yocto-Color (version 1) and Yocto-PowerColor modules. For these devices, the <tt>saveToFlash()</tt> method of the module must be used instead.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'set_hslColor':{syn:'Changes the current color of the LED, using a specific HSL color.',lib:'%.set_hslColor()',pro:'set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using a specific HSL color. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the LED, using a specific HSL color'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the RGB LED.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColor':{syn:'Changes the current color of the LED, using an RGB color.',lib:'%.set_rgbColor()',pro:'set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the LED, using an RGB color'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColorAtPowerOn':{syn:'Changes the color that the LED displays by default when the module is turned on.',lib:'%.set_rgbColorAtPowerOn()',pro:'set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the color that the LED displays by default when the module is turned on. Remember to call the <tt>saveLedsConfigAtPowerOn()</tt> method of the module if the modification must be kept. Note: for the original modules Yocto-Color (version 1) et Yocto-PowerColor, the <tt>saveToFlash()</tt> method must be used instead.</p>',par:{newval:'an integer corresponding to the color that the LED displays by default when the module is turned on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startBlinkSeq':{syn:'Starts the preprogrammed blinking sequence.',lib:'%.startBlinkSeq()',pro:'startBlinkSeq()',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence is run in a loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'stopBlinkSeq':{syn:'Stops the preprogrammed blinking sequence.',lib:'%.stopBlinkSeq()',pro:'stopBlinkSeq()',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: ColorLed)
//--- (generated code: ColorLedCluster)
doc['ColorLedCluster']={'':{syn:'RGB LED cluster control interface, available for instance in the Yocto-Color-V2, the Yocto-MaxiBuzzer or the Yocto-MaxiKnob',inc:'from yocto_colorledcluster import *',cmt:'<p>The <tt>YColorLedCluster</tt> class allows you to drive a color LED cluster. Unlike the <tt>ColorLed</tt> class, the <tt>YColorLedCluster</tt> class allows to handle several LEDs at once. Color changes can be done using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}
,'FindColorLedCluster':{syn:'Retrieves a RGB LED cluster for a given identifier.',lib:'YColorLedCluster.FindColorLedCluster()',pro:'FindColorLedCluster(<span id=pn>func</span>)',cmt:'<p>Retrieves a RGB LED cluster for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED cluster is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLedCluster.isOnline()</tt> to test if the RGB LED cluster is indeed online at a given time. In case of ambiguity when looking for a RGB LED cluster by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED cluster, for instance <tt>YRGBLED2.colorLedCluster</tt>.'},ret:'a <tt>YColorLedCluster</tt> object allowing you to drive the RGB LED cluster.'}
,'FirstColorLedCluster':{syn:'Starts the enumeration of RGB LED clusters currently accessible.',lib:'YColorLedCluster.FirstColorLedCluster()',pro:'FirstColorLedCluster()',cmt:'<p>Starts the enumeration of RGB LED clusters currently accessible. Use the method <tt>YColorLedCluster.nextColorLedCluster()</tt> to iterate on next RGB LED clusters.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to the first RGB LED cluster currently online, or a <tt>null</tt> pointer if there are none.'}
,'addHslMoveToBlinkSeq':{syn:'Adds an HSL transition to a sequence.',lib:'%.addHslMoveToBlinkSeq()',pro:'addHslMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Adds an HSL transition to a sequence. A sequence is a transition list, which can be executed in loop by an group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',hslValue:'target color (0xHHSSLL)',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'addJumpToBlinkSeq':{syn:'Adds to a sequence a jump to another sequence.',lib:'%.addJumpToBlinkSeq()',pro:'addJumpToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>linkSeqIndex</span>)',cmt:'<p>Adds to a sequence a jump to another sequence. When a pixel will reach this jump, it will be automatically relinked to the new sequence, and will run it starting from the beginning.</p>',par:{seqIndex:'sequence index.',linkSeqIndex:'index of the sequence to chain.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'addMirrorToBlinkSeq':{syn:'Adds a mirror ending to a sequence.',lib:'%.addMirrorToBlinkSeq()',pro:'addMirrorToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Adds a mirror ending to a sequence. When the sequence will reach the end of the last transition, its running speed will automatically be reversed so that the sequence plays in the reverse direction, like in a mirror. After the first transition of the sequence is played at the end of the reverse execution, the sequence starts again in the initial direction.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'addRgbMoveToBlinkSeq':{syn:'Adds an RGB transition to a sequence.',lib:'%.addRgbMoveToBlinkSeq()',pro:'addRgbMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Adds an RGB transition to a sequence. A sequence is a transition list, which can be executed in loop by a group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',rgbValue:'target color (0xRRGGBB)',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'addUnlinkToBlinkSeq':{syn:'Adds a to a sequence a hard stop code.',lib:'%.addUnlinkToBlinkSeq()',pro:'addUnlinkToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Adds a to a sequence a hard stop code. When a pixel will reach this stop code, instead of restarting the sequence in a loop it will automatically be unlinked from the sequence.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED cluster attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED cluster (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_activeLedCount':{syn:'Returns the number of LEDs currently handled by the device.',lib:'%.get_activeLedCount()',pro:'get_activeLedCount()',cmt:'<p>Returns the number of LEDs currently handled by the device.</p>',ret:'an integer corresponding to the number of LEDs currently handled by the device',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.ACTIVELEDCOUNT_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the RGB LED cluster (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED cluster (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED cluster (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_blinkSeqMaxCount':{syn:'Returns the maximum number of sequences that the device can handle.',lib:'%.get_blinkSeqMaxCount()',pro:'get_blinkSeqMaxCount()',cmt:'<p>Returns the maximum number of sequences that the device can handle.</p>',ret:'an integer corresponding to the maximum number of sequences that the device can handle',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.BLINKSEQMAXCOUNT_INVALID</tt>.'}
,'get_blinkSeqMaxSize':{syn:'Returns the maximum length of sequences.',lib:'%.get_blinkSeqMaxSize()',pro:'get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of sequences.</p>',ret:'an integer corresponding to the maximum length of sequences',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.BLINKSEQMAXSIZE_INVALID</tt>.'}
,'get_blinkSeqSignatures':{syn:'Returns a list on 32 bit signatures for specified blinking sequences.',lib:'%.get_blinkSeqSignatures()',pro:'get_blinkSeqSignatures(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 32 bit signatures for specified blinking sequences. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of 32 bit integer signatures',ext:'On failure, throws an exception or returns an empty array.'}
,'get_blinkSeqState':{syn:'Returns a list of integers with the started state for specified blinking sequences.',lib:'%.get_blinkSeqState()',pro:'get_blinkSeqState(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the started state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'}
,'get_blinkSeqStateAtPowerOn':{syn:'Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.',lib:'%.get_blinkSeqStateAtPowerOn()',pro:'get_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'}
,'get_blinkSeqStateSpeed':{syn:'Returns a list of integers with the current speed for specified blinking sequences.',lib:'%.get_blinkSeqStateSpeed()',pro:'get_blinkSeqStateSpeed(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the current speed for specified blinking sequences.</p>',par:{seqIndex:'index of the first sequence speed which should be returned',count:'number of sequence speeds which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'}
,'get_dynamicLedCount':{syn:'Returns the maximum number of LEDs that can perform autonomous transitions and sequences.',lib:'%.get_dynamicLedCount()',pro:'get_dynamicLedCount()',cmt:'<p>Returns the maximum number of LEDs that can perform autonomous transitions and sequences.</p>',ret:'an integer corresponding to the maximum number of LEDs that can perform autonomous transitions and sequences',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.DYNAMICLEDCOUNT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the RGB LED cluster.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED cluster object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the RGB LED cluster.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED cluster object'}
,'get_friendlyName':{syn:'Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED cluster if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED cluster (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED cluster using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the RGB LED cluster, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED cluster, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED cluster (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED cluster (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED cluster (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.HARDWAREID_INVALID</tt>.'}
,'get_ledType':{syn:'Returns the RGB LED type currently handled by the device.',lib:'%.get_ledType()',pro:'get_ledType()',cmt:'<p>Returns the RGB LED type currently handled by the device.</p>',ret:'a value among <tt>YColorLedCluster.LEDTYPE_RGB</tt>, <tt>YColorLedCluster.LEDTYPE_RGBW</tt> and <tt>YColorLedCluster.LEDTYPE_WS2811</tt> corresponding to the RGB LED type currently handled by the device',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.LEDTYPE_INVALID</tt>.'}
,'get_linkedSeqArray':{syn:'Returns a list on sequence index for each RGB LED.',lib:'%.get_linkedSeqArray()',pro:'get_linkedSeqArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on sequence index for each RGB LED. The first number represents the sequence index for the the first LED, the second number represents the sequence index for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of integers with sequence index',ext:'On failure, throws an exception or returns an empty array.'}
,'get_logicalName':{syn:'Returns the logical name of the RGB LED cluster.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED cluster.</p>',ret:'a string corresponding to the logical name of the RGB LED cluster.',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.LOGICALNAME_INVALID</tt>.'}
,'get_maxLedCount':{syn:'Returns the maximum number of LEDs that the device can handle.',lib:'%.get_maxLedCount()',pro:'get_maxLedCount()',cmt:'<p>Returns the maximum number of LEDs that the device can handle.</p>',ret:'an integer corresponding to the maximum number of LEDs that the device can handle',ext:'On failure, throws an exception or returns <tt>YColorLedCluster.MAXLEDCOUNT_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_rgbColorArray':{syn:'Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs.',lib:'%.get_rgbColorArray()',pro:'get_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs. The first number represents the RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'}
,'get_rgbColorArrayAtPowerOn':{syn:'Returns a list on 24bit RGB color values with the RGB LEDs startup colors.',lib:'%.get_rgbColorArrayAtPowerOn()',pro:'get_rgbColorArrayAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the RGB LEDs startup colors. The first number represents the startup RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'}
,'get_rgbColorBuffer':{syn:'Returns a binary buffer with content from the LED RGB buffer, as is.',lib:'%.get_rgbColorBuffer()',pro:'get_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a binary buffer with content from the LED RGB buffer, as is. First three bytes are RGB components for the first LED in the interval, the next three bytes for the second LED in the interval, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a binary buffer with RGB components of selected LEDs.',ext:'On failure, throws an exception or returns an empty binary buffer.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'hslArrayOfs_move':{syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'%.hslArrayOfs_move()',pro:'hslArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'hslArray_move':{syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'%.hslArray_move()',pro:'hslArray_move(<span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'hsl_move':{syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'%.hsl_move()',pro:'hsl_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular value (0..360 deg). There are always two paths to perform the transition: by increasing or by decreasing the hue. The module selects the shortest transition. If the difference is exactly 180 deg, the module selects the transition which increases the hue.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color (0xHHSSLL).',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'isOnline':{syn:'Checks if the RGB LED cluster is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the RGB LED cluster is currently reachable, without raising any error. If there is a cached value for the RGB LED cluster in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED cluster.</p>',ret:'<tt>true</tt> if the RGB LED cluster can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'linkLedToBlinkSeq':{syn:'Links adjacent LEDs to a specific sequence.',lib:'%.linkLedToBlinkSeq()',pro:'linkLedToBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LEDs start to execute the sequence as soon as startBlinkSeq is called. It is possible to add an offset in the execution: that way we can have several groups of LED executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'linkLedToBlinkSeqAtPowerOn':{syn:'Links adjacent LEDs to a specific sequence at device power-on.',lib:'%.linkLedToBlinkSeqAtPowerOn()',pro:'linkLedToBlinkSeqAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence at device power-on. Don\x27t forget to configure the sequence auto start flag as well and call <tt>saveLedsConfigAtPowerOn()</tt>. It is possible to add an offset in the execution: that way we can have several groups of LEDs executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'linkLedToPeriodicBlinkSeq':{syn:'Links adjacent LEDs to a specific sequence.',lib:'%.linkLedToPeriodicBlinkSeq()',pro:'linkLedToPeriodicBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>periods</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LED start to execute the sequence as soon as startBlinkSeq is called. This function automatically introduces a shift between LEDs so that the specified number of sequence periods appears on the group of LEDs (wave effect).</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',periods:'number of periods to show on LEDs.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'load':{syn:'Preloads the RGB LED cluster cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cluster cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextColorLedCluster':{syn:'Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>.',lib:'%.nextColorLedCluster()',pro:'nextColorLedCluster()',cmt:'<p>Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>. Caution: You can\x27t make any assumption about the returned RGB LED clusters order. If you want to find a specific a RGB LED cluster, use <tt>ColorLedCluster.findColorLedCluster()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to a RGB LED cluster currently online, or a <tt>null</tt> pointer if there are no more RGB LED clusters to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'resetBlinkSeq':{syn:'Stops a sequence execution and resets its contents.',lib:'%.resetBlinkSeq()',pro:'resetBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution and resets its contents. LEDs linked to this sequence are not automatically updated anymore.</p>',par:{seqIndex:'index of the sequence to reset'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'rgbArrayOfs_move':{syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'%.rgbArrayOfs_move()',pro:'rgbArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'rgbArray_move':{syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'%.rgbArray_move()',pro:'rgbArray_move(<span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'rgb_move':{syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'%.rgb_move()',pro:'rgb_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the RGB space.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color (0xRRGGBB).',delay:'transition duration in ms'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'saveBlinkSeq':{syn:'Saves the definition of a sequence.',lib:'%.saveBlinkSeq()',pro:'saveBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Saves the definition of a sequence. Warning: only sequence steps and flags are saved. to save the LEDs startup bindings, the method <tt>saveLedsConfigAtPowerOn()</tt> must be called.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'saveLedsConfigAtPowerOn':{syn:'Saves the LEDs power-on configuration.',lib:'%.saveLedsConfigAtPowerOn()',pro:'saveLedsConfigAtPowerOn()',cmt:'<p>Saves the LEDs power-on configuration. This includes the start-up color or sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the method <tt>saveBlinkSeq()</tt> must also be called to save the sequence definition.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_activeLedCount':{syn:'Changes the number of LEDs currently handled by the device.',lib:'%.set_activeLedCount()',pro:'set_activeLedCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of LEDs currently handled by the device. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'an integer corresponding to the number of LEDs currently handled by the device'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_blinkSeqSpeed':{syn:'Changes the execution speed of a sequence.',lib:'%.set_blinkSeqSpeed()',pro:'set_blinkSeqSpeed(<span id=pn>seqIndex</span>, <span id=pn>speed</span>)',cmt:'<p>Changes the execution speed of a sequence. The natural execution speed is 1000 per thousand. If you configure a slower speed, you can play the sequence in slow-motion. If you set a negative speed, you can play the sequence in reverse direction.</p>',par:{seqIndex:'index of the sequence to start.',speed:'sequence running speed (-1000...1000).'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_blinkSeqStateAtPowerOn':{syn:'Configures a sequence to make it start automatically at device startup.',lib:'%.set_blinkSeqStateAtPowerOn()',pro:'set_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>autostart</span>)',cmt:'<p>Configures a sequence to make it start automatically at device startup. Note that a sequence with a zero duration can\x27t be started. Don\x27t forget to call <tt>saveBlinkSeq()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{seqIndex:'index of the sequence to reset.',autostart:'0 to keep the sequence turned off and 1 to start it automatically.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_hslColor':{syn:'Changes the current color of consecutive LEDs in the cluster, using a HSL color.',lib:'%.set_hslColor()',pro:'set_hslColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_hslColorArray':{syn:'Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.',lib:'%.set_hslColorArray()',pro:'set_hslColorArray(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>)',cmt:'<p>Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is. The first number represents the HSL value of the LED specified as parameter, the second number represents the HSL value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of 24bit HSL codes, in the form 0xHHSSLL'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_hslColorAtPowerOn':{syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color.',lib:'%.set_hslColorAtPowerOn()',pro:'set_hslColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_hslColorBuffer':{syn:'Sends a binary buffer to the LED HSL buffer, as is.',lib:'%.set_hslColorBuffer()',pro:'set_hslColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED HSL buffer, as is. First three bytes are HSL components for the LED specified as parameter, the next three bytes for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_ledType':{syn:'Changes the RGB LED type currently handled by the device.',lib:'%.set_ledType()',pro:'set_ledType(<span id=pn>newval</span>)',cmt:'<p>Changes the RGB LED type currently handled by the device. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'a value among <tt>YColorLedCluster.LEDTYPE_RGB</tt>, <tt>YColorLedCluster.LEDTYPE_RGBW</tt> and <tt>YColorLedCluster.LEDTYPE_WS2811</tt> corresponding to the RGB LED type currently handled by the device'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the RGB LED cluster.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED cluster. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED cluster.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColor':{syn:'Changes the current color of consecutive LEDs in the cluster, using a RGB color.',lib:'%.set_rgbColor()',pro:'set_rgbColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColorArray':{syn:'Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.',lib:'%.set_rgbColorArray()',pro:'set_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>)',cmt:'<p>Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is. The first number represents the RGB value of the LED specified as parameter, the second number represents the RGB value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of 24bit RGB codes, in the form 0xRRGGBB'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColorAtPowerOn':{syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color.',lib:'%.set_rgbColorAtPowerOn()',pro:'set_rgbColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_rgbColorBuffer':{syn:'Sends a binary buffer to the LED RGB buffer, as is.',lib:'%.set_rgbColorBuffer()',pro:'set_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED RGB buffer, as is. First three bytes are RGB components for LED specified as parameter, the next three bytes for the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startBlinkSeq':{syn:'Starts a sequence execution: every LED linked to that sequence starts to run it in a loop.',lib:'%.startBlinkSeq()',pro:'startBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Starts a sequence execution: every LED linked to that sequence starts to run it in a loop. Note that a sequence with a zero duration can\x27t be started.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'stopBlinkSeq':{syn:'Stops a sequence execution.',lib:'%.stopBlinkSeq()',pro:'stopBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution. If started again, the execution restarts from the beginning.</p>',par:{seqIndex:'index of the sequence to stop.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unlinkLedFromBlinkSeq':{syn:'Unlinks adjacent LEDs from a sequence.',lib:'%.unlinkLedFromBlinkSeq()',pro:'unlinkLedFromBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Unlinks adjacent LEDs from a sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: ColorLedCluster)
//--- (generated code: ColorSensor)
doc['ColorSensor']={'':{syn:'Color sensor control interface',inc:'from yocto_colorsensor import *',cmt:'<p>The <tt>YColorSensor</tt> class allows you to read and configure Yoctopuce color sensors.</p>'}
,'FindColorSensor':{syn:'Retrieves a color sensor for a given identifier.',lib:'YColorSensor.FindColorSensor()',pro:'FindColorSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a color sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the color sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorSensor.isOnline()</tt> to test if the color sensor is indeed online at a given time. In case of ambiguity when looking for a color sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the color sensor, for instance <tt>MyDevice.colorSensor</tt>.'},ret:'a <tt>YColorSensor</tt> object allowing you to drive the color sensor.'}
,'FirstColorSensor':{syn:'Starts the enumeration of color sensors currently accessible.',lib:'YColorSensor.FirstColorSensor()',pro:'FirstColorSensor()',cmt:'<p>Starts the enumeration of color sensors currently accessible. Use the method <tt>YColorSensor.nextColorSensor()</tt> to iterate on next color sensors.</p>',ret:'a pointer to a <tt>YColorSensor</tt> object, corresponding to the first color sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the color sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'configureAutoGain':{syn:'Changes the sensor automatic gain control settings.',lib:'%.configureAutoGain()',pro:'configureAutoGain(<span id=pn>channel</span>, <span id=pn>minRaw</span>, <span id=pn>maxRaw</span>, <span id=pn>noSatur</span>)',cmt:'<p>Changes the sensor automatic gain control settings. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{channel:'reference channel to use for automated gain control.',minRaw:'lower threshold for the measured raw value, below which the gain is automatically increased as long as possible.',maxRaw:'high threshold for the measured raw value, over which the gain is automatically decreased as long as possible.',noSatur:'enables gain reduction in case of sensor saturation.'},ret:'<tt>YAPI.SUCCESS</tt> if the operation completes successfully. On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the color sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the color sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the color sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the color sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the color sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the color sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YColorSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_autoGain':{syn:'Returns the current autogain parameters of the sensor as a character string.',lib:'%.get_autoGain()',pro:'get_autoGain()',cmt:'<p>Returns the current autogain parameters of the sensor as a character string. The returned parameter format is: \x22Min &lt; Channel &lt; Max:Saturation\x22.</p>',ret:'a string corresponding to the current autogain parameters of the sensor as a character string',ext:'On failure, throws an exception or returns <tt>YColorSensor.AUTOGAIN_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the color sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the color sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the color sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the color sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the color sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the color sensor object'}
,'get_estimatedHSL':{syn:'Returns the estimated color in HSL color model (0xHHSSLL).',lib:'%.get_estimatedHSL()',pro:'get_estimatedHSL()',cmt:'<p>Returns the estimated color in HSL color model (0xHHSSLL). The HSL color model describes each color using a combination of 3 components:<ul> <li>Hue (H): the angle on the color wheel (0-360 degrees), mapped to 0...255</li> <li>Saturation (S): the intensity of the color (0-100%), mapped to 0...255</li> <li>Lightness (L): the brightness of the color (0-100%), mapped to 0...255</li></ul></p>',ret:'an integer corresponding to the estimated color in HSL color model (0xHHSSLL)',ext:'On failure, throws an exception or returns <tt>YColorSensor.ESTIMATEDHSL_INVALID</tt>.'}
,'get_estimatedOkLab':{syn:'Returns the estimated color according to the OkLab color model.',lib:'%.get_estimatedOkLab()',pro:'get_estimatedOkLab()',cmt:'<p>Returns the estimated color according to the OkLab color model. OkLab is a perceptual color model that aims to align human color perception with numerical values, so that colors that are visually near are also numerically near. Colors are represented using three components: <li>L: lightness, a real number between 0 and 1</li> <li>a: color variations between green and red, between -0.5 and 0.5</li> <li>b: color variations between blue and yellow, between -0.5 and 0.5.</li></ul></p>',ret:'a string corresponding to the estimated color according to the OkLab color model',ext:'On failure, throws an exception or returns <tt>YColorSensor.ESTIMATEDOKLAB_INVALID</tt>.'}
,'get_estimatedRGB':{syn:'Returns the estimated color in RGB color model (0xRRGGBB).',lib:'%.get_estimatedRGB()',pro:'get_estimatedRGB()',cmt:'<p>Returns the estimated color in RGB color model (0xRRGGBB). The RGB color model describes each color using a combination of 3 components:<ul> <li>Red (R): the intensity of red, in the 0...255 range</li> <li>Green (G): the intensity of green, in the 0...255 range</li> <li>Blue (B): the intensity of blue, in the 0...255 range</li></ul></p>',ret:'an integer corresponding to the estimated color in RGB color model (0xRRGGBB)',ext:'On failure, throws an exception or returns <tt>YColorSensor.ESTIMATEDRGB_INVALID</tt>.'}
,'get_estimatedXYZ':{syn:'Returns the estimated color according to the CIE XYZ color model.',lib:'%.get_estimatedXYZ()',pro:'get_estimatedXYZ()',cmt:'<p>Returns the estimated color according to the CIE XYZ color model. This color model is based on human vision and light perception, with three components represented by real numbers between 0 and 1:<ul> <li>X: corresponds to a component mixing sensitivity to red and green</li> <li>Y: represents luminance (perceived brightness)</li> <li>Z: corresponds to sensitivity to blue</li></ul></p>',ret:'a string corresponding to the estimated color according to the CIE XYZ color model',ext:'On failure, throws an exception or returns <tt>YColorSensor.ESTIMATEDXYZ_INVALID</tt>.'}
,'get_estimationModel':{syn:'Returns the predictive model used for color estimation (reflective or emissive).',lib:'%.get_estimationModel()',pro:'get_estimationModel()',cmt:'<p>Returns the predictive model used for color estimation (reflective or emissive).</p>',ret:'either <tt>YColorSensor.ESTIMATIONMODEL_REFLECTION</tt> or <tt>YColorSensor.ESTIMATIONMODEL_EMISSION</tt>, according to the predictive model used for color estimation (reflective or emissive)',ext:'On failure, throws an exception or returns <tt>YColorSensor.ESTIMATIONMODEL_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the color sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the color sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the color sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the color sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the color sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the color sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the color sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the color sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorSensor.FUNCTIONID_INVALID</tt>.'}
,'get_gain':{syn:'Returns the current spectral channel detector gain exponent.',lib:'%.get_gain()',pro:'get_gain()',cmt:'<p>Returns the current spectral channel detector gain exponent. For a value <ui>n</ui> ranging from 0 to 12, the applied gain is 2^(n-1). 0 corresponds to a gain of 0.5, and 12 corresponds to a gain of 2048.</p>',ret:'an integer corresponding to the current spectral channel detector gain exponent',ext:'On failure, throws an exception or returns <tt>YColorSensor.GAIN_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the color sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the color sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the color sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the color sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YColorSensor.HARDWAREID_INVALID</tt>.'}
,'get_integrationTime':{syn:'Returns the current integration time for spectral measure, in milliseconds.',lib:'%.get_integrationTime()',pro:'get_integrationTime()',cmt:'<p>Returns the current integration time for spectral measure, in milliseconds. A longer integration time increase the sensitivity for low light conditions, but reduces the measure taking rate and may lead to saturation for lighter colors.</p>',ret:'an integer corresponding to the current integration time for spectral measure, in milliseconds',ext:'On failure, throws an exception or returns <tt>YColorSensor.INTEGRATIONTIME_INVALID</tt>.'}
,'get_ledCalibration':{syn:'Returns the current sent to the illumination LEDs during the latest calibration.',lib:'%.get_ledCalibration()',pro:'get_ledCalibration()',cmt:'<p>Returns the current sent to the illumination LEDs during the latest calibration.</p>',ret:'an integer corresponding to the current sent to the illumination LEDs during the latest calibration',ext:'On failure, throws an exception or returns <tt>YColorSensor.LEDCALIBRATION_INVALID</tt>.'}
,'get_ledCurrent':{syn:'Returns the amount of current sent to the illumination LEDs, for reflection measures.',lib:'%.get_ledCurrent()',pro:'get_ledCurrent()',cmt:'<p>Returns the amount of current sent to the illumination LEDs, for reflection measures. The value is an integer ranging from 0 (LEDs off) to 254 (LEDs at maximum intensity).</p>',ret:'an integer corresponding to the amount of current sent to the illumination LEDs, for reflection measures',ext:'On failure, throws an exception or returns <tt>YColorSensor.LEDCURRENT_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the color sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the color sensor.</p>',ret:'a string corresponding to the logical name of the color sensor.',ext:'On failure, throws an exception or returns <tt>YColorSensor.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nearHTMLColor':{syn:'Returns the name of the HTML color closest to the estimated color.',lib:'%.get_nearHTMLColor()',pro:'get_nearHTMLColor()',cmt:'<p>Returns the name of the HTML color closest to the estimated color.</p>',ret:'a string corresponding to the name of the HTML color closest to the estimated color',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARHTMLCOLOR_INVALID</tt>.'}
,'get_nearRAL1':{syn:'Returns the RAL Classic color closest to the estimated color, with a similarity ratio.',lib:'%.get_nearRAL1()',pro:'get_nearRAL1()',cmt:'<p>Returns the RAL Classic color closest to the estimated color, with a similarity ratio.</p>',ret:'a string corresponding to the RAL Classic color closest to the estimated color, with a similarity ratio',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARRAL1_INVALID</tt>.'}
,'get_nearRAL2':{syn:'Returns the second closest RAL Classic color to the estimated color, with a similarity ratio.',lib:'%.get_nearRAL2()',pro:'get_nearRAL2()',cmt:'<p>Returns the second closest RAL Classic color to the estimated color, with a similarity ratio.</p>',ret:'a string corresponding to the second closest RAL Classic color to the estimated color, with a similarity ratio',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARRAL2_INVALID</tt>.'}
,'get_nearRAL3':{syn:'Returns the third closest RAL Classic color to the estimated color, with a similarity ratio.',lib:'%.get_nearRAL3()',pro:'get_nearRAL3()',cmt:'<p>Returns the third closest RAL Classic color to the estimated color, with a similarity ratio.</p>',ret:'a string corresponding to the third closest RAL Classic color to the estimated color, with a similarity ratio',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARRAL3_INVALID</tt>.'}
,'get_nearSimpleColor':{syn:'Returns the name of the basic color typically used to refer to the estimated color.',lib:'%.get_nearSimpleColor()',pro:'get_nearSimpleColor()',cmt:'<p>Returns the name of the basic color typically used to refer to the estimated color.</p>',ret:'a string corresponding to the name of the basic color typically used to refer to the estimated color',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARSIMPLECOLOR_INVALID</tt>.'}
,'get_nearSimpleColorIndex':{syn:'Returns the index of the basic color typically used to refer to the estimated color (enumerated value).',lib:'%.get_nearSimpleColorIndex()',pro:'get_nearSimpleColorIndex()',cmt:'<p>Returns the index of the basic color typically used to refer to the estimated color (enumerated value). The list of basic colors recognized is:<ul> <li>0 - Brown</li> <li>1 - Red</li> <li>2 - Orange</li> <li>3 - Yellow</li> <li>4 - White</li> <li>5 - Gray</li> <li>6 - Black</li> <li>7 - Green</li> <li>8 - Blue</li> <li>9 - Purple</li> <li>10 - Pink</li></ul></p>',ret:'a value among <tt>YColorSensor.NEARSIMPLECOLORINDEX_BROWN</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_RED</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_ORANGE</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_YELLOW</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_WHITE</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_GRAY</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_BLACK</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_GREEN</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_BLUE</tt>, <tt>YColorSensor.NEARSIMPLECOLORINDEX_PURPLE</tt> and <tt>YColorSensor.NEARSIMPLECOLORINDEX_PINK</tt> corresponding to the index of the basic color typically used to refer to the estimated color (enumerated value)',ext:'On failure, throws an exception or returns <tt>YColorSensor.NEARSIMPLECOLORINDEX_INVALID</tt>.'}
,'get_saturation':{syn:'Returns the current saturation state of the sensor, as an integer.',lib:'%.get_saturation()',pro:'get_saturation()',cmt:'<p>Returns the current saturation state of the sensor, as an integer. Bit 0 indicates saturation of the analog sensor, which can only be corrected by reducing the gain parameters or the luminosity. Bit 1 indicates saturation of the digital interface, which can be corrected by reducing the integration time or the gain.</p>',ret:'an integer corresponding to the current saturation state of the sensor, as an integer',ext:'On failure, throws an exception or returns <tt>YColorSensor.SATURATION_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_workingMode':{syn:'Returns the sensor working mode.',lib:'%.get_workingMode()',pro:'get_workingMode()',cmt:'<p>Returns the sensor working mode. In Auto mode, sensor parameters are automatically set based on the selected estimation model. In Expert mode, sensor parameters such as gain and integration time are configured manually.</p>',ret:'a value among <tt>YColorSensor.WORKINGMODE_AUTO</tt>, <tt>YColorSensor.WORKINGMODE_EXPERT</tt> and <tt>YColorSensor.WORKINGMODE_AUTOGAIN</tt> corresponding to the sensor working mode',ext:'On failure, throws an exception or returns <tt>YColorSensor.WORKINGMODE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the color sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the color sensor is currently reachable, without raising any error. If there is a cached value for the color sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the color sensor.</p>',ret:'<tt>true</tt> if the color sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the color sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the color sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextColorSensor':{syn:'Continues the enumeration of color sensors started using <tt>yFirstColorSensor()</tt>.',lib:'%.nextColorSensor()',pro:'nextColorSensor()',cmt:'<p>Continues the enumeration of color sensors started using <tt>yFirstColorSensor()</tt>. Caution: You can\x27t make any assumption about the returned color sensors order. If you want to find a specific a color sensor, use <tt>ColorSensor.findColorSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YColorSensor</tt> object, corresponding to a color sensor currently online, or a <tt>null</tt> pointer if there are no more color sensors to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_autoGain':{syn:'Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.',lib:'%.set_autoGain()',pro:'set_autoGain(<span id=pn>newval</span>)',cmt:'<p>Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_estimationModel':{syn:'Changes the predictive model to be used for color estimation (reflective or emissive).',lib:'%.set_estimationModel()',pro:'set_estimationModel(<span id=pn>newval</span>)',cmt:'<p>Changes the predictive model to be used for color estimation (reflective or emissive). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YColorSensor.ESTIMATIONMODEL_REFLECTION</tt> or <tt>YColorSensor.ESTIMATIONMODEL_EMISSION</tt>, according to the predictive model to be used for color estimation (reflective or emissive)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_gain':{syn:'Changes the spectral channel detector gain exponent.',lib:'%.set_gain()',pro:'set_gain(<span id=pn>newval</span>)',cmt:'<p>Changes the spectral channel detector gain exponent. For a value <ui>n</ui> ranging from 0 to 12, the applied gain is 2^(n-1). 0 corresponds to a gain of 0.5, and 12 corresponds to a gain of 2048. This method can only be used when the sensor is configured in expert mode; when running in auto mode, the change is ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the spectral channel detector gain exponent'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_integrationTime':{syn:'Changes the integration time for spectral measure, in milliseconds.',lib:'%.set_integrationTime()',pro:'set_integrationTime(<span id=pn>newval</span>)',cmt:'<p>Changes the integration time for spectral measure, in milliseconds. A longer integration time increase the sensitivity for low light conditions, but reduces the measure taking rate and may lead to saturation for lighter colors. This method can only be used when the sensor is configured in expert mode; when running in auto mode, the change is ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the integration time for spectral measure, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_ledCalibration':{syn:'Remember the LED current sent to the illumination LEDs during a calibration.',lib:'%.set_ledCalibration()',pro:'set_ledCalibration(<span id=pn>newval</span>)',cmt:'<p>Remember the LED current sent to the illumination LEDs during a calibration. Thanks to this, the device is able to use the same current when taking measures. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_ledCurrent':{syn:'Changes the amount of current sent to the illumination LEDs, for reflection measures.',lib:'%.set_ledCurrent()',pro:'set_ledCurrent(<span id=pn>newval</span>)',cmt:'<p>Changes the amount of current sent to the illumination LEDs, for reflection measures. The value is an integer ranging from 0 (LEDs off) to 254 (LEDs at maximum intensity).</p>',par:{newval:'an integer corresponding to the amount of current sent to the illumination LEDs, for reflection measures'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the color sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the color sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the color sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_workingMode':{syn:'Changes the sensor working mode.',lib:'%.set_workingMode()',pro:'set_workingMode(<span id=pn>newval</span>)',cmt:'<p>Changes the sensor working mode. In Auto mode, sensor parameters are automatically set based on the selected estimation model. In Expert mode, sensor parameters such as gain and integration time are configured manually. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YColorSensor.WORKINGMODE_AUTO</tt>, <tt>YColorSensor.WORKINGMODE_EXPERT</tt> and <tt>YColorSensor.WORKINGMODE_AUTOGAIN</tt> corresponding to the sensor working mode'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'turnLedOff':{syn:'Turns off the built-in illumination LEDs.',lib:'%.turnLedOff()',pro:'turnLedOff()',cmt:'<p>Turns off the built-in illumination LEDs. On failure, throws an exception or returns a negative error code.</p>'}
,'turnLedOn':{syn:'Turns on the built-in illumination LEDs using the same current as used during the latest calibration.',lib:'%.turnLedOn()',pro:'turnLedOn()',cmt:'<p>Turns on the built-in illumination LEDs using the same current as used during the latest calibration. On failure, throws an exception or returns a negative error code.</p>'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: ColorSensor)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function control interface, available for instance in the Yocto-3D-V2',inc:'from yocto_compass import *',cmt:'<p>The <tt>YCompass</tt> class allows you to read and configure Yoctopuce compass functions. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindCompass':{syn:'Retrieves a compass function for a given identifier.',lib:'YCompass.FindCompass()',pro:'FindCompass(<span id=pn>func</span>)',cmt:'<p>Retrieves a compass function for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the compass function is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCompass.isOnline()</tt> to test if the compass function is indeed online at a given time. In case of ambiguity when looking for a compass function by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the compass function, for instance <tt>Y3DMK002.compass</tt>.'},ret:'a <tt>YCompass</tt> object allowing you to drive the compass function.'}
,'FirstCompass':{syn:'Starts the enumeration of compass functions currently accessible.',lib:'YCompass.FirstCompass()',pro:'FirstCompass()',cmt:'<p>Starts the enumeration of compass functions currently accessible. Use the method <tt>YCompass.nextCompass()</tt> to iterate on next compass functions.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to the first compass function currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the compass function attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the compass function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the compass function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the compass function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YCompass.ADVMODE_IMMEDIATE</tt>, <tt>YCompass.ADVMODE_PERIOD_AVG</tt>, <tt>YCompass.ADVMODE_PERIOD_MIN</tt> and <tt>YCompass.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YCompass.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the compass function (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the compass function (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass function (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YCompass.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the measure update frequency, measured in Hz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz.</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz',ext:'On failure, throws an exception or returns <tt>YCompass.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>YCompass.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>YCompass.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the compass function.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the compass function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the compass function object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the compass function.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the compass function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the compass function object'}
,'get_friendlyName':{syn:'Returns a global identifier of the compass function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the compass function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the compass function if they are defined, otherwise the serial number of the module and the hardware identifier of the compass function (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the compass function using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCompass.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the compass function, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the compass function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the compass function (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCompass.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the compass function in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the compass function in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the compass function (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the compass function (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCompass.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>YCompass.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YCompass.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the compass function.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the compass function.</p>',ret:'a string corresponding to the logical name of the compass function.',ext:'On failure, throws an exception or returns <tt>YCompass.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>YCompass.LOWESTVALUE_INVALID</tt>.'}
,'get_magneticHeading':{syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'%.get_magneticHeading()',pro:'get_magneticHeading()',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:'On failure, throws an exception or returns <tt>YCompass.MAGNETICHEADING_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YCompass.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YCompass.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YCompass.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the relative bearing.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:'On failure, throws an exception or returns <tt>YCompass.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the compass function is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the compass function is currently reachable, without raising any error. If there is a cached value for the compass function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the compass function.</p>',ret:'<tt>true</tt> if the compass function can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the compass function cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the compass function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextCompass':{syn:'Continues the enumeration of compass functions started using <tt>yFirstCompass()</tt>.',lib:'%.nextCompass()',pro:'nextCompass()',cmt:'<p>Continues the enumeration of compass functions started using <tt>yFirstCompass()</tt>. Caution: You can\x27t make any assumption about the returned compass functions order. If you want to find a specific a compass function, use <tt>Compass.findCompass()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to a compass function currently online, or a <tt>null</tt> pointer if there are no more compass functions to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YCompass.ADVMODE_IMMEDIATE</tt>, <tt>YCompass.ADVMODE_PERIOD_AVG</tt>, <tt>YCompass.ADVMODE_PERIOD_MIN</tt> and <tt>YCompass.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the measure update frequency, measured in Hz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz. When the frequency is lower, the device performs averaging. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the compass function.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the compass function. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the compass function.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Compass)
//--- (generated code: ConsolidatedDataSet)
doc['ConsolidatedDataSet']={'':{syn:'Cross-sensor consolidated data sequence.',inc:'from yocto_module import *',cmt:'<p><tt>YConsolidatedDataSet</tt> objects make it possible to retrieve a set of recorded measures from multiple sensors, for a specified time interval. They can be used to load data points progressively, and to receive data records by timestamp, one by one..</p>'}
,'Init':{syn:'Returns an object holding historical data for multiple sensors, for a specified time interval.',lib:'YConsolidatedDataSet.Init()',pro:'Init(<span id=pn>sensorNames</span>, <span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Returns an object holding historical data for multiple sensors, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. The resulting object makes it possible to load progressively a large set of measures from multiple sensors, consolidating data on the fly to align records based on measurement timestamps.</p>',par:{sensorNames:'array of logical names or hardware identifiers of the sensors for which data must be loaded from their data logger.',startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of <tt>YConsolidatedDataSet</tt>, providing access to consolidated historical data. Records can be loaded progressively using the <tt>YConsolidatedDataSet.nextRecord()</tt> method.'}
,'nextRecord':{syn:'Extracts the next data record from the data logger of all sensors linked to this object.',lib:'%.nextRecord()',pro:'nextRecord(<span id=pn>datarec</span>)',cmt:'<p>Extracts the next data record from the data logger of all sensors linked to this object.</p>',par:{datarec:'array of floating point numbers, that will be filled by the function with the timestamp of the measure in first position, followed by the measured value in next positions.'},ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: ConsolidatedDataSet)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current sensor control interface, available for instance in the Yocto-Amp, the Yocto-Motor-DC or the Yocto-Watt',inc:'from yocto_current import *',cmt:'<p>The <tt>YCurrent</tt> class allows you to read and configure Yoctopuce current sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindCurrent':{syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent.FindCurrent()',pro:'FindCurrent(<span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the current sensor, for instance <tt>YAMPMK01.current1</tt>.'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'}
,'FirstCurrent':{syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent.FirstCurrent()',pro:'FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the current sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the current sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YCurrent.ADVMODE_IMMEDIATE</tt>, <tt>YCurrent.ADVMODE_PERIOD_AVG</tt>, <tt>YCurrent.ADVMODE_PERIOD_MIN</tt> and <tt>YCurrent.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YCurrent.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YCurrent.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>YCurrent.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the current, in mA, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>YCurrent.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_enabled':{syn:'Returns the activation state of this input.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns the activation state of this input.</p>',ret:'either <tt>YCurrent.ENABLED_FALSE</tt> or <tt>YCurrent.ENABLED_TRUE</tt>, according to the activation state of this input',ext:'On failure, throws an exception or returns <tt>YCurrent.ENABLED_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the current sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the current sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the current sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the current sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the current sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the current sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the current sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrent.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the current sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the current sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the current sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrent.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the current sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the current sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrent.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the current since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>YCurrent.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YCurrent.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the current sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:'On failure, throws an exception or returns <tt>YCurrent.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the current since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>YCurrent.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YCurrent.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YCurrent.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YCurrent.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the current.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:'On failure, throws an exception or returns <tt>YCurrent.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the current sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the current sensor is currently reachable, without raising any error. If there is a cached value for the current sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the current sensor.</p>',ret:'<tt>true</tt> if the current sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the current sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the current sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextCurrent':{syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'%.nextCurrent()',pro:'nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>. Caution: You can\x27t make any assumption about the returned current sensors order. If you want to find a specific a current sensor, use <tt>Current.findCurrent()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YCurrent.ADVMODE_IMMEDIATE</tt>, <tt>YCurrent.ADVMODE_PERIOD_AVG</tt>, <tt>YCurrent.ADVMODE_PERIOD_MIN</tt> and <tt>YCurrent.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabled':{syn:'Changes the activation state of this voltage input.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of this voltage input. When AC measurements are disabled, the device will always assume a DC signal, and vice-versa. When both AC and DC measurements are active, the device switches between AC and DC mode based on the relative amplitude of variations compared to the average value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YCurrent.ENABLED_FALSE</tt> or <tt>YCurrent.ENABLED_TRUE</tt>, according to the activation state of this voltage input'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the current sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Current)
//--- (generated code: CurrentLoopOutput)
doc['CurrentLoopOutput']={'':{syn:'4-20mA output control interface, available for instance in the Yocto-4-20mA-Tx',inc:'from yocto_currentloopoutput import *',cmt:'<p>The <tt>YCurrentLoopOutput</tt> class allows you to drive a 4-20mA output by regulating the current flowing through the current loop. It can also provide information about the power state of the current loop.</p>'}
,'FindCurrentLoopOutput':{syn:'Retrieves a 4-20mA output for a given identifier.',lib:'YCurrentLoopOutput.FindCurrentLoopOutput()',pro:'FindCurrentLoopOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a 4-20mA output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the 4-20mA output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrentLoopOutput.isOnline()</tt> to test if the 4-20mA output is indeed online at a given time. In case of ambiguity when looking for a 4-20mA output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the 4-20mA output, for instance <tt>TX420MA1.currentLoopOutput</tt>.'},ret:'a <tt>YCurrentLoopOutput</tt> object allowing you to drive the 4-20mA output.'}
,'FirstCurrentLoopOutput':{syn:'Starts the enumeration of 4-20mA outputs currently accessible.',lib:'YCurrentLoopOutput.FirstCurrentLoopOutput()',pro:'FirstCurrentLoopOutput()',cmt:'<p>Starts the enumeration of 4-20mA outputs currently accessible. Use the method <tt>YCurrentLoopOutput.nextCurrentLoopOutput()</tt> to iterate on next 4-20mA outputs.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to the first 4-20mA output currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the 4-20mA output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'currentMove':{syn:'Performs a smooth transition of current flowing in the loop.',lib:'%.currentMove()',pro:'currentMove(<span id=pn>mA_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of current flowing in the loop. Any current explicit change cancels any ongoing transition process.</p>',par:{mA_target:'new current value at the end of the transition (floating-point number, representing the end current in mA)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the 4-20mA output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the 4-20mA output (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the 4-20mA output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the 4-20mA output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_current':{syn:'Returns the loop current set point in mA.',lib:'%.get_current()',pro:'get_current()',cmt:'<p>Returns the loop current set point in mA.</p>',ret:'a floating point number corresponding to the loop current set point in mA',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.CURRENT_INVALID</tt>.'}
,'get_currentAtStartUp':{syn:'Returns the current in the loop at device startup, in mA.',lib:'%.get_currentAtStartUp()',pro:'get_currentAtStartUp()',cmt:'<p>Returns the current in the loop at device startup, in mA.</p>',ret:'a floating point number corresponding to the current in the loop at device startup, in mA',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.CURRENTATSTARTUP_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the 4-20mA output.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the 4-20mA output object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the 4-20mA output.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the 4-20mA output object'}
,'get_friendlyName':{syn:'Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the 4-20mA output if they are defined, otherwise the serial number of the module and the hardware identifier of the 4-20mA output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the 4-20mA output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the 4-20mA output, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the 4-20mA output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the 4-20mA output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the 4-20mA output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the 4-20mA output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the 4-20mA output.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the 4-20mA output.</p>',ret:'a string corresponding to the logical name of the 4-20mA output.',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.LOGICALNAME_INVALID</tt>.'}
,'get_loopPower':{syn:'Returns the loop powerstate.',lib:'%.get_loopPower()',pro:'get_loopPower()',cmt:'<p>Returns the loop powerstate. POWEROK: the loop \x09 is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not powered enough to maintain the current required (insufficient voltage).</p>',ret:'a value among <tt>YCurrentLoopOutput.LOOPPOWER_NOPWR</tt>, <tt>YCurrentLoopOutput.LOOPPOWER_LOWPWR</tt> and <tt>YCurrentLoopOutput.LOOPPOWER_POWEROK</tt> corresponding to the loop powerstate',ext:'On failure, throws an exception or returns <tt>YCurrentLoopOutput.LOOPPOWER_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the 4-20mA output is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the 4-20mA output is currently reachable, without raising any error. If there is a cached value for the 4-20mA output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the 4-20mA output.</p>',ret:'<tt>true</tt> if the 4-20mA output can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the 4-20mA output cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the 4-20mA output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextCurrentLoopOutput':{syn:'Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>.',lib:'%.nextCurrentLoopOutput()',pro:'nextCurrentLoopOutput()',cmt:'<p>Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>. Caution: You can\x27t make any assumption about the returned 4-20mA outputs order. If you want to find a specific a 4-20mA output, use <tt>CurrentLoopOutput.findCurrentLoopOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to a 4-20mA output currently online, or a <tt>null</tt> pointer if there are no more 4-20mA outputs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_current':{syn:'Changes the current loop, the valid range is from 3 to 21mA.',lib:'%.set_current()',pro:'set_current(<span id=pn>newval</span>)',cmt:'<p>Changes the current loop, the valid range is from 3 to 21mA. If the loop is \x09 not properly powered, the target current is not reached and \x09\x09loopPower is set to LOWPWR.</p>',par:{newval:'a floating point number corresponding to the current loop, the valid range is from 3 to 21mA'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentAtStartUp':{syn:'Changes the loop current at device start up.',lib:'%.set_currentAtStartUp()',pro:'set_currentAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the loop current at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the loop current at device start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the 4-20mA output.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the 4-20mA output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the 4-20mA output.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: CurrentLoopOutput)
//--- (generated code: DaisyChain)
doc['DaisyChain']={'':{syn:'Module chain configuration interface',inc:'from yocto_daisychain import *',cmt:'<p>The <tt>YDaisyChain</tt> class can be used to verify that devices that are daisy-chained directly from device to device, without a hub, are detected properly.</p>'}
,'FindDaisyChain':{syn:'Retrieves a module chain for a given identifier.',lib:'YDaisyChain.FindDaisyChain()',pro:'FindDaisyChain(<span id=pn>func</span>)',cmt:'<p>Retrieves a module chain for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the module chain is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDaisyChain.isOnline()</tt> to test if the module chain is indeed online at a given time. In case of ambiguity when looking for a module chain by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the module chain, for instance <tt>MyDevice.daisyChain</tt>.'},ret:'a <tt>YDaisyChain</tt> object allowing you to drive the module chain.'}
,'FirstDaisyChain':{syn:'Starts the enumeration of module chains currently accessible.',lib:'YDaisyChain.FirstDaisyChain()',pro:'FirstDaisyChain()',cmt:'<p>Starts the enumeration of module chains currently accessible. Use the method <tt>YDaisyChain.nextDaisyChain()</tt> to iterate on next module chains.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to the first module chain currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module chain attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the module chain (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the module chain (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the module chain (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the module chain (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YDaisyChain.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_childCount':{syn:'Returns the number of child nodes currently detected.',lib:'%.get_childCount()',pro:'get_childCount()',cmt:'<p>Returns the number of child nodes currently detected.</p>',ret:'an integer corresponding to the number of child nodes currently detected',ext:'On failure, throws an exception or returns <tt>YDaisyChain.CHILDCOUNT_INVALID</tt>.'}
,'get_daisyState':{syn:'Returns the state of the daisy-link between modules.',lib:'%.get_daisyState()',pro:'get_daisyState()',cmt:'<p>Returns the state of the daisy-link between modules.</p>',ret:'a value among <tt>YDaisyChain.DAISYSTATE_READY</tt>, <tt>YDaisyChain.DAISYSTATE_IS_CHILD</tt>, <tt>YDaisyChain.DAISYSTATE_FIRMWARE_MISMATCH</tt>, <tt>YDaisyChain.DAISYSTATE_CHILD_MISSING</tt> and <tt>YDaisyChain.DAISYSTATE_CHILD_LOST</tt> corresponding to the state of the daisy-link between modules',ext:'On failure, throws an exception or returns <tt>YDaisyChain.DAISYSTATE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the module chain.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the module chain object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the module chain.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the module chain object'}
,'get_friendlyName':{syn:'Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the module chain if they are defined, otherwise the serial number of the module and the hardware identifier of the module chain (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the module chain using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDaisyChain.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the module chain, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the module chain, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the module chain (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDaisyChain.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the module chain (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the module chain (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDaisyChain.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the module chain.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the module chain.</p>',ret:'a string corresponding to the logical name of the module chain.',ext:'On failure, throws an exception or returns <tt>YDaisyChain.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_requiredChildCount':{syn:'Returns the number of child nodes expected in normal conditions.',lib:'%.get_requiredChildCount()',pro:'get_requiredChildCount()',cmt:'<p>Returns the number of child nodes expected in normal conditions.</p>',ret:'an integer corresponding to the number of child nodes expected in normal conditions',ext:'On failure, throws an exception or returns <tt>YDaisyChain.REQUIREDCHILDCOUNT_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the module chain is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the module chain is currently reachable, without raising any error. If there is a cached value for the module chain in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the module chain.</p>',ret:'<tt>true</tt> if the module chain can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the module chain cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module chain cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextDaisyChain':{syn:'Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>.',lib:'%.nextDaisyChain()',pro:'nextDaisyChain()',cmt:'<p>Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>. Caution: You can\x27t make any assumption about the returned module chains order. If you want to find a specific a module chain, use <tt>DaisyChain.findDaisyChain()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to a module chain currently online, or a <tt>null</tt> pointer if there are no more module chains to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the module chain.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module chain. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module chain.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_requiredChildCount':{syn:'Changes the number of child nodes expected in normal conditions.',lib:'%.set_requiredChildCount()',pro:'set_requiredChildCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of child nodes expected in normal conditions. If the value is zero, no check is performed. If it is non-zero, the number child nodes is checked on startup and the status will change to error if the count does not match. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of child nodes expected in normal conditions'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: DaisyChain)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger control interface, available on most Yoctopuce sensors.',inc:'from yocto_module import *',cmt:'<p>A non-volatile memory for storing ongoing measured data is available on most Yoctopuce sensors. Recording can happen automatically, without requiring a permanent connection to a computer. The <tt>YDataLogger</tt> class controls the global parameters of the internal data logger. Recording control (start/stop) as well as data retrieval is done at sensor objects level.</p>'}
,'FindDataLogger':{syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger.FindDataLogger()',pro:'FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the data logger, for instance <tt>LIGHTMK4.dataLogger</tt>.'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'}
,'FirstDataLogger':{syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger.FirstDataLogger()',pro:'FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the data logger attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the data logger (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'forgetAllDataStreams':{syn:'Clears the data logger memory and discards all recorded data streams.',lib:'%.forgetAllDataStreams()',pro:'forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YDataLogger.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_autoStart':{syn:'Returns the default activation state of the data logger on power up.',lib:'%.get_autoStart()',pro:'get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>YDataLogger.AUTOSTART_OFF</tt> or <tt>YDataLogger.AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>YDataLogger.AUTOSTART_INVALID</tt>.'}
,'get_beaconDriven':{syn:'Returns true if the data logger is synchronised with the localization beacon.',lib:'%.get_beaconDriven()',pro:'get_beaconDriven()',cmt:'<p>Returns true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>YDataLogger.BEACONDRIVEN_OFF</tt> or <tt>YDataLogger.BEACONDRIVEN_ON</tt>, according to true if the data logger is synchronised with the localization beacon',ext:'On failure, throws an exception or returns <tt>YDataLogger.BEACONDRIVEN_INVALID</tt>.'}
,'get_currentRunIndex':{syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'%.get_currentRunIndex()',pro:'get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>YDataLogger.CURRENTRUNINDEX_INVALID</tt>.'}
,'get_dataSets':{syn:'Returns a list of <tt>YDataSet</tt> objects that can be used to retrieve all measures stored by the data logger.',lib:'%.get_dataSets()',pro:'get_dataSets()',cmt:'<p>Returns a list of <tt>YDataSet</tt> objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as <tt>YDataSet</tt> objects are not supported by firmwares older than version 13000.</p>',ret:'a list of <tt>YDataSet</tt> object.',ext:'On failure, throws an exception or returns an empty list.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the data logger.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the data logger object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the data logger.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the data logger object'}
,'get_friendlyName':{syn:'Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the data logger if they are defined, otherwise the serial number of the module and the hardware identifier of the data logger (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the data logger using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDataLogger.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the data logger, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the data logger, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the data logger (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDataLogger.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the data logger (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the data logger (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDataLogger.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the data logger.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:'On failure, throws an exception or returns <tt>YDataLogger.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recording':{syn:'Returns the current activation state of the data logger.',lib:'%.get_recording()',pro:'get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'a value among <tt>YDataLogger.RECORDING_OFF</tt>, <tt>YDataLogger.RECORDING_ON</tt> and <tt>YDataLogger.RECORDING_PENDING</tt> corresponding to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>YDataLogger.RECORDING_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_timeUTC':{syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'%.get_timeUTC()',pro:'get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>YDataLogger.TIMEUTC_INVALID</tt>.'}
,'get_usage':{syn:'Returns the percentage of datalogger memory in use.',lib:'%.get_usage()',pro:'get_usage()',cmt:'<p>Returns the percentage of datalogger memory in use.</p>',ret:'an integer corresponding to the percentage of datalogger memory in use',ext:'On failure, throws an exception or returns <tt>YDataLogger.USAGE_INVALID</tt>.'}
,'get_userData':ds.get_userData
,'isOnline':{syn:'Checks if the data logger is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the data logger is currently reachable, without raising any error. If there is a cached value for the data logger in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the data logger.</p>',ret:'<tt>true</tt> if the data logger can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the data logger cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the data logger cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextDataLogger':{syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'%.nextDataLogger()',pro:'nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>. Caution: You can\x27t make any assumption about the returned data loggers order. If you want to find a specific a data logger, use <tt>DataLogger.findDataLogger()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_autoStart':{syn:'Changes the default activation state of the data logger on power up.',lib:'%.set_autoStart()',pro:'set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Do not forget to call the <tt>saveToFlash()</tt> method of the module to save the configuration change. Note: if the device doesn\x27t have any time source at his disposal when starting up, it will wait for ~8 seconds before automatically starting to record with \x09 an arbitrary timestamp</p>',par:{newval:'either <tt>YDataLogger.AUTOSTART_OFF</tt> or <tt>YDataLogger.AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_beaconDriven':{syn:'Changes the type of synchronisation of the data logger.',lib:'%.set_beaconDriven()',pro:'set_beaconDriven(<span id=pn>newval</span>)',cmt:'<p>Changes the type of synchronisation of the data logger. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YDataLogger.BEACONDRIVEN_OFF</tt> or <tt>YDataLogger.BEACONDRIVEN_ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the data logger.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_recording':{syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'%.set_recording()',pro:'set_recording(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'a value among <tt>YDataLogger.RECORDING_OFF</tt>, <tt>YDataLogger.RECORDING_ON</tt> and <tt>YDataLogger.RECORDING_PENDING</tt> corresponding to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_timeUTC':{syn:'Changes the current UTC time reference used for recorded data.',lib:'%.set_timeUTC()',pro:'set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':ds.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: DataLogger)
//--- (generated code: DataSet)
doc['DataSet']={'':{syn:'Recorded data sequence, as returned by <tt>sensor.get_recordedData()</tt>',inc:'from yocto_module import *',cmt:'<p><tt>YDataSet</tt> objects make it possible to retrieve a set of recorded measures for a given sensor and a specified time interval. They can be used to load data points with a progress report. When the <tt>YDataSet</tt> object is instantiated by the <tt>sensor.get_recordedData()</tt> function, no data is yet loaded from the module. It is only when the <tt>loadMore()</tt> method is called over and over than data will be effectively loaded from the dataLogger.</p><p> A preview of available measures is available using the function <tt>get_preview()</tt> as soon as <tt>loadMore()</tt> has been called once. Measures themselves are available using function <tt>get_measures()</tt> when loaded by subsequent calls to <tt>loadMore()</tt>.</p><p> This class can only be used on devices that use a relatively recent firmware, as <tt>YDataSet</tt> objects are not supported by firmwares older than version 13000.</p>'}
,'get_endTimeUTC':{syn:'Returns the end time of the dataset, relative to the Jan 1, 1970.',lib:'%.get_endTimeUTC()',pro:'get_endTimeUTC()',cmt:'<p>Returns the end time of the dataset, relative to the Jan 1, 1970. When the <tt>YDataSet</tt> object is created, the end time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the end time is updated to reflect the timestamp of the last measure actually found in the dataLogger within the specified range.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_summary()</tt> which contain more precise informations.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the end of this data set (i.e. Unix time representation of the absolute time).'}
,'get_functionId':{syn:'Returns the hardware identifier of the function that performed the measure, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the function that performed the measure, without reference to the module. For example <tt>temperature1</tt>.</p>',ret:'a string that identifies the function (ex: <tt>temperature1</tt>)'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function (for example <tt>THRMCPL1-123456.temperature1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>THRMCPL1-123456.temperature1</tt>)',ext:'On failure, throws an exception or returns <tt>YDataSet.HARDWAREID_INVALID</tt>.'}
,'get_measures':{syn:'Returns all measured values currently available for this DataSet, as a list of <tt>YMeasure</tt> objects.',lib:'%.get_measures()',pro:'get_measures()',cmt:'<p>Returns all measured values currently available for this DataSet, as a list of <tt>YMeasure</tt> objects. Each item includes: - the start of the measure time interval - the end of the measure time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> Before calling this method, you should call <tt>loadMore()</tt> to load data from the device. You may have to call loadMore() several time until all rows are loaded, but you can start looking at available data rows before the load is complete.</p><p> The oldest measures are always loaded first, and the most recent measures will be loaded last. As a result, timestamps are normally sorted in ascending order within the measure table, unless there was an unexpected adjustment of the datalogger UTC clock.</p>',ret:'a table of records, where each record depicts the measured value for a given time interval',ext:'On failure, throws an exception or returns an empty array.'}
,'get_measuresAt':{syn:'Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>.',lib:'%.get_measuresAt()',pro:'get_measuresAt(<span id=pn>measure</span>)',cmt:'<p>Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>. The result is provided as a list of <tt>YMeasure</tt> objects.</p>',par:{measure:'condensed measure from the list previously returned by <tt>get_preview()</tt>.'},ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'}
,'get_preview':{syn:'Returns a condensed version of the measures that can retrieved in this <tt>YDataSet</tt>, as a list of <tt>YMeasure</tt> objects.',lib:'%.get_preview()',pro:'get_preview()',cmt:'<p>Returns a condensed version of the measures that can retrieved in this <tt>YDataSet</tt>, as a list of <tt>YMeasure</tt> objects. Each item includes: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This preview is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'}
,'get_progress':{syn:'Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100.',lib:'%.get_progress()',pro:'get_progress()',cmt:'<p>Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100. When the object is instantiated by <tt>get_dataSet</tt>, the progress is zero. Each time <tt>loadMore()</tt> is invoked, the progress is updated, to reach the value 100 only once all measures have been loaded.</p>',ret:'an integer in the range 0 to 100 (percentage of completion).'}
,'get_startTimeUTC':{syn:'Returns the start time of the dataset, relative to the Jan 1, 1970.',lib:'%.get_startTimeUTC()',pro:'get_startTimeUTC()',cmt:'<p>Returns the start time of the dataset, relative to the Jan 1, 1970. When the <tt>YDataSet</tt> object is created, the start time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the start time is updated to reflect the timestamp of the first measure actually found in the dataLogger within the specified range.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_summary()</tt> which contain more precise informations.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data set (i.e. Unix time representation of the absolute time).'}
,'get_summary':{syn:'Returns an <tt>YMeasure</tt> object which summarizes the whole <tt>YDataSet</tt>.',lib:'%.get_summary()',pro:'get_summary()',cmt:'<p>Returns an <tt>YMeasure</tt> object which summarizes the whole <tt>YDataSet</tt>. In includes the following information: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This summary is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'an <tt>YMeasure</tt> object'}
,'get_unit':{syn:'Returns the measuring unit for the measured value.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string that represents a physical unit.',ext:'On failure, throws an exception or returns <tt>YDataSet.UNIT_INVALID</tt>.'}
,'loadMore':{syn:'Loads the next block of measures from the dataLogger, and updates the progress indicator.',lib:'%.loadMore()',pro:'loadMore()',cmt:'<p>Loads the next block of measures from the dataLogger, and updates the progress indicator.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: DataSet)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO port control interface, available for instance in the Yocto-IO or the Yocto-Maxi-IO-V2',inc:'from yocto_digitalio import *',cmt:'<p>The <tt>YDigitalIO</tt> class allows you drive a Yoctopuce digital input/output port. It can be used to set up the direction of each channel, to read the state of each channel and to switch the state of each channel configures as an output. You can work on all channels at once, or one by one. Most functions \x09 use a binary representation for channels where bit 0 matches channel #0 , bit 1 matches channel \x09 #1 and so on. If you are not familiar with numbers binary representation, you will find more \x09 information here: <tt>https://en.wikipedia.org/wiki/Binary_number#Representation</tt>. It is also possible to automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}
,'FindDigitalIO':{syn:'Retrieves a digital IO port for a given identifier.',lib:'YDigitalIO.FindDigitalIO()',pro:'FindDigitalIO(<span id=pn>func</span>)',cmt:'<p>Retrieves a digital IO port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the digital IO port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDigitalIO.isOnline()</tt> to test if the digital IO port is indeed online at a given time. In case of ambiguity when looking for a digital IO port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the digital IO port, for instance <tt>YMINIIO0.digitalIO</tt>.'},ret:'a <tt>YDigitalIO</tt> object allowing you to drive the digital IO port.'}
,'FirstDigitalIO':{syn:'Starts the enumeration of digital IO ports currently accessible.',lib:'YDigitalIO.FirstDigitalIO()',pro:'FirstDigitalIO()',cmt:'<p>Starts the enumeration of digital IO ports currently accessible. Use the method <tt>YDigitalIO.nextDigitalIO()</tt> to iterate on next digital IO ports.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to the first digital IO port currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the digital IO port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'delayedPulse':{syn:'Schedules a pulse on a single bit for a specified duration.',lib:'%.delayedPulse()',pro:'delayedPulse(<span id=pn>bitno</span>, <span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the digital IO port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YDigitalIO.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bitDirection':{syn:'Returns the direction of a single bit (i.e.',lib:'%.get_bitDirection()',pro:'get_bitDirection(<span id=pn>bitno</span>)',cmt:'<p>Returns the direction of a single bit (i.e. channel) from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_bitOpenDrain':{syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'%.get_bitOpenDrain()',pro:'get_bitOpenDrain(<span id=pn>bitno</span>)',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_bitPolarity':{syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'%.get_bitPolarity()',pro:'get_bitPolarity(<span id=pn>bitno</span>)',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_bitState':{syn:'Returns the state of a single bit (i.e.',lib:'%.get_bitState()',pro:'get_bitState(<span id=pn>bitno</span>)',cmt:'<p>Returns the state of a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the digital IO port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the digital IO port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the digital IO port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the digital IO port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the digital IO port if they are defined, otherwise the serial number of the module and the hardware identifier of the digital IO port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the digital IO port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDigitalIO.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the digital IO port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the digital IO port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the digital IO port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDigitalIO.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the digital IO port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the digital IO port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDigitalIO.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the digital IO port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:'On failure, throws an exception or returns <tt>YDigitalIO.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_outputVoltage':{syn:'Returns the voltage source used to drive output bits.',lib:'%.get_outputVoltage()',pro:'get_outputVoltage()',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>YDigitalIO.OUTPUTVOLTAGE_USB_5V</tt>, <tt>YDigitalIO.OUTPUTVOLTAGE_USB_3V</tt> and <tt>YDigitalIO.OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:'On failure, throws an exception or returns <tt>YDigitalIO.OUTPUTVOLTAGE_INVALID</tt>.'}
,'get_portDiags':{syn:'Returns the port state diagnostics.',lib:'%.get_portDiags()',pro:'get_portDiags()',cmt:'<p>Returns the port state diagnostics. Bit 0 indicates a shortcut on output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent). During normal use, all diagnostic bits should stay clear.</p>',ret:'an integer corresponding to the port state diagnostics',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTDIAGS_INVALID</tt>.'}
,'get_portDirection':{syn:'Returns the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output.',lib:'%.get_portDirection()',pro:'get_portDirection()',cmt:'<p>Returns the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTDIRECTION_INVALID</tt>.'}
,'get_portOpenDrain':{syn:'Returns the electrical interface for each bit of the port.',lib:'%.get_portOpenDrain()',pro:'get_portOpenDrain()',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTOPENDRAIN_INVALID</tt>.'}
,'get_portPolarity':{syn:'Returns the polarity of all the bits of the port.',lib:'%.get_portPolarity()',pro:'get_portPolarity()',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTPOLARITY_INVALID</tt>.'}
,'get_portSize':{syn:'Returns the number of bits (i.e.',lib:'%.get_portSize()',pro:'get_portSize()',cmt:'<p>Returns the number of bits (i.e. channels)implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits (i.e',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTSIZE_INVALID</tt>.'}
,'get_portState':{syn:'Returns the digital IO port state as an integer with each bit representing a channel.',lib:'%.get_portState()',pro:'get_portState()',cmt:'<p>Returns the digital IO port state as an integer with each bit representing a channel. value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on...</p>',ret:'an integer corresponding to the digital IO port state as an integer with each bit representing a channel',ext:'On failure, throws an exception or returns <tt>YDigitalIO.PORTSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the digital IO port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the digital IO port is currently reachable, without raising any error. If there is a cached value for the digital IO port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the digital IO port.</p>',ret:'<tt>true</tt> if the digital IO port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the digital IO port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the digital IO port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextDigitalIO':{syn:'Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.',lib:'%.nextDigitalIO()',pro:'nextDigitalIO()',cmt:'<p>Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>. Caution: You can\x27t make any assumption about the returned digital IO ports order. If you want to find a specific a digital IO port, use <tt>DigitalIO.findDigitalIO()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to a digital IO port currently online, or a <tt>null</tt> pointer if there are no more digital IO ports to enumerate.'}
,'pulse':{syn:'Triggers a pulse on a single bit for a specified duration.',lib:'%.pulse()',pro:'pulse(<span id=pn>bitno</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'set_bitDirection':{syn:'Changes the direction of a single bit (i.e.',lib:'%.set_bitDirection()',pro:'set_bitDirection(<span id=pn>bitno</span>, <span id=pn>bitdirection</span>)',cmt:'<p>Changes the direction of a single bit (i.e. channel) from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bitOpenDrain':{syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'%.set_bitOpenDrain()',pro:'set_bitOpenDrain(<span id=pn>bitno</span>, <span id=pn>opendrain</span>)',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bitPolarity':{syn:'Changes the polarity of a single bit from the I/O port.',lib:'%.set_bitPolarity()',pro:'set_bitPolarity(<span id=pn>bitno</span>, <span id=pn>bitpolarity</span>)',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bitState':{syn:'Sets a single bit (i.e.',lib:'%.set_bitState()',pro:'set_bitState(<span id=pn>bitno</span>, <span id=pn>bitstate</span>)',cmt:'<p>Sets a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the digital IO port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the digital IO port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_outputVoltage':{syn:'Changes the voltage source used to drive output bits.',lib:'%.set_outputVoltage()',pro:'set_outputVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage source used to drive output bits. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'a value among <tt>YDigitalIO.OUTPUTVOLTAGE_USB_5V</tt>, <tt>YDigitalIO.OUTPUTVOLTAGE_USB_3V</tt> and <tt>YDigitalIO.OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_portDirection':{syn:'Changes the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output.',lib:'%.set_portDirection()',pro:'set_portDirection(<span id=pn>newval</span>)',cmt:'<p>Changes the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the I/O direction of all channels of the port (bitmap): 0 makes a bit an input, 1 makes it an output'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_portOpenDrain':{syn:'Changes the electrical interface for each bit of the port.',lib:'%.set_portOpenDrain()',pro:'set_portOpenDrain(<span id=pn>newval</span>)',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_portPolarity':{syn:'Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.',lib:'%.set_portPolarity()',pro:'set_portPolarity(<span id=pn>newval</span>)',cmt:'<p>Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting will be kept after a reboot.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_portState':{syn:'Changes the state of all digital IO port\x27s channels at once: the parameter is an integer where each bit represents a channel, with bit 0 matching channel #0.',lib:'%.set_portState()',pro:'set_portState(<span id=pn>newval</span>)',cmt:'<p>Changes the state of all digital IO port\x27s channels at once: the parameter is an integer where each bit represents a channel, with bit 0 matching channel #0. To set all channels to 0 -> <tt>0b00000000</tt> -> parameter = 0 To set channel #0 to 1 -> <tt>0b00000001</tt> -> parameter = 1 To set channel #1 to 1 -> <tt>0b00000010</tt> -> parameter = 2 To set channel #0 and #1 -> <tt>0b00000011</tt> -> parameter = 3 To set channel #2 to 1 -> <tt>0b00000100</tt> -> parameter = 4 an so on.... Only channels configured as outputs will be affecter, according to the value configured using <tt>set_portDirection</tt>.</p>',par:{newval:'an integer corresponding to the state of all digital IO port\x27s channels at once: the parameter is an integer where each bit represents a channel, with bit 0 matching channel #0'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'toggle_bitState':{syn:'Reverts a single bit (i.e.',lib:'%.toggle_bitState()',pro:'toggle_bitState(<span id=pn>bitno</span>)',cmt:'<p>Reverts a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: DigitalIO)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display control interface, available for instance in the Yocto-Display, the Yocto-MaxiDisplay, the Yocto-MaxiDisplay-G or the Yocto-MiniDisplay',inc:'from yocto_display import *',cmt:'<p>The <tt>YDisplay</tt> class allows to drive Yoctopuce displays. Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p><p> In order to draw on the screen, you should use the <tt>display.get_displayLayer</tt> method to retrieve the layer(s) on which you want to draw, and then use methods defined in <tt>YDisplayLayer</tt> to draw on the layers.</p>'}
,'FindDisplay':{syn:'Retrieves a display for a given identifier.',lib:'YDisplay.FindDisplay()',pro:'FindDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the display, for instance <tt>YD128X32.display</tt>.'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'}
,'FirstDisplay':{syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay.FirstDisplay()',pro:'FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the display attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'copyLayerContent':{syn:'Copies the whole content of a layer to another layer.',lib:'%.copyLayerContent()',pro:'copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the display (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'fade':{syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'%.fade()',pro:'fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the display (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YDisplay.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_autoInvertDelay':{syn:'Returns the interval between automatic display inversions, or 0 if automatic inversion is disabled.',lib:'%.get_autoInvertDelay()',pro:'get_autoInvertDelay()',cmt:'<p>Returns the interval between automatic display inversions, or 0 if automatic inversion is disabled. Using the automatic inversion mechanism reduces the burn-in that occurs on OLED screens over long periods when the same content remains displayed on the screen.</p>',ret:'an integer corresponding to the interval between automatic display inversions, or 0 if automatic inversion is disabled',ext:'On failure, throws an exception or returns <tt>YDisplay.AUTOINVERTDELAY_INVALID</tt>.'}
,'get_brightness':{syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'%.get_brightness()',pro:'get_brightness()',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>YDisplay.BRIGHTNESS_INVALID</tt>.'}
,'get_displayHeight':{syn:'Returns the display height, in pixels.',lib:'%.get_displayHeight()',pro:'get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>YDisplay.DISPLAYHEIGHT_INVALID</tt>.'}
,'get_displayLayer':{syn:'Returns a YDisplayLayer object that can be used to draw on the specified layer.',lib:'%.get_displayLayer()',pro:'get_displayLayer(<span id=pn>layerId</span>)',cmt:'<p>Returns a YDisplayLayer object that can be used to draw on the specified layer. The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>',par:{layerId:'the identifier of the layer (a number in range 0..layerCount-1)'},ret:'an <tt>YDisplayLayer</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'}
,'get_displayPanel':{syn:'Returns the exact model of the display panel.',lib:'%.get_displayPanel()',pro:'get_displayPanel()',cmt:'<p>Returns the exact model of the display panel.</p>',ret:'a string corresponding to the exact model of the display panel',ext:'On failure, throws an exception or returns <tt>YDisplay.DISPLAYPANEL_INVALID</tt>.'}
,'get_displayType':{syn:'Returns the display type: monochrome, gray levels or full color.',lib:'%.get_displayType()',pro:'get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>YDisplay.DISPLAYTYPE_MONO</tt>, <tt>YDisplay.DISPLAYTYPE_GRAY</tt>, <tt>YDisplay.DISPLAYTYPE_RGB</tt> and <tt>YDisplay.DISPLAYTYPE_EPAPER</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>YDisplay.DISPLAYTYPE_INVALID</tt>.'}
,'get_displayWidth':{syn:'Returns the display width, in pixels.',lib:'%.get_displayWidth()',pro:'get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>YDisplay.DISPLAYWIDTH_INVALID</tt>.'}
,'get_enabled':{syn:'Returns true if the screen is powered, false otherwise.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>YDisplay.ENABLED_FALSE</tt> or <tt>YDisplay.ENABLED_TRUE</tt>, according to true if the screen is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>YDisplay.ENABLED_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the display.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the display object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the display.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the display object'}
,'get_friendlyName':{syn:'Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the display if they are defined, otherwise the serial number of the module and the hardware identifier of the display (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the display using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDisplay.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the display, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the display, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the display (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDisplay.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the display (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the display (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDisplay.HARDWAREID_INVALID</tt>.'}
,'get_layerCount':{syn:'Returns the number of available layers to draw on.',lib:'%.get_layerCount()',pro:'get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>YDisplay.LAYERCOUNT_INVALID</tt>.'}
,'get_layerHeight':{syn:'Returns the height of the layers to draw on, in pixels.',lib:'%.get_layerHeight()',pro:'get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>YDisplay.LAYERHEIGHT_INVALID</tt>.'}
,'get_layerWidth':{syn:'Returns the width of the layers to draw on, in pixels.',lib:'%.get_layerWidth()',pro:'get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>YDisplay.LAYERWIDTH_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the display.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:'On failure, throws an exception or returns <tt>YDisplay.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_orientation':{syn:'Returns the currently selected display orientation.',lib:'%.get_orientation()',pro:'get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>YDisplay.ORIENTATION_LEFT</tt>, <tt>YDisplay.ORIENTATION_UP</tt>, <tt>YDisplay.ORIENTATION_RIGHT</tt> and <tt>YDisplay.ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>YDisplay.ORIENTATION_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_startupSeq':{syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'%.get_startupSeq()',pro:'get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>YDisplay.STARTUPSEQ_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the display is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the display is currently reachable, without raising any error. If there is a cached value for the display in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the display.</p>',ret:'<tt>true</tt> if the display can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the display cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the display cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'newSequence':{syn:'Starts to record all display commands into a sequence, for later replay.',lib:'%.newSequence()',pro:'newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'nextDisplay':{syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'%.nextDisplay()',pro:'nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>. Caution: You can\x27t make any assumption about the returned displays order. If you want to find a specific a display, use <tt>Display.findDisplay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'}
,'pauseSequence':{syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'%.pauseSequence()',pro:'pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'playSequence':{syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'%.playSequence()',pro:'playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'postponeRefresh':{syn:'Disables screen refresh for a short period of time.',lib:'%.postponeRefresh()',pro:'postponeRefresh(<span id=pn>duration</span>)',cmt:'<p>Disables screen refresh for a short period of time. The combination of <tt>postponeRefresh</tt> and <tt>triggerRefresh</tt> can be used as an alternative to double-buffering to avoid flickering during display updates.</p>',par:{duration:'duration of deactivation in milliseconds (max. 30 seconds)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'readDisplay':{syn:'Returns a color image with the current content of the display.',lib:'%.readDisplay()',pro:'readDisplay(<span id=pn>palette</span>)',cmt:'<p>Returns a color image with the current content of the display. The image is returned as a binary object, where each byte represents a pixel, from left to right and from top to bottom. The palette used to map byte values to RGB colors is filled into the list provided as argument. In all cases, the first palette entry (value 0) corresponds to the screen default background color. The image dimensions are given by the display width and height.</p>',par:{palette:'a list to be filled with the image palette'},ret:'a binary object if the call succeeds.',ext:'On failure, throws an exception or returns an empty binary object.'}
,'regenerateDisplay':{syn:'Forces an ePaper screen to perform a regenerative update using the slow update method.',lib:'%.regenerateDisplay()',pro:'regenerateDisplay()',cmt:'<p>Forces an ePaper screen to perform a regenerative update using the slow update method. Periodic use of the slow method (total panel update with multiple inversions) prevents ghosting effects and improves contrast.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'resetAll':{syn:'Clears the display screen and resets all display layers to their default state.',lib:'%.resetAll()',pro:'resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'saveSequence':{syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'%.saveSequence()',pro:'saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_autoInvertDelay':{syn:'Changes the interval between automatic display inversions.',lib:'%.set_autoInvertDelay()',pro:'set_autoInvertDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the interval between automatic display inversions. The parameter is the number of seconds, or 0 to disable automatic inversion. Using the automatic inversion mechanism reduces the burn-in that occurs on OLED screens over long periods when the same content remains displayed on the screen. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the interval between automatic display inversions'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_brightness':{syn:'Changes the brightness of the display.',lib:'%.set_brightness()',pro:'set_brightness(<span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_displayPanel':{syn:'Changes the model of display to match the connected display panel.',lib:'%.set_displayPanel()',pro:'set_displayPanel(<span id=pn>newval</span>)',cmt:'<p>Changes the model of display to match the connected display panel. This function has no effect if the module does not support the selected display panel. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the model of display to match the connected display panel'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabled':{syn:'Changes the power state of the display.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>YDisplay.ENABLED_FALSE</tt> or <tt>YDisplay.ENABLED_TRUE</tt>, according to the power state of the display'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the display.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_orientation':{syn:'Changes the display orientation.',lib:'%.set_orientation()',pro:'set_orientation(<span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YDisplay.ORIENTATION_LEFT</tt>, <tt>YDisplay.ORIENTATION_UP</tt>, <tt>YDisplay.ORIENTATION_RIGHT</tt> and <tt>YDisplay.ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupSeq':{syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'%.set_startupSeq()',pro:'set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'stopSequence':{syn:'Stops immediately any ongoing sequence replay.',lib:'%.stopSequence()',pro:'stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'swapLayerContent':{syn:'Swaps the whole content of two layers.',lib:'%.swapLayerContent()',pro:'swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between one hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerRefresh':{syn:'Trigger an immediate screen refresh.',lib:'%.triggerRefresh()',pro:'triggerRefresh()',cmt:'<p>Trigger an immediate screen refresh. The combination of <tt>postponeRefresh</tt> and <tt>triggerRefresh</tt> can be used as an alternative to double-buffering to avoid flickering during display updates.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'upload':{syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'%.upload()',pro:'upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'Interface for drawing into display layers, obtained by calling <tt>display.get_displayLayer</tt>.',inc:'from yocto_display import *',cmt:'<p>Each <tt>DisplayLayer</tt> represents an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}
,'clear':{syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'%.clear()',pro:'clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearConsole':{syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'%.clearConsole()',pro:'clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'consoleOut':{syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'%.consoleOut()',pro:'consoleOut(<span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawBar':{syn:'Draws a filled rectangular bar at a specified position.',lib:'%.drawBar()',pro:'drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawBitmap':{syn:'Draws a bitmap at the specified position.',lib:'%.drawBitmap()',pro:'drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawCircle':{syn:'Draws an empty circle at a specified position.',lib:'%.drawCircle()',pro:'drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawDisc':{syn:'Draws a filled disc at a given position.',lib:'%.drawDisc()',pro:'drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawImage':{syn:'Draws a GIF image at the specified position.',lib:'%.drawImage()',pro:'drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawPixel':{syn:'Draws a single pixel at the specified position.',lib:'%.drawPixel()',pro:'drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawRect':{syn:'Draws an empty rectangle at a specified position.',lib:'%.drawRect()',pro:'drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'drawText':{syn:'Draws a text string at the specified position.',lib:'%.drawText()',pro:'drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>YDisplayLayer.ALIGN</tt> enumeration: <tt>YDisplayLayer.ALIGN_TOP_LEFT</tt>, <tt>YDisplayLayer.ALIGN_CENTER_LEFT</tt>, <tt>YDisplayLayer.ALIGN_BASELINE_LEFT</tt>, <tt>YDisplayLayer.ALIGN_BOTTOM_LEFT</tt>, <tt>YDisplayLayer.ALIGN_TOP_CENTER</tt>, <tt>YDisplayLayer.ALIGN_CENTER</tt>, <tt>YDisplayLayer.ALIGN_BASELINE_CENTER</tt>, <tt>YDisplayLayer.ALIGN_BOTTOM_CENTER</tt>, <tt>YDisplayLayer.ALIGN_TOP_DECIMAL</tt>, <tt>YDisplayLayer.ALIGN_CENTER_DECIMAL</tt>, <tt>YDisplayLayer.ALIGN_BASELINE_DECIMAL</tt>, <tt>YDisplayLayer.ALIGN_BOTTOM_DECIMAL</tt>, <tt>YDisplayLayer.ALIGN_TOP_RIGHT</tt>, <tt>YDisplayLayer.ALIGN_CENTER_RIGHT</tt>, <tt>YDisplayLayer.ALIGN_BASELINE_RIGHT</tt>, <tt>YDisplayLayer.ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_display':{syn:'Gets parent YDisplay.',lib:'%.get_display()',pro:'get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'}
,'get_displayHeight':{syn:'Returns the display height, in pixels.',lib:'%.get_displayHeight()',pro:'get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.'}
,'get_displayWidth':{syn:'Returns the display width, in pixels.',lib:'%.get_displayWidth()',pro:'get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.'}
,'get_layerHeight':{syn:'Returns the height of the layers to draw on, in pixels.',lib:'%.get_layerHeight()',pro:'get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.'}
,'get_layerWidth':{syn:'Returns the width of the layers to draw on, in pixels.',lib:'%.get_layerWidth()',pro:'get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.'}
,'hide':{syn:'Hides the layer.',lib:'%.hide()',pro:'hide()',cmt:'<p>Hides the layer. The state of the layer is preserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'lineTo':{syn:'Draws a line from current drawing pointer position to the specified position.',lib:'%.lineTo()',pro:'lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'moveTo':{syn:'Moves the drawing pointer of this layer to the specified position.',lib:'%.moveTo()',pro:'moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'reset':{syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'%.reset()',pro:'reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectColorPen':{syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'%.selectColorPen()',pro:'selectColorPen(<span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectEraser':{syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'%.selectEraser()',pro:'selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectFont':{syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'%.selectFont()',pro:'selectFont(<span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name, embedded fonts are 8x8.yfm, Small.yfm, Medium.yfm, Large.yfm (not available on Yocto-MiniDisplay).'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectGrayPen':{syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'%.selectGrayPen()',pro:'selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lightest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setAntialiasingMode':{syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'%.setAntialiasingMode()',pro:'setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzziness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<tt>true</tt> to enable anti-aliasing, <tt>false</tt> to disable it.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setConsoleBackground':{syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'%.setConsoleBackground()',pro:'setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setConsoleMargins':{syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'%.setConsoleMargins()',pro:'setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setConsoleWordWrap':{syn:'Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.',lib:'%.setConsoleWordWrap()',pro:'setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setLayerPosition':{syn:'Sets the position of the layer relative to the display upper left corner.',lib:'%.setLayerPosition()',pro:'setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unhide':{syn:'Shows the layer.',lib:'%.unhide()',pro:'unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: DisplayLayer)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'Dual power switch control interface, available for instance in the Yocto-Servo',inc:'from yocto_dualpower import *',cmt:'<p>The <tt>YDualPower</tt> class allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}
,'FindDualPower':{syn:'Retrieves a dual power switch for a given identifier.',lib:'YDualPower.FindDualPower()',pro:'FindDualPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power switch for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the dual power switch is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the dual power switch is indeed online at a given time. In case of ambiguity when looking for a dual power switch by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the dual power switch, for instance <tt>SERVORC1.dualPower</tt>.'},ret:'a <tt>YDualPower</tt> object allowing you to drive the dual power switch.'}
,'FirstDualPower':{syn:'Starts the enumeration of dual power switches currently accessible.',lib:'YDualPower.FirstDualPower()',pro:'FirstDualPower()',cmt:'<p>Starts the enumeration of dual power switches currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power switches.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power switch currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the dual power switch attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the dual power switch in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the dual power switch in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the dual power switch (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the dual power switch (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the dual power switch (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the dual power switch (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YDualPower.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the dual power switch.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the dual power switch. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the dual power switch object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the dual power switch.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the dual power switch. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the dual power switch object'}
,'get_extVoltage':{syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'%.get_extVoltage()',pro:'get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>YDualPower.EXTVOLTAGE_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the dual power switch in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the dual power switch in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the dual power switch if they are defined, otherwise the serial number of the module and the hardware identifier of the dual power switch (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the dual power switch using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDualPower.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the dual power switch, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the dual power switch, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the dual power switch (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDualPower.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the dual power switch in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the dual power switch in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the dual power switch (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the dual power switch (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YDualPower.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the dual power switch.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the dual power switch.</p>',ret:'a string corresponding to the logical name of the dual power switch.',ext:'On failure, throws an exception or returns <tt>YDualPower.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_powerControl':{syn:'Returns the selected power source for module functions that require lots of current.',lib:'%.get_powerControl()',pro:'get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>YDualPower.POWERCONTROL_AUTO</tt>, <tt>YDualPower.POWERCONTROL_FROM_USB</tt>, <tt>YDualPower.POWERCONTROL_FROM_EXT</tt> and <tt>YDualPower.POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>YDualPower.POWERCONTROL_INVALID</tt>.'}
,'get_powerState':{syn:'Returns the current power source for module functions that require lots of current.',lib:'%.get_powerState()',pro:'get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>YDualPower.POWERSTATE_OFF</tt>, <tt>YDualPower.POWERSTATE_FROM_USB</tt> and <tt>YDualPower.POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>YDualPower.POWERSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the dual power switch is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the dual power switch is currently reachable, without raising any error. If there is a cached value for the dual power switch in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the dual power switch.</p>',ret:'<tt>true</tt> if the dual power switch can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the dual power switch cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the dual power switch cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextDualPower':{syn:'Continues the enumeration of dual power switches started using <tt>yFirstDualPower()</tt>.',lib:'%.nextDualPower()',pro:'nextDualPower()',cmt:'<p>Continues the enumeration of dual power switches started using <tt>yFirstDualPower()</tt>. Caution: You can\x27t make any assumption about the returned dual power switches order. If you want to find a specific a dual power switch, use <tt>DualPower.findDualPower()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power switch currently online, or a <tt>null</tt> pointer if there are no more dual power switches to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the dual power switch.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the dual power switch. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the dual power switch.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_powerControl':{syn:'Changes the selected power source for module functions that require lots of current.',lib:'%.set_powerControl()',pro:'set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YDualPower.POWERCONTROL_AUTO</tt>, <tt>YDualPower.POWERCONTROL_FROM_USB</tt>, <tt>YDualPower.POWERCONTROL_FROM_EXT</tt> and <tt>YDualPower.POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: DualPower)
//--- (generated code: FileRecord)
doc['FileRecord']={'':{syn:'Description of a file on the device filesystem, returned by <tt>files.get_list</tt>',inc:'from yocto_files import *',cmt:'<p><tt>YFileRecord</tt> objects are used to describe a file that is stored on a Yoctopuce device. These objects are used in particular in conjunction with the <tt>YFiles</tt> class.</p>'}
,'get_crc':{syn:'Returns the 32-bit CRC of the file content.',lib:'%.get_crc()',pro:'get_crc()',cmt:'<p>Returns the 32-bit CRC of the file content.</p>',ret:'the 32-bit CRC of the file content.'}
,'get_name':{syn:'Returns the name of the file.',lib:'%.get_name()',pro:'get_name()',cmt:'<p>Returns the name of the file.</p>',ret:'a string with the name of the file.'}
,'get_size':{syn:'Returns the size of the file in bytes.',lib:'%.get_size()',pro:'get_size()',cmt:'<p>Returns the size of the file in bytes.</p>',ret:'the size of the file.'}
};
//--- (end of generated code: FileRecord)
//--- (generated code: Files)
doc['Files']={'':{syn:'Filesystem control interface, available for instance in the Yocto-Color-V2, the Yocto-SPI, the YoctoHub-Ethernet or the YoctoHub-GSM-4G',inc:'from yocto_files import *',cmt:'<p>The YFiles class is used to access the filesystem embedded on some Yoctopuce devices. This filesystem makes it possible for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}
,'FindFiles':{syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles.FindFiles()',pro:'FindFiles(<span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the filesystem, for instance <tt>YRGBLED2.files</tt>.'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'}
,'FirstFiles':{syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles.FirstFiles()',pro:'FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the filesystem attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the filesystem (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'download':{syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'%.download()',pro:'download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'}
,'fileExist':{syn:'Tests if a file exists on the filesystem of the module.',lib:'%.fileExist()',pro:'fileExist(<span id=pn>filename</span>)',cmt:'<p>Tests if a file exists on the filesystem of the module.</p>',par:{filename:'the filename to test.'},ret:'true if the file exists, false otherwise.',ext:'On failure, throws an exception.'}
,'format_fs':{syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'%.format_fs()',pro:'format_fs()',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YFiles.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_content_crc':{syn:'Returns the expected file CRC for a given content.',lib:'%.get_content_crc()',pro:'get_content_crc(<span id=pn>content</span>)',cmt:'<p>Returns the expected file CRC for a given content. Note that the CRC value may vary depending on the version of the filesystem used by the hub, so it is important to use this method if a reference value needs to be computed.</p>',par:{content:'a buffer representing a file content'},ret:'the 32-bit CRC summarizing the file content, as it would be returned by the <tt>get_crc()</tt> method of <tt>YFileRecord</tt> objects returned by <tt>get_list()</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the filesystem.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the filesystem object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the filesystem.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the filesystem object'}
,'get_filesCount':{syn:'Returns the number of files currently loaded in the filesystem.',lib:'%.get_filesCount()',pro:'get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>YFiles.FILESCOUNT_INVALID</tt>.'}
,'get_freeSpace':{syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'%.get_freeSpace()',pro:'get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>YFiles.FREESPACE_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the filesystem if they are defined, otherwise the serial number of the module and the hardware identifier of the filesystem (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the filesystem using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YFiles.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the filesystem, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the filesystem, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the filesystem (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YFiles.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the filesystem (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the filesystem (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YFiles.HARDWAREID_INVALID</tt>.'}
,'get_list':{syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'%.get_list()',pro:'get_list(<span id=pn>pattern</span>)',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wild cards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:'On failure, throws an exception or returns an empty list.'}
,'get_logicalName':{syn:'Returns the logical name of the filesystem.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:'On failure, throws an exception or returns <tt>YFiles.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the filesystem is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the filesystem is currently reachable, without raising any error. If there is a cached value for the filesystem in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the filesystem.</p>',ret:'<tt>true</tt> if the filesystem can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the filesystem cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the filesystem cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextFiles':{syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'%.nextFiles()',pro:'nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>. Caution: You can\x27t make any assumption about the returned filesystems order. If you want to find a specific a filesystem, use <tt>Files.findFiles()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'remove':{syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'%.remove()',pro:'remove(<span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the filesystem.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'upload':{syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'%.upload()',pro:'upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Files)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Firmware update process control interface, returned by <tt>module.updateFirmware</tt> method.',inc:'from yocto_module import *',cmt:'<p>The <tt>YFirmwareUpdate</tt> class let you control the firmware update of a Yoctopuce module. This class should not be instantiate directly, but instances should be retrieved using the <tt>YModule</tt> method <tt>module.updateFirmware</tt>.</p>'}
,'CheckFirmware':{syn:'Test if the byn file is valid for this module.',lib:'YFirmwareUpdate.CheckFirmware()',pro:'CheckFirmware(<span id=pn>serial</span>, <span id=pn>path</span>, <span id=pn>minrelease</span>)',cmt:'<p>Test if the byn file is valid for this module. It is possible to pass a directory instead of a file. In that case, this method returns the path of the most recent appropriate byn file. This method will ignore any firmware older than minrelease.</p>',par:{serial:'the serial number of the module to update',path:'the path of a byn file or a directory that contains byn files',minrelease:'a positive integer'},ret:': the path of the byn file to use, or an empty string if no byn files matches the requirement',ext:'On failure, returns a string that starts with \x22error:\x22.'}
,'GetAllBootLoaders':{syn:'Returns a list of all the modules in \x22firmware update\x22 mode.',lib:'YFirmwareUpdate.GetAllBootLoaders()',pro:'GetAllBootLoaders()',cmt:'<p>Returns a list of all the modules in \x22firmware update\x22 mode.</p>',ret:'an array of strings containing the serial numbers of devices in \x22firmware update\x22 mode.'}
,'get_progress':{syn:'Returns the progress of the firmware update, on a scale from 0 to 100.',lib:'%.get_progress()',pro:'get_progress()',cmt:'<p>Returns the progress of the firmware update, on a scale from 0 to 100. When the object is instantiated, the progress is zero. The value is updated during the firmware update process until the value of 100 is reached. The 100 value means that the firmware update was completed successfully. If an error occurs during the firmware update, a negative value is returned, and the error message can be retrieved with <tt>get_progressMessage</tt>.</p>',ret:'an integer in the range 0 to 100 (percentage of completion) or a negative error code in case of failure.'}
,'get_progressMessage':{syn:'Returns the last progress message of the firmware update process.',lib:'%.get_progressMessage()',pro:'get_progressMessage()',cmt:'<p>Returns the last progress message of the firmware update process. If an error occurs during the firmware update process, the error message is returned</p>',ret:'a string with the latest progress message, or the error message.'}
,'startUpdate':{syn:'Starts the firmware update process.',lib:'%.startUpdate()',pro:'startUpdate()',cmt:'<p>Starts the firmware update process. This method starts the firmware update process in background. This method returns immediately. You can monitor the progress of the firmware update with the <tt>get_progress()</tt> and <tt>get_progressMessage()</tt> methods.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure returns a negative error code.'}
};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor control interface, available for instance in the Yocto-0-10V-Rx, the Yocto-4-20mA-Rx, the Yocto-Bridge or the Yocto-milliVolt-Rx',inc:'from yocto_genericsensor import *',cmt:'<p>The <tt>YGenericSensor</tt> class allows you to read and configure Yoctopuce signal transducers. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}
,'FindGenericSensor':{syn:'Retrieves a generic sensor for a given identifier.',lib:'YGenericSensor.FindGenericSensor()',pro:'FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a generic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the generic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGenericSensor.isOnline()</tt> to test if the generic sensor is indeed online at a given time. In case of ambiguity when looking for a generic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the generic sensor, for instance <tt>RX010V01.genericSensor1</tt>.'},ret:'a <tt>YGenericSensor</tt> object allowing you to drive the generic sensor.'}
,'FirstGenericSensor':{syn:'Starts the enumeration of generic sensors currently accessible.',lib:'YGenericSensor.FirstGenericSensor()',pro:'FirstGenericSensor()',cmt:'<p>Starts the enumeration of generic sensors currently accessible. Use the method <tt>YGenericSensor.nextGenericSensor()</tt> to iterate on next generic sensors.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to the first generic sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the generic sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the generic sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YGenericSensor.ADVMODE_IMMEDIATE</tt>, <tt>YGenericSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YGenericSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YGenericSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YGenericSensor.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YGenericSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>YGenericSensor.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current measured value.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>YGenericSensor.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_enabled':{syn:'Returns the activation state of this input.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns the activation state of this input.</p>',ret:'either <tt>YGenericSensor.ENABLED_FALSE</tt> or <tt>YGenericSensor.ENABLED_TRUE</tt>, according to the activation state of this input',ext:'On failure, throws an exception or returns <tt>YGenericSensor.ENABLED_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the generic sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the generic sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the generic sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the generic sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the generic sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the generic sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the generic sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGenericSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the generic sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the generic sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the generic sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGenericSensor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the generic sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the generic sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGenericSensor.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YGenericSensor.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YGenericSensor.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the generic sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:'On failure, throws an exception or returns <tt>YGenericSensor.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YGenericSensor.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YGenericSensor.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YGenericSensor.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signalBias':{syn:'Returns the electric signal bias for zero shift adjustment.',lib:'%.get_signalBias()',pro:'get_signalBias()',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is under-reporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SIGNALBIAS_INVALID</tt>.'}
,'get_signalRange':{syn:'Returns the input signal range used by the sensor.',lib:'%.get_signalRange()',pro:'get_signalRange()',cmt:'<p>Returns the input signal range used by the sensor.</p>',ret:'a string corresponding to the input signal range used by the sensor',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SIGNALRANGE_INVALID</tt>.'}
,'get_signalSampling':{syn:'Returns the electric signal sampling method to use.',lib:'%.get_signalSampling()',pro:'get_signalSampling()',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>YGenericSensor.SIGNALSAMPLING_HIGH_RATE</tt>, <tt>YGenericSensor.SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>YGenericSensor.SIGNALSAMPLING_LOW_NOISE</tt>, <tt>YGenericSensor.SIGNALSAMPLING_LOW_NOISE_FILTERED</tt>, <tt>YGenericSensor.SIGNALSAMPLING_HIGHEST_RATE</tt> and <tt>YGenericSensor.SIGNALSAMPLING_AC</tt> corresponding to the electric signal sampling method to use',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SIGNALSAMPLING_INVALID</tt>.'}
,'get_signalUnit':{syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'%.get_signalUnit()',pro:'get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SIGNALUNIT_INVALID</tt>.'}
,'get_signalValue':{syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'%.get_signalValue()',pro:'get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>YGenericSensor.SIGNALVALUE_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>YGenericSensor.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_valueRange':{syn:'Returns the physical value range measured by the sensor.',lib:'%.get_valueRange()',pro:'get_valueRange()',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:'On failure, throws an exception or returns <tt>YGenericSensor.VALUERANGE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the generic sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the generic sensor is currently reachable, without raising any error. If there is a cached value for the generic sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the generic sensor.</p>',ret:'<tt>true</tt> if the generic sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the generic sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the generic sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextGenericSensor':{syn:'Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.',lib:'%.nextGenericSensor()',pro:'nextGenericSensor()',cmt:'<p>Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>. Caution: You can\x27t make any assumption about the returned generic sensors order. If you want to find a specific a generic sensor, use <tt>GenericSensor.findGenericSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to a generic sensor currently online, or a <tt>null</tt> pointer if there are no more generic sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YGenericSensor.ADVMODE_IMMEDIATE</tt>, <tt>YGenericSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YGenericSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YGenericSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabled':{syn:'Changes the activation state of this input.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of this input. When an input is disabled, its value is no more updated. On some devices, disabling an input can improve the refresh rate of the other active inputs. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YGenericSensor.ENABLED_FALSE</tt> or <tt>YGenericSensor.ENABLED_TRUE</tt>, according to the activation state of this input'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the generic sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the generic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':{syn:'Modifies the resolution of the measured physical values.',lib:'%.set_resolution()',pro:'set_resolution(<span id=pn>newval</span>)',cmt:'<p>Modifies the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself. This feature is very handy when one need to publish values through callbacks with a specific resolution. The new resolution is specified a floating point value such as 1.0, 0.1, 0.01, 0.02, 0.05 etc.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_signalBias':{syn:'Changes the electric signal bias for zero shift adjustment.',lib:'%.set_signalBias()',pro:'set_signalBias(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positive when it should be zero, set up a positive signalBias of the same value to fix the zero shift. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_signalRange':{syn:'Changes the input signal range used by the sensor.',lib:'%.set_signalRange()',pro:'set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Changes the input signal range used by the sensor. When the input signal gets out of the planned range, the output value will be set to an arbitrary large value, whose sign indicates the direction of the range overrun.</p><p> For a 4-20mA sensor, the default input signal range is \x224...20\x22. For a 0-10V sensor, the default input signal range is \x220.1...10\x22. For numeric communication interfaces, the default input signal range is \x22-999999.999...999999.999\x22.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the input signal range used by the sensor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_signalSampling':{syn:'Changes the electric signal sampling method to use.',lib:'%.set_signalSampling()',pro:'set_signalSampling(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YGenericSensor.SIGNALSAMPLING_HIGH_RATE</tt>, <tt>YGenericSensor.SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>YGenericSensor.SIGNALSAMPLING_LOW_NOISE</tt>, <tt>YGenericSensor.SIGNALSAMPLING_LOW_NOISE_FILTERED</tt>, <tt>YGenericSensor.SIGNALSAMPLING_HIGHEST_RATE</tt> and <tt>YGenericSensor.SIGNALSAMPLING_AC</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the measured value.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_valueRange':{syn:'Changes the output value range, corresponding to the physical value measured by the sensor.',lib:'%.set_valueRange()',pro:'set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Changes the output value range, corresponding to the physical value measured by the sensor. The default output value range is the same as the input signal range (1:1 mapping), but you can change it so that the function automatically computes the physical value encoded by the input signal. Be aware that, as a side effect, the range modification may automatically modify the display resolution.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the output value range, corresponding to the physical value measured by the sensor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'zeroAdjust':{syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'%.zeroAdjust()',pro:'zeroAdjust()',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: GenericSensor)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'Geolocalization control interface (GPS, GNSS, ...), available for instance in the Yocto-GPS-V2',inc:'from yocto_gps import *',cmt:'<p>The <tt>YGps</tt> class allows you to retrieve positioning data from a GPS/GNSS sensor. This class can provides complete positioning information. However, if you wish to define callbacks on position changes or record the position in the datalogger, you should use the <tt>YLatitude</tt> et <tt>YLongitude</tt> classes.</p>'}
,'FindGps':{syn:'Retrieves a geolocalization module for a given identifier.',lib:'YGps.FindGps()',pro:'FindGps(<span id=pn>func</span>)',cmt:'<p>Retrieves a geolocalization module for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the geolocalization module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGps.isOnline()</tt> to test if the geolocalization module is indeed online at a given time. In case of ambiguity when looking for a geolocalization module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the geolocalization module, for instance <tt>YGNSSMK2.gps</tt>.'},ret:'a <tt>YGps</tt> object allowing you to drive the geolocalization module.'}
,'FirstGps':{syn:'Starts the enumeration of geolocalization modules currently accessible.',lib:'YGps.FirstGps()',pro:'FirstGps()',cmt:'<p>Starts the enumeration of geolocalization modules currently accessible. Use the method <tt>YGps.nextGps()</tt> to iterate on next geolocalization modules.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to the first geolocalization module currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the geolocalization module attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the geolocalization module in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the geolocalization module in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the geolocalization module (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the geolocalization module (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the geolocalization module (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the geolocalization module (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YGps.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_altitude':{syn:'Returns the current altitude.',lib:'%.get_altitude()',pro:'get_altitude()',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:'On failure, throws an exception or returns <tt>YGps.ALTITUDE_INVALID</tt>.'}
,'get_constellation':{syn:'Returns the the satellites constellation used to compute positioning data.',lib:'%.get_constellation()',pro:'get_constellation()',cmt:'<p>Returns the the satellites constellation used to compute positioning data.</p>',ret:'a value among <tt>YGps.CONSTELLATION_GNSS</tt>, <tt>YGps.CONSTELLATION_GPS</tt>, <tt>YGps.CONSTELLATION_GLONASS</tt>, <tt>YGps.CONSTELLATION_GALILEO</tt>, <tt>YGps.CONSTELLATION_GPS_GLONASS</tt>, <tt>YGps.CONSTELLATION_GPS_GALILEO</tt> and <tt>YGps.CONSTELLATION_GLONASS_GALILEO</tt> corresponding to the the satellites constellation used to compute positioning data',ext:'On failure, throws an exception or returns <tt>YGps.CONSTELLATION_INVALID</tt>.'}
,'get_coordSystem':{syn:'Returns the representation system used for positioning data.',lib:'%.get_coordSystem()',pro:'get_coordSystem()',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>YGps.COORDSYSTEM_GPS_DMS</tt>, <tt>YGps.COORDSYSTEM_GPS_DM</tt> and <tt>YGps.COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data',ext:'On failure, throws an exception or returns <tt>YGps.COORDSYSTEM_INVALID</tt>.'}
,'get_dateTime':{syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'%.get_dateTime()',pro:'get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>YGps.DATETIME_INVALID</tt>.'}
,'get_dilution':{syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'%.get_dilution()',pro:'get_dilution()',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:'On failure, throws an exception or returns <tt>YGps.DILUTION_INVALID</tt>.'}
,'get_direction':{syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'%.get_direction()',pro:'get_direction()',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:'On failure, throws an exception or returns <tt>YGps.DIRECTION_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the geolocalization module.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the geolocalization module. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the geolocalization module object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the geolocalization module.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the geolocalization module. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the geolocalization module object'}
,'get_friendlyName':{syn:'Returns a global identifier of the geolocalization module in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the geolocalization module in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the geolocalization module if they are defined, otherwise the serial number of the module and the hardware identifier of the geolocalization module (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the geolocalization module using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGps.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the geolocalization module, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the geolocalization module, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the geolocalization module (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGps.FUNCTIONID_INVALID</tt>.'}
,'get_gpsRefreshRate':{syn:'Returns effective GPS data refresh frequency.',lib:'%.get_gpsRefreshRate()',pro:'get_gpsRefreshRate()',cmt:'<p>Returns effective GPS data refresh frequency. this value is refreshed every 5 seconds only.</p>',ret:'a floating point number corresponding to effective GPS data refresh frequency',ext:'On failure, throws an exception or returns <tt>YGps.GPSREFRESHRATE_INVALID</tt>.'}
,'get_groundSpeed':{syn:'Returns the current ground speed in Km/h.',lib:'%.get_groundSpeed()',pro:'get_groundSpeed()',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:'On failure, throws an exception or returns <tt>YGps.GROUNDSPEED_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the geolocalization module in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the geolocalization module in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the geolocalization module (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the geolocalization module (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGps.HARDWAREID_INVALID</tt>.'}
,'get_isFixed':{syn:'Returns TRUE if the receiver has found enough satellites to work.',lib:'%.get_isFixed()',pro:'get_isFixed()',cmt:'<p>Returns TRUE if the receiver has found enough satellites to work.</p>',ret:'either <tt>YGps.ISFIXED_FALSE</tt> or <tt>YGps.ISFIXED_TRUE</tt>, according to TRUE if the receiver has found enough satellites to work',ext:'On failure, throws an exception or returns <tt>YGps.ISFIXED_INVALID</tt>.'}
,'get_latitude':{syn:'Returns the current latitude.',lib:'%.get_latitude()',pro:'get_latitude()',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:'On failure, throws an exception or returns <tt>YGps.LATITUDE_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the geolocalization module.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the geolocalization module.</p>',ret:'a string corresponding to the logical name of the geolocalization module.',ext:'On failure, throws an exception or returns <tt>YGps.LOGICALNAME_INVALID</tt>.'}
,'get_longitude':{syn:'Returns the current longitude.',lib:'%.get_longitude()',pro:'get_longitude()',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:'On failure, throws an exception or returns <tt>YGps.LONGITUDE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_satCount':{syn:'Returns the total count of satellites used to compute GPS position.',lib:'%.get_satCount()',pro:'get_satCount()',cmt:'<p>Returns the total count of satellites used to compute GPS position.</p>',ret:'an integer corresponding to the total count of satellites used to compute GPS position',ext:'On failure, throws an exception or returns <tt>YGps.SATCOUNT_INVALID</tt>.'}
,'get_satPerConst':{syn:'Returns the count of visible satellites per constellation encoded on a 32 bit integer: bits 0..',lib:'%.get_satPerConst()',pro:'get_satPerConst()',cmt:'<p>Returns the count of visible satellites per constellation encoded on a 32 bit integer: bits 0..5: GPS satellites count, bits 6..11 : Glonass, bits 12..17 : Galileo. this value is refreshed every 5 seconds only.</p>',ret:'an integer corresponding to the count of visible satellites per constellation encoded on a 32 bit integer: bits 0.',ext:'On failure, throws an exception or returns <tt>YGps.SATPERCONST_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unixTime':{syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'%.get_unixTime()',pro:'get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>YGps.UNIXTIME_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_utcOffset':{syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'%.get_utcOffset()',pro:'get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>YGps.UTCOFFSET_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the geolocalization module is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the geolocalization module is currently reachable, without raising any error. If there is a cached value for the geolocalization module in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the geolocalization module.</p>',ret:'<tt>true</tt> if the geolocalization module can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the geolocalization module cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the geolocalization module cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextGps':{syn:'Continues the enumeration of geolocalization modules started using <tt>yFirstGps()</tt>.',lib:'%.nextGps()',pro:'nextGps()',cmt:'<p>Continues the enumeration of geolocalization modules started using <tt>yFirstGps()</tt>. Caution: You can\x27t make any assumption about the returned geolocalization modules order. If you want to find a specific a geolocalization module, use <tt>Gps.findGps()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to a geolocalization module currently online, or a <tt>null</tt> pointer if there are no more geolocalization modules to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_constellation':{syn:'Changes the satellites constellation used to compute positioning data.',lib:'%.set_constellation()',pro:'set_constellation(<span id=pn>newval</span>)',cmt:'<p>Changes the satellites constellation used to compute positioning data. Possible constellations are GNSS ( = all supported constellations), GPS, Glonass, Galileo , and the 3 possible pairs. This setting has no effect on Yocto-GPS (V1).</p>',par:{newval:'a value among <tt>YGps.CONSTELLATION_GNSS</tt>, <tt>YGps.CONSTELLATION_GPS</tt>, <tt>YGps.CONSTELLATION_GLONASS</tt>, <tt>YGps.CONSTELLATION_GALILEO</tt>, <tt>YGps.CONSTELLATION_GPS_GLONASS</tt>, <tt>YGps.CONSTELLATION_GPS_GALILEO</tt> and <tt>YGps.CONSTELLATION_GLONASS_GALILEO</tt> corresponding to the satellites constellation used to compute positioning data'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_coordSystem':{syn:'Changes the representation system used for positioning data.',lib:'%.set_coordSystem()',pro:'set_coordSystem(<span id=pn>newval</span>)',cmt:'<p>Changes the representation system used for positioning data. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YGps.COORDSYSTEM_GPS_DMS</tt>, <tt>YGps.COORDSYSTEM_GPS_DM</tt> and <tt>YGps.COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the geolocalization module.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the geolocalization module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the geolocalization module.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_utcOffset':{syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'%.set_utcOffset()',pro:'set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Gps)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'Ground speed sensor control interface, available for instance in the Yocto-GPS-V2',inc:'from yocto_groundspeed import *',cmt:'<p>The <tt>YGroundSpeed</tt> class allows you to read and configure Yoctopuce ground speed sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindGroundSpeed':{syn:'Retrieves a ground speed sensor for a given identifier.',lib:'YGroundSpeed.FindGroundSpeed()',pro:'FindGroundSpeed(<span id=pn>func</span>)',cmt:'<p>Retrieves a ground speed sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the ground speed sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGroundSpeed.isOnline()</tt> to test if the ground speed sensor is indeed online at a given time. In case of ambiguity when looking for a ground speed sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the ground speed sensor, for instance <tt>YGNSSMK2.groundSpeed</tt>.'},ret:'a <tt>YGroundSpeed</tt> object allowing you to drive the ground speed sensor.'}
,'FirstGroundSpeed':{syn:'Starts the enumeration of ground speed sensors currently accessible.',lib:'YGroundSpeed.FirstGroundSpeed()',pro:'FirstGroundSpeed()',cmt:'<p>Starts the enumeration of ground speed sensors currently accessible. Use the method <tt>YGroundSpeed.nextGroundSpeed()</tt> to iterate on next ground speed sensors.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to the first ground speed sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the ground speed sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the ground speed sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YGroundSpeed.ADVMODE_IMMEDIATE</tt>, <tt>YGroundSpeed.ADVMODE_PERIOD_AVG</tt>, <tt>YGroundSpeed.ADVMODE_PERIOD_MIN</tt> and <tt>YGroundSpeed.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the ground speed sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the ground speed sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the ground speed sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the ground speed sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the ground speed sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the ground speed sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the ground speed sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the ground speed sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the ground speed sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the ground speed sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the ground speed sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the ground speed sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the ground speed sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the ground speed.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:'On failure, throws an exception or returns <tt>YGroundSpeed.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the ground speed sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the ground speed sensor is currently reachable, without raising any error. If there is a cached value for the ground speed sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the ground speed sensor.</p>',ret:'<tt>true</tt> if the ground speed sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the ground speed sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the ground speed sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextGroundSpeed':{syn:'Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.',lib:'%.nextGroundSpeed()',pro:'nextGroundSpeed()',cmt:'<p>Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>. Caution: You can\x27t make any assumption about the returned ground speed sensors order. If you want to find a specific a ground speed sensor, use <tt>GroundSpeed.findGroundSpeed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to a ground speed sensor currently online, or a <tt>null</tt> pointer if there are no more ground speed sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YGroundSpeed.ADVMODE_IMMEDIATE</tt>, <tt>YGroundSpeed.ADVMODE_PERIOD_AVG</tt>, <tt>YGroundSpeed.ADVMODE_PERIOD_MIN</tt> and <tt>YGroundSpeed.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the ground speed sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the ground speed sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: GroundSpeed)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope control interface, available for instance in the Yocto-3D-V2',inc:'from yocto_gyro import *',cmt:'<p>The <tt>YGyro</tt> class allows you to read and configure Yoctopuce gyroscopes. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the possibility to access x, y and z components of the rotation vector separately, as well as the possibility to deal with quaternion-based orientation estimates.</p>'}
,'FindGyro':{syn:'Retrieves a gyroscope for a given identifier.',lib:'YGyro.FindGyro()',pro:'FindGyro(<span id=pn>func</span>)',cmt:'<p>Retrieves a gyroscope for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the gyroscope is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGyro.isOnline()</tt> to test if the gyroscope is indeed online at a given time. In case of ambiguity when looking for a gyroscope by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the gyroscope, for instance <tt>Y3DMK002.gyro</tt>.'},ret:'a <tt>YGyro</tt> object allowing you to drive the gyroscope.'}
,'FirstGyro':{syn:'Starts the enumeration of gyroscopes currently accessible.',lib:'YGyro.FirstGyro()',pro:'FirstGyro()',cmt:'<p>Starts the enumeration of gyroscopes currently accessible. Use the method <tt>YGyro.nextGyro()</tt> to iterate on next gyroscopes.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to the first gyro currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the gyroscope attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the gyroscope (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YGyro.ADVMODE_IMMEDIATE</tt>, <tt>YGyro.ADVMODE_PERIOD_AVG</tt>, <tt>YGyro.ADVMODE_PERIOD_MIN</tt> and <tt>YGyro.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YGyro.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YGyro.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the measure update frequency, measured in Hz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz.</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz',ext:'On failure, throws an exception or returns <tt>YGyro.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGyro.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGyro.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the gyroscope.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the gyroscope object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the gyroscope.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the gyroscope object'}
,'get_friendlyName':{syn:'Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the gyroscope if they are defined, otherwise the serial number of the module and the hardware identifier of the gyroscope (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the gyroscope using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGyro.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the gyroscope, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the gyroscope, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the gyroscope (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGyro.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the gyroscope (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the gyroscope (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YGyro.HARDWAREID_INVALID</tt>.'}
,'get_heading':{syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_heading()',pro:'get_heading()',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>YGyro.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YGyro.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the gyroscope.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:'On failure, throws an exception or returns <tt>YGyro.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>YGyro.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_pitch':{syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_pitch()',pro:'get_pitch()',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'}
,'get_quaternionW':{syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_quaternionW()',pro:'get_quaternionW()',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.</p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'}
,'get_quaternionX':{syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_quaternionX()',pro:'get_quaternionX()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'}
,'get_quaternionY':{syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_quaternionY()',pro:'get_quaternionY()',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'}
,'get_quaternionZ':{syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_quaternionZ()',pro:'get_quaternionZ()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YGyro.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YGyro.RESOLUTION_INVALID</tt>.'}
,'get_roll':{syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'%.get_roll()',pro:'get_roll()',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YGyro.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the angular velocity.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:'On failure, throws an exception or returns <tt>YGyro.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_xValue':{syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'%.get_xValue()',pro:'get_xValue()',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGyro.XVALUE_INVALID</tt>.'}
,'get_yValue':{syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'%.get_yValue()',pro:'get_yValue()',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGyro.YVALUE_INVALID</tt>.'}
,'get_zValue':{syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'%.get_zValue()',pro:'get_zValue()',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>YGyro.ZVALUE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the gyroscope is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the gyroscope is currently reachable, without raising any error. If there is a cached value for the gyroscope in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the gyroscope.</p>',ret:'<tt>true</tt> if the gyroscope can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the gyroscope cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the gyroscope cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextGyro':{syn:'Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.',lib:'%.nextGyro()',pro:'nextGyro()',cmt:'<p>Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>. Caution: You can\x27t make any assumption about the returned gyroscopes order. If you want to find a specific a gyroscope, use <tt>Gyro.findGyro()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to a gyroscope currently online, or a <tt>null</tt> pointer if there are no more gyroscopes to enumerate.'}
,'registerAnglesCallback':{syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'%.registerAnglesCallback()',pro:'registerAnglesCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take four arguments: the YGyro object of the turning device, and the floating point values of the three angles roll, pitch and heading in degrees (as floating-point numbers).'}}
,'registerQuaternionCallback':{syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'%.registerQuaternionCallback()',pro:'registerQuaternionCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take five arguments: the YGyro object of the turning device, and the floating point values of the four components w, x, y and z (as floating-point numbers).'}}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YGyro.ADVMODE_IMMEDIATE</tt>, <tt>YGyro.ADVMODE_PERIOD_AVG</tt>, <tt>YGyro.ADVMODE_PERIOD_MIN</tt> and <tt>YGyro.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the measure update frequency, measured in Hz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz. When the frequency is lower, the device performs averaging. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the gyroscope.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the gyroscope. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Gyro)
//--- (generated code: Hub)
doc['Hub']={'':{syn:'YoctoHub or VirtualHub currently in use by the API.',inc:'from yocto_module import *'}
,'FindHubInUse':{syn:'Retrieves hub for a given identifier.',lib:'YHub.FindHubInUse()',pro:'FindHubInUse(<span id=pn>url</span>)',cmt:'<p>Retrieves hub for a given identifier. The identifier can be the URL or the serial of the hub.</p>',par:{url:'The url or serial of the hub.'},ret:'a pointer to a <tt>YHub</tt> object, corresponding to the first hub currently in use by the API, or a <tt>null</tt> pointer if none has been registered.'}
,'FirstHubInUse':{syn:'Starts the enumeration of hubs currently in use by the API.',lib:'YHub.FirstHubInUse()',pro:'FirstHubInUse()',cmt:'<p>Starts the enumeration of hubs currently in use by the API. Use the method <tt>YHub.nextHubInUse()</tt> to iterate on the next hubs.</p>',ret:'a pointer to a <tt>YHub</tt> object, corresponding to the first hub currently in use by the API, or a <tt>null</tt> pointer if none has been registered.'}
,'get_connectionState':{syn:'Returns the state of the connection with this hub.',lib:'%.get_connectionState()',pro:'get_connectionState()',cmt:'<p>Returns the state of the connection with this hub. (TRYING, CONNECTED, RECONNECTING, ABORTED, UNREGISTERED)</p>'}
,'get_connectionUrl':{syn:'Returns the URL currently in use to communicate with this hub.',lib:'%.get_connectionUrl()',pro:'get_connectionUrl()',cmt:'<p>Returns the URL currently in use to communicate with this hub.</p>'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the hub.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the hub. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the hub object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the hub.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the hub. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the hub object'}
,'get_knownUrls':{syn:'Returns all known URLs that have been used to register this hub.',lib:'%.get_knownUrls()',pro:'get_knownUrls()',cmt:'<p>Returns all known URLs that have been used to register this hub. URLs are pointing to the same hub when the devices connected are sharing the same serial number.</p>'}
,'get_networkTimeout':{syn:'Returns the network connection delay for this hub.',lib:'%.get_networkTimeout()',pro:'get_networkTimeout()',cmt:'<p>Returns the network connection delay for this hub. The default value is inherited from <tt>ySetNetworkTimeout</tt> at the time when the hub is registered, but it can be updated afterward for each specific hub if necessary.</p>',ret:'the network connection delay in milliseconds.'}
,'get_registeredUrl':{syn:'Returns the URL that has been used first to register this hub.',lib:'%.get_registeredUrl()',pro:'get_registeredUrl()',cmt:'<p>Returns the URL that has been used first to register this hub.</p>'}
,'get_serialNumber':{syn:'Returns the hub serial number, if the hub was already connected once.',lib:'%.get_serialNumber()',pro:'get_serialNumber()',cmt:'<p>Returns the hub serial number, if the hub was already connected once.</p>'}
,'get_userData':ds.get_userData
,'isInUse':{syn:'Tells if this hub is still registered within the API.',lib:'%.isInUse()',pro:'isInUse()',cmt:'<p>Tells if this hub is still registered within the API.</p>',ret:'<tt>true</tt> if the hub has not been unregistered.'}
,'isOnline':{syn:'Tells if there is an active communication channel with this hub.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Tells if there is an active communication channel with this hub.</p>',ret:'<tt>true</tt> if the hub is currently connected.'}
,'isReadOnly':{syn:'Tells if write access on this hub is blocked.',lib:'%.isReadOnly()',pro:'isReadOnly()',cmt:'<p>Tells if write access on this hub is blocked. Return <tt>true</tt> if it is not possible to change attributes on this hub</p>',ret:'<tt>true</tt> if it is not possible to change attributes on this hub.'}
,'nextHubInUse':{syn:'Continues the module enumeration started using <tt>YHub.FirstHubInUse()</tt>.',lib:'%.nextHubInUse()',pro:'nextHubInUse()',cmt:'<p>Continues the module enumeration started using <tt>YHub.FirstHubInUse()</tt>. Caution: You can\x27t make any assumption about the order of returned hubs.</p>',ret:'a pointer to a <tt>YHub</tt> object, corresponding to the next hub currently in use, or a <tt>null</tt> pointer if there are no more hubs to enumerate.'}
,'set_networkTimeout':{syn:'Modifies tthe network connection delay for this hub.',lib:'%.set_networkTimeout()',pro:'set_networkTimeout(<span id=pn>networkMsTimeout</span>)',cmt:'<p>Modifies tthe network connection delay for this hub. The default value is inherited from <tt>ySetNetworkTimeout</tt> at the time when the hub is registered, but it can be updated afterward for each specific hub if necessary.</p>',par:{networkMsTimeout:'the network connection delay in milliseconds.'}}
,'set_userData':ds.set_userData
};
//--- (end of generated code: Hub)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'YoctoHub slave port control interface, available for instance in the YoctoHub-Ethernet, the YoctoHub-GSM-4G, the YoctoHub-Shield or the YoctoHub-Wireless-n',inc:'from yocto_hubport import *',cmt:'<p>The <tt>YHubPort</tt> class provides control over the power supply for slave ports on a YoctoHub. It provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}
,'FindHubPort':{syn:'Retrieves a YoctoHub slave port for a given identifier.',lib:'YHubPort.FindHubPort()',pro:'FindHubPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a YoctoHub slave port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the YoctoHub slave port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the YoctoHub slave port is indeed online at a given time. In case of ambiguity when looking for a YoctoHub slave port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the YoctoHub slave port, for instance <tt>YHUBETH1.hubPort1</tt>.'},ret:'a <tt>YHubPort</tt> object allowing you to drive the YoctoHub slave port.'}
,'FirstHubPort':{syn:'Starts the enumeration of YoctoHub slave ports currently accessible.',lib:'YHubPort.FirstHubPort()',pro:'FirstHubPort()',cmt:'<p>Starts the enumeration of YoctoHub slave ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next YoctoHub slave ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first YoctoHub slave port currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the YoctoHub slave port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the YoctoHub slave port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the YoctoHub slave port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the YoctoHub slave port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the YoctoHub slave port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the YoctoHub slave port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the YoctoHub slave port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YHubPort.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_baudRate':{syn:'Returns the current baud rate used by this YoctoHub port, in kbps.',lib:'%.get_baudRate()',pro:'get_baudRate()',cmt:'<p>Returns the current baud rate used by this YoctoHub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this YoctoHub port, in kbps',ext:'On failure, throws an exception or returns <tt>YHubPort.BAUDRATE_INVALID</tt>.'}
,'get_enabled':{syn:'Returns true if the YoctoHub port is powered, false otherwise.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns true if the YoctoHub port is powered, false otherwise.</p>',ret:'either <tt>YHubPort.ENABLED_FALSE</tt> or <tt>YHubPort.ENABLED_TRUE</tt>, according to true if the YoctoHub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>YHubPort.ENABLED_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the YoctoHub slave port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the YoctoHub slave port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the YoctoHub slave port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the YoctoHub slave port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the YoctoHub slave port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the YoctoHub slave port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the YoctoHub slave port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the YoctoHub slave port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the YoctoHub slave port if they are defined, otherwise the serial number of the module and the hardware identifier of the YoctoHub slave port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the YoctoHub slave port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHubPort.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the YoctoHub slave port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the YoctoHub slave port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the YoctoHub slave port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHubPort.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the YoctoHub slave port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the YoctoHub slave port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the YoctoHub slave port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the YoctoHub slave port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHubPort.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the YoctoHub slave port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the YoctoHub slave port.</p>',ret:'a string corresponding to the logical name of the YoctoHub slave port.',ext:'On failure, throws an exception or returns <tt>YHubPort.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_portState':{syn:'Returns the current state of the YoctoHub port.',lib:'%.get_portState()',pro:'get_portState()',cmt:'<p>Returns the current state of the YoctoHub port.</p>',ret:'a value among <tt>YHubPort.PORTSTATE_OFF</tt>, <tt>YHubPort.PORTSTATE_OVRLD</tt>, <tt>YHubPort.PORTSTATE_ON</tt>, <tt>YHubPort.PORTSTATE_RUN</tt> and <tt>YHubPort.PORTSTATE_PROG</tt> corresponding to the current state of the YoctoHub port',ext:'On failure, throws an exception or returns <tt>YHubPort.PORTSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the YoctoHub slave port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the YoctoHub slave port is currently reachable, without raising any error. If there is a cached value for the YoctoHub slave port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the YoctoHub slave port.</p>',ret:'<tt>true</tt> if the YoctoHub slave port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the YoctoHub slave port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the YoctoHub slave port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextHubPort':{syn:'Continues the enumeration of YoctoHub slave ports started using <tt>yFirstHubPort()</tt>.',lib:'%.nextHubPort()',pro:'nextHubPort()',cmt:'<p>Continues the enumeration of YoctoHub slave ports started using <tt>yFirstHubPort()</tt>. Caution: You can\x27t make any assumption about the returned YoctoHub slave ports order. If you want to find a specific a YoctoHub slave port, use <tt>HubPort.findHubPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a YoctoHub slave port currently online, or a <tt>null</tt> pointer if there are no more YoctoHub slave ports to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_enabled':{syn:'Changes the activation of the YoctoHub port.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation of the YoctoHub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>YHubPort.ENABLED_FALSE</tt> or <tt>YHubPort.ENABLED_TRUE</tt>, according to the activation of the YoctoHub port'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the YoctoHub slave port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the YoctoHub slave port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the YoctoHub slave port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: HubPort)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity sensor control interface, available for instance in the Yocto-CO2-V2, the Yocto-Meteo-V2 or the Yocto-VOC-V3',inc:'from yocto_humidity import *',cmt:'<p>The <tt>YHumidity</tt> class allows you to read and configure Yoctopuce humidity sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindHumidity':{syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity.FindHumidity()',pro:'FindHumidity(<span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the humidity sensor, for instance <tt>YCO2MK02.humidity</tt>.'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'}
,'FirstHumidity':{syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity.FirstHumidity()',pro:'FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the humidity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the humidity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_absHum':{syn:'Returns the current absolute humidity, in grams per cubic meter of air.',lib:'%.get_absHum()',pro:'get_absHum()',cmt:'<p>Returns the current absolute humidity, in grams per cubic meter of air.</p>',ret:'a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air',ext:'On failure, throws an exception or returns <tt>YHumidity.ABSHUM_INVALID</tt>.'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YHumidity.ADVMODE_IMMEDIATE</tt>, <tt>YHumidity.ADVMODE_PERIOD_AVG</tt>, <tt>YHumidity.ADVMODE_PERIOD_MIN</tt> and <tt>YHumidity.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YHumidity.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YHumidity.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>YHumidity.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>YHumidity.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the humidity sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the humidity sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the humidity sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the humidity sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the humidity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the humidity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the humidity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHumidity.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the humidity sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the humidity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the humidity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHumidity.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the humidity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the humidity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YHumidity.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>YHumidity.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YHumidity.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the humidity sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:'On failure, throws an exception or returns <tt>YHumidity.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>YHumidity.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_relHum':{syn:'Returns the current relative humidity, in per cents.',lib:'%.get_relHum()',pro:'get_relHum()',cmt:'<p>Returns the current relative humidity, in per cents.</p>',ret:'a floating point number corresponding to the current relative humidity, in per cents',ext:'On failure, throws an exception or returns <tt>YHumidity.RELHUM_INVALID</tt>.'}
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YHumidity.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YHumidity.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YHumidity.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the humidity.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:'On failure, throws an exception or returns <tt>YHumidity.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the humidity sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the humidity sensor is currently reachable, without raising any error. If there is a cached value for the humidity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the humidity sensor.</p>',ret:'<tt>true</tt> if the humidity sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the humidity sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the humidity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextHumidity':{syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'%.nextHumidity()',pro:'nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>. Caution: You can\x27t make any assumption about the returned humidity sensors order. If you want to find a specific a humidity sensor, use <tt>Humidity.findHumidity()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YHumidity.ADVMODE_IMMEDIATE</tt>, <tt>YHumidity.ADVMODE_PERIOD_AVG</tt>, <tt>YHumidity.ADVMODE_PERIOD_MIN</tt> and <tt>YHumidity.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the humidity sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_unit':{syn:'Changes the primary unit for measuring humidity.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the primary unit for measuring humidity. That unit is a string. If that strings starts with the letter \x27g\x27, the primary measured value is the absolute humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity (RH), in per cents.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the primary unit for measuring humidity'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Humidity)
//--- (generated code: I2cPort)
doc['I2cPort']={'':{syn:'I2C port control interface, available for instance in the Yocto-I2C',inc:'from yocto_i2cport import *',cmt:'<p>The <tt>YI2cPort</tt> classe allows you to fully drive a Yoctopuce I2C port. It can be used to send and receive data, and to configure communication parameters (baud rate, etc). Note that Yoctopuce I2C ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}
,'FindI2cPort':{syn:'Retrieves an I2C port for a given identifier.',lib:'YI2cPort.FindI2cPort()',pro:'FindI2cPort(<span id=pn>func</span>)',cmt:'<p>Retrieves an I2C port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the I2C port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YI2cPort.isOnline()</tt> to test if the I2C port is indeed online at a given time. In case of ambiguity when looking for an I2C port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the I2C port, for instance <tt>YI2CMK01.i2cPort</tt>.'},ret:'a <tt>YI2cPort</tt> object allowing you to drive the I2C port.'}
,'FirstI2cPort':{syn:'Starts the enumeration of I2C ports currently accessible.',lib:'YI2cPort.FirstI2cPort()',pro:'FirstI2cPort()',cmt:'<p>Starts the enumeration of I2C ports currently accessible. Use the method <tt>YI2cPort.nextI2cPort()</tt> to iterate on next I2C ports.</p>',ret:'a pointer to a <tt>YI2cPort</tt> object, corresponding to the first I2C port currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the I2C port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the I2C port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the I2C port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the I2C port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the I2C port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the I2C port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the I2C port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YI2cPort.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentJob':{syn:'Returns the name of the job file currently in use.',lib:'%.get_currentJob()',pro:'get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>YI2cPort.CURRENTJOB_INVALID</tt>.'}
,'get_errCount':{syn:'Returns the total number of communication errors detected since last reset.',lib:'%.get_errCount()',pro:'get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>YI2cPort.ERRCOUNT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the I2C port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the I2C port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the I2C port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the I2C port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the I2C port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the I2C port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the I2C port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the I2C port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the I2C port if they are defined, otherwise the serial number of the module and the hardware identifier of the I2C port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the I2C port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YI2cPort.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the I2C port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the I2C port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the I2C port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YI2cPort.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the I2C port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the I2C port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the I2C port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the I2C port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YI2cPort.HARDWAREID_INVALID</tt>.'}
,'get_i2cMode':{syn:'Returns the I2C port communication parameters, as a string such as \x22400kbps,2000ms,NoRestart\x22.',lib:'%.get_i2cMode()',pro:'get_i2cMode()',cmt:'<p>Returns the I2C port communication parameters, as a string such as \x22400kbps,2000ms,NoRestart\x22. The string includes the baud rate, the recovery delay after communications errors, and if needed the option <tt>NoRestart</tt> to use a Stop/Start sequence instead of the Restart state when performing read on the I2C bus.</p>',ret:'a string corresponding to the I2C port communication parameters, as a string such as \x22400kbps,2000ms,NoRestart\x22',ext:'On failure, throws an exception or returns <tt>YI2cPort.I2CMODE_INVALID</tt>.'}
,'get_i2cVoltageLevel':{syn:'Returns the voltage level used on the I2C bus.',lib:'%.get_i2cVoltageLevel()',pro:'get_i2cVoltageLevel()',cmt:'<p>Returns the voltage level used on the I2C bus.</p>',ret:'a value among <tt>YI2cPort.I2CVOLTAGELEVEL_OFF</tt>, <tt>YI2cPort.I2CVOLTAGELEVEL_3V3</tt> and <tt>YI2cPort.I2CVOLTAGELEVEL_1V8</tt> corresponding to the voltage level used on the I2C bus',ext:'On failure, throws an exception or returns <tt>YI2cPort.I2CVOLTAGELEVEL_INVALID</tt>.'}
,'get_jobMaxSize':{syn:'Returns maximum size allowed for job files.',lib:'%.get_jobMaxSize()',pro:'get_jobMaxSize()',cmt:'<p>Returns maximum size allowed for job files.</p>',ret:'an integer corresponding to maximum size allowed for job files',ext:'On failure, throws an exception or returns <tt>YI2cPort.JOBMAXSIZE_INVALID</tt>.'}
,'get_jobMaxTask':{syn:'Returns the maximum number of tasks in a job that the device can handle.',lib:'%.get_jobMaxTask()',pro:'get_jobMaxTask()',cmt:'<p>Returns the maximum number of tasks in a job that the device can handle.</p>',ret:'an integer corresponding to the maximum number of tasks in a job that the device can handle',ext:'On failure, throws an exception or returns <tt>YI2cPort.JOBMAXTASK_INVALID</tt>.'}
,'get_lastMsg':{syn:'Returns the latest message fully received (for Line and Frame protocols).',lib:'%.get_lastMsg()',pro:'get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line and Frame protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line and Frame protocols)',ext:'On failure, throws an exception or returns <tt>YI2cPort.LASTMSG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the I2C port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the I2C port.</p>',ret:'a string corresponding to the logical name of the I2C port.',ext:'On failure, throws an exception or returns <tt>YI2cPort.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_protocol':{syn:'Returns the type of protocol used to send I2C messages, as a string.',lib:'%.get_protocol()',pro:'get_protocol()',cmt:'<p>Returns the type of protocol used to send I2C messages, as a string. Possible values are \x22Line\x22 for messages separated by LF or \x22Char\x22 for continuous stream of codes.</p>',ret:'a string corresponding to the type of protocol used to send I2C messages, as a string',ext:'On failure, throws an exception or returns <tt>YI2cPort.PROTOCOL_INVALID</tt>.'}
,'get_rxCount':{syn:'Returns the total number of bytes received since last reset.',lib:'%.get_rxCount()',pro:'get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>YI2cPort.RXCOUNT_INVALID</tt>.'}
,'get_rxMsgCount':{syn:'Returns the total number of messages received since last reset.',lib:'%.get_rxMsgCount()',pro:'get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>YI2cPort.RXMSGCOUNT_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_startupJob':{syn:'Returns the job file to use when the device is powered on.',lib:'%.get_startupJob()',pro:'get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>YI2cPort.STARTUPJOB_INVALID</tt>.'}
,'get_txCount':{syn:'Returns the total number of bytes transmitted since last reset.',lib:'%.get_txCount()',pro:'get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>YI2cPort.TXCOUNT_INVALID</tt>.'}
,'get_txMsgCount':{syn:'Returns the total number of messages send since last reset.',lib:'%.get_txMsgCount()',pro:'get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>YI2cPort.TXMSGCOUNT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'i2cSendAndReceiveArray':{syn:'Sends a one-way message (provided as a list of integer) to a device on the I2C bus, then read back the specified number of bytes from device.',lib:'%.i2cSendAndReceiveArray()',pro:'i2cSendAndReceiveArray(<span id=pn>slaveAddr</span>, <span id=pn>values</span>, <span id=pn>rcvCount</span>)',cmt:'<p>Sends a one-way message (provided as a list of integer) to a device on the I2C bus, then read back the specified number of bytes from device. This function checks and reports communication errors on the I2C bus.</p>',par:{slaveAddr:'the 7-bit address of the slave device (without the direction bit)',values:'a list of data bytes to be sent',rcvCount:'the number of bytes to receive once the data bytes are sent'},ret:'a list of bytes with the data received from slave device.',ext:'On failure, throws an exception or returns an empty array.'}
,'i2cSendAndReceiveBin':{syn:'Sends a one-way message (provided as a a binary buffer) to a device on the I2C bus, then read back the specified number of bytes from device.',lib:'%.i2cSendAndReceiveBin()',pro:'i2cSendAndReceiveBin(<span id=pn>slaveAddr</span>, <span id=pn>buff</span>, <span id=pn>rcvCount</span>)',cmt:'<p>Sends a one-way message (provided as a a binary buffer) to a device on the I2C bus, then read back the specified number of bytes from device. This function checks and reports communication errors on the I2C bus.</p>',par:{slaveAddr:'the 7-bit address of the slave device (without the direction bit)',buff:'the binary buffer to be sent',rcvCount:'the number of bytes to receive once the data bytes are sent'},ret:'a list of bytes with the data received from slave device.',ext:'On failure, throws an exception or returns an empty binary buffer.'}
,'i2cSendArray':{syn:'Sends a one-way message (provided as a list of integer) to a device on the I2C bus.',lib:'%.i2cSendArray()',pro:'i2cSendArray(<span id=pn>slaveAddr</span>, <span id=pn>values</span>)',cmt:'<p>Sends a one-way message (provided as a list of integer) to a device on the I2C bus. This function checks and reports communication errors on the I2C bus.</p>',par:{slaveAddr:'the 7-bit address of the slave device (without the direction bit)',values:'a list of data bytes to be sent'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'i2cSendBin':{syn:'Sends a one-way message (provided as a a binary buffer) to a device on the I2C bus.',lib:'%.i2cSendBin()',pro:'i2cSendBin(<span id=pn>slaveAddr</span>, <span id=pn>buff</span>)',cmt:'<p>Sends a one-way message (provided as a a binary buffer) to a device on the I2C bus. This function checks and reports communication errors on the I2C bus.</p>',par:{slaveAddr:'the 7-bit address of the slave device (without the direction bit)',buff:'the binary buffer to be sent'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'isOnline':{syn:'Checks if the I2C port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the I2C port is currently reachable, without raising any error. If there is a cached value for the I2C port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the I2C port.</p>',ret:'<tt>true</tt> if the I2C port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the I2C port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the I2C port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextI2cPort':{syn:'Continues the enumeration of I2C ports started using <tt>yFirstI2cPort()</tt>.',lib:'%.nextI2cPort()',pro:'nextI2cPort()',cmt:'<p>Continues the enumeration of I2C ports started using <tt>yFirstI2cPort()</tt>. Caution: You can\x27t make any assumption about the returned I2C ports order. If you want to find a specific an I2C port, use <tt>I2cPort.findI2cPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YI2cPort</tt> object, corresponding to an I2C port currently online, or a <tt>null</tt> pointer if there are no more I2C ports to enumerate.'}
,'queryHex':{syn:'Sends a binary message to the serial port, and reads the reply, if any.',lib:'%.queryHex()',pro:'queryHex(<span id=pn>hexString</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a binary message to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for Frame-based protocol.</p>',par:{hexString:'the message to send, coded in hexadecimal',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next frame received after sending the message, as a hex string. Additional frames can be obtained by calling readHex or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'queryLine':{syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'%.queryLine()',pro:'queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'readLine':{syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'%.readLine()',pro:'readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'}
,'readMessages':{syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'%.readMessages()',pro:'readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'read_avail':{syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'%.read_avail()',pro:'read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'}
,'read_seek':{syn:'Changes the current internal stream position to the specified value.',lib:'%.read_seek()',pro:'read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'}
,'read_tell':{syn:'Returns the current absolute stream position pointer of the API object.',lib:'%.read_tell()',pro:'read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Clears the serial port buffer and resets counters to zero.',lib:'%.reset()',pro:'reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectJob':{syn:'Load and start processing the specified job file.',lib:'%.selectJob()',pro:'selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentJob':{syn:'Selects a job file to run immediately.',lib:'%.set_currentJob()',pro:'set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Selects a job file to run immediately. If an empty string is given as argument, stops running current job file.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_i2cMode':{syn:'Changes the I2C port communication parameters, with a string such as \x22400kbps,2000ms\x22.',lib:'%.set_i2cMode()',pro:'set_i2cMode(<span id=pn>newval</span>)',cmt:'<p>Changes the I2C port communication parameters, with a string such as \x22400kbps,2000ms\x22. The string includes the baud rate, the recovery delay after communications errors, and if needed the option <tt>NoRestart</tt> to use a Stop/Start sequence instead of the Restart state when performing read on the I2C bus. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the I2C port communication parameters, with a string such as \x22400kbps,2000ms\x22'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_i2cVoltageLevel':{syn:'Changes the voltage level used on the I2C bus.',lib:'%.set_i2cVoltageLevel()',pro:'set_i2cVoltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage level used on the I2C bus. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YI2cPort.I2CVOLTAGELEVEL_OFF</tt>, <tt>YI2cPort.I2CVOLTAGELEVEL_3V3</tt> and <tt>YI2cPort.I2CVOLTAGELEVEL_1V8</tt> corresponding to the voltage level used on the I2C bus'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the I2C port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the I2C port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the I2C port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_protocol':{syn:'Changes the type of protocol used to send I2C messages.',lib:'%.set_protocol()',pro:'set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used to send I2C messages. Possible values are \x22Line\x22 for messages separated by LF or \x22Char\x22 for continuous stream of codes. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each message sent. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the type of protocol used to send I2C messages'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupJob':{syn:'Changes the job to use when the device is powered on.',lib:'%.set_startupJob()',pro:'set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'snoopMessages':{syn:'Retrieves messages (both direction) in the I2C port buffer, starting at current position.',lib:'%.snoopMessages()',pro:'snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the I2C port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of <tt>YI2cSnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'snoopMessagesEx':{syn:'Retrieves messages (both direction) in the I2C port buffer, starting at current position.',lib:'%.snoopMessagesEx()',pro:'snoopMessagesEx(<span id=pn>maxWait</span>, <span id=pn>maxMsg</span>)',cmt:'<p>Retrieves messages (both direction) in the I2C port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.',maxMsg:'the maximum number of messages to be returned by the function; up to 254.'},ret:'an array of <tt>YI2cSnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'uploadJob':{syn:'Saves the job definition string (JSON data) into a job file.',lib:'%.uploadJob()',pro:'uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeArray':{syn:'Sends a byte sequence (provided as a list of bytes) to the I2C bus.',lib:'%.writeArray()',pro:'writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the I2C bus. Depending on the I2C bus state, the first byte will be interpreted as an address byte or a data byte.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeBin':{syn:'Sends a binary buffer to the I2C bus, as is.',lib:'%.writeBin()',pro:'writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the I2C bus, as is. Depending on the I2C bus state, the first byte will be interpreted as an address byte or a data byte.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeByte':{syn:'Sends a single byte to the I2C bus.',lib:'%.writeByte()',pro:'writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the I2C bus. Depending on the I2C bus state, the byte will be interpreted as an address byte or a data byte.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeHex':{syn:'Sends a byte sequence (provided as a hexadecimal string) to the I2C bus.',lib:'%.writeHex()',pro:'writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the I2C bus. Depending on the I2C bus state, the first byte will be interpreted as an address byte or a data byte.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeLine':{syn:'Sends a text-encoded I2C code stream to the I2C bus, and release the bus.',lib:'%.writeLine()',pro:'writeLine(<span id=pn>codes</span>)',cmt:'<p>Sends a text-encoded I2C code stream to the I2C bus, and release the bus. An I2C code stream is a string made of hexadecimal data bytes, but that may also include the I2C state transitions code: \x22{S}\x22 to emit a start condition, \x22{R}\x22 for a repeated start condition, \x22{P}\x22 for a stop condition, \x22xx\x22 for receiving a data byte, \x22{A}\x22 to ack a data byte received and \x22{N}\x22 to nack a data byte received. At the end of the stream, a stop condition is added if missing and a newline is added to the receive buffer as well.</p>',par:{codes:'the code stream to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeStr':{syn:'Sends a text-encoded I2C code stream to the I2C bus, as is.',lib:'%.writeStr()',pro:'writeStr(<span id=pn>codes</span>)',cmt:'<p>Sends a text-encoded I2C code stream to the I2C bus, as is. An I2C code stream is a string made of hexadecimal data bytes, but that may also include the I2C state transitions code: \x22{S}\x22 to emit a start condition, \x22{R}\x22 for a repeated start condition, \x22{P}\x22 for a stop condition, \x22xx\x22 for receiving a data byte, \x22{A}\x22 to ack a data byte received and \x22{N}\x22 to nack a data byte received. If a newline (\x22\x5Cn\x22) is included in the stream, the message will be terminated and a newline will also be added to the receive stream.</p>',par:{codes:'the code stream to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: I2cPort)
//--- (generated code: I2cSnoopingRecord)
doc['I2cSnoopingRecord']={'':{syn:'Intercepted I2C message description, returned by <tt>i2cPort.snoopMessages</tt> method',inc:'from yocto_i2cport import *'}
,'get_direction':{syn:'Returns the message direction (RX=0, TX=1).',lib:'%.get_direction()',pro:'get_direction()',cmt:'<p>Returns the message direction (RX=0, TX=1).</p>',ret:'the message direction (RX=0, TX=1).'}
,'get_message':{syn:'Returns the message content.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the message content.</p>',ret:'the message content.'}
,'get_pos':{syn:'Returns the absolute position of the message end.',lib:'%.get_pos()',pro:'get_pos()',cmt:'<p>Returns the absolute position of the message end.</p>',ret:'the absolute position of the message end.'}
,'get_time':{syn:'Returns the elapsed time, in ms, since the beginning of the preceding message.',lib:'%.get_time()',pro:'get_time()',cmt:'<p>Returns the elapsed time, in ms, since the beginning of the preceding message.</p>',ret:'the elapsed time, in ms, since the beginning of the preceding message.'}
};
//--- (end of generated code: I2cSnoopingRecord)
//--- (generated code: InputCapture)
doc['InputCapture']={'':{syn:'Instant snapshot trigger control interface',inc:'from yocto_inputcapture import *',cmt:'<p>The <tt>YInputCapture</tt> class allows you to access data samples measured by a Yoctopuce electrical sensor. The data capture can be triggered manually, or be configured to detect specific events.</p>'}
,'FindInputCapture':{syn:'Retrieves an instant snapshot trigger for a given identifier.',lib:'YInputCapture.FindInputCapture()',pro:'FindInputCapture(<span id=pn>func</span>)',cmt:'<p>Retrieves an instant snapshot trigger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the instant snapshot trigger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YInputCapture.isOnline()</tt> to test if the instant snapshot trigger is indeed online at a given time. In case of ambiguity when looking for an instant snapshot trigger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the instant snapshot trigger, for instance <tt>MyDevice.inputCapture</tt>.'},ret:'a <tt>YInputCapture</tt> object allowing you to drive the instant snapshot trigger.'}
,'FirstInputCapture':{syn:'Starts the enumeration of instant snapshot triggers currently accessible.',lib:'YInputCapture.FirstInputCapture()',pro:'FirstInputCapture()',cmt:'<p>Starts the enumeration of instant snapshot triggers currently accessible. Use the method <tt>YInputCapture.nextInputCapture()</tt> to iterate on next instant snapshot triggers.</p>',ret:'a pointer to a <tt>YInputCapture</tt> object, corresponding to the first instant snapshot trigger currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the instant snapshot trigger attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the instant snapshot trigger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the instant snapshot trigger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the instant snapshot trigger (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the instant snapshot trigger (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the instant snapshot trigger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the instant snapshot trigger (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YInputCapture.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_captureType':{syn:'Returns the type of automatic conditional capture.',lib:'%.get_captureType()',pro:'get_captureType()',cmt:'<p>Returns the type of automatic conditional capture.</p>',ret:'a value among <tt>YInputCapture.CAPTURETYPE_NONE</tt>, <tt>YInputCapture.CAPTURETYPE_TIMED</tt>, <tt>YInputCapture.CAPTURETYPE_V_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_P_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_P_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_V_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_V_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_P_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_P_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_PF_MIN</tt> and <tt>YInputCapture.CAPTURETYPE_DPF_MIN</tt> corresponding to the type of automatic conditional capture',ext:'On failure, throws an exception or returns <tt>YInputCapture.CAPTURETYPE_INVALID</tt>.'}
,'get_captureTypeAtStartup':{syn:'Returns the type of automatic conditional capture applied at device power on.',lib:'%.get_captureTypeAtStartup()',pro:'get_captureTypeAtStartup()',cmt:'<p>Returns the type of automatic conditional capture applied at device power on.</p>',ret:'a value among <tt>YInputCapture.CAPTURETYPEATSTARTUP_NONE</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_TIMED</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_PF_MIN</tt> and <tt>YInputCapture.CAPTURETYPEATSTARTUP_DPF_MIN</tt> corresponding to the type of automatic conditional capture applied at device power on',ext:'On failure, throws an exception or returns <tt>YInputCapture.CAPTURETYPEATSTARTUP_INVALID</tt>.'}
,'get_condAlign':{syn:'Returns the relative position of the trigger event within the capture window.',lib:'%.get_condAlign()',pro:'get_condAlign()',cmt:'<p>Returns the relative position of the trigger event within the capture window. When the value is 50%, the capture is centered on the event.</p>',ret:'an integer corresponding to the relative position of the trigger event within the capture window',ext:'On failure, throws an exception or returns <tt>YInputCapture.CONDALIGN_INVALID</tt>.'}
,'get_condValue':{syn:'Returns current threshold value for automatic conditional capture.',lib:'%.get_condValue()',pro:'get_condValue()',cmt:'<p>Returns current threshold value for automatic conditional capture.</p>',ret:'a floating point number corresponding to current threshold value for automatic conditional capture',ext:'On failure, throws an exception or returns <tt>YInputCapture.CONDVALUE_INVALID</tt>.'}
,'get_condValueAtStartup':{syn:'Returns the threshold value for automatic conditional capture applied at device power on.',lib:'%.get_condValueAtStartup()',pro:'get_condValueAtStartup()',cmt:'<p>Returns the threshold value for automatic conditional capture applied at device power on.</p>',ret:'a floating point number corresponding to the threshold value for automatic conditional capture applied at device power on',ext:'On failure, throws an exception or returns <tt>YInputCapture.CONDVALUEATSTARTUP_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the instant snapshot trigger.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the instant snapshot trigger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the instant snapshot trigger object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the instant snapshot trigger.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the instant snapshot trigger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the instant snapshot trigger object'}
,'get_friendlyName':{syn:'Returns a global identifier of the instant snapshot trigger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the instant snapshot trigger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the instant snapshot trigger if they are defined, otherwise the serial number of the module and the hardware identifier of the instant snapshot trigger (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the instant snapshot trigger using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputCapture.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the instant snapshot trigger, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the instant snapshot trigger, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the instant snapshot trigger (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputCapture.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the instant snapshot trigger in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the instant snapshot trigger in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the instant snapshot trigger (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the instant snapshot trigger (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputCapture.HARDWAREID_INVALID</tt>.'}
,'get_immediateCapture':{syn:'Returns a new immediate capture of the device inputs.',lib:'%.get_immediateCapture()',pro:'get_immediateCapture(<span id=pn>msDuration</span>)',cmt:'<p>Returns a new immediate capture of the device inputs.</p>',par:{msDuration:'duration of the capture window, in milliseconds (eg. between 20 and 1000).'},ret:'an <tt>YInputCaptureData</tt> object including data series for the specified duration. On failure, throws an exception or returns an capture object.'}
,'get_lastCapture':{syn:'Returns all details about the last automatic input capture.',lib:'%.get_lastCapture()',pro:'get_lastCapture()',cmt:'<p>Returns all details about the last automatic input capture.</p>',ret:'an <tt>YInputCaptureData</tt> object including data series and all related meta-information. On failure, throws an exception or returns an capture object.'}
,'get_lastCaptureTime':{syn:'Returns the number of elapsed milliseconds between the module power on and the last capture (time of trigger), or zero if no capture has been done.',lib:'%.get_lastCaptureTime()',pro:'get_lastCaptureTime()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last capture (time of trigger), or zero if no capture has been done.</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last capture (time of trigger), or zero if no capture has been done',ext:'On failure, throws an exception or returns <tt>YInputCapture.LASTCAPTURETIME_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the instant snapshot trigger.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the instant snapshot trigger.</p>',ret:'a string corresponding to the logical name of the instant snapshot trigger.',ext:'On failure, throws an exception or returns <tt>YInputCapture.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nSamples':{syn:'Returns the number of samples that will be captured.',lib:'%.get_nSamples()',pro:'get_nSamples()',cmt:'<p>Returns the number of samples that will be captured.</p>',ret:'an integer corresponding to the number of samples that will be captured',ext:'On failure, throws an exception or returns <tt>YInputCapture.NSAMPLES_INVALID</tt>.'}
,'get_samplingRate':{syn:'Returns the sampling frequency, in Hz.',lib:'%.get_samplingRate()',pro:'get_samplingRate()',cmt:'<p>Returns the sampling frequency, in Hz.</p>',ret:'an integer corresponding to the sampling frequency, in Hz',ext:'On failure, throws an exception or returns <tt>YInputCapture.SAMPLINGRATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the instant snapshot trigger is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the instant snapshot trigger is currently reachable, without raising any error. If there is a cached value for the instant snapshot trigger in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the instant snapshot trigger.</p>',ret:'<tt>true</tt> if the instant snapshot trigger can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the instant snapshot trigger cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the instant snapshot trigger cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextInputCapture':{syn:'Continues the enumeration of instant snapshot triggers started using <tt>yFirstInputCapture()</tt>.',lib:'%.nextInputCapture()',pro:'nextInputCapture()',cmt:'<p>Continues the enumeration of instant snapshot triggers started using <tt>yFirstInputCapture()</tt>. Caution: You can\x27t make any assumption about the returned instant snapshot triggers order. If you want to find a specific an instant snapshot trigger, use <tt>InputCapture.findInputCapture()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YInputCapture</tt> object, corresponding to an instant snapshot trigger currently online, or a <tt>null</tt> pointer if there are no more instant snapshot triggers to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_captureType':{syn:'Changes the type of automatic conditional capture.',lib:'%.set_captureType()',pro:'set_captureType(<span id=pn>newval</span>)',cmt:'<p>Changes the type of automatic conditional capture.</p>',par:{newval:'a value among <tt>YInputCapture.CAPTURETYPE_NONE</tt>, <tt>YInputCapture.CAPTURETYPE_TIMED</tt>, <tt>YInputCapture.CAPTURETYPE_V_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_P_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_P_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_V_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_V_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_V_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_I_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_I_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_P_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPE_P_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPE_PF_MIN</tt> and <tt>YInputCapture.CAPTURETYPE_DPF_MIN</tt> corresponding to the type of automatic conditional capture'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_captureTypeAtStartup':{syn:'Changes the type of automatic conditional capture applied at device power on.',lib:'%.set_captureTypeAtStartup()',pro:'set_captureTypeAtStartup(<span id=pn>newval</span>)',cmt:'<p>Changes the type of automatic conditional capture applied at device power on. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a value among <tt>YInputCapture.CAPTURETYPEATSTARTUP_NONE</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_TIMED</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_V_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_RMS_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_I_RMS_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_AVG_MAX</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_P_AVG_MIN</tt>, <tt>YInputCapture.CAPTURETYPEATSTARTUP_PF_MIN</tt> and <tt>YInputCapture.CAPTURETYPEATSTARTUP_DPF_MIN</tt> corresponding to the type of automatic conditional capture applied at device power on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_condAlign':{syn:'Changes the relative position of the trigger event within the capture window.',lib:'%.set_condAlign()',pro:'set_condAlign(<span id=pn>newval</span>)',cmt:'<p>Changes the relative position of the trigger event within the capture window. The new value must be between 10% (on the left) and 90% (on the right). When the value is 50%, the capture is centered on the event.</p><p> If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'an integer corresponding to the relative position of the trigger event within the capture window'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_condValue':{syn:'Changes current threshold value for automatic conditional capture.',lib:'%.set_condValue()',pro:'set_condValue(<span id=pn>newval</span>)',cmt:'<p>Changes current threshold value for automatic conditional capture.</p>',par:{newval:'a floating point number corresponding to current threshold value for automatic conditional capture'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_condValueAtStartup':{syn:'Changes current threshold value for automatic conditional capture applied at device power on.',lib:'%.set_condValueAtStartup()',pro:'set_condValueAtStartup(<span id=pn>newval</span>)',cmt:'<p>Changes current threshold value for automatic conditional capture applied at device power on. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a floating point number corresponding to current threshold value for automatic conditional capture applied at device power on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the instant snapshot trigger.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the instant snapshot trigger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the instant snapshot trigger.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_nSamples':{syn:'Changes the type of automatic conditional capture.',lib:'%.set_nSamples()',pro:'set_nSamples(<span id=pn>newval</span>)',cmt:'<p>Changes the type of automatic conditional capture. The maximum number of samples depends on the device memory.</p><p> If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'an integer corresponding to the type of automatic conditional capture'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: InputCapture)
//--- (generated code: InputCaptureData)
doc['InputCaptureData']={'':{syn:'Sampled data from a Yoctopuce electrical sensor',inc:'from yocto_inputcapture import *',cmt:'<p><tt>InputCaptureData</tt> objects represent raw data sampled by the analog/digital converter present in a Yoctopuce electrical sensor. When several inputs are samples simultaneously, their data are provided as distinct series.</p>'}
,'get_captureType':{syn:'Returns the type of automatic conditional capture that triggered the capture of this data sequence.',lib:'%.get_captureType()',pro:'get_captureType()',cmt:'<p>Returns the type of automatic conditional capture that triggered the capture of this data sequence.</p>',ret:'the type of conditional capture.'}
,'get_recordCount':{syn:'Returns the number of records captured (in a serie).',lib:'%.get_recordCount()',pro:'get_recordCount()',cmt:'<p>Returns the number of records captured (in a serie). In the exceptional case where it was not possible to transfer all data in time, the number of records actually present in the series might be lower than the number of records captured</p>',ret:'an integer corresponding to the number of records expected in each serie.'}
,'get_samplingRate':{syn:'Returns the effective sampling rate of the device.',lib:'%.get_samplingRate()',pro:'get_samplingRate()',cmt:'<p>Returns the effective sampling rate of the device.</p>',ret:'an integer corresponding to the number of samples taken each second.'}
,'get_serie1Unit':{syn:'Returns the unit of measurement for data points in the first serie.',lib:'%.get_serie1Unit()',pro:'get_serie1Unit()',cmt:'<p>Returns the unit of measurement for data points in the first serie.</p>',ret:'a string containing to a physical unit of measurement.'}
,'get_serie1Values':{syn:'Returns the sampled data corresponding to the first serie.',lib:'%.get_serie1Values()',pro:'get_serie1Values()',cmt:'<p>Returns the sampled data corresponding to the first serie. The corresponding physical unit can be obtained using the method <tt>get_serie1Unit()</tt>.</p>',ret:'a list of real numbers corresponding to all samples received for serie 1.',ext:'On failure, throws an exception or returns an empty array.'}
,'get_serie2Unit':{syn:'Returns the unit of measurement for data points in the second serie.',lib:'%.get_serie2Unit()',pro:'get_serie2Unit()',cmt:'<p>Returns the unit of measurement for data points in the second serie.</p>',ret:'a string containing to a physical unit of measurement.'}
,'get_serie2Values':{syn:'Returns the sampled data corresponding to the second serie.',lib:'%.get_serie2Values()',pro:'get_serie2Values()',cmt:'<p>Returns the sampled data corresponding to the second serie. The corresponding physical unit can be obtained using the method <tt>get_serie2Unit()</tt>.</p>',ret:'a list of real numbers corresponding to all samples received for serie 2.',ext:'On failure, throws an exception or returns an empty array.'}
,'get_serie3Unit':{syn:'Returns the unit of measurement for data points in the third serie.',lib:'%.get_serie3Unit()',pro:'get_serie3Unit()',cmt:'<p>Returns the unit of measurement for data points in the third serie.</p>',ret:'a string containing to a physical unit of measurement.'}
,'get_serie3Values':{syn:'Returns the sampled data corresponding to the third serie.',lib:'%.get_serie3Values()',pro:'get_serie3Values()',cmt:'<p>Returns the sampled data corresponding to the third serie. The corresponding physical unit can be obtained using the method <tt>get_serie3Unit()</tt>.</p>',ret:'a list of real numbers corresponding to all samples received for serie 3.',ext:'On failure, throws an exception or returns an empty array.'}
,'get_serieCount':{syn:'Returns the number of series available in the capture.',lib:'%.get_serieCount()',pro:'get_serieCount()',cmt:'<p>Returns the number of series available in the capture.</p>',ret:'an integer corresponding to the number of simultaneous data series available.'}
,'get_triggerPosition':{syn:'Returns the index in the series of the sample corresponding to the exact time when the capture was triggered.',lib:'%.get_triggerPosition()',pro:'get_triggerPosition()',cmt:'<p>Returns the index in the series of the sample corresponding to the exact time when the capture was triggered. In case of trigger based on average or RMS value, the trigger index corresponds to the end of the averaging period.</p>',ret:'an integer corresponding to a position in the data serie.'}
,'get_triggerRealTimeUTC':{syn:'Returns the absolute time when the capture was triggered, as a Unix timestamp.',lib:'%.get_triggerRealTimeUTC()',pro:'get_triggerRealTimeUTC()',cmt:'<p>Returns the absolute time when the capture was triggered, as a Unix timestamp. Milliseconds are included in this timestamp (floating-point number).</p>',ret:'a floating-point number corresponding to the number of seconds between the Jan 1, 1970 and the moment where the capture was triggered.'}
,'get_triggerValue':{syn:'Returns the threshold value that triggered this automatic conditional capture, if it was not an instant captured triggered manually.',lib:'%.get_triggerValue()',pro:'get_triggerValue()',cmt:'<p>Returns the threshold value that triggered this automatic conditional capture, if it was not an instant captured triggered manually.</p>',ret:'the conditional threshold value at the time of capture.'}
};
//--- (end of generated code: InputCaptureData)
//--- (generated code: InputChain)
doc['InputChain']={'':{syn:'InputChain function interface',inc:'from yocto_inputchain import *',cmt:'<p>The <tt>YInputChain</tt> class provides access to separate digital inputs connected in a chain.</p>'}
,'FindInputChain':{syn:'Retrieves a digital input chain for a given identifier.',lib:'YInputChain.FindInputChain()',pro:'FindInputChain(<span id=pn>func</span>)',cmt:'<p>Retrieves a digital input chain for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the digital input chain is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YInputChain.isOnline()</tt> to test if the digital input chain is indeed online at a given time. In case of ambiguity when looking for a digital input chain by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the digital input chain, for instance <tt>MyDevice.inputChain</tt>.'},ret:'a <tt>YInputChain</tt> object allowing you to drive the digital input chain.'}
,'FirstInputChain':{syn:'Starts the enumeration of digital input chains currently accessible.',lib:'YInputChain.FirstInputChain()',pro:'FirstInputChain()',cmt:'<p>Starts the enumeration of digital input chains currently accessible. Use the method <tt>YInputChain.nextInputChain()</tt> to iterate on next digital input chains.</p>',ret:'a pointer to a <tt>YInputChain</tt> object, corresponding to the first digital input chain currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the digital input chain attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the digital input chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the digital input chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the digital input chain (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the digital input chain (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the digital input chain (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital input chain (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YInputChain.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bitChain1':{syn:'Returns the state of input 1 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain1()',pro:'get_bitChain1()',cmt:'<p>Returns the state of input 1 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 1 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN1_INVALID</tt>.'}
,'get_bitChain2':{syn:'Returns the state of input 2 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain2()',pro:'get_bitChain2()',cmt:'<p>Returns the state of input 2 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 2 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN2_INVALID</tt>.'}
,'get_bitChain3':{syn:'Returns the state of input 3 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain3()',pro:'get_bitChain3()',cmt:'<p>Returns the state of input 3 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 3 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN3_INVALID</tt>.'}
,'get_bitChain4':{syn:'Returns the state of input 4 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain4()',pro:'get_bitChain4()',cmt:'<p>Returns the state of input 4 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 4 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN4_INVALID</tt>.'}
,'get_bitChain5':{syn:'Returns the state of input 5 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain5()',pro:'get_bitChain5()',cmt:'<p>Returns the state of input 5 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 5 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN5_INVALID</tt>.'}
,'get_bitChain6':{syn:'Returns the state of input 6 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain6()',pro:'get_bitChain6()',cmt:'<p>Returns the state of input 6 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 6 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN6_INVALID</tt>.'}
,'get_bitChain7':{syn:'Returns the state of input 7 for all nodes of the input chain, as a hexadecimal string.',lib:'%.get_bitChain7()',pro:'get_bitChain7()',cmt:'<p>Returns the state of input 7 for all nodes of the input chain, as a hexadecimal string. The node nearest to the controller is the lowest bit of the result.</p>',ret:'a string corresponding to the state of input 7 for all nodes of the input chain, as a hexadecimal string',ext:'On failure, throws an exception or returns <tt>YInputChain.BITCHAIN7_INVALID</tt>.'}
,'get_chainDiags':{syn:'Returns the controller state diagnostics.',lib:'%.get_chainDiags()',pro:'get_chainDiags()',cmt:'<p>Returns the controller state diagnostics. Bit 0 indicates a chain length error, bit 1 indicates an inactivity timeout and bit 2 indicates a loopback test failure.</p>',ret:'an integer corresponding to the controller state diagnostics',ext:'On failure, throws an exception or returns <tt>YInputChain.CHAINDIAGS_INVALID</tt>.'}
,'get_detectedNodes':{syn:'Returns the number of nodes detected in the chain.',lib:'%.get_detectedNodes()',pro:'get_detectedNodes()',cmt:'<p>Returns the number of nodes detected in the chain.</p>',ret:'an integer corresponding to the number of nodes detected in the chain',ext:'On failure, throws an exception or returns <tt>YInputChain.DETECTEDNODES_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the digital input chain.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the digital input chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the digital input chain object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the digital input chain.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the digital input chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the digital input chain object'}
,'get_expectedNodes':{syn:'Returns the number of nodes expected in the chain.',lib:'%.get_expectedNodes()',pro:'get_expectedNodes()',cmt:'<p>Returns the number of nodes expected in the chain.</p>',ret:'an integer corresponding to the number of nodes expected in the chain',ext:'On failure, throws an exception or returns <tt>YInputChain.EXPECTEDNODES_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the digital input chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the digital input chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the digital input chain if they are defined, otherwise the serial number of the module and the hardware identifier of the digital input chain (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the digital input chain using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputChain.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the digital input chain, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the digital input chain, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the digital input chain (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputChain.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the digital input chain in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the digital input chain in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the digital input chain (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the digital input chain (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YInputChain.HARDWAREID_INVALID</tt>.'}
,'get_lastEvents':{syn:'Returns a string with last events observed on the digital input chain.',lib:'%.get_lastEvents()',pro:'get_lastEvents()',cmt:'<p>Returns a string with last events observed on the digital input chain. This method return only events that are still buffered in the device memory.</p>',ret:'a string with last events observed (one per line).',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the digital input chain.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the digital input chain.</p>',ret:'a string corresponding to the logical name of the digital input chain.',ext:'On failure, throws an exception or returns <tt>YInputChain.LOGICALNAME_INVALID</tt>.'}
,'get_loopbackTest':{syn:'Returns the activation state of the exhaustive chain connectivity test.',lib:'%.get_loopbackTest()',pro:'get_loopbackTest()',cmt:'<p>Returns the activation state of the exhaustive chain connectivity test. The connectivity test requires a cable connecting the end of the chain to the loopback test connector.</p>',ret:'either <tt>YInputChain.LOOPBACKTEST_OFF</tt> or <tt>YInputChain.LOOPBACKTEST_ON</tt>, according to the activation state of the exhaustive chain connectivity test',ext:'On failure, throws an exception or returns <tt>YInputChain.LOOPBACKTEST_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_refreshRate':{syn:'Returns the desired refresh rate, measured in Hz.',lib:'%.get_refreshRate()',pro:'get_refreshRate()',cmt:'<p>Returns the desired refresh rate, measured in Hz. The higher the refresh rate is set, the higher the communication speed on the chain will be.</p>',ret:'an integer corresponding to the desired refresh rate, measured in Hz',ext:'On failure, throws an exception or returns <tt>YInputChain.REFRESHRATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_watchdogPeriod':{syn:'Returns the wait time in seconds before triggering an inactivity timeout error.',lib:'%.get_watchdogPeriod()',pro:'get_watchdogPeriod()',cmt:'<p>Returns the wait time in seconds before triggering an inactivity timeout error.</p>',ret:'an integer corresponding to the wait time in seconds before triggering an inactivity timeout error',ext:'On failure, throws an exception or returns <tt>YInputChain.WATCHDOGPERIOD_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the digital input chain is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the digital input chain is currently reachable, without raising any error. If there is a cached value for the digital input chain in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the digital input chain.</p>',ret:'<tt>true</tt> if the digital input chain can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the digital input chain cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the digital input chain cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextInputChain':{syn:'Continues the enumeration of digital input chains started using <tt>yFirstInputChain()</tt>.',lib:'%.nextInputChain()',pro:'nextInputChain()',cmt:'<p>Continues the enumeration of digital input chains started using <tt>yFirstInputChain()</tt>. Caution: You can\x27t make any assumption about the returned digital input chains order. If you want to find a specific a digital input chain, use <tt>InputChain.findInputChain()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YInputChain</tt> object, corresponding to a digital input chain currently online, or a <tt>null</tt> pointer if there are no more digital input chains to enumerate.'}
,'registerStateChangeCallback':{syn:'Registers a callback function to be called each time that an event is detected on the input chain.The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>.',lib:'%.registerStateChangeCallback()',pro:'registerStateChangeCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function to be called each time that an event is detected on the input chain.The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take four arguments: the <tt>YInputChain</tt> object that emitted the event, the UTC timestamp of the event, a character string describing the type of event and a character string with the event data. On failure, throws an exception or returns a negative error code.'}}
,'registerValueCallback':ds.registerValueCallback
,'resetWatchdog':{syn:'Resets the application watchdog countdown.',lib:'%.resetWatchdog()',pro:'resetWatchdog()',cmt:'<p>Resets the application watchdog countdown. If you have set up a non-zero <tt>watchdogPeriod</tt>, you should call this function on a regular basis to prevent the application inactivity error to be triggered.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_expectedNodes':{syn:'Changes the number of nodes expected in the chain.',lib:'%.set_expectedNodes()',pro:'set_expectedNodes(<span id=pn>newval</span>)',cmt:'<p>Changes the number of nodes expected in the chain. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of nodes expected in the chain'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the digital input chain.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the digital input chain. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the digital input chain.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_loopbackTest':{syn:'Changes the activation state of the exhaustive chain connectivity test.',lib:'%.set_loopbackTest()',pro:'set_loopbackTest(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the exhaustive chain connectivity test. The connectivity test requires a cable connecting the end of the chain to the loopback test connector. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'either <tt>YInputChain.LOOPBACKTEST_OFF</tt> or <tt>YInputChain.LOOPBACKTEST_ON</tt>, according to the activation state of the exhaustive chain connectivity test'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_refreshRate':{syn:'Changes the desired refresh rate, measured in Hz.',lib:'%.set_refreshRate()',pro:'set_refreshRate(<span id=pn>newval</span>)',cmt:'<p>Changes the desired refresh rate, measured in Hz. The higher the refresh rate is set, the higher the communication speed on the chain will be. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the desired refresh rate, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_watchdogPeriod':{syn:'Changes the wait time in seconds before triggering an inactivity timeout error.',lib:'%.set_watchdogPeriod()',pro:'set_watchdogPeriod(<span id=pn>newval</span>)',cmt:'<p>Changes the wait time in seconds before triggering an inactivity timeout error. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the wait time in seconds before triggering an inactivity timeout error'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: InputChain)
//--- (generated code: Introduction)
doc['*0.Introduction']={'':{syn:'',inc:'',cmt:'<p>The Yoctopuce library for Python will let you use Yoctopuce devices in your own software, written in Python.</p><p> A few lines of code are enough to use a module Yoctopuce. Here is the skeleton of a Python code snipplet to use the Temperature function. </p> <div class=\'sourcecode\'><span style="color:#00E;">&#91;</span>...<span style="color:#00E;">&#93;</span><br /> <span style="color: #CE7B00; font-style: italic;"># Enable detection of USB devices</span><br /> errmsg<span style="color:#00E;">=</span><span style="color:#29c;">YRefParam</span><span style="color:#00E;">&#40;</span><span style="color:#00E;">&#41;</span><br /> <span style="color:#29c;">YAPI</span>.<span style="color:#066;">RegisterHub</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;usb&quot;</span><span style="color:#00E;">,</span>errmsg<span style="color:#00E;">&#41;</span><br /> <span style="color:#00E;">&#91;</span>...<span style="color:#00E;">&#93;</span><br /> <br /> <span style="color: #CE7B00; font-style: italic;"># Retrieve the object used to interact with the device</span><br /> temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;METEOMK2-123456.temperature&quot;</span><span style="color:#00E;">&#41;</span><br /> <br /> <span style="color: #CE7B00; font-style: italic;"># Hot-plug is easy: just check that the device is online</span><br /> <span style="color:#00E;">if</span> temperature.<span style="color:#066;">isOnline</span><span style="color:#00E;">&#40;</span><span style="color:#00E;">&#41;</span>:<br /> &nbsp; &nbsp; <span style="color: #CE7B00; font-style: italic;"># Use temperature.get_currentValue()</span><br /> &nbsp; &nbsp; <span style="color:#00E;">&#91;</span>...<span style="color:#00E;">&#93;</span><br /> &nbsp; &nbsp; <br /> <span style="color:#00E;">&#91;</span>...<span style="color:#00E;">&#93;</span> &nbsp; &nbsp;</div> <p> Let\'s look at these lines in more details. </p> <h3>YAPI.RegisterHub</h3> <p>The <tt>yAPI.RegisterHub</tt> function initializes the Yoctopuce API and indicates where the modules should be looked for. When used with the parameter <tt>"usb"</tt>, it will use the modules locally connected to the computer running the library. If the initialization does not succeed, this function returns a value different from <tt>YAPI.SUCCESS</tt> and <tt>errmsg</tt> contains the error message. </p> <h3>YTemperature.FindTemperature</h3> <p> The <tt>YTemperature.FindTemperature</tt> function allows you to find a temperature sensor from the serial number of the module on which it resides and from its function name. You can use logical names as well, as long as you have initialized them. Let us imagine a module Yoctopuce module with serial number <i>METEOMK2-123456</i> which you have named "<i>MyModule</i>", and for which you have given the <i>temperature</i> function the name "<i>MyFunction</i>". The following five calls are strictly equivalent, as long as "<i>MyFunction</i>" is defined only once. </p> <div class=\'sourcecode\'>temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;METEOMK2-123456.temperature&quot;</span><span style="color:#00E;">&#41;</span><br /> temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;METEOMK2-123456.MyFunction&quot;</span><span style="color:#00E;">&#41;</span><br /> temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;MyModule.temperature&quot;</span><span style="color:#00E;">&#41;</span><br /> temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;MyModule.MyFunction&quot;</span><span style="color:#00E;">&#41;</span><br /> temperature <span style="color:#00E;">=</span> <span style="color:#29c;">YTemperature</span>.<span style="color:#066;">FindTemperature</span><span style="color:#00E;">&#40;</span><span style="color:#090;">&quot;MyFunction&quot;</span><span style="color:#00E;">&#41;</span></div> <p> <tt>YTemperature.FindTemperature</tt> returns an object which you can then use at will to control the temperature sensor. </p> <h3>isOnline</h3> <p> The <tt>isOnline()</tt> method of the object returned by <tt>YTemperature.FindTemperature</tt> allows you to know if the corresponding module is present and in working order. </p> <h3>About python imports</h3> <p>This documentation assumes that you are using the Python library downloaded directly from the Yoctopuce website, but if you are using the library installed with PIP, then you will need to prefix all imports with <i>yoctopuce.</i>. Meaning all the import examples shown in the documentation, such as:<p> <div class=\'sourcecode\'><span style="color:#00E;">from</span> yocto_api <span style="color:#00E;">import</span> *</div> <p>need to be converted , when the yoctopuce library was installed by PIP, to:</p> <div class=\'sourcecode\'><span style="color:#00E;">from</span> yoctopuce.<span style="color:#066;">yocto_api</span> <span style="color:#00E;">import</span> *</div><h3>Further information</h3><p>For more details on the use of the various objects found in the Yoctopuce library, you can click on the class names on the left column. But if you are just getting started with Yoctopuce devices, we recommend that you start by reading our tutorials on <a target="_blank" href="https://www.yoctopuce.com/EN/tutorials.php">www.yoctopuce.com/EN/tutorials.php</a>, and in particular the article named <a target="_blank" href="https://www.yoctopuce.com/EN/article/how-to-start-in-python-with-yoctopuce-modules">How to start in Python with Yoctopuce modules</a>.</p><p>In case of problem, don\'t hesitate to contact support by e-mail: <tt>support@yoctopuce.com</tt></p>'}};
//--- (end of generated code: Introduction)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude sensor control interface, available for instance in the Yocto-GPS-V2',inc:'from yocto_latitude import *',cmt:'<p>The <tt>YLatitude</tt> class allows you to read and configure Yoctopuce latitude sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindLatitude':{syn:'Retrieves a latitude sensor for a given identifier.',lib:'YLatitude.FindLatitude()',pro:'FindLatitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a latitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the latitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLatitude.isOnline()</tt> to test if the latitude sensor is indeed online at a given time. In case of ambiguity when looking for a latitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the latitude sensor, for instance <tt>YGNSSMK2.latitude</tt>.'},ret:'a <tt>YLatitude</tt> object allowing you to drive the latitude sensor.'}
,'FirstLatitude':{syn:'Starts the enumeration of latitude sensors currently accessible.',lib:'YLatitude.FirstLatitude()',pro:'FirstLatitude()',cmt:'<p>Starts the enumeration of latitude sensors currently accessible. Use the method <tt>YLatitude.nextLatitude()</tt> to iterate on next latitude sensors.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to the first latitude sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the latitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the latitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YLatitude.ADVMODE_IMMEDIATE</tt>, <tt>YLatitude.ADVMODE_PERIOD_AVG</tt>, <tt>YLatitude.ADVMODE_PERIOD_MIN</tt> and <tt>YLatitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YLatitude.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YLatitude.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLatitude.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLatitude.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the latitude sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the latitude sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the latitude sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the latitude sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the latitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the latitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the latitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLatitude.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the latitude sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the latitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the latitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLatitude.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the latitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the latitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLatitude.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>YLatitude.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YLatitude.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the latitude sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:'On failure, throws an exception or returns <tt>YLatitude.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>YLatitude.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YLatitude.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YLatitude.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YLatitude.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the latitude.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:'On failure, throws an exception or returns <tt>YLatitude.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the latitude sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the latitude sensor is currently reachable, without raising any error. If there is a cached value for the latitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the latitude sensor.</p>',ret:'<tt>true</tt> if the latitude sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the latitude sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the latitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextLatitude':{syn:'Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.',lib:'%.nextLatitude()',pro:'nextLatitude()',cmt:'<p>Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>. Caution: You can\x27t make any assumption about the returned latitude sensors order. If you want to find a specific a latitude sensor, use <tt>Latitude.findLatitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to a latitude sensor currently online, or a <tt>null</tt> pointer if there are no more latitude sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YLatitude.ADVMODE_IMMEDIATE</tt>, <tt>YLatitude.ADVMODE_PERIOD_AVG</tt>, <tt>YLatitude.ADVMODE_PERIOD_MIN</tt> and <tt>YLatitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the latitude sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the latitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Latitude)
//--- (generated code: Led)
doc['Led']={'':{syn:'Monochrome LED control interface, available for instance in the Yocto-Buzzer, the YoctoBox-Short-Thin-Black-Prox, the YoctoBox-Short-Thin-Transp or the YoctoBox-Short-Thin-Transp-Prox',inc:'from yocto_led import *',cmt:'<p>The <tt>YLed</tt> class allows you to drive a monocolor LED. You can not only to drive the intensity of the LED, but also to have it blink at various preset frequencies.</p>'}
,'FindLed':{syn:'Retrieves a monochrome LED for a given identifier.',lib:'YLed.FindLed()',pro:'FindLed(<span id=pn>func</span>)',cmt:'<p>Retrieves a monochrome LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the monochrome LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the monochrome LED is indeed online at a given time. In case of ambiguity when looking for a monochrome LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the monochrome LED, for instance <tt>YBUZZER2.led1</tt>.'},ret:'a <tt>YLed</tt> object allowing you to drive the monochrome LED.'}
,'FirstLed':{syn:'Starts the enumeration of monochrome LEDs currently accessible.',lib:'YLed.FirstLed()',pro:'FirstLed()',cmt:'<p>Starts the enumeration of monochrome LEDs currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next monochrome LEDs.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first monochrome LED currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the monochrome LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the monochrome LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the monochrome LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the monochrome LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the monochrome LED (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the monochrome LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monochrome LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YLed.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_blinking':{syn:'Returns the current LED signaling mode.',lib:'%.get_blinking()',pro:'get_blinking()',cmt:'<p>Returns the current LED signaling mode.</p>',ret:'a value among <tt>YLed.BLINKING_STILL</tt>, <tt>YLed.BLINKING_RELAX</tt>, <tt>YLed.BLINKING_AWARE</tt>, <tt>YLed.BLINKING_RUN</tt>, <tt>YLed.BLINKING_CALL</tt> and <tt>YLed.BLINKING_PANIC</tt> corresponding to the current LED signaling mode',ext:'On failure, throws an exception or returns <tt>YLed.BLINKING_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the monochrome LED.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the monochrome LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the monochrome LED object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the monochrome LED.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the monochrome LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the monochrome LED object'}
,'get_friendlyName':{syn:'Returns a global identifier of the monochrome LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the monochrome LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the monochrome LED if they are defined, otherwise the serial number of the module and the hardware identifier of the monochrome LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the monochrome LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLed.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the monochrome LED, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the monochrome LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the monochrome LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLed.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the monochrome LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the monochrome LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the monochrome LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the monochrome LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLed.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the monochrome LED.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the monochrome LED.</p>',ret:'a string corresponding to the logical name of the monochrome LED.',ext:'On failure, throws an exception or returns <tt>YLed.LOGICALNAME_INVALID</tt>.'}
,'get_luminosity':{syn:'Returns the current LED intensity (in per cent).',lib:'%.get_luminosity()',pro:'get_luminosity()',cmt:'<p>Returns the current LED intensity (in per cent).</p>',ret:'an integer corresponding to the current LED intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>YLed.LUMINOSITY_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_power':{syn:'Returns the current LED state.',lib:'%.get_power()',pro:'get_power()',cmt:'<p>Returns the current LED state.</p>',ret:'either <tt>YLed.POWER_OFF</tt> or <tt>YLed.POWER_ON</tt>, according to the current LED state',ext:'On failure, throws an exception or returns <tt>YLed.POWER_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the monochrome LED is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the monochrome LED is currently reachable, without raising any error. If there is a cached value for the monochrome LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the monochrome LED.</p>',ret:'<tt>true</tt> if the monochrome LED can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the monochrome LED cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the monochrome LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextLed':{syn:'Continues the enumeration of monochrome LEDs started using <tt>yFirstLed()</tt>.',lib:'%.nextLed()',pro:'nextLed()',cmt:'<p>Continues the enumeration of monochrome LEDs started using <tt>yFirstLed()</tt>. Caution: You can\x27t make any assumption about the returned monochrome LEDs order. If you want to find a specific a monochrome LED, use <tt>Led.findLed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a monochrome LED currently online, or a <tt>null</tt> pointer if there are no more monochrome LEDs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_blinking':{syn:'Changes the current LED signaling mode.',lib:'%.set_blinking()',pro:'set_blinking(<span id=pn>newval</span>)',cmt:'<p>Changes the current LED signaling mode.</p>',par:{newval:'a value among <tt>YLed.BLINKING_STILL</tt>, <tt>YLed.BLINKING_RELAX</tt>, <tt>YLed.BLINKING_AWARE</tt>, <tt>YLed.BLINKING_RUN</tt>, <tt>YLed.BLINKING_CALL</tt> and <tt>YLed.BLINKING_PANIC</tt> corresponding to the current LED signaling mode'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the monochrome LED.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the monochrome LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the monochrome LED.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_luminosity':{syn:'Changes the current LED intensity (in per cent).',lib:'%.set_luminosity()',pro:'set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the current LED intensity (in per cent). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the current LED intensity (in per cent)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_power':{syn:'Changes the state of the LED.',lib:'%.set_power()',pro:'set_power(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the LED.</p>',par:{newval:'either <tt>YLed.POWER_OFF</tt> or <tt>YLed.POWER_ON</tt>, according to the state of the LED'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Led)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'Light sensor control interface, available for instance in the Yocto-Light-V4, the Yocto-Proximity or the Yocto-RangeFinder',inc:'from yocto_lightsensor import *',cmt:'<p>The <tt>YLightSensor</tt> class allows you to read and configure Yoctopuce light sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}
,'FindLightSensor':{syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor.FindLightSensor()',pro:'FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the light sensor, for instance <tt>LIGHTMK4.lightSensor</tt>.'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'}
,'FirstLightSensor':{syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor.FirstLightSensor()',pro:'FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrate':{syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'%.calibrate()',pro:'calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the light sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the light sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YLightSensor.ADVMODE_IMMEDIATE</tt>, <tt>YLightSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YLightSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YLightSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YLightSensor.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YLightSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLightSensor.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the ambient light, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the ambient light, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLightSensor.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the light sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the light sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the light sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the light sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the light sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the light sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the light sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLightSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the light sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the light sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the light sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLightSensor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the light sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the light sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLightSensor.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>YLightSensor.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YLightSensor.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the light sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:'On failure, throws an exception or returns <tt>YLightSensor.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>YLightSensor.LOWESTVALUE_INVALID</tt>.'}
,'get_measureType':{syn:'Returns the type of light measure.',lib:'%.get_measureType()',pro:'get_measureType()',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>YLightSensor.MEASURETYPE_HUMAN_EYE</tt>, <tt>YLightSensor.MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>YLightSensor.MEASURETYPE_INFRARED</tt>, <tt>YLightSensor.MEASURETYPE_HIGH_RATE</tt>, <tt>YLightSensor.MEASURETYPE_HIGH_ENERGY</tt> and <tt>YLightSensor.MEASURETYPE_HIGH_RESOLUTION</tt> corresponding to the type of light measure',ext:'On failure, throws an exception or returns <tt>YLightSensor.MEASURETYPE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YLightSensor.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YLightSensor.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YLightSensor.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the ambient light.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:'On failure, throws an exception or returns <tt>YLightSensor.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the light sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the light sensor is currently reachable, without raising any error. If there is a cached value for the light sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the light sensor.</p>',ret:'<tt>true</tt> if the light sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the light sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the light sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextLightSensor':{syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'%.nextLightSensor()',pro:'nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>. Caution: You can\x27t make any assumption about the returned light sensors order. If you want to find a specific a light sensor, use <tt>LightSensor.findLightSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YLightSensor.ADVMODE_IMMEDIATE</tt>, <tt>YLightSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YLightSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YLightSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the light sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_measureType':{syn:'Changes the light sensor type used in the device.',lib:'%.set_measureType()',pro:'set_measureType(<span id=pn>newval</span>)',cmt:'<p>Changes the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YLightSensor.MEASURETYPE_HUMAN_EYE</tt>, <tt>YLightSensor.MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>YLightSensor.MEASURETYPE_INFRARED</tt>, <tt>YLightSensor.MEASURETYPE_HIGH_RATE</tt>, <tt>YLightSensor.MEASURETYPE_HIGH_ENERGY</tt> and <tt>YLightSensor.MEASURETYPE_HIGH_RESOLUTION</tt> corresponding to the light sensor type used in the device'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: LightSensor)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude sensor control interface, available for instance in the Yocto-GPS-V2',inc:'from yocto_longitude import *',cmt:'<p>The <tt>YLongitude</tt> class allows you to read and configure Yoctopuce longitude sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindLongitude':{syn:'Retrieves a longitude sensor for a given identifier.',lib:'YLongitude.FindLongitude()',pro:'FindLongitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a longitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the longitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLongitude.isOnline()</tt> to test if the longitude sensor is indeed online at a given time. In case of ambiguity when looking for a longitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the longitude sensor, for instance <tt>YGNSSMK2.longitude</tt>.'},ret:'a <tt>YLongitude</tt> object allowing you to drive the longitude sensor.'}
,'FirstLongitude':{syn:'Starts the enumeration of longitude sensors currently accessible.',lib:'YLongitude.FirstLongitude()',pro:'FirstLongitude()',cmt:'<p>Starts the enumeration of longitude sensors currently accessible. Use the method <tt>YLongitude.nextLongitude()</tt> to iterate on next longitude sensors.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to the first longitude sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the longitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the longitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YLongitude.ADVMODE_IMMEDIATE</tt>, <tt>YLongitude.ADVMODE_PERIOD_AVG</tt>, <tt>YLongitude.ADVMODE_PERIOD_MIN</tt> and <tt>YLongitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YLongitude.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YLongitude.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLongitude.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>YLongitude.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the longitude sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the longitude sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the longitude sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the longitude sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the longitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the longitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the longitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLongitude.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the longitude sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the longitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the longitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLongitude.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the longitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the longitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YLongitude.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>YLongitude.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YLongitude.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the longitude sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:'On failure, throws an exception or returns <tt>YLongitude.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>YLongitude.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YLongitude.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YLongitude.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YLongitude.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the longitude.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:'On failure, throws an exception or returns <tt>YLongitude.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the longitude sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the longitude sensor is currently reachable, without raising any error. If there is a cached value for the longitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the longitude sensor.</p>',ret:'<tt>true</tt> if the longitude sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the longitude sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the longitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextLongitude':{syn:'Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.',lib:'%.nextLongitude()',pro:'nextLongitude()',cmt:'<p>Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>. Caution: You can\x27t make any assumption about the returned longitude sensors order. If you want to find a specific a longitude sensor, use <tt>Longitude.findLongitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to a longitude sensor currently online, or a <tt>null</tt> pointer if there are no more longitude sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YLongitude.ADVMODE_IMMEDIATE</tt>, <tt>YLongitude.ADVMODE_PERIOD_AVG</tt>, <tt>YLongitude.ADVMODE_PERIOD_MIN</tt> and <tt>YLongitude.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the longitude sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the longitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Longitude)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer control interface, available for instance in the Yocto-3D-V2',inc:'from yocto_magnetometer import *',cmt:'<p>The <tt>YSensor</tt> class is the parent class for all Yoctopuce sensor types. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provides a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The <tt>YAnButton</tt> class is the only analog input which does not inherit from <tt>YSensor</tt>.</p>'}
,'FindMagnetometer':{syn:'Retrieves a magnetometer for a given identifier.',lib:'YMagnetometer.FindMagnetometer()',pro:'FindMagnetometer(<span id=pn>func</span>)',cmt:'<p>Retrieves a magnetometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the magnetometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMagnetometer.isOnline()</tt> to test if the magnetometer is indeed online at a given time. In case of ambiguity when looking for a magnetometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the magnetometer, for instance <tt>Y3DMK002.magnetometer</tt>.'},ret:'a <tt>YMagnetometer</tt> object allowing you to drive the magnetometer.'}
,'FirstMagnetometer':{syn:'Starts the enumeration of magnetometers currently accessible.',lib:'YMagnetometer.FirstMagnetometer()',pro:'FirstMagnetometer()',cmt:'<p>Starts the enumeration of magnetometers currently accessible. Use the method <tt>YMagnetometer.nextMagnetometer()</tt> to iterate on next magnetometers.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to the first magnetometer currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the magnetometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the magnetometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YMagnetometer.ADVMODE_IMMEDIATE</tt>, <tt>YMagnetometer.ADVMODE_PERIOD_AVG</tt>, <tt>YMagnetometer.ADVMODE_PERIOD_MIN</tt> and <tt>YMagnetometer.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YMagnetometer.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMagnetometer.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the measure update frequency, measured in Hz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz.</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz',ext:'On failure, throws an exception or returns <tt>YMagnetometer.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMagnetometer.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMagnetometer.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the magnetometer.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the magnetometer object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the magnetometer.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the magnetometer object'}
,'get_friendlyName':{syn:'Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the magnetometer if they are defined, otherwise the serial number of the module and the hardware identifier of the magnetometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the magnetometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMagnetometer.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the magnetometer, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the magnetometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the magnetometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMagnetometer.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the magnetometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the magnetometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMagnetometer.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>YMagnetometer.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YMagnetometer.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the magnetometer.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:'On failure, throws an exception or returns <tt>YMagnetometer.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>YMagnetometer.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YMagnetometer.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YMagnetometer.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YMagnetometer.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the magnetic field.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:'On failure, throws an exception or returns <tt>YMagnetometer.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_xValue':{syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'%.get_xValue()',pro:'get_xValue()',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMagnetometer.XVALUE_INVALID</tt>.'}
,'get_yValue':{syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'%.get_yValue()',pro:'get_yValue()',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMagnetometer.YVALUE_INVALID</tt>.'}
,'get_zValue':{syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'%.get_zValue()',pro:'get_zValue()',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMagnetometer.ZVALUE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the magnetometer is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the magnetometer is currently reachable, without raising any error. If there is a cached value for the magnetometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the magnetometer.</p>',ret:'<tt>true</tt> if the magnetometer can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the magnetometer cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the magnetometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMagnetometer':{syn:'Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.',lib:'%.nextMagnetometer()',pro:'nextMagnetometer()',cmt:'<p>Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>. Caution: You can\x27t make any assumption about the returned magnetometers order. If you want to find a specific a magnetometer, use <tt>Magnetometer.findMagnetometer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to a magnetometer currently online, or a <tt>null</tt> pointer if there are no more magnetometers to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YMagnetometer.ADVMODE_IMMEDIATE</tt>, <tt>YMagnetometer.ADVMODE_PERIOD_AVG</tt>, <tt>YMagnetometer.ADVMODE_PERIOD_MIN</tt> and <tt>YMagnetometer.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the measure update frequency, measured in Hz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz. When the frequency is lower, the device performs averaging. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the magnetometer.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the magnetometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Magnetometer)
//--- (generated code: Measure)
doc['Measure']={'':{syn:'Measured value, returned in particular by the methods of the <tt>YDataSet</tt> class.',inc:'from yocto_module import *',cmt:'<p><tt>YMeasure</tt> objects are used within the API to represent a value measured at a specified time. These objects are used in particular in conjunction with the <tt>YDataSet</tt> class, but also for sensors periodic timed reports (see <tt>sensor.registerTimedReportCallback</tt>).</p>'}
,'get_averageValue':{syn:'Returns the average value observed during the time interval covered by this measure.',lib:'%.get_averageValue()',pro:'get_averageValue()',cmt:'<p>Returns the average value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the average value observed.'}
,'get_endTimeUTC':{syn:'Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'%.get_endTimeUTC()',pro:'get_endTimeUTC()',cmt:'<p>Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher than 1 sample per second, the timestamp may have a fractional part.</p>',ret:'a floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the end of this measure.'}
,'get_maxValue':{syn:'Returns the largest value observed during the time interval covered by this measure.',lib:'%.get_maxValue()',pro:'get_maxValue()',cmt:'<p>Returns the largest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the largest value observed.'}
,'get_minValue':{syn:'Returns the smallest value observed during the time interval covered by this measure.',lib:'%.get_minValue()',pro:'get_minValue()',cmt:'<p>Returns the smallest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the smallest value observed.'}
,'get_startTimeUTC':{syn:'Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'%.get_startTimeUTC()',pro:'get_startTimeUTC()',cmt:'<p>Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher then 1 sample per second, the timestamp may have a fractional part.</p>',ret:'a floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the beginning of this measure.'}
};
//--- (end of generated code: Measure)
//--- (generated code: MessageBox)
doc['MessageBox']={'':{syn:'SMS message box interface control interface, available for instance in the YoctoHub-GSM-2G, the YoctoHub-GSM-3G-EU, the YoctoHub-GSM-3G-NA or the YoctoHub-GSM-4G',inc:'from yocto_messagebox import *',cmt:'<p>The <tt>YMessageBox</tt> class provides SMS sending and receiving capability for GSM-enabled Yoctopuce devices.</p>'}
,'FindMessageBox':{syn:'Retrieves a SMS message box interface for a given identifier.',lib:'YMessageBox.FindMessageBox()',pro:'FindMessageBox(<span id=pn>func</span>)',cmt:'<p>Retrieves a SMS message box interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the SMS message box interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMessageBox.isOnline()</tt> to test if the SMS message box interface is indeed online at a given time. In case of ambiguity when looking for a SMS message box interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the SMS message box interface, for instance <tt>YHUBGSM1.messageBox</tt>.'},ret:'a <tt>YMessageBox</tt> object allowing you to drive the SMS message box interface.'}
,'FirstMessageBox':{syn:'Starts the enumeration of SMS message box interfaces currently accessible.',lib:'YMessageBox.FirstMessageBox()',pro:'FirstMessageBox()',cmt:'<p>Starts the enumeration of SMS message box interfaces currently accessible. Use the method <tt>YMessageBox.nextMessageBox()</tt> to iterate on next SMS message box interfaces.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to the first SMS message box interface currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the SMS message box interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'clearPduCounters':{syn:'Clear the SMS units counters.',lib:'%.clearPduCounters()',pro:'clearPduCounters()',cmt:'<p>Clear the SMS units counters.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the SMS message box interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the SMS message box interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the SMS message box interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the SMS message box interface (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the SMS message box interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SMS message box interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMessageBox.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the SMS message box interface.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the SMS message box interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the SMS message box interface object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the SMS message box interface.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the SMS message box interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the SMS message box interface object'}
,'get_friendlyName':{syn:'Returns a global identifier of the SMS message box interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the SMS message box interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the SMS message box interface if they are defined, otherwise the serial number of the module and the hardware identifier of the SMS message box interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the SMS message box interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMessageBox.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the SMS message box interface, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the SMS message box interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the SMS message box interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMessageBox.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the SMS message box interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the SMS message box interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the SMS message box interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the SMS message box interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMessageBox.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the SMS message box interface.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the SMS message box interface.</p>',ret:'a string corresponding to the logical name of the SMS message box interface.',ext:'On failure, throws an exception or returns <tt>YMessageBox.LOGICALNAME_INVALID</tt>.'}
,'get_messages':{syn:'Returns the list of messages received and not deleted.',lib:'%.get_messages()',pro:'get_messages()',cmt:'<p>Returns the list of messages received and not deleted. This function will automatically decode concatenated SMS.</p>',ret:'an YSms object list.',ext:'On failure, throws an exception or returns an empty list.'}
,'get_module':ds.get_module
,'get_obey':{syn:'Returns the phone number authorized to send remote management commands.',lib:'%.get_obey()',pro:'get_obey()',cmt:'<p>Returns the phone number authorized to send remote management commands. When a phone number is specified, the hub will take contre of all incoming SMS messages: it will execute commands coming from the authorized number, and delete all messages once received (whether authorized or not). If you need to receive SMS messages using your own software, leave this attribute empty.</p>',ret:'a string corresponding to the phone number authorized to send remote management commands',ext:'On failure, throws an exception or returns <tt>YMessageBox.OBEY_INVALID</tt>.'}
,'get_pduReceived':{syn:'Returns the number of SMS units received so far.',lib:'%.get_pduReceived()',pro:'get_pduReceived()',cmt:'<p>Returns the number of SMS units received so far.</p>',ret:'an integer corresponding to the number of SMS units received so far',ext:'On failure, throws an exception or returns <tt>YMessageBox.PDURECEIVED_INVALID</tt>.'}
,'get_pduSent':{syn:'Returns the number of SMS units sent so far.',lib:'%.get_pduSent()',pro:'get_pduSent()',cmt:'<p>Returns the number of SMS units sent so far.</p>',ret:'an integer corresponding to the number of SMS units sent so far',ext:'On failure, throws an exception or returns <tt>YMessageBox.PDUSENT_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_slotsCount':{syn:'Returns the total number of message storage slots on the SIM card.',lib:'%.get_slotsCount()',pro:'get_slotsCount()',cmt:'<p>Returns the total number of message storage slots on the SIM card.</p>',ret:'an integer corresponding to the total number of message storage slots on the SIM card',ext:'On failure, throws an exception or returns <tt>YMessageBox.SLOTSCOUNT_INVALID</tt>.'}
,'get_slotsInUse':{syn:'Returns the number of message storage slots currently in use.',lib:'%.get_slotsInUse()',pro:'get_slotsInUse()',cmt:'<p>Returns the number of message storage slots currently in use.</p>',ret:'an integer corresponding to the number of message storage slots currently in use',ext:'On failure, throws an exception or returns <tt>YMessageBox.SLOTSINUSE_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the SMS message box interface is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the SMS message box interface is currently reachable, without raising any error. If there is a cached value for the SMS message box interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the SMS message box interface.</p>',ret:'<tt>true</tt> if the SMS message box interface can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the SMS message box interface cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the SMS message box interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'newMessage':{syn:'Creates a new empty SMS message, to be configured and sent later on.',lib:'%.newMessage()',pro:'newMessage(<span id=pn>recipient</span>)',cmt:'<p>Creates a new empty SMS message, to be configured and sent later on.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'nextMessageBox':{syn:'Continues the enumeration of SMS message box interfaces started using <tt>yFirstMessageBox()</tt>.',lib:'%.nextMessageBox()',pro:'nextMessageBox()',cmt:'<p>Continues the enumeration of SMS message box interfaces started using <tt>yFirstMessageBox()</tt>. Caution: You can\x27t make any assumption about the returned SMS message box interfaces order. If you want to find a specific a SMS message box interface, use <tt>MessageBox.findMessageBox()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to a SMS message box interface currently online, or a <tt>null</tt> pointer if there are no more SMS message box interfaces to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'sendFlashMessage':{syn:'Sends a Flash SMS (class 0 message).',lib:'%.sendFlashMessage()',pro:'sendFlashMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset immediately and are usually not saved on the SIM card. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'sendTextMessage':{syn:'Sends a regular text SMS, with standard parameters.',lib:'%.sendTextMessage()',pro:'sendTextMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Sends a regular text SMS, with standard parameters. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> and <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the SMS message box interface.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the SMS message box interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the SMS message box interface.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_obey':{syn:'Changes the phone number authorized to send remote management commands.',lib:'%.set_obey()',pro:'set_obey(<span id=pn>newval</span>)',cmt:'<p>Changes the phone number authorized to send remote management commands. The phone number usually starts with a \x27+\x27 and does not include spacers. When a phone number is specified, the hub will take contre of all incoming SMS messages: it will execute commands coming from the authorized number, and delete all messages once received (whether authorized or not). If you need to receive SMS messages using your own software, leave this attribute empty. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. </p><p> This feature is only available since YoctoHub-GSM-4G.</p>',par:{newval:'a string corresponding to the phone number authorized to send remote management commands'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pduReceived':{syn:'Changes the value of the incoming SMS units counter.',lib:'%.set_pduReceived()',pro:'set_pduReceived(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the incoming SMS units counter'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pduSent':{syn:'Changes the value of the outgoing SMS units counter.',lib:'%.set_pduSent()',pro:'set_pduSent(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing SMS units counter'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: MessageBox)
//--- (generated code: MicroPython)
doc['MicroPython']={'':{syn:'MicroPython interpreter control interface',inc:'from yocto_micropython import *',cmt:'<p>The <tt>YMicroPython</tt> class provides control of the MicroPython interpreter that can be found on some Yoctopuce devices.</p>'}
,'FindMicroPython':{syn:'Retrieves a MicroPython interpreter for a given identifier.',lib:'YMicroPython.FindMicroPython()',pro:'FindMicroPython(<span id=pn>func</span>)',cmt:'<p>Retrieves a MicroPython interpreter for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the MicroPython interpreter is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMicroPython.isOnline()</tt> to test if the MicroPython interpreter is indeed online at a given time. In case of ambiguity when looking for a MicroPython interpreter by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the MicroPython interpreter, for instance <tt>MyDevice.microPython</tt>.'},ret:'a <tt>YMicroPython</tt> object allowing you to drive the MicroPython interpreter.'}
,'FirstMicroPython':{syn:'Starts the enumeration of MicroPython interpreters currently accessible.',lib:'YMicroPython.FirstMicroPython()',pro:'FirstMicroPython()',cmt:'<p>Starts the enumeration of MicroPython interpreters currently accessible. Use the method <tt>YMicroPython.nextMicroPython()</tt> to iterate on next MicroPython interpreters.</p>',ret:'a pointer to a <tt>YMicroPython</tt> object, corresponding to the first MicroPython interpreter currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the MicroPython interpreter attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'clearLogs':{syn:'Clears MicroPython interpreter console log buffer.',lib:'%.clearLogs()',pro:'clearLogs()',cmt:'<p>Clears MicroPython interpreter console log buffer.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the MicroPython interpreter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the MicroPython interpreter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the MicroPython interpreter (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'eval':{syn:'Submit MicroPython code for execution in the interpreter.',lib:'%.eval()',pro:'eval(<span id=pn>codeName</span>, <span id=pn>mpyCode</span>)',cmt:'<p>Submit MicroPython code for execution in the interpreter. If the MicroPython interpreter is busy, this function will block until it becomes available. The code is then uploaded, compiled and executed on the fly, without beeing stored on the device filesystem.</p><p> There is no implicit reset of the MicroPython interpreter with this function. Use method <tt>reset()</tt> if you need to start from a fresh environment to run your code.</p><p> Note that although MicroPython is mostly compatible with recent Python 3.x interpreters, the limited ressources on the device impose some restrictions, in particular regarding the libraries that can be used. Please refer to the documentation for more details.</p>',par:{codeName:'name of the code file (used for error reporting only)',mpyCode:'MicroPython code to compile and execute'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the MicroPython interpreter (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the MicroPython interpreter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the MicroPython interpreter (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMicroPython.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentScript':{syn:'Returns the name of currently active script, if any.',lib:'%.get_currentScript()',pro:'get_currentScript()',cmt:'<p>Returns the name of currently active script, if any.</p>',ret:'a string corresponding to the name of currently active script, if any',ext:'On failure, throws an exception or returns <tt>YMicroPython.CURRENTSCRIPT_INVALID</tt>.'}
,'get_debugMode':{syn:'Returns the activation state of MicroPython debugging interface.',lib:'%.get_debugMode()',pro:'get_debugMode()',cmt:'<p>Returns the activation state of MicroPython debugging interface.</p>',ret:'either <tt>YMicroPython.DEBUGMODE_OFF</tt> or <tt>YMicroPython.DEBUGMODE_ON</tt>, according to the activation state of MicroPython debugging interface',ext:'On failure, throws an exception or returns <tt>YMicroPython.DEBUGMODE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the MicroPython interpreter.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the MicroPython interpreter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the MicroPython interpreter object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the MicroPython interpreter.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the MicroPython interpreter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the MicroPython interpreter object'}
,'get_friendlyName':{syn:'Returns a global identifier of the MicroPython interpreter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the MicroPython interpreter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the MicroPython interpreter if they are defined, otherwise the serial number of the module and the hardware identifier of the MicroPython interpreter (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the MicroPython interpreter using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMicroPython.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the MicroPython interpreter, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the MicroPython interpreter, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the MicroPython interpreter (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMicroPython.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the MicroPython interpreter in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the MicroPython interpreter in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the MicroPython interpreter (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the MicroPython interpreter (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMicroPython.HARDWAREID_INVALID</tt>.'}
,'get_heapFrag':{syn:'Returns the fragmentation ratio of MicroPython main memory, as observed at the end of the last garbage collection.',lib:'%.get_heapFrag()',pro:'get_heapFrag()',cmt:'<p>Returns the fragmentation ratio of MicroPython main memory, as observed at the end of the last garbage collection.</p>',ret:'an integer corresponding to the fragmentation ratio of MicroPython main memory, as observed at the end of the last garbage collection',ext:'On failure, throws an exception or returns <tt>YMicroPython.HEAPFRAG_INVALID</tt>.'}
,'get_heapUsage':{syn:'Returns the percentage of MicroPython main memory in use, as observed at the end of the last garbage collection.',lib:'%.get_heapUsage()',pro:'get_heapUsage()',cmt:'<p>Returns the percentage of MicroPython main memory in use, as observed at the end of the last garbage collection.</p>',ret:'an integer corresponding to the percentage of MicroPython main memory in use, as observed at the end of the last garbage collection',ext:'On failure, throws an exception or returns <tt>YMicroPython.HEAPUSAGE_INVALID</tt>.'}
,'get_lastLogs':{syn:'Returns a string with last logs of the MicroPython interpreter.',lib:'%.get_lastLogs()',pro:'get_lastLogs()',cmt:'<p>Returns a string with last logs of the MicroPython interpreter. This method return only logs that are still in the module.</p>',ret:'a string with last MicroPython logs. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'}
,'get_lastMsg':{syn:'Returns the last message produced by a python script.',lib:'%.get_lastMsg()',pro:'get_lastMsg()',cmt:'<p>Returns the last message produced by a python script.</p>',ret:'a string corresponding to the last message produced by a python script',ext:'On failure, throws an exception or returns <tt>YMicroPython.LASTMSG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the MicroPython interpreter.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the MicroPython interpreter.</p>',ret:'a string corresponding to the logical name of the MicroPython interpreter.',ext:'On failure, throws an exception or returns <tt>YMicroPython.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_stackUsage':{syn:'Returns the maximum percentage of MicroPython call stack in use, as observed at the end of the last garbage collection.',lib:'%.get_stackUsage()',pro:'get_stackUsage()',cmt:'<p>Returns the maximum percentage of MicroPython call stack in use, as observed at the end of the last garbage collection.</p>',ret:'an integer corresponding to the maximum percentage of MicroPython call stack in use, as observed at the end of the last garbage collection',ext:'On failure, throws an exception or returns <tt>YMicroPython.STACKUSAGE_INVALID</tt>.'}
,'get_startupDelay':{syn:'Returns the wait time before running the startup script on power on, measured in seconds.',lib:'%.get_startupDelay()',pro:'get_startupDelay()',cmt:'<p>Returns the wait time before running the startup script on power on, measured in seconds.</p>',ret:'a floating point number corresponding to the wait time before running the startup script on power on, measured in seconds',ext:'On failure, throws an exception or returns <tt>YMicroPython.STARTUPDELAY_INVALID</tt>.'}
,'get_startupScript':{syn:'Returns the name of the script to run when the device is powered on.',lib:'%.get_startupScript()',pro:'get_startupScript()',cmt:'<p>Returns the name of the script to run when the device is powered on.</p>',ret:'a string corresponding to the name of the script to run when the device is powered on',ext:'On failure, throws an exception or returns <tt>YMicroPython.STARTUPSCRIPT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_xheapUsage':{syn:'Returns the percentage of MicroPython external memory in use, as observed at the end of the last garbage collection.',lib:'%.get_xheapUsage()',pro:'get_xheapUsage()',cmt:'<p>Returns the percentage of MicroPython external memory in use, as observed at the end of the last garbage collection.</p>',ret:'an integer corresponding to the percentage of MicroPython external memory in use, as observed at the end of the last garbage collection',ext:'On failure, throws an exception or returns <tt>YMicroPython.XHEAPUSAGE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the MicroPython interpreter is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the MicroPython interpreter is currently reachable, without raising any error. If there is a cached value for the MicroPython interpreter in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the MicroPython interpreter.</p>',ret:'<tt>true</tt> if the MicroPython interpreter can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the MicroPython interpreter cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the MicroPython interpreter cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMicroPython':{syn:'Continues the enumeration of MicroPython interpreters started using <tt>yFirstMicroPython()</tt>.',lib:'%.nextMicroPython()',pro:'nextMicroPython()',cmt:'<p>Continues the enumeration of MicroPython interpreters started using <tt>yFirstMicroPython()</tt>. Caution: You can\x27t make any assumption about the returned MicroPython interpreters order. If you want to find a specific a MicroPython interpreter, use <tt>MicroPython.findMicroPython()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMicroPython</tt> object, corresponding to a MicroPython interpreter currently online, or a <tt>null</tt> pointer if there are no more MicroPython interpreters to enumerate.'}
,'registerLogCallback':{syn:'Registers a device log callback function.',lib:'%.registerLogCallback()',pro:'registerLogCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a device log callback function. This callback will be called each time microPython sends a new log message.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take two arguments: the module object that emitted the log message, and the character string containing the log. On failure, throws an exception or returns a negative error code.'}}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Stops current execution, and reset the MicroPython interpreter to initial state.',lib:'%.reset()',pro:'reset()',cmt:'<p>Stops current execution, and reset the MicroPython interpreter to initial state. All global variables are cleared, and all imports are forgotten.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentScript':{syn:'Stops current running script, and/or selects a script to run immediately in a fresh new environment.',lib:'%.set_currentScript()',pro:'set_currentScript(<span id=pn>newval</span>)',cmt:'<p>Stops current running script, and/or selects a script to run immediately in a fresh new environment. If the MicroPython interpreter is busy running a script, this function will abort it immediately and reset the execution environment. If a non-empty string is given as argument, the new script will be started.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_debugMode':{syn:'Changes the activation state of MicroPython debugging interface.',lib:'%.set_debugMode()',pro:'set_debugMode(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of MicroPython debugging interface.</p>',par:{newval:'either <tt>YMicroPython.DEBUGMODE_OFF</tt> or <tt>YMicroPython.DEBUGMODE_ON</tt>, according to the activation state of MicroPython debugging interface'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the MicroPython interpreter.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the MicroPython interpreter. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the MicroPython interpreter.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupDelay':{syn:'Changes the wait time before running the startup script on power on, between 0.1 second and 25 seconds.',lib:'%.set_startupDelay()',pro:'set_startupDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the wait time before running the startup script on power on, between 0.1 second and 25 seconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the wait time before running the startup script on power on, between 0.1 second and 25 seconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupScript':{syn:'Changes the script to run when the device is powered on.',lib:'%.set_startupScript()',pro:'set_startupScript(<span id=pn>newval</span>)',cmt:'<p>Changes the script to run when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the script to run when the device is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: MicroPython)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor control interface, available for instance in the Yocto-Motor-DC',inc:'from yocto_motor import *',cmt:'<p>The <tt>YMotor</tt> class allows you to drive a DC motor. It can be used to configure the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}
,'FindMotor':{syn:'Retrieves a motor for a given identifier.',lib:'YMotor.FindMotor()',pro:'FindMotor(<span id=pn>func</span>)',cmt:'<p>Retrieves a motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMotor.isOnline()</tt> to test if the motor is indeed online at a given time. In case of ambiguity when looking for a motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the motor, for instance <tt>MOTORCTL.motor</tt>.'},ret:'a <tt>YMotor</tt> object allowing you to drive the motor.'}
,'FirstMotor':{syn:'Starts the enumeration of motors currently accessible.',lib:'YMotor.FirstMotor()',pro:'FirstMotor()',cmt:'<p>Starts the enumeration of motors currently accessible. Use the method <tt>YMotor.nextMotor()</tt> to iterate on next motors.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to the first motor currently online, or a <tt>null</tt> pointer if there are none.'}
,'brakingForceMove':{syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'%.brakingForceMove()',pro:'brakingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'drivingForceMove':{syn:'Changes progressively the power sent to the motor for a specific duration.',lib:'%.drivingForceMove()',pro:'drivingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the power sent to the motor for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the motor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMotor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_brakingForce':{syn:'Returns the braking force applied to the motor, as a percentage.',lib:'%.get_brakingForce()',pro:'get_brakingForce()',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:'On failure, throws an exception or returns <tt>YMotor.BRAKINGFORCE_INVALID</tt>.'}
,'get_cutOffVoltage':{syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'%.get_cutOffVoltage()',pro:'get_cutOffVoltage()',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:'On failure, throws an exception or returns <tt>YMotor.CUTOFFVOLTAGE_INVALID</tt>.'}
,'get_drivingForce':{syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'%.get_drivingForce()',pro:'get_drivingForce()',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:'On failure, throws an exception or returns <tt>YMotor.DRIVINGFORCE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the motor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the motor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the motor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the motor object'}
,'get_failSafeTimeout':{syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'%.get_failSafeTimeout()',pro:'get_failSafeTimeout()',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:'On failure, throws an exception or returns <tt>YMotor.FAILSAFETIMEOUT_INVALID</tt>.'}
,'get_frequency':{syn:'Returns the PWM frequency used to control the motor.',lib:'%.get_frequency()',pro:'get_frequency()',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:'On failure, throws an exception or returns <tt>YMotor.FREQUENCY_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the motor if they are defined, otherwise the serial number of the module and the hardware identifier of the motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMotor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the motor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMotor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMotor.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the motor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:'On failure, throws an exception or returns <tt>YMotor.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_motorStatus':{syn:'Return the controller state.',lib:'%.get_motorStatus()',pro:'get_motorStatus()',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an over current condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>YMotor.MOTORSTATUS_IDLE</tt>, <tt>YMotor.MOTORSTATUS_BRAKE</tt>, <tt>YMotor.MOTORSTATUS_FORWD</tt>, <tt>YMotor.MOTORSTATUS_BACKWD</tt>, <tt>YMotor.MOTORSTATUS_LOVOLT</tt>, <tt>YMotor.MOTORSTATUS_HICURR</tt>, <tt>YMotor.MOTORSTATUS_HIHEAT</tt> and <tt>YMotor.MOTORSTATUS_FAILSF</tt>',ext:'On failure, throws an exception or returns <tt>YMotor.MOTORSTATUS_INVALID</tt>.'}
,'get_overCurrentLimit':{syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'%.get_overCurrentLimit()',pro:'get_overCurrentLimit()',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:'On failure, throws an exception or returns <tt>YMotor.OVERCURRENTLIMIT_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_starterTime':{syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'%.get_starterTime()',pro:'get_starterTime()',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:'On failure, throws an exception or returns <tt>YMotor.STARTERTIME_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the motor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the motor is currently reachable, without raising any error. If there is a cached value for the motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the motor.</p>',ret:'<tt>true</tt> if the motor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'keepALive':{syn:'Rearms the controller failsafe timer.',lib:'%.keepALive()',pro:'keepALive()',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitly rearms the failsafe timer.</p>'}
,'load':{syn:'Preloads the motor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMotor':{syn:'Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.',lib:'%.nextMotor()',pro:'nextMotor()',cmt:'<p>Continues the enumeration of motors started using <tt>yFirstMotor()</tt>. Caution: You can\x27t make any assumption about the returned motors order. If you want to find a specific a motor, use <tt>Motor.findMotor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to a motor currently online, or a <tt>null</tt> pointer if there are no more motors to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'resetStatus':{syn:'Reset the controller state to IDLE.',lib:'%.resetStatus()',pro:'resetStatus()',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitly after any error condition is signaled.</p>'}
,'set_brakingForce':{syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'%.set_brakingForce()',pro:'set_brakingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_cutOffVoltage':{syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'%.set_cutOffVoltage()',pro:'set_cutOffVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_drivingForce':{syn:'Changes immediately the power sent to the motor.',lib:'%.set_drivingForce()',pro:'set_drivingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_failSafeTimeout':{syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'%.set_failSafeTimeout()',pro:'set_failSafeTimeout(<span id=pn>newval</span>)',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_frequency':{syn:'Changes the PWM frequency used to control the motor.',lib:'%.set_frequency()',pro:'set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the motor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_overCurrentLimit':{syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'%.set_overCurrentLimit()',pro:'set_overCurrentLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_starterTime':{syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'%.set_starterTime()',pro:'set_starterTime(<span id=pn>newval</span>)',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Motor)
//--- (generated code: MultiAxisController)
doc['MultiAxisController']={'':{syn:'MultiAxisController function interface',inc:'from yocto_multiaxiscontroller import *',cmt:'<p>The <tt>YMultiAxisController</tt> class allows you to drive multiple stepper motors synchronously.</p>'}
,'FindMultiAxisController':{syn:'Retrieves a multi-axis controller for a given identifier.',lib:'YMultiAxisController.FindMultiAxisController()',pro:'FindMultiAxisController(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-axis controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-axis controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiAxisController.isOnline()</tt> to test if the multi-axis controller is indeed online at a given time. In case of ambiguity when looking for a multi-axis controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-axis controller, for instance <tt>MyDevice.multiAxisController</tt>.'},ret:'a <tt>YMultiAxisController</tt> object allowing you to drive the multi-axis controller.'}
,'FirstMultiAxisController':{syn:'Starts the enumeration of multi-axis controllers currently accessible.',lib:'YMultiAxisController.FirstMultiAxisController()',pro:'FirstMultiAxisController()',cmt:'<p>Starts the enumeration of multi-axis controllers currently accessible. Use the method <tt>YMultiAxisController.nextMultiAxisController()</tt> to iterate on next multi-axis controllers.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to the first multi-axis controller currently online, or a <tt>null</tt> pointer if there are none.'}
,'abortAndBrake':{syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'%.abortAndBrake()',pro:'abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'abortAndHiZ':{syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'%.abortAndHiZ()',pro:'abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-axis controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-axis controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'emergencyStop':{syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'%.emergencyStop()',pro:'emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'findHomePosition':{syn:'Starts all motors backward at the specified speeds, to search for the motor home position.',lib:'%.findHomePosition()',pro:'findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Starts all motors backward at the specified speeds, to search for the motor home position.</p>',par:{speed:'desired speed for all axis, in steps per second.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the multi-axis controller (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the multi-axis controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-axis controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the multi-axis controller.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-axis controller object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the multi-axis controller.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-axis controller object'}
,'get_friendlyName':{syn:'Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-axis controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-axis controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-axis controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the multi-axis controller, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-axis controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-axis controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.FUNCTIONID_INVALID</tt>.'}
,'get_globalState':{syn:'Returns the stepper motor set overall state.',lib:'%.get_globalState()',pro:'get_globalState()',cmt:'<p>Returns the stepper motor set overall state.</p>',ret:'a value among <tt>YMultiAxisController.GLOBALSTATE_ABSENT</tt>, <tt>YMultiAxisController.GLOBALSTATE_ALERT</tt>, <tt>YMultiAxisController.GLOBALSTATE_HI_Z</tt>, <tt>YMultiAxisController.GLOBALSTATE_STOP</tt>, <tt>YMultiAxisController.GLOBALSTATE_RUN</tt> and <tt>YMultiAxisController.GLOBALSTATE_BATCH</tt> corresponding to the stepper motor set overall state',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.GLOBALSTATE_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-axis controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-axis controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the multi-axis controller.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the multi-axis controller.</p>',ret:'a string corresponding to the logical name of the multi-axis controller.',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nAxis':{syn:'Returns the number of synchronized controllers.',lib:'%.get_nAxis()',pro:'get_nAxis()',cmt:'<p>Returns the number of synchronized controllers.</p>',ret:'an integer corresponding to the number of synchronized controllers',ext:'On failure, throws an exception or returns <tt>YMultiAxisController.NAXIS_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the multi-axis controller is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the multi-axis controller is currently reachable, without raising any error. If there is a cached value for the multi-axis controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-axis controller.</p>',ret:'<tt>true</tt> if the multi-axis controller can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the multi-axis controller cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-axis controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'moveRel':{syn:'Starts all motors synchronously to reach a given relative position.',lib:'%.moveRel()',pro:'moveRel(<span id=pn>relPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given relative position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'moveTo':{syn:'Starts all motors synchronously to reach a given absolute position.',lib:'%.moveTo()',pro:'moveTo(<span id=pn>absPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given absolute position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{absPos:'absolute position, measured in steps from each origin.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMultiAxisController':{syn:'Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>.',lib:'%.nextMultiAxisController()',pro:'nextMultiAxisController()',cmt:'<p>Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>. Caution: You can\x27t make any assumption about the returned multi-axis controllers order. If you want to find a specific a multi-axis controller, use <tt>MultiAxisController.findMultiAxisController()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to a multi-axis controller currently online, or a <tt>null</tt> pointer if there are no more multi-axis controllers to enumerate.'}
,'pause':{syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'%.pause()',pro:'pause(<span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Reinitialize all controllers and clear all alert flags.',lib:'%.reset()',pro:'reset()',cmt:'<p>Reinitialize all controllers and clear all alert flags.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the multi-axis controller.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-axis controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-axis controller.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_nAxis':{syn:'Changes the number of synchronized controllers.',lib:'%.set_nAxis()',pro:'set_nAxis(<span id=pn>newval</span>)',cmt:'<p>Changes the number of synchronized controllers.</p>',par:{newval:'an integer corresponding to the number of synchronized controllers'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: MultiAxisController)
//--- (generated code: MultiCellWeighScale)
doc['MultiCellWeighScale']={'':{syn:'Multi-cell weighing scale sensor control interface, available for instance in the Yocto-MaxiBridge',inc:'from yocto_multicellweighscale import *',cmt:'<p>The <tt>YMultiCellWeighScale</tt> class provides a weight measurement from a set of ratiometric sensors. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cells themselves.</p>'}
,'FindMultiCellWeighScale':{syn:'Retrieves a multi-cell weighing scale sensor for a given identifier.',lib:'YMultiCellWeighScale.FindMultiCellWeighScale()',pro:'FindMultiCellWeighScale(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-cell weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-cell weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiCellWeighScale.isOnline()</tt> to test if the multi-cell weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a multi-cell weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-cell weighing scale sensor, for instance <tt>YWMBRDG1.multiCellWeighScale</tt>.'},ret:'a <tt>YMultiCellWeighScale</tt> object allowing you to drive the multi-cell weighing scale sensor.'}
,'FirstMultiCellWeighScale':{syn:'Starts the enumeration of multi-cell weighing scale sensors currently accessible.',lib:'YMultiCellWeighScale.FirstMultiCellWeighScale()',pro:'FirstMultiCellWeighScale()',cmt:'<p>Starts the enumeration of multi-cell weighing scale sensors currently accessible. Use the method <tt>YMultiCellWeighScale.nextMultiCellWeighScale()</tt> to iterate on next multi-cell weighing scale sensors.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to the first multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-cell weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-cell weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YMultiCellWeighScale.ADVMODE_IMMEDIATE</tt>, <tt>YMultiCellWeighScale.ADVMODE_PERIOD_AVG</tt>, <tt>YMultiCellWeighScale.ADVMODE_PERIOD_MIN</tt> and <tt>YMultiCellWeighScale.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-cell weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_cellCount':{syn:'Returns the number of load cells in use.',lib:'%.get_cellCount()',pro:'get_cellCount()',cmt:'<p>Returns the number of load cells in use.</p>',ret:'an integer corresponding to the number of load cells in use',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.CELLCOUNT_INVALID</tt>.'}
,'get_compTempAvg':{syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'%.get_compTempAvg()',pro:'get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.COMPTEMPAVG_INVALID</tt>.'}
,'get_compTempChg':{syn:'Returns the current temperature variation, used for thermal compensation.',lib:'%.get_compTempChg()',pro:'get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.COMPTEMPCHG_INVALID</tt>.'}
,'get_compensation':{syn:'Returns the current current thermal compensation value.',lib:'%.get_compensation()',pro:'get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.COMPENSATION_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the multi-cell weighing scale sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-cell weighing scale sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the multi-cell weighing scale sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-cell weighing scale sensor object'}
,'get_excitation':{syn:'Returns the current load cell bridge excitation method.',lib:'%.get_excitation()',pro:'get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>YMultiCellWeighScale.EXCITATION_OFF</tt>, <tt>YMultiCellWeighScale.EXCITATION_DC</tt> and <tt>YMultiCellWeighScale.EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.EXCITATION_INVALID</tt>.'}
,'get_externalSense':{syn:'Returns true if entry 4 is used as external sense for 6-wires load cells.',lib:'%.get_externalSense()',pro:'get_externalSense()',cmt:'<p>Returns true if entry 4 is used as external sense for 6-wires load cells.</p>',ret:'either <tt>YMultiCellWeighScale.EXTERNALSENSE_FALSE</tt> or <tt>YMultiCellWeighScale.EXTERNALSENSE_TRUE</tt>, according to true if entry 4 is used as external sense for 6-wires load cells',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.EXTERNALSENSE_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-cell weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-cell weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-cell weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-cell weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the multi-cell weighing scale sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the multi-cell weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the multi-cell weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_tempAvgAdaptRatio':{syn:'Returns the averaged temperature update rate, in per mille.',lib:'%.get_tempAvgAdaptRatio()',pro:'get_tempAvgAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.TEMPAVGADAPTRATIO_INVALID</tt>.'}
,'get_tempChgAdaptRatio':{syn:'Returns the temperature change update rate, in per mille.',lib:'%.get_tempChgAdaptRatio()',pro:'get_tempChgAdaptRatio()',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.TEMPCHGADAPTRATIO_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_zeroTracking':{syn:'Returns the zero tracking threshold value.',lib:'%.get_zeroTracking()',pro:'get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>YMultiCellWeighScale.ZEROTRACKING_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the multi-cell weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-cell weighing scale sensor.</p>',ret:'<tt>true</tt> if the multi-cell weighing scale sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the multi-cell weighing scale sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-cell weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMultiCellWeighScale':{syn:'Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>.',lib:'%.nextMultiCellWeighScale()',pro:'nextMultiCellWeighScale()',cmt:'<p>Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>. Caution: You can\x27t make any assumption about the returned multi-cell weighing scale sensors order. If you want to find a specific a multi-cell weighing scale sensor, use <tt>MultiCellWeighScale.findMultiCellWeighScale()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to a multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more multi-cell weighing scale sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YMultiCellWeighScale.ADVMODE_IMMEDIATE</tt>, <tt>YMultiCellWeighScale.ADVMODE_PERIOD_AVG</tt>, <tt>YMultiCellWeighScale.ADVMODE_PERIOD_MIN</tt> and <tt>YMultiCellWeighScale.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_cellCount':{syn:'Changes the number of load cells in use.',lib:'%.set_cellCount()',pro:'set_cellCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of load cells in use. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of load cells in use'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_excitation':{syn:'Changes the current load cell bridge excitation method.',lib:'%.set_excitation()',pro:'set_excitation(<span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YMultiCellWeighScale.EXCITATION_OFF</tt>, <tt>YMultiCellWeighScale.EXCITATION_DC</tt> and <tt>YMultiCellWeighScale.EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_externalSense':{syn:'Changes the configuration to tell if entry 4 is used as external sense for 6-wires load cells.',lib:'%.set_externalSense()',pro:'set_externalSense(<span id=pn>newval</span>)',cmt:'<p>Changes the configuration to tell if entry 4 is used as external sense for 6-wires load cells. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YMultiCellWeighScale.EXTERNALSENSE_FALSE</tt> or <tt>YMultiCellWeighScale.EXTERNALSENSE_TRUE</tt>, according to the configuration to tell if entry 4 is used as external sense for 6-wires load cells'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the multi-cell weighing scale sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-cell weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-cell weighing scale sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_tempAvgAdaptRatio':{syn:'Changes the averaged temperature update rate, in per mille.',lib:'%.set_tempAvgAdaptRatio()',pro:'set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_tempChgAdaptRatio':{syn:'Changes the temperature change update rate, in per mille.',lib:'%.set_tempChgAdaptRatio()',pro:'set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 per mille. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the weight.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_zeroTracking':{syn:'Changes the zero tracking threshold value.',lib:'%.set_zeroTracking()',pro:'set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setupSpan':{syn:'Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.',lib:'%.setupSpan()',pro:'setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'tare':{syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'%.tare()',pro:'tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: MultiCellWeighScale)
//--- (generated code: MultiSensController)
doc['MultiSensController']={'':{syn:'Sensor chain configuration interface, available for instance in the Yocto-Temperature-IR',inc:'from yocto_multisenscontroller import *',cmt:'<p>The <tt>YMultiSensController</tt> class allows you to set up a customized sensor chain on devices featuring that functionality.</p>'}
,'FindMultiSensController':{syn:'Retrieves a multi-sensor controller for a given identifier.',lib:'YMultiSensController.FindMultiSensController()',pro:'FindMultiSensController(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-sensor controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-sensor controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiSensController.isOnline()</tt> to test if the multi-sensor controller is indeed online at a given time. In case of ambiguity when looking for a multi-sensor controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-sensor controller, for instance <tt>YTEMPIR1.multiSensController</tt>.'},ret:'a <tt>YMultiSensController</tt> object allowing you to drive the multi-sensor controller.'}
,'FirstMultiSensController':{syn:'Starts the enumeration of multi-sensor controllers currently accessible.',lib:'YMultiSensController.FirstMultiSensController()',pro:'FirstMultiSensController()',cmt:'<p>Starts the enumeration of multi-sensor controllers currently accessible. Use the method <tt>YMultiSensController.nextMultiSensController()</tt> to iterate on next multi-sensor controllers.</p>',ret:'a pointer to a <tt>YMultiSensController</tt> object, corresponding to the first multi-sensor controller currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-sensor controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-sensor controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the multi-sensor controller (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the multi-sensor controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-sensor controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YMultiSensController.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the multi-sensor controller.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-sensor controller object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the multi-sensor controller.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-sensor controller object'}
,'get_friendlyName':{syn:'Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-sensor controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-sensor controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-sensor controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiSensController.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the multi-sensor controller, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-sensor controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-sensor controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiSensController.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-sensor controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-sensor controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YMultiSensController.HARDWAREID_INVALID</tt>.'}
,'get_lastAddressDetected':{syn:'Returns the I2C address of the most recently detected sensor.',lib:'%.get_lastAddressDetected()',pro:'get_lastAddressDetected()',cmt:'<p>Returns the I2C address of the most recently detected sensor. This method can be used to in case of I2C communication error to determine what is the last sensor that can be reached, or after a call to <tt>setupAddress</tt> to make sure that the address change was properly processed.</p>',ret:'an integer corresponding to the I2C address of the most recently detected sensor',ext:'On failure, throws an exception or returns <tt>YMultiSensController.LASTADDRESSDETECTED_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the multi-sensor controller.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the multi-sensor controller.</p>',ret:'a string corresponding to the logical name of the multi-sensor controller.',ext:'On failure, throws an exception or returns <tt>YMultiSensController.LOGICALNAME_INVALID</tt>.'}
,'get_maintenanceMode':{syn:'Returns true when the device is in maintenance mode.',lib:'%.get_maintenanceMode()',pro:'get_maintenanceMode()',cmt:'<p>Returns true when the device is in maintenance mode.</p>',ret:'either <tt>YMultiSensController.MAINTENANCEMODE_FALSE</tt> or <tt>YMultiSensController.MAINTENANCEMODE_TRUE</tt>, according to true when the device is in maintenance mode',ext:'On failure, throws an exception or returns <tt>YMultiSensController.MAINTENANCEMODE_INVALID</tt>.'}
,'get_maxSensors':{syn:'Returns the maximum configurable sensor count allowed on this device.',lib:'%.get_maxSensors()',pro:'get_maxSensors()',cmt:'<p>Returns the maximum configurable sensor count allowed on this device.</p>',ret:'an integer corresponding to the maximum configurable sensor count allowed on this device',ext:'On failure, throws an exception or returns <tt>YMultiSensController.MAXSENSORS_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nSensors':{syn:'Returns the number of sensors to poll.',lib:'%.get_nSensors()',pro:'get_nSensors()',cmt:'<p>Returns the number of sensors to poll.</p>',ret:'an integer corresponding to the number of sensors to poll',ext:'On failure, throws an exception or returns <tt>YMultiSensController.NSENSORS_INVALID</tt>.'}
,'get_sensorAddress':{syn:'Triggers the I2C address detection procedure for the only sensor connected to the device.',lib:'%.get_sensorAddress()',pro:'get_sensorAddress()',cmt:'<p>Triggers the I2C address detection procedure for the only sensor connected to the device. This method is only intended to work with a single sensor connected to the device. If several sensors are connected, the result is unpredictable.</p>',ret:'the I2C address of the detected sensor, or 0 if none is found',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the multi-sensor controller is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the multi-sensor controller is currently reachable, without raising any error. If there is a cached value for the multi-sensor controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-sensor controller.</p>',ret:'<tt>true</tt> if the multi-sensor controller can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the multi-sensor controller cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-sensor controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextMultiSensController':{syn:'Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensController()</tt>.',lib:'%.nextMultiSensController()',pro:'nextMultiSensController()',cmt:'<p>Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensController()</tt>. Caution: You can\x27t make any assumption about the returned multi-sensor controllers order. If you want to find a specific a multi-sensor controller, use <tt>MultiSensController.findMultiSensController()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiSensController</tt> object, corresponding to a multi-sensor controller currently online, or a <tt>null</tt> pointer if there are no more multi-sensor controllers to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the multi-sensor controller.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-sensor controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-sensor controller.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maintenanceMode':{syn:'Changes the device mode to enable maintenance and to stop sensor polling.',lib:'%.set_maintenanceMode()',pro:'set_maintenanceMode(<span id=pn>newval</span>)',cmt:'<p>Changes the device mode to enable maintenance and to stop sensor polling. This way, the device does not automatically restart when it cannot communicate with one of the sensors.</p>',par:{newval:'either <tt>YMultiSensController.MAINTENANCEMODE_FALSE</tt> or <tt>YMultiSensController.MAINTENANCEMODE_TRUE</tt>, according to the device mode to enable maintenance and to stop sensor polling'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_nSensors':{syn:'Changes the number of sensors to poll.',lib:'%.set_nSensors()',pro:'set_nSensors(<span id=pn>newval</span>)',cmt:'<p>Changes the number of sensors to poll. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. It is recommended to restart the device with <tt>module->reboot()</tt> after modifying (and saving) this settings.</p>',par:{newval:'an integer corresponding to the number of sensors to poll'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'setupAddress':{syn:'Configures the I2C address of the only sensor connected to the device.',lib:'%.setupAddress()',pro:'setupAddress(<span id=pn>addr</span>)',cmt:'<p>Configures the I2C address of the only sensor connected to the device. It is recommended to put the the device in maintenance mode before changing sensor addresses. This method is only intended to work with a single sensor connected to the device. If several sensors are connected, the result is unpredictable.</p><p> Note that the device is expecting to find a sensor or a string of sensors with specific addresses. Check the device documentation to find out which addresses should be used.</p>',par:{addr:'new address of the connected sensor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: MultiSensController)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network interface control interface, available for instance in the YoctoHub-Ethernet, the YoctoHub-GSM-4G, the YoctoHub-Wireless-SR or the YoctoHub-Wireless-n',inc:'from yocto_network import *',cmt:'<p><tt>YNetwork</tt> objects provide access to TCP/IP parameters of Yoctopuce devices that include a built-in network interface.</p>'}
,'FindNetwork':{syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork.FindNetwork()',pro:'FindNetwork(<span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the network interface, for instance <tt>YHUBETH1.network</tt>.'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'}
,'FirstNetwork':{syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork.FirstNetwork()',pro:'FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'}
,'callbackLogin':{syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'%.callbackLogin()',pro:'callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the network interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the network interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_adminPassword':{syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'%.get_adminPassword()',pro:'get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>YNetwork.ADMINPASSWORD_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YNetwork.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_callbackCredentials':{syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'%.get_callbackCredentials()',pro:'get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKCREDENTIALS_INVALID</tt>.'}
,'get_callbackEncoding':{syn:'Returns the encoding standard to use for representing notification values.',lib:'%.get_callbackEncoding()',pro:'get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>YNetwork.CALLBACKENCODING_FORM</tt>, <tt>YNetwork.CALLBACKENCODING_JSON</tt>, <tt>YNetwork.CALLBACKENCODING_JSON_ARRAY</tt>, <tt>YNetwork.CALLBACKENCODING_CSV</tt>, <tt>YNetwork.CALLBACKENCODING_YOCTO_API</tt>, <tt>YNetwork.CALLBACKENCODING_JSON_NUM</tt>, <tt>YNetwork.CALLBACKENCODING_EMONCMS</tt>, <tt>YNetwork.CALLBACKENCODING_AZURE</tt>, <tt>YNetwork.CALLBACKENCODING_INFLUXDB</tt>, <tt>YNetwork.CALLBACKENCODING_MQTT</tt>, <tt>YNetwork.CALLBACKENCODING_YOCTO_API_JZON</tt>, <tt>YNetwork.CALLBACKENCODING_PRTG</tt> and <tt>YNetwork.CALLBACKENCODING_INFLUXDB_V2</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKENCODING_INVALID</tt>.'}
,'get_callbackInitialDelay':{syn:'Returns the initial waiting time before first callback notifications, in seconds.',lib:'%.get_callbackInitialDelay()',pro:'get_callbackInitialDelay()',cmt:'<p>Returns the initial waiting time before first callback notifications, in seconds.</p>',ret:'an integer corresponding to the initial waiting time before first callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKINITIALDELAY_INVALID</tt>.'}
,'get_callbackMaxDelay':{syn:'Returns the waiting time between two HTTP callbacks when there is nothing new.',lib:'%.get_callbackMaxDelay()',pro:'get_callbackMaxDelay()',cmt:'<p>Returns the waiting time between two HTTP callbacks when there is nothing new.</p>',ret:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKMAXDELAY_INVALID</tt>.'}
,'get_callbackMethod':{syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'%.get_callbackMethod()',pro:'get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>YNetwork.CALLBACKMETHOD_POST</tt>, <tt>YNetwork.CALLBACKMETHOD_GET</tt> and <tt>YNetwork.CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKMETHOD_INVALID</tt>.'}
,'get_callbackMinDelay':{syn:'Returns the minimum waiting time between two HTTP callbacks, in seconds.',lib:'%.get_callbackMinDelay()',pro:'get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two HTTP callbacks, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKMINDELAY_INVALID</tt>.'}
,'get_callbackSchedule':{syn:'Returns the HTTP callback schedule strategy, as a text string.',lib:'%.get_callbackSchedule()',pro:'get_callbackSchedule()',cmt:'<p>Returns the HTTP callback schedule strategy, as a text string.</p>',ret:'a string corresponding to the HTTP callback schedule strategy, as a text string',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKSCHEDULE_INVALID</tt>.'}
,'get_callbackTemplate':{syn:'Returns the activation state of the custom template file to customize callback format.',lib:'%.get_callbackTemplate()',pro:'get_callbackTemplate()',cmt:'<p>Returns the activation state of the custom template file to customize callback format. If the custom callback template is disabled, it will be ignored even if present on the YoctoHub.</p>',ret:'either <tt>YNetwork.CALLBACKTEMPLATE_OFF</tt> or <tt>YNetwork.CALLBACKTEMPLATE_ON</tt>, according to the activation state of the custom template file to customize callback format',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKTEMPLATE_INVALID</tt>.'}
,'get_callbackUrl':{syn:'Returns the callback URL to notify of significant state changes.',lib:'%.get_callbackUrl()',pro:'get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>YNetwork.CALLBACKURL_INVALID</tt>.'}
,'get_currentDNS':{syn:'Returns the IP address of the DNS server currently used by the device.',lib:'%.get_currentDNS()',pro:'get_currentDNS()',cmt:'<p>Returns the IP address of the DNS server currently used by the device.</p>',ret:'a string corresponding to the IP address of the DNS server currently used by the device',ext:'On failure, throws an exception or returns <tt>YNetwork.CURRENTDNS_INVALID</tt>.'}
,'get_defaultPage':{syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'%.get_defaultPage()',pro:'get_defaultPage()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>YNetwork.DEFAULTPAGE_INVALID</tt>.'}
,'get_discoverable':{syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'%.get_discoverable()',pro:'get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>YNetwork.DISCOVERABLE_FALSE</tt> or <tt>YNetwork.DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>YNetwork.DISCOVERABLE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the network interface.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the network interface object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the network interface.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the network interface object'}
,'get_friendlyName':{syn:'Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the network interface if they are defined, otherwise the serial number of the module and the hardware identifier of the network interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the network interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YNetwork.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the network interface, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the network interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the network interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YNetwork.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the network interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the network interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YNetwork.HARDWAREID_INVALID</tt>.'}
,'get_httpPort':{syn:'Returns the TCP port used to serve the hub web UI.',lib:'%.get_httpPort()',pro:'get_httpPort()',cmt:'<p>Returns the TCP port used to serve the hub web UI.</p>',ret:'an integer corresponding to the TCP port used to serve the hub web UI',ext:'On failure, throws an exception or returns <tt>YNetwork.HTTPPORT_INVALID</tt>.'}
,'get_httpsPort':{syn:'Returns the secure TCP port used to serve the hub web UI.',lib:'%.get_httpsPort()',pro:'get_httpsPort()',cmt:'<p>Returns the secure TCP port used to serve the hub web UI.</p>',ret:'an integer corresponding to the secure TCP port used to serve the hub web UI',ext:'On failure, throws an exception or returns <tt>YNetwork.HTTPSPORT_INVALID</tt>.'}
,'get_ipAddress':{syn:'Returns the IP address currently in use by the device.',lib:'%.get_ipAddress()',pro:'get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>YNetwork.IPADDRESS_INVALID</tt>.'}
,'get_ipConfig':{syn:'Returns the IP configuration of the network interface.',lib:'%.get_ipConfig()',pro:'get_ipConfig()',cmt:'<p>Returns the IP configuration of the network interface.</p><p> If the network interface is set up to use a static IP address, the string starts with \x22STATIC:\x22 and is followed by three parameters, separated by \x22/\x22. The first is the device IP address, followed by the subnet mask length, and finally the router IP address (default gateway). For instance: \x22STATIC:192.168.1.14/16/192.168.1.1\x22</p><p> If the network interface is configured to receive its IP from a DHCP server, the string start with \x22DHCP:\x22 and is followed by three parameters separated by \x22/\x22. The first is the fallback IP address, then the fallback subnet mask length and finally the fallback router IP address. These three parameters are used when no DHCP reply is received.</p>',ret:'a string corresponding to the IP configuration of the network interface',ext:'On failure, throws an exception or returns <tt>YNetwork.IPCONFIG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the network interface.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:'On failure, throws an exception or returns <tt>YNetwork.LOGICALNAME_INVALID</tt>.'}
,'get_macAddress':{syn:'Returns the MAC address of the network interface.',lib:'%.get_macAddress()',pro:'get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>YNetwork.MACADDRESS_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_ntpServer':{syn:'Returns the IP address of the NTP server to be used by the device.',lib:'%.get_ntpServer()',pro:'get_ntpServer()',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:'On failure, throws an exception or returns <tt>YNetwork.NTPSERVER_INVALID</tt>.'}
,'get_poeCurrent':{syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.',lib:'%.get_poeCurrent()',pro:'get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milliamps',ext:'On failure, throws an exception or returns <tt>YNetwork.POECURRENT_INVALID</tt>.'}
,'get_primaryDNS':{syn:'Returns the IP address of the primary name server to be used by the module.',lib:'%.get_primaryDNS()',pro:'get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>YNetwork.PRIMARYDNS_INVALID</tt>.'}
,'get_readiness':{syn:'Returns the current established working mode of the network interface.',lib:'%.get_readiness()',pro:'get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>YNetwork.READINESS_DOWN</tt>, <tt>YNetwork.READINESS_EXISTS</tt>, <tt>YNetwork.READINESS_LINKED</tt>, <tt>YNetwork.READINESS_LAN_OK</tt> and <tt>YNetwork.READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>YNetwork.READINESS_INVALID</tt>.'}
,'get_router':{syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'%.get_router()',pro:'get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>YNetwork.ROUTER_INVALID</tt>.'}
,'get_secondaryDNS':{syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'%.get_secondaryDNS()',pro:'get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>YNetwork.SECONDARYDNS_INVALID</tt>.'}
,'get_securityMode':{syn:'Returns the security level chosen to prevent unauthorized access to the server.',lib:'%.get_securityMode()',pro:'get_securityMode()',cmt:'<p>Returns the security level chosen to prevent unauthorized access to the server.</p>',ret:'a value among <tt>YNetwork.SECURITYMODE_UNDEFINED</tt>, <tt>YNetwork.SECURITYMODE_LEGACY</tt>, <tt>YNetwork.SECURITYMODE_MIXED</tt> and <tt>YNetwork.SECURITYMODE_SECURE</tt> corresponding to the security level chosen to prevent unauthorized access to the server',ext:'On failure, throws an exception or returns <tt>YNetwork.SECURITYMODE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_subnetMask':{syn:'Returns the subnet mask currently used by the device.',lib:'%.get_subnetMask()',pro:'get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>YNetwork.SUBNETMASK_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_userPassword':{syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'%.get_userPassword()',pro:'get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>YNetwork.USERPASSWORD_INVALID</tt>.'}
,'get_wwwWatchdogDelay':{syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'%.get_wwwWatchdogDelay()',pro:'get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>YNetwork.WWWWATCHDOGDELAY_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the network interface is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the network interface is currently reachable, without raising any error. If there is a cached value for the network interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the network interface.</p>',ret:'<tt>true</tt> if the network interface can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the network interface cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the network interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextNetwork':{syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'%.nextNetwork()',pro:'nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>. Caution: You can\x27t make any assumption about the returned network interfaces order. If you want to find a specific a network interface, use <tt>Network.findNetwork()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'}
,'ping':{syn:'Pings host to test the network connectivity.',lib:'%.ping()',pro:'ping(<span id=pn>host</span>)',cmt:'<p>Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'}
,'registerValueCallback':ds.registerValueCallback
,'set_adminPassword':{syn:'Changes the password for the \x22admin\x22 user.',lib:'%.set_adminPassword()',pro:'set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackCredentials':{syn:'Changes the credentials required to connect to the callback address.',lib:'%.set_callbackCredentials()',pro:'set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackEncoding':{syn:'Changes the encoding standard to use for representing notification values.',lib:'%.set_callbackEncoding()',pro:'set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YNetwork.CALLBACKENCODING_FORM</tt>, <tt>YNetwork.CALLBACKENCODING_JSON</tt>, <tt>YNetwork.CALLBACKENCODING_JSON_ARRAY</tt>, <tt>YNetwork.CALLBACKENCODING_CSV</tt>, <tt>YNetwork.CALLBACKENCODING_YOCTO_API</tt>, <tt>YNetwork.CALLBACKENCODING_JSON_NUM</tt>, <tt>YNetwork.CALLBACKENCODING_EMONCMS</tt>, <tt>YNetwork.CALLBACKENCODING_AZURE</tt>, <tt>YNetwork.CALLBACKENCODING_INFLUXDB</tt>, <tt>YNetwork.CALLBACKENCODING_MQTT</tt>, <tt>YNetwork.CALLBACKENCODING_YOCTO_API_JZON</tt>, <tt>YNetwork.CALLBACKENCODING_PRTG</tt> and <tt>YNetwork.CALLBACKENCODING_INFLUXDB_V2</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackInitialDelay':{syn:'Changes the initial waiting time before first callback notifications, in seconds.',lib:'%.set_callbackInitialDelay()',pro:'set_callbackInitialDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the initial waiting time before first callback notifications, in seconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the initial waiting time before first callback notifications, in seconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackMaxDelay':{syn:'Changes the waiting time between two HTTP callbacks when there is nothing new.',lib:'%.set_callbackMaxDelay()',pro:'set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting time between two HTTP callbacks when there is nothing new. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackMethod':{syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'%.set_callbackMethod()',pro:'set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YNetwork.CALLBACKMETHOD_POST</tt>, <tt>YNetwork.CALLBACKMETHOD_GET</tt> and <tt>YNetwork.CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackMinDelay':{syn:'Changes the minimum waiting time between two HTTP callbacks, in seconds.',lib:'%.set_callbackMinDelay()',pro:'set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two HTTP callbacks, in seconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackSchedule':{syn:'Changes the HTTP callback schedule strategy, as a text string.',lib:'%.set_callbackSchedule()',pro:'set_callbackSchedule(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP callback schedule strategy, as a text string. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the HTTP callback schedule strategy, as a text string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackTemplate':{syn:'Enable the use of a template file to customize callbacks format.',lib:'%.set_callbackTemplate()',pro:'set_callbackTemplate(<span id=pn>newval</span>)',cmt:'<p>Enable the use of a template file to customize callbacks format. When the custom callback template file is enabled, the template file will be loaded for each callback in order to build the data to post to the server. If template file does not exist on the YoctoHub, the callback will fail with an error message indicating the name of the expected template file. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YNetwork.CALLBACKTEMPLATE_OFF</tt> or <tt>YNetwork.CALLBACKTEMPLATE_ON</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_callbackUrl':{syn:'Changes the callback URL to notify significant state changes.',lib:'%.set_callbackUrl()',pro:'set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_defaultPage':{syn:'Changes the default HTML page returned by the hub.',lib:'%.set_defaultPage()',pro:'set_defaultPage(<span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible to change this page for file that has been uploaded on the hub. The maximum filename size is 15 characters. When you change this parameter, remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_discoverable':{syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'%.set_discoverable()',pro:'set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YNetwork.DISCOVERABLE_FALSE</tt> or <tt>YNetwork.DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_httpPort':{syn:'Changes the the TCP port used to serve the hub web UI.',lib:'%.set_httpPort()',pro:'set_httpPort(<span id=pn>newval</span>)',cmt:'<p>Changes the the TCP port used to serve the hub web UI. The default value is port 80, which is the default for all Web servers. Regardless of the value set here, the hub will always reply on port 4444, which is used by default by Yoctopuce API library. When you change this parameter, remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the the TCP port used to serve the hub web UI'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_httpsPort':{syn:'Changes the secure TCP port used to serve the hub web UI.',lib:'%.set_httpsPort()',pro:'set_httpsPort(<span id=pn>newval</span>)',cmt:'<p>Changes the secure TCP port used to serve the hub web UI. The default value is port 4443, which is the default for all Web servers. When you change this parameter, remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the secure TCP port used to serve the hub web UI'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the network interface.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_ntpServer':{syn:'Changes the IP address of the NTP server to be used by the module.',lib:'%.set_ntpServer()',pro:'set_ntpServer(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the NTP server to be used by the module. Use an empty string to restore the factory set address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_periodicCallbackSchedule':{syn:'Set up periodic HTTP callbacks (simplified function).',lib:'%.set_periodicCallbackSchedule()',pro:'set_periodicCallbackSchedule(<span id=pn>interval</span>, <span id=pn>offset</span>)',cmt:'<p>Set up periodic HTTP callbacks (simplified function).</p>',par:{interval:'a string representing the callback periodicity, expressed in seconds, minutes or hours, eg. \x2260s\x22, \x225m\x22, \x221h\x22, \x2248h\x22.',offset:'an integer representing the time offset relative to the period when the callback should occur. For instance, if the periodicity is 24h, an offset of 7 will make the callback occur each day at 7AM.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_primaryDNS':{syn:'Changes the IP address of the primary name server to be used by the module.',lib:'%.set_primaryDNS()',pro:'set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_secondaryDNS':{syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'%.set_secondaryDNS()',pro:'set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_securityMode':{syn:'Changes the security level used to prevent unauthorized access to the server.',lib:'%.set_securityMode()',pro:'set_securityMode(<span id=pn>newval</span>)',cmt:'<p>Changes the security level used to prevent unauthorized access to the server. The value <tt>UNDEFINED</tt> causes the security configuration wizard to be displayed the next time you log on to the Web console. The value <tt>LEGACY</tt> offers unencrypted HTTP access by default, and is designed to provide compatibility with legacy applications that do not handle password or do not support <tt>HTTPS</tt>. But it should only be used when system security is guaranteed by other means, such as the use of a firewall. The value <tt>MIXED</tt> requires the configuration of passwords, and allows access via both HTTP (unencrypted) and HTTPS (encrypted), while requiring the Yoctopuce API to be tolerant of certificate characteristics. The value <tt>SECURE</tt> requires the configuration of passwords and the use of secure communications in all cases. When you change this parameter, remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YNetwork.SECURITYMODE_UNDEFINED</tt>, <tt>YNetwork.SECURITYMODE_LEGACY</tt>, <tt>YNetwork.SECURITYMODE_MIXED</tt> and <tt>YNetwork.SECURITYMODE_SECURE</tt> corresponding to the security level used to prevent unauthorized access to the server'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_userPassword':{syn:'Changes the password for the \x22user\x22 user.',lib:'%.set_userPassword()',pro:'set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_wwwWatchdogDelay':{syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'%.set_wwwWatchdogDelay()',pro:'set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerCallback':{syn:'Trigger an HTTP callback quickly.',lib:'%.triggerCallback()',pro:'triggerCallback()',cmt:'<p>Trigger an HTTP callback quickly. This function can even be called within an HTTP callback, in which case the next callback will be triggered 5 seconds after the end of the current callback, regardless if the minimum time between callbacks configured in the device.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'useDHCP':{syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'%.useDHCP()',pro:'useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (e.g. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'useDHCPauto':{syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'%.useDHCPauto()',pro:'useDHCPauto()',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses an IP of the network 169.254.0.0/16 (APIPA). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'useStaticIP':{syn:'Changes the configuration of the network interface to use a static IP address.',lib:'%.useStaticIP()',pro:'useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (e.g. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Network)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'Operating system control interface via the VirtualHub application',inc:'from yocto_oscontrol import *',cmt:'<p>The <tt>YOScontrol</tt> class provides some control over the operating system running a VirtualHub. YOsControl is available on VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}
,'FindOsControl':{syn:'Retrieves OS control for a given identifier.',lib:'YOsControl.FindOsControl()',pro:'FindOsControl(<span id=pn>func</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the OS control, for instance <tt>MyDevice.osControl</tt>.'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'}
,'FirstOsControl':{syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl.FirstOsControl()',pro:'FirstOsControl()',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the OS control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the OS control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YOsControl.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the OS control.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the OS control object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the OS control.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the OS control object'}
,'get_friendlyName':{syn:'Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the OS control if they are defined, otherwise the serial number of the module and the hardware identifier of the OS control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the OS control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YOsControl.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the OS control, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the OS control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the OS control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YOsControl.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the OS control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the OS control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YOsControl.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the OS control.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:'On failure, throws an exception or returns <tt>YOsControl.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_shutdownCountdown':{syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'%.get_shutdownCountdown()',pro:'get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>YOsControl.SHUTDOWNCOUNTDOWN_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the OS control is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the OS control is currently reachable, without raising any error. If there is a cached value for the OS control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the OS control.</p>',ret:'<tt>true</tt> if the OS control can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the OS control cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the OS control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextOsControl':{syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'%.nextOsControl()',pro:'nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>. Caution: You can\x27t make any assumption about the returned OS control order. If you want to find a specific OS control, use <tt>OsControl.findOsControl()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'}
,'reboot':{syn:'Schedules an OS reboot after a given number of seconds.',lib:'%.reboot()',pro:'reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules an OS reboot after a given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before reboot'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the OS control.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'shutdown':{syn:'Schedules an OS shutdown after a given number of seconds.',lib:'%.shutdown()',pro:'shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: OsControl)
//--- (generated code: Power)
doc['Power']={'':{syn:'Electrical power sensor control interface, available for instance in the Yocto-Watt',inc:'from yocto_power import *',cmt:'<p>The <tt>YPower</tt> class allows you to read and configure Yoctopuce electrical power sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}
,'FindPower':{syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower.FindPower()',pro:'FindPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor, for instance <tt>YWATTMK1.power</tt>.'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'}
,'FirstPower':{syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower.FirstPower()',pro:'FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the electrical power sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the electrical power sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YPower.ADVMODE_IMMEDIATE</tt>, <tt>YPower.ADVMODE_PERIOD_AVG</tt>, <tt>YPower.ADVMODE_PERIOD_MIN</tt> and <tt>YPower.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YPower.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPower.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_cosPhi':{syn:'Returns the Displacement Power factor (DPF), i.e.',lib:'%.get_cosPhi()',pro:'get_cosPhi()',cmt:'<p>Returns the Displacement Power factor (DPF), i.e. cosine of the phase shift between the voltage and current fundamentals. On the Yocto-Watt (V1), the value returned by this method correponds to the power factor as this device is cannot estimate the true DPF.</p>',ret:'a floating point number corresponding to the Displacement Power factor (DPF), i.e',ext:'On failure, throws an exception or returns <tt>YPower.COSPHI_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>YPower.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>YPower.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_deliveredEnergyMeter':{syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when positive.',lib:'%.get_deliveredEnergyMeter()',pro:'get_deliveredEnergyMeter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when positive. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when positive',ext:'On failure, throws an exception or returns <tt>YPower.DELIVEREDENERGYMETER_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the electrical power sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the electrical power sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the electrical power sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the electrical power sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the electrical power sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the electrical power sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the electrical power sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPower.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the electrical power sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the electrical power sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the electrical power sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPower.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the electrical power sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the electrical power sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPower.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>YPower.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YPower.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the electrical power sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:'On failure, throws an exception or returns <tt>YPower.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>YPower.LOWESTVALUE_INVALID</tt>.'}
,'get_meter':{syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'%.get_meter()',pro:'get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. This is the sum of forward and backwad energy transfers, if you are insterested in only one direction, use get_receivedEnergyMeter() or get_deliveredEnergyMeter(). Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>YPower.METER_INVALID</tt>.'}
,'get_meterTimer':{syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'%.get_meterTimer()',pro:'get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>YPower.METERTIMER_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_powerFactor':{syn:'Returns the power factor (PF), i.e.',lib:'%.get_powerFactor()',pro:'get_powerFactor()',cmt:'<p>Returns the power factor (PF), i.e. ratio between the active power consumed (in W) and the apparent power provided (VA).</p>',ret:'a floating point number corresponding to the power factor (PF), i.e',ext:'On failure, throws an exception or returns <tt>YPower.POWERFACTOR_INVALID</tt>.'}
,'get_receivedEnergyMeter':{syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when negative.',lib:'%.get_receivedEnergyMeter()',pro:'get_receivedEnergyMeter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when negative. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time, but only when negative',ext:'On failure, throws an exception or returns <tt>YPower.RECEIVEDENERGYMETER_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YPower.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YPower.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YPower.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the electrical power.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:'On failure, throws an exception or returns <tt>YPower.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the electrical power sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the electrical power sensor is currently reachable, without raising any error. If there is a cached value for the electrical power sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the electrical power sensor.</p>',ret:'<tt>true</tt> if the electrical power sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the electrical power sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the electrical power sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPower':{syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'%.nextPower()',pro:'nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>. Caution: You can\x27t make any assumption about the returned electrical power sensors order. If you want to find a specific a electrical power sensor, use <tt>Power.findPower()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Resets the energy counters.',lib:'%.reset()',pro:'reset()',cmt:'<p>Resets the energy counters.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YPower.ADVMODE_IMMEDIATE</tt>, <tt>YPower.ADVMODE_PERIOD_AVG</tt>, <tt>YPower.ADVMODE_PERIOD_MIN</tt> and <tt>YPower.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the electrical power sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Power)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'Power output control interface, available for instance in the Yocto-I2C, the Yocto-MaxiMicroVolt-Rx, the Yocto-SPI or the Yocto-Serial',inc:'from yocto_poweroutput import *',cmt:'<p>The <tt>YPowerOutput</tt> class allows you to control the power output featured on some Yoctopuce devices.</p>'}
,'FindPowerOutput':{syn:'Retrieves a power output for a given identifier.',lib:'YPowerOutput.FindPowerOutput()',pro:'FindPowerOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a power output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerOutput.isOnline()</tt> to test if the power output is indeed online at a given time. In case of ambiguity when looking for a power output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the power output, for instance <tt>YI2CMK01.powerOutput</tt>.'},ret:'a <tt>YPowerOutput</tt> object allowing you to drive the power output.'}
,'FirstPowerOutput':{syn:'Starts the enumeration of power output currently accessible.',lib:'YPowerOutput.FirstPowerOutput()',pro:'FirstPowerOutput()',cmt:'<p>Starts the enumeration of power output currently accessible. Use the method <tt>YPowerOutput.nextPowerOutput()</tt> to iterate on next power output.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to the first power output currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the power output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the power output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the power output (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the power output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPowerOutput.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the power output.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power output object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the power output.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power output object'}
,'get_friendlyName':{syn:'Returns a global identifier of the power output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the power output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power output if they are defined, otherwise the serial number of the module and the hardware identifier of the power output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerOutput.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the power output, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the power output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerOutput.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the power output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerOutput.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the power output.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the power output.</p>',ret:'a string corresponding to the logical name of the power output.',ext:'On failure, throws an exception or returns <tt>YPowerOutput.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_voltage':{syn:'Returns the voltage on the power output featured by the module.',lib:'%.get_voltage()',pro:'get_voltage()',cmt:'<p>Returns the voltage on the power output featured by the module.</p>',ret:'a value among <tt>YPowerOutput.VOLTAGE_OFF</tt>, <tt>YPowerOutput.VOLTAGE_OUT3V3</tt>, <tt>YPowerOutput.VOLTAGE_OUT5V</tt>, <tt>YPowerOutput.VOLTAGE_OUT4V7</tt> and <tt>YPowerOutput.VOLTAGE_OUT1V8</tt> corresponding to the voltage on the power output featured by the module',ext:'On failure, throws an exception or returns <tt>YPowerOutput.VOLTAGE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the power output is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the power output is currently reachable, without raising any error. If there is a cached value for the power output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power output.</p>',ret:'<tt>true</tt> if the power output can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the power output cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the power output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPowerOutput':{syn:'Continues the enumeration of power output started using <tt>yFirstPowerOutput()</tt>.',lib:'%.nextPowerOutput()',pro:'nextPowerOutput()',cmt:'<p>Continues the enumeration of power output started using <tt>yFirstPowerOutput()</tt>. Caution: You can\x27t make any assumption about the returned power output order. If you want to find a specific a power output, use <tt>PowerOutput.findPowerOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to a power output currently online, or a <tt>null</tt> pointer if there are no more power output to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the power output.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power output.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltage':{syn:'Changes the voltage on the power output provided by the module.',lib:'%.set_voltage()',pro:'set_voltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage on the power output provided by the module. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YPowerOutput.VOLTAGE_OFF</tt>, <tt>YPowerOutput.VOLTAGE_OUT3V3</tt>, <tt>YPowerOutput.VOLTAGE_OUT5V</tt>, <tt>YPowerOutput.VOLTAGE_OUT4V7</tt> and <tt>YPowerOutput.VOLTAGE_OUT1V8</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: PowerOutput)
//--- (generated code: PowerSupply)
doc['PowerSupply']={'':{syn:'Regulated power supply control interface',inc:'from yocto_powersupply import *',cmt:'<p>The <tt>YPowerSupply</tt> class allows you to drive a Yoctopuce power supply. It can be use to change the voltage and current limits, and to enable/disable the output.</p>'}
,'FindPowerSupply':{syn:'Retrieves a regulated power supply for a given identifier.',lib:'YPowerSupply.FindPowerSupply()',pro:'FindPowerSupply(<span id=pn>func</span>)',cmt:'<p>Retrieves a regulated power supply for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the regulated power supply is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerSupply.isOnline()</tt> to test if the regulated power supply is indeed online at a given time. In case of ambiguity when looking for a regulated power supply by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the regulated power supply, for instance <tt>MyDevice.powerSupply</tt>.'},ret:'a <tt>YPowerSupply</tt> object allowing you to drive the regulated power supply.'}
,'FirstPowerSupply':{syn:'Starts the enumeration of regulated power supplies currently accessible.',lib:'YPowerSupply.FirstPowerSupply()',pro:'FirstPowerSupply()',cmt:'<p>Starts the enumeration of regulated power supplies currently accessible. Use the method <tt>YPowerSupply.nextPowerSupply()</tt> to iterate on next regulated power supplies.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to the first regulated power supply currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the regulated power supply attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the regulated power supply (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the regulated power supply (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the regulated power supply (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the regulated power supply (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPowerSupply.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentLimit':{syn:'Returns the current limit, in mA.',lib:'%.get_currentLimit()',pro:'get_currentLimit()',cmt:'<p>Returns the current limit, in mA.</p>',ret:'a floating point number corresponding to the current limit, in mA',ext:'On failure, throws an exception or returns <tt>YPowerSupply.CURRENTLIMIT_INVALID</tt>.'}
,'get_currentLimitAtStartUp':{syn:'Returns the selected current limit at device startup, in mA.',lib:'%.get_currentLimitAtStartUp()',pro:'get_currentLimitAtStartUp()',cmt:'<p>Returns the selected current limit at device startup, in mA.</p>',ret:'a floating point number corresponding to the selected current limit at device startup, in mA',ext:'On failure, throws an exception or returns <tt>YPowerSupply.CURRENTLIMITATSTARTUP_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the regulated power supply.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the regulated power supply object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the regulated power supply.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the regulated power supply object'}
,'get_friendlyName':{syn:'Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the regulated power supply if they are defined, otherwise the serial number of the module and the hardware identifier of the regulated power supply (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the regulated power supply using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerSupply.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the regulated power supply, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the regulated power supply, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the regulated power supply (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerSupply.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the regulated power supply (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the regulated power supply (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPowerSupply.HARDWAREID_INVALID</tt>.'}
,'get_inputVoltage':{syn:'Returns the measured input voltage, in V.',lib:'%.get_inputVoltage()',pro:'get_inputVoltage()',cmt:'<p>Returns the measured input voltage, in V.</p>',ret:'a floating point number corresponding to the measured input voltage, in V',ext:'On failure, throws an exception or returns <tt>YPowerSupply.INPUTVOLTAGE_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the regulated power supply.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the regulated power supply.</p>',ret:'a string corresponding to the logical name of the regulated power supply.',ext:'On failure, throws an exception or returns <tt>YPowerSupply.LOGICALNAME_INVALID</tt>.'}
,'get_measuredCurrent':{syn:'Returns the measured output current, in mA.',lib:'%.get_measuredCurrent()',pro:'get_measuredCurrent()',cmt:'<p>Returns the measured output current, in mA.</p>',ret:'a floating point number corresponding to the measured output current, in mA',ext:'On failure, throws an exception or returns <tt>YPowerSupply.MEASUREDCURRENT_INVALID</tt>.'}
,'get_measuredVoltage':{syn:'Returns the measured output voltage, in V.',lib:'%.get_measuredVoltage()',pro:'get_measuredVoltage()',cmt:'<p>Returns the measured output voltage, in V.</p>',ret:'a floating point number corresponding to the measured output voltage, in V',ext:'On failure, throws an exception or returns <tt>YPowerSupply.MEASUREDVOLTAGE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_powerOutput':{syn:'Returns the power supply output switch state.',lib:'%.get_powerOutput()',pro:'get_powerOutput()',cmt:'<p>Returns the power supply output switch state.</p>',ret:'either <tt>YPowerSupply.POWEROUTPUT_OFF</tt> or <tt>YPowerSupply.POWEROUTPUT_ON</tt>, according to the power supply output switch state',ext:'On failure, throws an exception or returns <tt>YPowerSupply.POWEROUTPUT_INVALID</tt>.'}
,'get_powerOutputAtStartUp':{syn:'Returns the power supply output switch state.',lib:'%.get_powerOutputAtStartUp()',pro:'get_powerOutputAtStartUp()',cmt:'<p>Returns the power supply output switch state.</p>',ret:'either <tt>YPowerSupply.POWEROUTPUTATSTARTUP_OFF</tt> or <tt>YPowerSupply.POWEROUTPUTATSTARTUP_ON</tt>, according to the power supply output switch state',ext:'On failure, throws an exception or returns <tt>YPowerSupply.POWEROUTPUTATSTARTUP_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_voltageLimit':{syn:'Returns the voltage limit, in V.',lib:'%.get_voltageLimit()',pro:'get_voltageLimit()',cmt:'<p>Returns the voltage limit, in V.</p>',ret:'a floating point number corresponding to the voltage limit, in V',ext:'On failure, throws an exception or returns <tt>YPowerSupply.VOLTAGELIMIT_INVALID</tt>.'}
,'get_voltageLimitAtStartUp':{syn:'Returns the selected voltage limit at device startup, in V.',lib:'%.get_voltageLimitAtStartUp()',pro:'get_voltageLimitAtStartUp()',cmt:'<p>Returns the selected voltage limit at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage limit at device startup, in V',ext:'On failure, throws an exception or returns <tt>YPowerSupply.VOLTAGELIMITATSTARTUP_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the regulated power supply is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the regulated power supply is currently reachable, without raising any error. If there is a cached value for the regulated power supply in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the regulated power supply.</p>',ret:'<tt>true</tt> if the regulated power supply can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the regulated power supply cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the regulated power supply cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPowerSupply':{syn:'Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>.',lib:'%.nextPowerSupply()',pro:'nextPowerSupply()',cmt:'<p>Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>. Caution: You can\x27t make any assumption about the returned regulated power supplies order. If you want to find a specific a regulated power supply, use <tt>PowerSupply.findPowerSupply()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to a regulated power supply currently online, or a <tt>null</tt> pointer if there are no more regulated power supplies to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_currentLimit':{syn:'Changes the current limit, in mA.',lib:'%.set_currentLimit()',pro:'set_currentLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the current limit, in mA.</p>',par:{newval:'a floating point number corresponding to the current limit, in mA'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentLimitAtStartUp':{syn:'Changes the current limit at device start up.',lib:'%.set_currentLimitAtStartUp()',pro:'set_currentLimitAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the current limit at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the current limit at device start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the regulated power supply.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the regulated power supply. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the regulated power supply.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_powerOutput':{syn:'Changes the power supply output switch state.',lib:'%.set_powerOutput()',pro:'set_powerOutput(<span id=pn>newval</span>)',cmt:'<p>Changes the power supply output switch state.</p>',par:{newval:'either <tt>YPowerSupply.POWEROUTPUT_OFF</tt> or <tt>YPowerSupply.POWEROUTPUT_ON</tt>, according to the power supply output switch state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_powerOutputAtStartUp':{syn:'Changes the power supply output switch state at device start up.',lib:'%.set_powerOutputAtStartUp()',pro:'set_powerOutputAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the power supply output switch state at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'either <tt>YPowerSupply.POWEROUTPUTATSTARTUP_OFF</tt> or <tt>YPowerSupply.POWEROUTPUTATSTARTUP_ON</tt>, according to the power supply output switch state at device start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltageLimit':{syn:'Changes the voltage limit, in V.',lib:'%.set_voltageLimit()',pro:'set_voltageLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage limit, in V.</p>',par:{newval:'a floating point number corresponding to the voltage limit, in V'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_voltageLimitAtStartUp':{syn:'Changes the voltage set point at device start up.',lib:'%.set_voltageLimitAtStartUp()',pro:'set_voltageLimitAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage set point at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the voltage set point at device start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'voltageMove':{syn:'Performs a smooth transition of output voltage.',lib:'%.voltageMove()',pro:'voltageMove(<span id=pn>V_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of output voltage. Any explicit voltage change cancels any ongoing transition process.</p>',par:{V_target:'new output voltage value at the end of the transition (floating-point number, representing the end voltage in V)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.'}
};
//--- (end of generated code: PowerSupply)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure sensor control interface, available for instance in the Yocto-Altimeter-V2, the Yocto-CO2-V2, the Yocto-Meteo-V2 or the Yocto-Pressure',inc:'from yocto_pressure import *',cmt:'<p>The <tt>YPressure</tt> class allows you to read and configure Yoctopuce pressure sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindPressure':{syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure.FindPressure()',pro:'FindPressure(<span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the pressure sensor, for instance <tt>YALTIMK2.pressure</tt>.'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'}
,'FirstPressure':{syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure.FirstPressure()',pro:'FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the pressure sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the pressure sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YPressure.ADVMODE_IMMEDIATE</tt>, <tt>YPressure.ADVMODE_PERIOD_AVG</tt>, <tt>YPressure.ADVMODE_PERIOD_MIN</tt> and <tt>YPressure.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YPressure.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPressure.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>YPressure.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>YPressure.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the pressure sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the pressure sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the pressure sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the pressure sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the pressure sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the pressure sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the pressure sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPressure.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the pressure sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the pressure sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the pressure sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPressure.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the pressure sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the pressure sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPressure.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>YPressure.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YPressure.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the pressure sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:'On failure, throws an exception or returns <tt>YPressure.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>YPressure.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YPressure.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YPressure.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YPressure.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the pressure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:'On failure, throws an exception or returns <tt>YPressure.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the pressure sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the pressure sensor is currently reachable, without raising any error. If there is a cached value for the pressure sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the pressure sensor.</p>',ret:'<tt>true</tt> if the pressure sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the pressure sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the pressure sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPressure':{syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'%.nextPressure()',pro:'nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>. Caution: You can\x27t make any assumption about the returned pressure sensors order. If you want to find a specific a pressure sensor, use <tt>Pressure.findPressure()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YPressure.ADVMODE_IMMEDIATE</tt>, <tt>YPressure.ADVMODE_PERIOD_AVG</tt>, <tt>YPressure.ADVMODE_PERIOD_MIN</tt> and <tt>YPressure.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the pressure sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Pressure)
//--- (generated code: Proximity)
doc['Proximity']={'':{syn:'Proximity sensor control interface, available for instance in the Yocto-Proximity',inc:'from yocto_proximity import *',cmt:'<p>The <tt>YProximity</tt> class allows you to read and configure Yoctopuce proximity sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to set up a detection threshold and to count the number of detected state changes.</p>'}
,'FindProximity':{syn:'Retrieves a proximity sensor for a given identifier.',lib:'YProximity.FindProximity()',pro:'FindProximity(<span id=pn>func</span>)',cmt:'<p>Retrieves a proximity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the proximity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YProximity.isOnline()</tt> to test if the proximity sensor is indeed online at a given time. In case of ambiguity when looking for a proximity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the proximity sensor, for instance <tt>YPROXIM1.proximity1</tt>.'},ret:'a <tt>YProximity</tt> object allowing you to drive the proximity sensor.'}
,'FirstProximity':{syn:'Starts the enumeration of proximity sensors currently accessible.',lib:'YProximity.FirstProximity()',pro:'FirstProximity()',cmt:'<p>Starts the enumeration of proximity sensors currently accessible. Use the method <tt>YProximity.nextProximity()</tt> to iterate on next proximity sensors.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to the first proximity sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the proximity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the proximity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YProximity.ADVMODE_IMMEDIATE</tt>, <tt>YProximity.ADVMODE_PERIOD_AVG</tt>, <tt>YProximity.ADVMODE_PERIOD_MIN</tt> and <tt>YProximity.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YProximity.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the proximity sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the proximity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the proximity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YProximity.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YProximity.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the proximity detection, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the proximity detection, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the proximity detection, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YProximity.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_detectionHysteresis':{syn:'Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'%.get_detectionHysteresis()',pro:'get_detectionHysteresis()',cmt:'<p>Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>YProximity.DETECTIONHYSTERESIS_INVALID</tt>.'}
,'get_detectionThreshold':{syn:'Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'%.get_detectionThreshold()',pro:'get_detectionThreshold()',cmt:'<p>Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>YProximity.DETECTIONTHRESHOLD_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the proximity sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the proximity sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the proximity sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the proximity sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the proximity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the proximity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the proximity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YProximity.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the proximity sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the proximity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the proximity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YProximity.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the proximity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the proximity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YProximity.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the proximity detection since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>YProximity.HIGHESTVALUE_INVALID</tt>.'}
,'get_isPresent':{syn:'Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.',lib:'%.get_isPresent()',pro:'get_isPresent()',cmt:'<p>Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.</p>',ret:'either <tt>YProximity.ISPRESENT_FALSE</tt> or <tt>YProximity.ISPRESENT_TRUE</tt>, according to true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise',ext:'On failure, throws an exception or returns <tt>YProximity.ISPRESENT_INVALID</tt>.'}
,'get_lastTimeApproached':{syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).',lib:'%.get_lastTimeApproached()',pro:'get_lastTimeApproached()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present)',ext:'On failure, throws an exception or returns <tt>YProximity.LASTTIMEAPPROACHED_INVALID</tt>.'}
,'get_lastTimeRemoved':{syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).',lib:'%.get_lastTimeRemoved()',pro:'get_lastTimeRemoved()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent)',ext:'On failure, throws an exception or returns <tt>YProximity.LASTTIMEREMOVED_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YProximity.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the proximity sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the proximity sensor.</p>',ret:'a string corresponding to the logical name of the proximity sensor.',ext:'On failure, throws an exception or returns <tt>YProximity.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the proximity detection since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>YProximity.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_presenceMinTime':{syn:'Returns the minimal detection duration before signalling a presence event.',lib:'%.get_presenceMinTime()',pro:'get_presenceMinTime()',cmt:'<p>Returns the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a presence event',ext:'On failure, throws an exception or returns <tt>YProximity.PRESENCEMINTIME_INVALID</tt>.'}
,'get_proximityReportMode':{syn:'Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'%.get_proximityReportMode()',pro:'get_proximityReportMode()',cmt:'<p>Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.</p>',ret:'a value among <tt>YProximity.PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>YProximity.PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>YProximity.PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>YProximity.PROXIMITYREPORTMODE_INVALID</tt>.'}
,'get_pulseCounter':{syn:'Returns the pulse counter value.',lib:'%.get_pulseCounter()',pro:'get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>YProximity.PULSECOUNTER_INVALID</tt>.'}
,'get_pulseTimer':{syn:'Returns the timer of the pulse counter (ms).',lib:'%.get_pulseTimer()',pro:'get_pulseTimer()',cmt:'<p>Returns the timer of the pulse counter (ms).</p>',ret:'an integer corresponding to the timer of the pulse counter (ms)',ext:'On failure, throws an exception or returns <tt>YProximity.PULSETIMER_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_removalMinTime':{syn:'Returns the minimal detection duration before signalling a removal event.',lib:'%.get_removalMinTime()',pro:'get_removalMinTime()',cmt:'<p>Returns the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a removal event',ext:'On failure, throws an exception or returns <tt>YProximity.REMOVALMINTIME_INVALID</tt>.'}
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YProximity.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YProximity.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YProximity.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signalValue':{syn:'Returns the current value of signal measured by the proximity sensor.',lib:'%.get_signalValue()',pro:'get_signalValue()',cmt:'<p>Returns the current value of signal measured by the proximity sensor.</p>',ret:'a floating point number corresponding to the current value of signal measured by the proximity sensor',ext:'On failure, throws an exception or returns <tt>YProximity.SIGNALVALUE_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the proximity detection.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the proximity detection.</p>',ret:'a string corresponding to the measuring unit for the proximity detection',ext:'On failure, throws an exception or returns <tt>YProximity.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the proximity sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the proximity sensor is currently reachable, without raising any error. If there is a cached value for the proximity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the proximity sensor.</p>',ret:'<tt>true</tt> if the proximity sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the proximity sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the proximity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextProximity':{syn:'Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>.',lib:'%.nextProximity()',pro:'nextProximity()',cmt:'<p>Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>. Caution: You can\x27t make any assumption about the returned proximity sensors order. If you want to find a specific a proximity sensor, use <tt>Proximity.findProximity()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to a proximity sensor currently online, or a <tt>null</tt> pointer if there are no more proximity sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'resetCounter':{syn:'Resets the pulse counter value as well as its timer.',lib:'%.resetCounter()',pro:'resetCounter()',cmt:'<p>Resets the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YProximity.ADVMODE_IMMEDIATE</tt>, <tt>YProximity.ADVMODE_PERIOD_AVG</tt>, <tt>YProximity.ADVMODE_PERIOD_MIN</tt> and <tt>YProximity.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_detectionHysteresis':{syn:'Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'%.set_detectionHysteresis()',pro:'set_detectionHysteresis(<span id=pn>newval</span>)',cmt:'<p>Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_detectionThreshold':{syn:'Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'%.set_detectionThreshold()',pro:'set_detectionThreshold(<span id=pn>newval</span>)',cmt:'<p>Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the proximity sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the proximity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the proximity sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_presenceMinTime':{syn:'Changes the minimal detection duration before signalling a presence event.',lib:'%.set_presenceMinTime()',pro:'set_presenceMinTime(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a presence event'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_proximityReportMode':{syn:'Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'%.set_proximityReportMode()',pro:'set_proximityReportMode(<span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter(). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YProximity.PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>YProximity.PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>YProximity.PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_removalMinTime':{syn:'Changes the minimal detection duration before signalling a removal event.',lib:'%.set_removalMinTime()',pro:'set_removalMinTime(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a removal event'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Proximity)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PWM input control interface, available for instance in the Yocto-PWM-Rx',inc:'from yocto_pwminput import *',cmt:'<p>The <tt>YPwmInput</tt> class allows you to read and configure Yoctopuce PWM inputs. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cycle, the frequency or the pulse width.</p>'}
,'FindPwmInput':{syn:'Retrieves a PWM input for a given identifier.',lib:'YPwmInput.FindPwmInput()',pro:'FindPwmInput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmInput.isOnline()</tt> to test if the PWM input is indeed online at a given time. In case of ambiguity when looking for a PWM input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM input, for instance <tt>YPWMRX01.pwmInput1</tt>.'},ret:'a <tt>YPwmInput</tt> object allowing you to drive the PWM input.'}
,'FirstPwmInput':{syn:'Starts the enumeration of PWM inputs currently accessible.',lib:'YPwmInput.FirstPwmInput()',pro:'FirstPwmInput()',cmt:'<p>Starts the enumeration of PWM inputs currently accessible. Use the method <tt>YPwmInput.nextPwmInput()</tt> to iterate on next PWM inputs.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to the first PWM input currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YPwmInput.ADVMODE_IMMEDIATE</tt>, <tt>YPwmInput.ADVMODE_PERIOD_AVG</tt>, <tt>YPwmInput.ADVMODE_PERIOD_MIN</tt> and <tt>YPwmInput.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YPwmInput.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPwmInput.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the input signal sampling rate, in kHz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the input signal sampling rate, in kHz.</p>',ret:'an integer corresponding to the input signal sampling rate, in kHz',ext:'On failure, throws an exception or returns <tt>YPwmInput.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:'On failure, throws an exception or returns <tt>YPwmInput.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in %, the pulse length in ms, etc.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:'On failure, throws an exception or returns <tt>YPwmInput.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_debouncePeriod':{syn:'Returns the shortest expected pulse duration, in ms.',lib:'%.get_debouncePeriod()',pro:'get_debouncePeriod()',cmt:'<p>Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',ret:'an integer corresponding to the shortest expected pulse duration, in ms',ext:'On failure, throws an exception or returns <tt>YPwmInput.DEBOUNCEPERIOD_INVALID</tt>.'}
,'get_dutyCycle':{syn:'Returns the PWM duty cycle, in per cents.',lib:'%.get_dutyCycle()',pro:'get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>YPwmInput.DUTYCYCLE_INVALID</tt>.'}
,'get_edgesPerPeriod':{syn:'Returns the number of edges detected per preiod.',lib:'%.get_edgesPerPeriod()',pro:'get_edgesPerPeriod()',cmt:'<p>Returns the number of edges detected per preiod. For a clean PWM signal, this should be exactly two, but in cas the signal is created by a mechanical contact with bounces, it can get higher.</p>',ret:'an integer corresponding to the number of edges detected per preiod',ext:'On failure, throws an exception or returns <tt>YPwmInput.EDGESPERPERIOD_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the PWM input.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM input object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the PWM input.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM input object'}
,'get_frequency':{syn:'Returns the PWM frequency in Hz.',lib:'%.get_frequency()',pro:'get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>YPwmInput.FREQUENCY_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM input if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmInput.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the PWM input, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmInput.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmInput.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>YPwmInput.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YPwmInput.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the PWM input.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:'On failure, throws an exception or returns <tt>YPwmInput.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>YPwmInput.LOWESTVALUE_INVALID</tt>.'}
,'get_minFrequency':{syn:'Returns the minimum detected frequency, in Hz.',lib:'%.get_minFrequency()',pro:'get_minFrequency()',cmt:'<p>Returns the minimum detected frequency, in Hz. Slower signals will be consider as zero frequency.</p>',ret:'a floating point number corresponding to the minimum detected frequency, in Hz',ext:'On failure, throws an exception or returns <tt>YPwmInput.MINFREQUENCY_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_period':{syn:'Returns the PWM period in milliseconds.',lib:'%.get_period()',pro:'get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>YPwmInput.PERIOD_INVALID</tt>.'}
,'get_pulseCounter':{syn:'Returns the pulse counter value.',lib:'%.get_pulseCounter()',pro:'get_pulseCounter()',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>YPwmInput.PULSECOUNTER_INVALID</tt>.'}
,'get_pulseDuration':{syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'%.get_pulseDuration()',pro:'get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>YPwmInput.PULSEDURATION_INVALID</tt>.'}
,'get_pulseTimer':{syn:'Returns the timer of the pulses counter (ms).',lib:'%.get_pulseTimer()',pro:'get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>YPwmInput.PULSETIMER_INVALID</tt>.'}
,'get_pwmReportMode':{syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'%.get_pwmReportMode()',pro:'get_pwmReportMode()',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>YPwmInput.PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_CPS</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_CPM</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_STATE</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQ_CPS</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQ_CPM</tt> and <tt>YPwmInput.PWMREPORTMODE_PWM_PERIODCOUNT</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>YPwmInput.PWMREPORTMODE_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YPwmInput.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YPwmInput.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YPwmInput.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings but can be modified if needed.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:'On failure, throws an exception or returns <tt>YPwmInput.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the PWM input is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the PWM input is currently reachable, without raising any error. If there is a cached value for the PWM input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM input.</p>',ret:'<tt>true</tt> if the PWM input can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the PWM input cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPwmInput':{syn:'Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.',lib:'%.nextPwmInput()',pro:'nextPwmInput()',cmt:'<p>Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>. Caution: You can\x27t make any assumption about the returned PWM inputs order. If you want to find a specific a PWM input, use <tt>PwmInput.findPwmInput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to a PWM input currently online, or a <tt>null</tt> pointer if there are no more PWM inputs to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'resetCounter':{syn:'Resets the pulse counter value as well as its timer.',lib:'%.resetCounter()',pro:'resetCounter()',cmt:'<p>Resets the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'resetPeriodDetection':{syn:'Resets the periodicity detection algorithm.',lib:'%.resetPeriodDetection()',pro:'resetPeriodDetection()',cmt:'<p>Resets the periodicity detection algorithm.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YPwmInput.ADVMODE_IMMEDIATE</tt>, <tt>YPwmInput.ADVMODE_PERIOD_AVG</tt>, <tt>YPwmInput.ADVMODE_PERIOD_MIN</tt> and <tt>YPwmInput.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the input signal sampling rate, measured in kHz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the input signal sampling rate, measured in kHz. A lower sampling frequency can be used to hide hide-frequency bounce effects, for instance on electromechanical contacts, but limits the measure resolution. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the input signal sampling rate, measured in kHz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_debouncePeriod':{syn:'Changes the shortest expected pulse duration, in ms.',lib:'%.set_debouncePeriod()',pro:'set_debouncePeriod(<span id=pn>newval</span>)',cmt:'<p>Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the shortest expected pulse duration, in ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the PWM input.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_minFrequency':{syn:'Changes the minimum detected frequency, in Hz.',lib:'%.set_minFrequency()',pro:'set_minFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum detected frequency, in Hz. Slower signals will be consider as zero frequency. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the minimum detected frequency, in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pwmReportMode':{syn:'Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'%.set_pwmReportMode()',pro:'set_pwmReportMode(<span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter(). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YPwmInput.PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_CPS</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_CPM</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_STATE</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQ_CPS</tt>, <tt>YPwmInput.PWMREPORTMODE_PWM_FREQ_CPM</tt> and <tt>YPwmInput.PWMREPORTMODE_PWM_PERIODCOUNT</tt> corresponding to the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_unit':{syn:'Changes the measuring unit for the measured quantity.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured quantity. That unit is just a string which is automatically initialized each time the measurement mode is changed. But is can be set to an arbitrary value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured quantity'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: PwmInput)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'PWM generator control interface, available for instance in the Yocto-PWM-Tx',inc:'from yocto_pwmoutput import *',cmt:'<p>The <tt>YPwmOutput</tt> class allows you to drive a pulse-width modulated output (PWM). You can configure the frequency as well as the duty cycle, and set up progressive transitions.</p>'}
,'FindPwmOutput':{syn:'Retrieves a PWM generator for a given identifier.',lib:'YPwmOutput.FindPwmOutput()',pro:'FindPwmOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM generator for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM generator is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmOutput.isOnline()</tt> to test if the PWM generator is indeed online at a given time. In case of ambiguity when looking for a PWM generator by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM generator, for instance <tt>YPWMTX01.pwmOutput1</tt>.'},ret:'a <tt>YPwmOutput</tt> object allowing you to drive the PWM generator.'}
,'FirstPwmOutput':{syn:'Starts the enumeration of PWM generators currently accessible.',lib:'YPwmOutput.FirstPwmOutput()',pro:'FirstPwmOutput()',cmt:'<p>Starts the enumeration of PWM generators currently accessible. Use the method <tt>YPwmOutput.nextPwmOutput()</tt> to iterate on next PWM generators.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to the first PWM generator currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM generator attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the PWM generator in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM generator in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM generator (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'dutyCycleMove':{syn:'Performs a smooth change of the duty cycle toward a given value.',lib:'%.dutyCycleMove()',pro:'dutyCycleMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth change of the duty cycle toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new duty cycle at the end of the transition (percentage, floating-point number between 0 and 100)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'frequencyMove':{syn:'Performs a smooth frequency change toward a given value.',lib:'%.frequencyMove()',pro:'frequencyMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth frequency change toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new frequency at the end of the transition (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the PWM generator (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the PWM generator (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM generator (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPwmOutput.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_dutyCycle':{syn:'Returns the PWM duty cycle, in per cents.',lib:'%.get_dutyCycle()',pro:'get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>YPwmOutput.DUTYCYCLE_INVALID</tt>.'}
,'get_dutyCycleAtPowerOn':{syn:'Returns the PWM generators duty cycle at device power on as a floating point number between 0 and 100.',lib:'%.get_dutyCycleAtPowerOn()',pro:'get_dutyCycleAtPowerOn()',cmt:'<p>Returns the PWM generators duty cycle at device power on as a floating point number between 0 and 100.</p>',ret:'a floating point number corresponding to the PWM generators duty cycle at device power on as a floating point number between 0 and 100',ext:'On failure, throws an exception or returns <tt>YPwmOutput.DUTYCYCLEATPOWERON_INVALID</tt>.'}
,'get_enabled':{syn:'Returns the state of the PWM generators.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns the state of the PWM generators.</p>',ret:'either <tt>YPwmOutput.ENABLED_FALSE</tt> or <tt>YPwmOutput.ENABLED_TRUE</tt>, according to the state of the PWM generators',ext:'On failure, throws an exception or returns <tt>YPwmOutput.ENABLED_INVALID</tt>.'}
,'get_enabledAtPowerOn':{syn:'Returns the state of the PWM at device power on.',lib:'%.get_enabledAtPowerOn()',pro:'get_enabledAtPowerOn()',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>YPwmOutput.ENABLEDATPOWERON_FALSE</tt> or <tt>YPwmOutput.ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on',ext:'On failure, throws an exception or returns <tt>YPwmOutput.ENABLEDATPOWERON_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the PWM generator.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM generator. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM generator object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the PWM generator.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM generator. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM generator object'}
,'get_frequency':{syn:'Returns the PWM frequency in Hz.',lib:'%.get_frequency()',pro:'get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>YPwmOutput.FREQUENCY_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the PWM generator in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM generator in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM generator if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM generator (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM generator using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmOutput.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the PWM generator, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM generator, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM generator (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmOutput.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the PWM generator in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM generator in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM generator (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM generator (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmOutput.HARDWAREID_INVALID</tt>.'}
,'get_invertedOutput':{syn:'Returns true if the output signal is configured as inverted, and false otherwise.',lib:'%.get_invertedOutput()',pro:'get_invertedOutput()',cmt:'<p>Returns true if the output signal is configured as inverted, and false otherwise.</p>',ret:'either <tt>YPwmOutput.INVERTEDOUTPUT_FALSE</tt> or <tt>YPwmOutput.INVERTEDOUTPUT_TRUE</tt>, according to true if the output signal is configured as inverted, and false otherwise',ext:'On failure, throws an exception or returns <tt>YPwmOutput.INVERTEDOUTPUT_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the PWM generator.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the PWM generator.</p>',ret:'a string corresponding to the logical name of the PWM generator.',ext:'On failure, throws an exception or returns <tt>YPwmOutput.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_period':{syn:'Returns the PWM period in milliseconds.',lib:'%.get_period()',pro:'get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>YPwmOutput.PERIOD_INVALID</tt>.'}
,'get_pulseDuration':{syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'%.get_pulseDuration()',pro:'get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>YPwmOutput.PULSEDURATION_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the PWM generator is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the PWM generator is currently reachable, without raising any error. If there is a cached value for the PWM generator in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM generator.</p>',ret:'<tt>true</tt> if the PWM generator can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the PWM generator cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM generator cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPwmOutput':{syn:'Continues the enumeration of PWM generators started using <tt>yFirstPwmOutput()</tt>.',lib:'%.nextPwmOutput()',pro:'nextPwmOutput()',cmt:'<p>Continues the enumeration of PWM generators started using <tt>yFirstPwmOutput()</tt>. Caution: You can\x27t make any assumption about the returned PWM generators order. If you want to find a specific a PWM generator, use <tt>PwmOutput.findPwmOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to a PWM generator currently online, or a <tt>null</tt> pointer if there are no more PWM generators to enumerate.'}
,'phaseMove':{syn:'Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel.',lib:'%.phaseMove()',pro:'phaseMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel. The phase shift is executed by slightly changing the frequency temporarily during the specified duration. This function only makes sense when both channels are running, either at the same frequency, or at a multiple of the channel frequency. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'phase shift at the end of the transition, in milliseconds (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'pulseDurationMove':{syn:'Performs a smooth transition of the pulse duration toward a given value.',lib:'%.pulseDurationMove()',pro:'pulseDurationMove(<span id=pn>ms_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'set_dutyCycle':{syn:'Changes the PWM duty cycle, in per cents.',lib:'%.set_dutyCycle()',pro:'set_dutyCycle(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_dutyCycleAtPowerOn':{syn:'Changes the PWM duty cycle at device power on.',lib:'%.set_dutyCycleAtPowerOn()',pro:'set_dutyCycleAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabled':{syn:'Stops or starts the PWM.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>YPwmOutput.ENABLED_FALSE</tt> or <tt>YPwmOutput.ENABLED_TRUE</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabledAtPowerOn':{syn:'Changes the state of the PWM at device power on.',lib:'%.set_enabledAtPowerOn()',pro:'set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the PWM at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>YPwmOutput.ENABLEDATPOWERON_FALSE</tt> or <tt>YPwmOutput.ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_frequency':{syn:'Changes the PWM frequency.',lib:'%.set_frequency()',pro:'set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change, in other words, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies. If you call the matching module <tt>saveToFlash()</tt> method, the frequency will be kept after a device power cycle. To stop the PWM signal, do not set the frequency to zero, use the set_enabled() method instead.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_invertedOutput':{syn:'Changes the inversion mode of the output signal.',lib:'%.set_invertedOutput()',pro:'set_invertedOutput(<span id=pn>newval</span>)',cmt:'<p>Changes the inversion mode of the output signal. Remember to call the matching module <tt>saveToFlash()</tt> method if you want the change to be kept after power cycle.</p>',par:{newval:'either <tt>YPwmOutput.INVERTEDOUTPUT_FALSE</tt> or <tt>YPwmOutput.INVERTEDOUTPUT_TRUE</tt>, according to the inversion mode of the output signal'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the PWM generator.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM generator. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM generator.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_period':{syn:'Changes the PWM period in milliseconds.',lib:'%.set_period()',pro:'set_period(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM period in milliseconds. Caution: in order to avoid random truncation of the current pulse, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies. If you call the matching module <tt>saveToFlash()</tt> method, the frequency will be kept after a device power cycle.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pulseDuration':{syn:'Changes the PWM pulse length, in milliseconds.',lib:'%.set_pulseDuration()',pro:'set_pulseDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'triggerPulsesByDuration':{syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'%.triggerPulsesByDuration()',pro:'triggerPulsesByDuration(<span id=pn>ms_target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{ms_target:'desired pulse duration (floating-point number, representing the pulse duration in milliseconds)',n_pulses:'desired pulse count'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerPulsesByDutyCycle':{syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'%.triggerPulsesByDutyCycle()',pro:'triggerPulsesByDutyCycle(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired duty cycle for the generated pulses (percentage, floating-point number between 0 and 100)',n_pulses:'desired pulse count'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'triggerPulsesByFrequency':{syn:'Trigger a given number of pulses at the specified frequency, using current duty cycle.',lib:'%.triggerPulsesByFrequency()',pro:'triggerPulsesByFrequency(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses at the specified frequency, using current duty cycle. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired frequency for the generated pulses (floating-point number)',n_pulses:'desired pulse count'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PWM generator power source control interface, available for instance in the Yocto-PWM-Tx',inc:'from yocto_pwmpowersource import *',cmt:'<p>The <tt>YPwmPowerSource</tt> class allows you to configure the voltage source used by all PWM outputs on the same device.</p>'}
,'FindPwmPowerSource':{syn:'Retrieves a PWM generator power source for a given identifier.',lib:'YPwmPowerSource.FindPwmPowerSource()',pro:'FindPwmPowerSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM generator power source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM generator power source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmPowerSource.isOnline()</tt> to test if the PWM generator power source is indeed online at a given time. In case of ambiguity when looking for a PWM generator power source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM generator power source, for instance <tt>YPWMTX01.pwmPowerSource</tt>.'},ret:'a <tt>YPwmPowerSource</tt> object allowing you to drive the PWM generator power source.'}
,'FirstPwmPowerSource':{syn:'Starts the enumeration of PWM generator power sources currently accessible.',lib:'YPwmPowerSource.FirstPwmPowerSource()',pro:'FirstPwmPowerSource()',cmt:'<p>Starts the enumeration of PWM generator power sources currently accessible. Use the method <tt>YPwmPowerSource.nextPwmPowerSource()</tt> to iterate on next PWM generator power sources.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to the first PWM generator power source currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM generator power source attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the PWM generator power source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM generator power source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM generator power source (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the PWM generator power source (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the PWM generator power source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM generator power source (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the PWM generator power source.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM generator power source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM generator power source object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the PWM generator power source.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM generator power source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM generator power source object'}
,'get_friendlyName':{syn:'Returns a global identifier of the PWM generator power source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM generator power source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM generator power source if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM generator power source (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM generator power source using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the PWM generator power source, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM generator power source, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM generator power source (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the PWM generator power source in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM generator power source in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM generator power source (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM generator power source (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the PWM generator power source.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the PWM generator power source.</p>',ret:'a string corresponding to the logical name of the PWM generator power source.',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_powerMode':{syn:'Returns the selected power source for the PWM on the same device.',lib:'%.get_powerMode()',pro:'get_powerMode()',cmt:'<p>Returns the selected power source for the PWM on the same device.</p>',ret:'a value among <tt>YPwmPowerSource.POWERMODE_USB_5V</tt>, <tt>YPwmPowerSource.POWERMODE_USB_3V</tt>, <tt>YPwmPowerSource.POWERMODE_EXT_V</tt> and <tt>YPwmPowerSource.POWERMODE_OPNDRN</tt> corresponding to the selected power source for the PWM on the same device',ext:'On failure, throws an exception or returns <tt>YPwmPowerSource.POWERMODE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the PWM generator power source is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the PWM generator power source is currently reachable, without raising any error. If there is a cached value for the PWM generator power source in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM generator power source.</p>',ret:'<tt>true</tt> if the PWM generator power source can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the PWM generator power source cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM generator power source cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextPwmPowerSource':{syn:'Continues the enumeration of PWM generator power sources started using <tt>yFirstPwmPowerSource()</tt>.',lib:'%.nextPwmPowerSource()',pro:'nextPwmPowerSource()',cmt:'<p>Continues the enumeration of PWM generator power sources started using <tt>yFirstPwmPowerSource()</tt>. Caution: You can\x27t make any assumption about the returned PWM generator power sources order. If you want to find a specific a PWM generator power source, use <tt>PwmPowerSource.findPwmPowerSource()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to a PWM generator power source currently online, or a <tt>null</tt> pointer if there are no more PWM generator power sources to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the PWM generator power source.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM generator power source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM generator power source.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_powerMode':{syn:'Changes the PWM power source.',lib:'%.set_powerMode()',pro:'set_powerMode(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a value among <tt>YPwmPowerSource.POWERMODE_USB_5V</tt>, <tt>YPwmPowerSource.POWERMODE_USB_3V</tt>, <tt>YPwmPowerSource.POWERMODE_EXT_V</tt> and <tt>YPwmPowerSource.POWERMODE_OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Base interface to access quaternion components, available for instance in the Yocto-3D-V2',inc:'from yocto_gyro import *',cmt:'<p>The <tt>YQt</tt> class provides direct access to the 3D attitude estimation provided by Yoctopuce inertial sensors. The four instances of <tt>YQt</tt> provide direct access to the individual quaternion components representing the orientation. It is usually not needed to use the <tt>YQt</tt> class directly, as the <tt>YGyro</tt> class provides a more convenient higher-level interface.</p>'}
,'FindQt':{syn:'Retrieves a quaternion component for a given identifier.',lib:'YQt.FindQt()',pro:'FindQt(<span id=pn>func</span>)',cmt:'<p>Retrieves a quaternion component for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quaternion component is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQt.isOnline()</tt> to test if the quaternion component is indeed online at a given time. In case of ambiguity when looking for a quaternion component by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quaternion component, for instance <tt>Y3DMK002.qt1</tt>.'},ret:'a <tt>YQt</tt> object allowing you to drive the quaternion component.'}
,'FirstQt':{syn:'Starts the enumeration of quaternion components currently accessible.',lib:'YQt.FirstQt()',pro:'FirstQt()',cmt:'<p>Starts the enumeration of quaternion components currently accessible. Use the method <tt>YQt.nextQt()</tt> to iterate on next quaternion components.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to the first quaternion component currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quaternion component attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quaternion component (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YQt.ADVMODE_IMMEDIATE</tt>, <tt>YQt.ADVMODE_PERIOD_AVG</tt>, <tt>YQt.ADVMODE_PERIOD_MIN</tt> and <tt>YQt.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YQt.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YQt.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>YQt.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the value, in units, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the value, in units, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>YQt.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the quaternion component.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quaternion component object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the quaternion component.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quaternion component object'}
,'get_friendlyName':{syn:'Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quaternion component if they are defined, otherwise the serial number of the module and the hardware identifier of the quaternion component (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quaternion component using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQt.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the quaternion component, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the quaternion component, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quaternion component (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQt.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quaternion component (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quaternion component (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQt.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the value since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>YQt.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YQt.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the quaternion component.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:'On failure, throws an exception or returns <tt>YQt.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the value since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>YQt.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YQt.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YQt.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YQt.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the value.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:'On failure, throws an exception or returns <tt>YQt.UNIT_INVALID</tt>.'}
,'get_userData':ds.get_userData
,'isOnline':{syn:'Checks if the quaternion component is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the quaternion component is currently reachable, without raising any error. If there is a cached value for the quaternion component in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quaternion component.</p>',ret:'<tt>true</tt> if the quaternion component can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the quaternion component cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the quaternion component cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextQt':{syn:'Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.',lib:'%.nextQt()',pro:'nextQt()',cmt:'<p>Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>. Caution: You can\x27t make any assumption about the returned quaternion components order. If you want to find a specific a quaternion component, use <tt>Qt.findQt()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to a quaternion component currently online, or a <tt>null</tt> pointer if there are no more quaternion components to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YQt.ADVMODE_IMMEDIATE</tt>, <tt>YQt.ADVMODE_PERIOD_AVG</tt>, <tt>YQt.ADVMODE_PERIOD_MIN</tt> and <tt>YQt.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the quaternion component.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quaternion component. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':ds.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Qt)
//--- (generated code: QuadratureDecoder)
doc['QuadratureDecoder']={'':{syn:'Quadrature decoder control interface, available for instance in the Yocto-MaxiKnob or the Yocto-PWM-Rx',inc:'from yocto_quadraturedecoder import *',cmt:'<p>The <tt>YQuadratureDecoder</tt> class allows you to read and configure Yoctopuce quadrature decoders. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindQuadratureDecoder':{syn:'Retrieves a quadrature decoder for a given identifier.',lib:'YQuadratureDecoder.FindQuadratureDecoder()',pro:'FindQuadratureDecoder(<span id=pn>func</span>)',cmt:'<p>Retrieves a quadrature decoder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quadrature decoder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQuadratureDecoder.isOnline()</tt> to test if the quadrature decoder is indeed online at a given time. In case of ambiguity when looking for a quadrature decoder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quadrature decoder, for instance <tt>YMXBTN01.quadratureDecoder1</tt>.'},ret:'a <tt>YQuadratureDecoder</tt> object allowing you to drive the quadrature decoder.'}
,'FirstQuadratureDecoder':{syn:'Starts the enumeration of quadrature decoders currently accessible.',lib:'YQuadratureDecoder.FirstQuadratureDecoder()',pro:'FirstQuadratureDecoder()',cmt:'<p>Starts the enumeration of quadrature decoders currently accessible. Use the method <tt>YQuadratureDecoder.nextQuadratureDecoder()</tt> to iterate on next quadrature decoders.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to the first quadrature decoder currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quadrature decoder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quadrature decoder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YQuadratureDecoder.ADVMODE_IMMEDIATE</tt>, <tt>YQuadratureDecoder.ADVMODE_PERIOD_AVG</tt>, <tt>YQuadratureDecoder.ADVMODE_PERIOD_MIN</tt> and <tt>YQuadratureDecoder.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the quadrature decoder (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the quadrature decoder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quadrature decoder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the position, in pas, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the position, in pas, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the position, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_decoding':{syn:'Returns the current activation state of the quadrature decoder.',lib:'%.get_decoding()',pro:'get_decoding()',cmt:'<p>Returns the current activation state of the quadrature decoder.</p>',ret:'either <tt>YQuadratureDecoder.DECODING_OFF</tt> or <tt>YQuadratureDecoder.DECODING_ON</tt>, according to the current activation state of the quadrature decoder',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.DECODING_INVALID</tt>.'}
,'get_edgesPerCycle':{syn:'Returns the edge count per full cycle configuration setting.',lib:'%.get_edgesPerCycle()',pro:'get_edgesPerCycle()',cmt:'<p>Returns the edge count per full cycle configuration setting.</p>',ret:'an integer corresponding to the edge count per full cycle configuration setting',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.EDGESPERCYCLE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the quadrature decoder.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quadrature decoder object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the quadrature decoder.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quadrature decoder object'}
,'get_friendlyName':{syn:'Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quadrature decoder if they are defined, otherwise the serial number of the module and the hardware identifier of the quadrature decoder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quadrature decoder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the quadrature decoder, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the quadrature decoder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quadrature decoder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quadrature decoder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quadrature decoder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the position since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the quadrature decoder.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the quadrature decoder.</p>',ret:'a string corresponding to the logical name of the quadrature decoder.',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the position since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_speed':{syn:'Returns the cycle frequency, in Hz.',lib:'%.get_speed()',pro:'get_speed()',cmt:'<p>Returns the cycle frequency, in Hz.</p>',ret:'a floating point number corresponding to the cycle frequency, in Hz',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.SPEED_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the position.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the position.</p>',ret:'a string corresponding to the measuring unit for the position',ext:'On failure, throws an exception or returns <tt>YQuadratureDecoder.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the quadrature decoder is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the quadrature decoder is currently reachable, without raising any error. If there is a cached value for the quadrature decoder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quadrature decoder.</p>',ret:'<tt>true</tt> if the quadrature decoder can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the quadrature decoder cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the quadrature decoder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextQuadratureDecoder':{syn:'Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>.',lib:'%.nextQuadratureDecoder()',pro:'nextQuadratureDecoder()',cmt:'<p>Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>. Caution: You can\x27t make any assumption about the returned quadrature decoders order. If you want to find a specific a quadrature decoder, use <tt>QuadratureDecoder.findQuadratureDecoder()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to a quadrature decoder currently online, or a <tt>null</tt> pointer if there are no more quadrature decoders to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YQuadratureDecoder.ADVMODE_IMMEDIATE</tt>, <tt>YQuadratureDecoder.ADVMODE_PERIOD_AVG</tt>, <tt>YQuadratureDecoder.ADVMODE_PERIOD_MIN</tt> and <tt>YQuadratureDecoder.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentValue':{syn:'Changes the current expected position of the quadrature decoder.',lib:'%.set_currentValue()',pro:'set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current expected position of the quadrature decoder. Invoking this function implicitly activates the quadrature decoder.</p>',par:{newval:'a floating point number corresponding to the current expected position of the quadrature decoder'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_decoding':{syn:'Changes the activation state of the quadrature decoder.',lib:'%.set_decoding()',pro:'set_decoding(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the quadrature decoder. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YQuadratureDecoder.DECODING_OFF</tt> or <tt>YQuadratureDecoder.DECODING_ON</tt>, according to the activation state of the quadrature decoder'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_edgesPerCycle':{syn:'Changes the edge count per full cycle configuration setting.',lib:'%.set_edgesPerCycle()',pro:'set_edgesPerCycle(<span id=pn>newval</span>)',cmt:'<p>Changes the edge count per full cycle configuration setting. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the edge count per full cycle configuration setting'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the quadrature decoder.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quadrature decoder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quadrature decoder.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: QuadratureDecoder)
//--- (generated code: RangeFinder)
doc['RangeFinder']={'':{syn:'Range finder control interface, available for instance in the Yocto-RangeFinder',inc:'from yocto_rangefinder import *',cmt:'<p>The <tt>YRangeFinder</tt> class allows you to read and configure Yoctopuce range finders. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}
,'FindRangeFinder':{syn:'Retrieves a range finder for a given identifier.',lib:'YRangeFinder.FindRangeFinder()',pro:'FindRangeFinder(<span id=pn>func</span>)',cmt:'<p>Retrieves a range finder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the range finder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRangeFinder.isOnline()</tt> to test if the range finder is indeed online at a given time. In case of ambiguity when looking for a range finder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the range finder, for instance <tt>YRNGFND1.rangeFinder1</tt>.'},ret:'a <tt>YRangeFinder</tt> object allowing you to drive the range finder.'}
,'FirstRangeFinder':{syn:'Starts the enumeration of range finders currently accessible.',lib:'YRangeFinder.FirstRangeFinder()',pro:'FirstRangeFinder()',cmt:'<p>Starts the enumeration of range finders currently accessible. Use the method <tt>YRangeFinder.nextRangeFinder()</tt> to iterate on next range finders.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to the first range finder currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'cancelCoverGlassCalibrations':{syn:'Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings.',lib:'%.cancelCoverGlassCalibrations()',pro:'cancelCoverGlassCalibrations()',cmt:'<p>Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the range finder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the range finder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YRangeFinder.ADVMODE_IMMEDIATE</tt>, <tt>YRangeFinder.ADVMODE_PERIOD_AVG</tt>, <tt>YRangeFinder.ADVMODE_PERIOD_MIN</tt> and <tt>YRangeFinder.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YRangeFinder.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the range finder (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the range finder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the range finder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YRangeFinder.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>YRangeFinder.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentTemperature':{syn:'Returns the current sensor temperature, as a floating point number.',lib:'%.get_currentTemperature()',pro:'get_currentTemperature()',cmt:'<p>Returns the current sensor temperature, as a floating point number.</p>',ret:'a floating point number corresponding to the current sensor temperature, as a floating point number',ext:'On failure, throws an exception or returns <tt>YRangeFinder.CURRENTTEMPERATURE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the range measured, in mm, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the range measured, in mm, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the range measured, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>YRangeFinder.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the range finder.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the range finder object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the range finder.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the range finder object'}
,'get_friendlyName':{syn:'Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the range finder if they are defined, otherwise the serial number of the module and the hardware identifier of the range finder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the range finder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRangeFinder.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the range finder, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the range finder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the range finder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRangeFinder.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareCalibrationTemperature':{syn:'Returns the temperature at the time when the latest calibration was performed.',lib:'%.get_hardwareCalibrationTemperature()',pro:'get_hardwareCalibrationTemperature()',cmt:'<p>Returns the temperature at the time when the latest calibration was performed. This function can be used to determine if a new calibration for ambient temperature is required.</p>',ret:'a temperature, as a floating point number. On failure, throws an exception or return YAPI_INVALID_DOUBLE.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the range finder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the range finder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRangeFinder.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the range measured since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>YRangeFinder.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YRangeFinder.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the range finder.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the range finder.</p>',ret:'a string corresponding to the logical name of the range finder.',ext:'On failure, throws an exception or returns <tt>YRangeFinder.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the range measured since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>YRangeFinder.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_quality':{syn:'Returns a measure quality estimate, based on measured dispersion.',lib:'%.get_quality()',pro:'get_quality()',cmt:'<p>Returns a measure quality estimate, based on measured dispersion.</p>',ret:'an integer corresponding to a measure quality estimate, based on measured dispersion',ext:'On failure, throws an exception or returns <tt>YRangeFinder.QUALITY_INVALID</tt>.'}
,'get_rangeFinderMode':{syn:'Returns the range finder running mode.',lib:'%.get_rangeFinderMode()',pro:'get_rangeFinderMode()',cmt:'<p>Returns the range finder running mode. The rangefinder running mode allows you to put priority on precision, speed or maximum range.</p>',ret:'a value among <tt>YRangeFinder.RANGEFINDERMODE_DEFAULT</tt>, <tt>YRangeFinder.RANGEFINDERMODE_LONG_RANGE</tt>, <tt>YRangeFinder.RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>YRangeFinder.RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the range finder running mode',ext:'On failure, throws an exception or returns <tt>YRangeFinder.RANGEFINDERMODE_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YRangeFinder.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YRangeFinder.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YRangeFinder.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_timeFrame':{syn:'Returns the time frame used to measure the distance and estimate the measure reliability.',lib:'%.get_timeFrame()',pro:'get_timeFrame()',cmt:'<p>Returns the time frame used to measure the distance and estimate the measure reliability. The time frame is expressed in milliseconds.</p>',ret:'an integer corresponding to the time frame used to measure the distance and estimate the measure reliability',ext:'On failure, throws an exception or returns <tt>YRangeFinder.TIMEFRAME_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the range measured.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the range measured.</p>',ret:'a string corresponding to the measuring unit for the range measured',ext:'On failure, throws an exception or returns <tt>YRangeFinder.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the range finder is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the range finder is currently reachable, without raising any error. If there is a cached value for the range finder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the range finder.</p>',ret:'<tt>true</tt> if the range finder can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the range finder cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the range finder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextRangeFinder':{syn:'Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>.',lib:'%.nextRangeFinder()',pro:'nextRangeFinder()',cmt:'<p>Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>. Caution: You can\x27t make any assumption about the returned range finders order. If you want to find a specific a range finder, use <tt>RangeFinder.findRangeFinder()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to a range finder currently online, or a <tt>null</tt> pointer if there are no more range finders to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YRangeFinder.ADVMODE_IMMEDIATE</tt>, <tt>YRangeFinder.ADVMODE_PERIOD_AVG</tt>, <tt>YRangeFinder.ADVMODE_PERIOD_MIN</tt> and <tt>YRangeFinder.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the range finder.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the range finder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the range finder.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_rangeFinderMode':{syn:'Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.',lib:'%.set_rangeFinderMode()',pro:'set_rangeFinderMode(<span id=pn>newval</span>)',cmt:'<p>Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YRangeFinder.RANGEFINDERMODE_DEFAULT</tt>, <tt>YRangeFinder.RANGEFINDERMODE_LONG_RANGE</tt>, <tt>YRangeFinder.RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>YRangeFinder.RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the rangefinder running mode, allowing you to put priority on precision, speed or maximum range'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_timeFrame':{syn:'Changes the time frame used to measure the distance and estimate the measure reliability.',lib:'%.set_timeFrame()',pro:'set_timeFrame(<span id=pn>newval</span>)',cmt:'<p>Changes the time frame used to measure the distance and estimate the measure reliability. The time frame is expressed in milliseconds. A larger timeframe improves stability and reliability, at the cost of higher latency, but prevents the detection of events shorter than the time frame. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the time frame used to measure the distance and estimate the measure reliability'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the measured range.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured range. That unit is a string. String value can be <tt>\x22</tt> or <tt>mm</tt>. Any other value is ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the rangeFinder function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured range'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'triggerOffsetCalibration':{syn:'Triggers the hardware offset calibration of the distance sensor.',lib:'%.triggerOffsetCalibration()',pro:'triggerOffsetCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware offset calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'triggerSpadCalibration':{syn:'Triggers the photon detector hardware calibration.',lib:'%.triggerSpadCalibration()',pro:'triggerSpadCalibration()',cmt:'<p>Triggers the photon detector hardware calibration. This function is part of the calibration procedure to compensate for the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'triggerTemperatureCalibration':{syn:'Triggers a sensor calibration according to the current ambient temperature.',lib:'%.triggerTemperatureCalibration()',pro:'triggerTemperatureCalibration()',cmt:'<p>Triggers a sensor calibration according to the current ambient temperature. That calibration process needs no physical interaction with the sensor. It is performed automatically at device startup, but it is recommended to start it again when the temperature delta since the latest calibration exceeds 8 degrees Celsius.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'triggerXTalkCalibration':{syn:'Triggers the hardware cross-talk calibration of the distance sensor.',lib:'%.triggerXTalkCalibration()',pro:'triggerXTalkCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware cross-talk calibration of the distance sensor. This function is part of the calibration procedure to compensate for the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: RangeFinder)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real-time clock control interface, available for instance in the YoctoHub-GSM-4G, the YoctoHub-Wireless-SR, the YoctoHub-Wireless-g or the YoctoHub-Wireless-n',inc:'from yocto_realtimeclock import *',cmt:'<p>The <tt>YRealTimeClock</tt> class provide access to the embedded real-time clock available on some Yoctopuce devices. It can provide current date and time, even after a power outage lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}
,'FindRealTimeClock':{syn:'Retrieves a real-time clock for a given identifier.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Retrieves a real-time clock for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the real-time clock is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRealTimeClock.isOnline()</tt> to test if the real-time clock is indeed online at a given time. In case of ambiguity when looking for a real-time clock by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the real-time clock, for instance <tt>YHUBGSM5.realTimeClock</tt>.'},ret:'a <tt>YRealTimeClock</tt> object allowing you to drive the real-time clock.'}
,'FirstRealTimeClock':{syn:'Starts the enumeration of real-time clocks currently accessible.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'FirstRealTimeClock()',cmt:'<p>Starts the enumeration of real-time clocks currently accessible. Use the method <tt>YRealTimeClock.nextRealTimeClock()</tt> to iterate on next real-time clocks.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to the first real-time clock currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the real-time clock attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the real-time clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the real-time clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the real-time clock (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the real-time clock (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the real-time clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the real-time clock (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_dateTime':{syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'%.get_dateTime()',pro:'get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.DATETIME_INVALID</tt>.'}
,'get_disableHostSync':{syn:'Returns true if the automatic clock synchronization with host has been disabled, and false otherwise.',lib:'%.get_disableHostSync()',pro:'get_disableHostSync()',cmt:'<p>Returns true if the automatic clock synchronization with host has been disabled, and false otherwise.</p>',ret:'either <tt>YRealTimeClock.DISABLEHOSTSYNC_FALSE</tt> or <tt>YRealTimeClock.DISABLEHOSTSYNC_TRUE</tt>, according to true if the automatic clock synchronization with host has been disabled, and false otherwise',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.DISABLEHOSTSYNC_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the real-time clock.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the real-time clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the real-time clock object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the real-time clock.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the real-time clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the real-time clock object'}
,'get_friendlyName':{syn:'Returns a global identifier of the real-time clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the real-time clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the real-time clock if they are defined, otherwise the serial number of the module and the hardware identifier of the real-time clock (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the real-time clock using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the real-time clock, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the real-time clock, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the real-time clock (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the real-time clock in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the real-time clock in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the real-time clock (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the real-time clock (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the real-time clock.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the real-time clock.</p>',ret:'a string corresponding to the logical name of the real-time clock.',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_timeSet':{syn:'Returns true if the clock has been set, and false otherwise.',lib:'%.get_timeSet()',pro:'get_timeSet()',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>YRealTimeClock.TIMESET_FALSE</tt> or <tt>YRealTimeClock.TIMESET_TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.TIMESET_INVALID</tt>.'}
,'get_unixTime':{syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'%.get_unixTime()',pro:'get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.UNIXTIME_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_utcOffset':{syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'%.get_utcOffset()',pro:'get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>YRealTimeClock.UTCOFFSET_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the real-time clock is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the real-time clock is currently reachable, without raising any error. If there is a cached value for the real-time clock in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the real-time clock.</p>',ret:'<tt>true</tt> if the real-time clock can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the real-time clock cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the real-time clock cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextRealTimeClock':{syn:'Continues the enumeration of real-time clocks started using <tt>yFirstRealTimeClock()</tt>.',lib:'%.nextRealTimeClock()',pro:'nextRealTimeClock()',cmt:'<p>Continues the enumeration of real-time clocks started using <tt>yFirstRealTimeClock()</tt>. Caution: You can\x27t make any assumption about the returned real-time clocks order. If you want to find a specific a real-time clock, use <tt>RealTimeClock.findRealTimeClock()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to a real-time clock currently online, or a <tt>null</tt> pointer if there are no more real-time clocks to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_disableHostSync':{syn:'Changes the automatic clock synchronization with host working state.',lib:'%.set_disableHostSync()',pro:'set_disableHostSync(<span id=pn>newval</span>)',cmt:'<p>Changes the automatic clock synchronization with host working state. To disable automatic synchronization, set the value to true. To enable automatic synchronization (default), set the value to false.</p><p> If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'either <tt>YRealTimeClock.DISABLEHOSTSYNC_FALSE</tt> or <tt>YRealTimeClock.DISABLEHOSTSYNC_TRUE</tt>, according to the automatic clock synchronization with host working state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the real-time clock.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the real-time clock. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the real-time clock.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unixTime':{syn:'Changes the current time.',lib:'%.set_unixTime()',pro:'set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_utcOffset':{syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'%.set_utcOffset()',pro:'set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: RealTimeClock)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'3D reference frame configuration interface, available for instance in the Yocto-3D-V2 or the Yocto-Inclinometer',inc:'from yocto_refframe import *',cmt:'<p>The <tt>YRefFrame</tt> class is used to set up the base orientation of the Yoctopuce inertial sensors. Thanks to this, orientation functions relative to the earth surface plane can use the proper reference frame. For some devices, the class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}
,'FindRefFrame':{syn:'Retrieves a reference frame for a given identifier.',lib:'YRefFrame.FindRefFrame()',pro:'FindRefFrame(<span id=pn>func</span>)',cmt:'<p>Retrieves a reference frame for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the reference frame is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRefFrame.isOnline()</tt> to test if the reference frame is indeed online at a given time. In case of ambiguity when looking for a reference frame by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the reference frame, for instance <tt>Y3DMK002.refFrame</tt>.'},ret:'a <tt>YRefFrame</tt> object allowing you to drive the reference frame.'}
,'FirstRefFrame':{syn:'Starts the enumeration of reference frames currently accessible.',lib:'YRefFrame.FirstRefFrame()',pro:'FirstRefFrame()',cmt:'<p>Starts the enumeration of reference frames currently accessible. Use the method <tt>YRefFrame.nextRefFrame()</tt> to iterate on next reference frames.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to the first reference frame currently online, or a <tt>null</tt> pointer if there are none.'}
,'cancel3DCalibration':{syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'%.cancel3DCalibration()',pro:'cancel3DCalibration()',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the reference frame attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the reference frame (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_3DCalibrationHint':{syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'%.get_3DCalibrationHint()',pro:'get_3DCalibrationHint()',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'}
,'get_3DCalibrationLogMsg':{syn:'Returns the latest log message from the calibration process.',lib:'%.get_3DCalibrationLogMsg()',pro:'get_3DCalibrationLogMsg()',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'}
,'get_3DCalibrationProgress':{syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'%.get_3DCalibrationProgress()',pro:'get_3DCalibrationProgress()',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'}
,'get_3DCalibrationStage':{syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'%.get_3DCalibrationStage()',pro:'get_3DCalibrationStage()',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'}
,'get_3DCalibrationStageProgress':{syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'%.get_3DCalibrationStageProgress()',pro:'get_3DCalibrationStageProgress()',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'}
,'get_advertisedValue':{syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YRefFrame.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bearing':{syn:'Returns the reference bearing used by the compass.',lib:'%.get_bearing()',pro:'get_bearing()',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:'On failure, throws an exception or returns <tt>YRefFrame.BEARING_INVALID</tt>.'}
,'get_calibrationState':{syn:'Returns the 3D sensor calibration state (Yocto-3D-V2 only).',lib:'%.get_calibrationState()',pro:'get_calibrationState()',cmt:'<p>Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns an integer representing the calibration state of the 3 inertial sensors of the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state of the accelerometer, tenths show the calibration state of the magnetometer while units show the calibration state of the gyroscope. For each sensor, the value 0 means no calibration and the value 3 means full calibration.</p>',ret:'an integer representing the calibration state of Yocto-3D-V2: 333 when fully calibrated, 0 when not calibrated at all.',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the reference frame.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the reference frame object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the reference frame.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the reference frame object'}
,'get_friendlyName':{syn:'Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the reference frame if they are defined, otherwise the serial number of the module and the hardware identifier of the reference frame (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the reference frame using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRefFrame.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the reference frame, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the reference frame, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the reference frame (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRefFrame.FUNCTIONID_INVALID</tt>.'}
,'get_fusionMode':{syn:'Returns the sensor fusion mode.',lib:'%.get_fusionMode()',pro:'get_fusionMode()',cmt:'<p>Returns the sensor fusion mode. Note that available sensor fusion modes depend on the sensor type.</p>',ret:'a value among <tt>YRefFrame.FUSIONMODE_NDOF</tt>, <tt>YRefFrame.FUSIONMODE_NDOF_FMC_OFF</tt>, <tt>YRefFrame.FUSIONMODE_M4G</tt>, <tt>YRefFrame.FUSIONMODE_COMPASS</tt>, <tt>YRefFrame.FUSIONMODE_IMU</tt>, <tt>YRefFrame.FUSIONMODE_INCLIN_90DEG_1G8</tt>, <tt>YRefFrame.FUSIONMODE_INCLIN_90DEG_3G6</tt> and <tt>YRefFrame.FUSIONMODE_INCLIN_10DEG</tt> corresponding to the sensor fusion mode',ext:'On failure, throws an exception or returns <tt>YRefFrame.FUSIONMODE_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the reference frame (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the reference frame (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRefFrame.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the reference frame.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:'On failure, throws an exception or returns <tt>YRefFrame.LOGICALNAME_INVALID</tt>.'}
,'get_measureQuality':{syn:'Returns estimated quality of the orientation (Yocto-3D-V2 only).',lib:'%.get_measureQuality()',pro:'get_measureQuality()',cmt:'<p>Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns an integer between 0 and 3 representing the degree of confidence of the position estimate. When the value is 3, the estimation is reliable. Below 3, one should expect sudden corrections, in particular for heading (<tt>compass</tt> function). The most frequent causes for values below 3 are magnetic interferences, and accelerations or rotations beyond the sensor range.</p>',ret:'an integer between 0 and 3 (3 when the measure is reliable)',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'}
,'get_module':ds.get_module
,'get_mountOrientation':{syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'%.get_mountOrientation()',pro:'get_mountOrientation()',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>YRefFrame.MOUNTORIENTATION</tt> (<tt>YRefFrame.MOUNTORIENTATION_TWELVE</tt>, <tt>YRefFrame.MOUNTORIENTATION_THREE</tt>, <tt>YRefFrame.MOUNTORIENTATION_SIX</tt>, <tt>YRefFrame.MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:'On failure, throws an exception or returns Y_MOUNTORIENTATION_INVALID.'}
,'get_mountPosition':{syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'%.get_mountPosition()',pro:'get_mountPosition()',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>YRefFrame.MOUNTPOSITION</tt> enumeration (<tt>YRefFrame.MOUNTPOSITION_BOTTOM</tt>, <tt>YRefFrame.MOUNTPOSITION_TOP</tt>, <tt>YRefFrame.MOUNTPOSITION_FRONT</tt>, <tt>YRefFrame.MOUNTPOSITION_RIGHT</tt>, <tt>YRefFrame.MOUNTPOSITION_REAR</tt>, <tt>YRefFrame.MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:'On failure, throws an exception or returns Y_MOUNTPOSITION_INVALID.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the reference frame is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the reference frame is currently reachable, without raising any error. If there is a cached value for the reference frame in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the reference frame.</p>',ret:'<tt>true</tt> if the reference frame can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the reference frame cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the reference frame cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'more3DCalibration':{syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'%.more3DCalibration()',pro:'more3DCalibration()',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextRefFrame':{syn:'Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.',lib:'%.nextRefFrame()',pro:'nextRefFrame()',cmt:'<p>Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>. Caution: You can\x27t make any assumption about the returned reference frames order. If you want to find a specific a reference frame, use <tt>RefFrame.findRefFrame()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to a reference frame currently online, or a <tt>null</tt> pointer if there are no more reference frames to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'save3DCalibration':{syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'%.save3DCalibration()',pro:'save3DCalibration()',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed. Remember to call the <tt>saveToFlash()</tt> method of the module if the changes must be kept when the device is restarted.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'set_bearing':{syn:'Changes the reference bearing used by the compass.',lib:'%.set_bearing()',pro:'set_bearing(<span id=pn>newval</span>)',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p><p> For instance, if you set up as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North.</p><p> Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_fusionMode':{syn:'Change the sensor fusion mode.',lib:'%.set_fusionMode()',pro:'set_fusionMode(<span id=pn>newval</span>)',cmt:'<p>Change the sensor fusion mode. Note that available sensor fusion modes depend on the sensor type. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'a value among <tt>YRefFrame.FUSIONMODE_NDOF</tt>, <tt>YRefFrame.FUSIONMODE_NDOF_FMC_OFF</tt>, <tt>YRefFrame.FUSIONMODE_M4G</tt>, <tt>YRefFrame.FUSIONMODE_COMPASS</tt>, <tt>YRefFrame.FUSIONMODE_IMU</tt>, <tt>YRefFrame.FUSIONMODE_INCLIN_90DEG_1G8</tt>, <tt>YRefFrame.FUSIONMODE_INCLIN_90DEG_3G6</tt> and <tt>YRefFrame.FUSIONMODE_INCLIN_10DEG</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the reference frame.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the reference frame. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_mountPosition':{syn:'Changes the compass and tilt sensor frame of reference.',lib:'%.set_mountPosition()',pro:'set_mountPosition(<span id=pn>position</span>, <span id=pn>orientation</span>)',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>YRefFrame.MOUNTPOSITION</tt> enumeration (<tt>YRefFrame.MOUNTPOSITION_BOTTOM</tt>, <tt>YRefFrame.MOUNTPOSITION_TOP</tt>, <tt>YRefFrame.MOUNTPOSITION_FRONT</tt>, <tt>YRefFrame.MOUNTPOSITION_RIGHT</tt>, <tt>YRefFrame.MOUNTPOSITION_REAR</tt>, <tt>YRefFrame.MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>YRefFrame.MOUNTORIENTATION</tt> (<tt>YRefFrame.MOUNTORIENTATION_TWELVE</tt>, <tt>YRefFrame.MOUNTORIENTATION_THREE</tt>, <tt>YRefFrame.MOUNTORIENTATION_SIX</tt>, <tt>YRefFrame.MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.'},ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'start3DCalibration':{syn:'Initiates the sensors tridimensional calibration process.',lib:'%.start3DCalibration()',pro:'start3DCalibration()',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors.</p><p> After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be cancelled at any time using method <tt>cancel3DCalibration</tt>.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: RefFrame)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay control interface, available for instance in the Yocto-LatchedRelay, the Yocto-MaxiPowerRelay, the Yocto-PowerRelay-V3 or the Yocto-Relay',inc:'from yocto_relay import *',cmt:'<p>The <tt>YRelay</tt> class allows you to drive a Yoctopuce relay or optocoupled output. It can be used to simply switch the output on or off, but also to automatically generate short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (normally closed) and the output B corresponding to the active state (normally open).</p>'}
,'FindRelay':{syn:'Retrieves a relay for a given identifier.',lib:'YRelay.FindRelay()',pro:'FindRelay(<span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the relay, for instance <tt>YLTCHRL1.relay1</tt>.'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'}
,'FirstRelay':{syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay.FirstRelay()',pro:'FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the relay attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'delayedPulse':{syn:'Schedules a pulse.',lib:'%.delayedPulse()',pro:'delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the relay (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the relay (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YRelay.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_countdown':{syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'%.get_countdown()',pro:'get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>YRelay.COUNTDOWN_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the relay.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the relay object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the relay.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the relay object'}
,'get_friendlyName':{syn:'Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the relay if they are defined, otherwise the serial number of the module and the hardware identifier of the relay (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the relay using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRelay.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the relay, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the relay, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the relay (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRelay.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the relay (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the relay (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRelay.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the relay.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:'On failure, throws an exception or returns <tt>YRelay.LOGICALNAME_INVALID</tt>.'}
,'get_maxTimeOnStateA':{syn:'Returns the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state.',lib:'%.get_maxTimeOnStateA()',pro:'get_maxTimeOnStateA()',cmt:'<p>Returns the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state. Zero means no time limit.</p>',ret:'an integer corresponding to the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state',ext:'On failure, throws an exception or returns <tt>YRelay.MAXTIMEONSTATEA_INVALID</tt>.'}
,'get_maxTimeOnStateB':{syn:'Retourne the maximum time (ms) allowed for the relay to stay in state B before automatically switching back in to A state.',lib:'%.get_maxTimeOnStateB()',pro:'get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for the relay to stay in state B before automatically switching back in to A state. Zero means no time limit.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>YRelay.MAXTIMEONSTATEB_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_output':{syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'%.get_output()',pro:'get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>YRelay.OUTPUT_OFF</tt> or <tt>YRelay.OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>YRelay.OUTPUT_INVALID</tt>.'}
,'get_pulseTimer':{syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'%.get_pulseTimer()',pro:'get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>YRelay.PULSETIMER_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_state':{syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'%.get_state()',pro:'get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>YRelay.STATE_A</tt> or <tt>YRelay.STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>YRelay.STATE_INVALID</tt>.'}
,'get_stateAtPowerOn':{syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).',lib:'%.get_stateAtPowerOn()',pro:'get_stateAtPowerOn()',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).</p>',ret:'a value among <tt>YRelay.STATEATPOWERON_UNCHANGED</tt>, <tt>YRelay.STATEATPOWERON_A</tt> and <tt>YRelay.STATEATPOWERON_B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is)',ext:'On failure, throws an exception or returns <tt>YRelay.STATEATPOWERON_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the relay is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the relay is currently reachable, without raising any error. If there is a cached value for the relay in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the relay.</p>',ret:'<tt>true</tt> if the relay can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the relay cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the relay cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextRelay':{syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'%.nextRelay()',pro:'nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>. Caution: You can\x27t make any assumption about the returned relays order. If you want to find a specific a relay, use <tt>Relay.findRelay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'}
,'pulse':{syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'%.pulse()',pro:'pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the relay.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxTimeOnStateA':{syn:'Changes the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state.',lib:'%.set_maxTimeOnStateA()',pro:'set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state. Use zero for no time limit. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximum time (ms) allowed for the relay to stay in state A before automatically switching back in to B state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxTimeOnStateB':{syn:'Changes the maximum time (ms) allowed for the relay to stay in state B before automatically switching back in to A state.',lib:'%.set_maxTimeOnStateB()',pro:'set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum time (ms) allowed for the relay to stay in state B before automatically switching back in to A state. Use zero for no time limit. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximum time (ms) allowed for the relay to stay in state B before automatically switching back in to A state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_output':{syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'%.set_output()',pro:'set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>YRelay.OUTPUT_OFF</tt> or <tt>YRelay.OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_state':{syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'%.set_state()',pro:'set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>YRelay.STATE_A</tt> or <tt>YRelay.STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_stateAtPowerOn':{syn:'Changes the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).',lib:'%.set_stateAtPowerOn()',pro:'set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>YRelay.STATEATPOWERON_UNCHANGED</tt>, <tt>YRelay.STATEATPOWERON_A</tt> and <tt>YRelay.STATEATPOWERON_B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'toggle':{syn:'Switch the relay to the opposite state.',lib:'%.toggle()',pro:'toggle()',cmt:'<p>Switch the relay to the opposite state.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Relay)
//--- (generated code: RfidOptions)
doc['RfidOptions']={'':{syn:'Additional parameters for operations on RFID tags.',inc:'from yocto_rfidreader import *',cmt:'<p>The <tt>YRfidOptions</tt> objects are used to specify additional optional parameters to RFID commands that interact with tags, including security keys. When instantiated,the parameters of this object are pre-initialized to a value which corresponds to the most common usage.</p>'}
,'DisableBoundaryChecks':{syn:'Disables the tag memory overflow test.',lib:'YRfidOptions.DisableBoundaryChecks',pro:'<span id=bool>bool</span> <span class=\x27propname\x27>DisableBoundaryChecks</span>',cmt:'<p>Disables the tag memory overflow test. By default, the Yoctopuce library\x27s read/write functions detect overruns and do not run commands that are likely to fail. If you nevertheless wish to try to access more memory than the tag announces, you can try to use this option.</p>'}
,'EnableDryRun':{syn:'Enables simulation mode to check the affected block range as well as access rights.',lib:'YRfidOptions.EnableDryRun',pro:'<span id=bool>bool</span> <span class=\x27propname\x27>EnableDryRun</span>',cmt:'<p>Enables simulation mode to check the affected block range as well as access rights. When this option is active, the operation is not fully applied to the RFID tag but the affected block range is determined and the optional access key is tested on these blocks. The access key rights are not tested though. This option applies to write / configure operations only, it is ignored for read operations.</p>'}
,'EnableRawAccess':{syn:'Enables direct access to RFID tag control blocks.',lib:'YRfidOptions.EnableRawAccess',pro:'<span id=bool>bool</span> <span class=\x27propname\x27>EnableRawAccess</span>',cmt:'<p>Enables direct access to RFID tag control blocks. By default, Yoctopuce library read and write functions only work on data blocks and automatically skip special blocks, as specific functions are provided to configure security parameters found in control blocks. If you need to access control blocks in your own way using read/write functions, enable this option. Use this option wisely, as overwriting a special block migth very well irreversibly alter your tag behavior.</p>'}
,'ForceMultiBlockAccess':{syn:'Forces the use of multi-block commands to access RFID tag memory blocks.',lib:'YRfidOptions.ForceMultiBlockAccess',pro:'<span id=bool>bool</span> <span class=\x27propname\x27>ForceMultiBlockAccess</span>',cmt:'<p>Forces the use of multi-block commands to access RFID tag memory blocks. By default, the Yoctopuce library uses the most efficient access strategy generally available for each tag type, but you can force the use of multi-block commands if you know for sure that the RFID tags you are using do support multi-block commands. Be aware that even if a tag allows multi-block operations, the maximum number of blocks that can be written or read at the same time can be (very) limited. If the tag does not support multi-block mode for the wanted operation, the option will be ignored.</p>'}
,'ForceSingleBlockAccess':{syn:'Forces the use of single-block commands to access RFID tag memory blocks.',lib:'YRfidOptions.ForceSingleBlockAccess',pro:'<span id=bool>bool</span> <span class=\x27propname\x27>ForceSingleBlockAccess</span>',cmt:'<p>Forces the use of single-block commands to access RFID tag memory blocks. By default, the Yoctopuce library uses the most efficient access strategy generally available for each tag type, but you can force the use of single-block commands if the RFID tags you are using do not support multi-block commands. If operation speed is not a priority, choose single-block mode as it will work with any mode.</p>'}
,'HexKey':{syn:'Security key to be used to access the RFID tag, as an hexadecimal string.',lib:'YRfidOptions.HexKey',pro:'<span id=str>string</span> <span class=\x27propname\x27>HexKey</span>',cmt:'<p>Security key to be used to access the RFID tag, as an hexadecimal string. The key will only be used if you also specify which type of key it is, using property <tt>KeyType</tt>.</p>'}
,'KeyType':{syn:'Type of security key to be used to access the RFID tag.',lib:'YRfidOptions.KeyType',pro:'<span id=int>int</span> <span class=\x27propname\x27>KeyType</span>',cmt:'<p>Type of security key to be used to access the RFID tag. For MIFARE Classic tags, allowed values are <tt>Y_MIFARE_KEY_A</tt> or <tt>Y_MIFARE_KEY_B</tt>. The default value is <tt>Y_NO_RFID_KEY</tt>, in that case the reader will use the most common default key for the tag type. When a security key is required, it must be provided using property <tt>HexKey</tt>.</p>'}
};
//--- (end of generated code: RfidOptions)
//--- (generated code: RfidReader)
doc['RfidReader']={'':{syn:'RfidReader function interface',inc:'from yocto_rfidreader import *',cmt:'<p>The <tt>YRfidReader</tt> class allows you to detect RFID tags, as well as read and write on these tags if the security settings allow it. Short reminder:<br> <ul> <li>A tag\x27s memory is generally organized in fixed-size blocks.</li> <li>At tag level, each block must be read and written in its entirety.</li> <li>Some blocks are special configuration blocks, and may alter the tag\x27s behavior if they are rewritten with arbitrary data.</li> <li>Data blocks can be set to read-only mode, but on many tags, this operation is irreversible.</li> </ul> By default, the RfidReader class automatically manages these blocks so that arbitrary size data can be manipulated of without risk and without knowledge of tag architecture.</p>'}
,'FindRfidReader':{syn:'Retrieves a RFID reader for a given identifier.',lib:'YRfidReader.FindRfidReader()',pro:'FindRfidReader(<span id=pn>func</span>)',cmt:'<p>Retrieves a RFID reader for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RFID reader is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRfidReader.isOnline()</tt> to test if the RFID reader is indeed online at a given time. In case of ambiguity when looking for a RFID reader by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RFID reader, for instance <tt>MyDevice.rfidReader</tt>.'},ret:'a <tt>YRfidReader</tt> object allowing you to drive the RFID reader.'}
,'FirstRfidReader':{syn:'Starts the enumeration of RFID readers currently accessible.',lib:'YRfidReader.FirstRfidReader()',pro:'FirstRfidReader()',cmt:'<p>Starts the enumeration of RFID readers currently accessible. Use the method <tt>YRfidReader.nextRfidReader()</tt> to iterate on next RFID readers.</p>',ret:'a pointer to a <tt>YRfidReader</tt> object, corresponding to the first RFID reader currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RFID reader attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the RFID reader in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RFID reader in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RFID reader (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the RFID reader (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the RFID reader (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RFID reader (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YRfidReader.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the RFID reader.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RFID reader. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RFID reader object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the RFID reader.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RFID reader. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RFID reader object'}
,'get_friendlyName':{syn:'Returns a global identifier of the RFID reader in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the RFID reader in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RFID reader if they are defined, otherwise the serial number of the module and the hardware identifier of the RFID reader (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RFID reader using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRfidReader.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the RFID reader, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the RFID reader, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RFID reader (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRfidReader.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the RFID reader in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RFID reader in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RFID reader (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RFID reader (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YRfidReader.HARDWAREID_INVALID</tt>.'}
,'get_lastEvents':{syn:'Returns a string with last tag arrival/removal events observed.',lib:'%.get_lastEvents()',pro:'get_lastEvents()',cmt:'<p>Returns a string with last tag arrival/removal events observed. This method return only events that are still buffered in the device memory.</p>',ret:'a string with last events observed (one per line).',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the RFID reader.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the RFID reader.</p>',ret:'a string corresponding to the logical name of the RFID reader.',ext:'On failure, throws an exception or returns <tt>YRfidReader.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nTags':{syn:'Returns the number of RFID tags currently detected.',lib:'%.get_nTags()',pro:'get_nTags()',cmt:'<p>Returns the number of RFID tags currently detected.</p>',ret:'an integer corresponding to the number of RFID tags currently detected',ext:'On failure, throws an exception or returns <tt>YRfidReader.NTAGS_INVALID</tt>.'}
,'get_refreshRate':{syn:'Returns the tag list refresh rate, measured in Hz.',lib:'%.get_refreshRate()',pro:'get_refreshRate()',cmt:'<p>Returns the tag list refresh rate, measured in Hz.</p>',ret:'an integer corresponding to the tag list refresh rate, measured in Hz',ext:'On failure, throws an exception or returns <tt>YRfidReader.REFRESHRATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_tagIdList':{syn:'Returns the list of RFID tags currently detected by the reader.',lib:'%.get_tagIdList()',pro:'get_tagIdList()',cmt:'<p>Returns the list of RFID tags currently detected by the reader.</p>',ret:'a list of strings, corresponding to each tag identifier (UID).',ext:'On failure, throws an exception or returns an empty list.'}
,'get_tagInfo':{syn:'Returns a description of the properties of an existing RFID tag.',lib:'%.get_tagInfo()',pro:'get_tagInfo(<span id=pn>tagId</span>, <span id=pn>status</span>)',cmt:'<p>Returns a description of the properties of an existing RFID tag. This function can cause communications with the tag.</p>',par:{tagId:'identifier of the tag to check',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a <tt>YRfidTagInfo</tt> object.',ext:'On failure, throws an exception or returns an empty <tt>YRfidTagInfo</tt> objact. When it happens, you can get more information from the <tt>status</tt> object.'}
,'get_tagLockState':{syn:'Reads the locked state for RFID tag memory data blocks.',lib:'%.get_tagLockState()',pro:'get_tagLockState(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBlocks</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads the locked state for RFID tag memory data blocks. FirstBlock cannot be a special block, and any special block encountered in the middle of the read operation will be skipped automatically.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'number of the first block to check',nBlocks:'number of blocks to check',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a list of booleans with the lock state of selected blocks',ext:'On failure, throws an exception or returns an empty list. When it happens, you can get more information from the <tt>status</tt> object.'}
,'get_tagSpecialBlocks':{syn:'Tells which block of a RFID tag memory are special and cannot be used to store user data.',lib:'%.get_tagSpecialBlocks()',pro:'get_tagSpecialBlocks(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBlocks</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Tells which block of a RFID tag memory are special and cannot be used to store user data. Mistakely writing a special block can lead to an irreversible alteration of the tag.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'number of the first block to check',nBlocks:'number of blocks to check',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a list of booleans with the lock state of selected blocks',ext:'On failure, throws an exception or returns an empty list. When it happens, you can get more information from the <tt>status</tt> object.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the RFID reader is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the RFID reader is currently reachable, without raising any error. If there is a cached value for the RFID reader in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RFID reader.</p>',ret:'<tt>true</tt> if the RFID reader can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the RFID reader cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RFID reader cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextRfidReader':{syn:'Continues the enumeration of RFID readers started using <tt>yFirstRfidReader()</tt>.',lib:'%.nextRfidReader()',pro:'nextRfidReader()',cmt:'<p>Continues the enumeration of RFID readers started using <tt>yFirstRfidReader()</tt>. Caution: You can\x27t make any assumption about the returned RFID readers order. If you want to find a specific a RFID reader, use <tt>RfidReader.findRfidReader()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRfidReader</tt> object, corresponding to a RFID reader currently online, or a <tt>null</tt> pointer if there are no more RFID readers to enumerate.'}
,'registerEventCallback':{syn:'Registers a callback function to be called each time that an RFID tag appears or disappears.',lib:'%.registerEventCallback()',pro:'registerEventCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function to be called each time that an RFID tag appears or disappears. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take four arguments: the <tt>YRfidReader</tt> object that emitted the event, the UTC timestamp of the event, a character string describing the type of event (\x22+\x22 or \x22-\x22) and a character string with the RFID tag identifier. On failure, throws an exception or returns a negative error code.'}}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the RFID reader.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RFID reader. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RFID reader.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_refreshRate':{syn:'Changes the present tag list refresh rate, measured in Hz.',lib:'%.set_refreshRate()',pro:'set_refreshRate(<span id=pn>newval</span>)',cmt:'<p>Changes the present tag list refresh rate, measured in Hz. The reader will do its best to respect it. Note that the reader cannot detect tag arrival or removal while it is communicating with a tag. Maximum frequency is limited to 100Hz, but in real life it will be difficult to do better than 50Hz. A zero value will power off the device radio. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the present tag list refresh rate, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'tagGetAFI':{syn:'Reads an RFID tag AFI byte (ISO 15693 only).',lib:'%.tagGetAFI()',pro:'tagGetAFI(<span id=pn>tagId</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads an RFID tag AFI byte (ISO 15693 only).</p>',par:{tagId:'identifier of the tag to use',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'the AFI value (0...255)',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagGetDSFID':{syn:'Reads an RFID tag DSFID byte (ISO 15693 only).',lib:'%.tagGetDSFID()',pro:'tagGetDSFID(<span id=pn>tagId</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads an RFID tag DSFID byte (ISO 15693 only).</p>',par:{tagId:'identifier of the tag to use',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'the DSFID value (0...255)',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagLockAFI':{syn:'Locks the RFID tag AFI byte (ISO 15693 only).',lib:'%.tagLockAFI()',pro:'tagLockAFI(<span id=pn>tagId</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Locks the RFID tag AFI byte (ISO 15693 only). This operation is definitive and irreversible.</p>',par:{tagId:'identifier of the tag to use',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagLockBlocks':{syn:'Changes an RFID tag configuration to prevents any further write to the selected blocks.',lib:'%.tagLockBlocks()',pro:'tagLockBlocks(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBlocks</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Changes an RFID tag configuration to prevents any further write to the selected blocks. This operation is definitive and irreversible. Depending on the tag type and block index, adjascent blocks may become read-only as well, based on the locking granularity.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'first block to lock',nBlocks:'number of blocks to lock',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagLockDSFID':{syn:'Locks the RFID tag DSFID byte (ISO 15693 only).',lib:'%.tagLockDSFID()',pro:'tagLockDSFID(<span id=pn>tagId</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Locks the RFID tag DSFID byte (ISO 15693 only). This operation is definitive and irreversible.</p>',par:{tagId:'identifier of the tag to use',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagReadArray':{syn:'Reads data from an RFID tag memory, as a byte list.',lib:'%.tagReadArray()',pro:'tagReadArray(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBytes</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads data from an RFID tag memory, as a byte list. The read operation may span accross multiple blocks if the requested number of bytes is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the read operation will be skipped automatically. If you rather want to read special blocks, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where read should start',nBytes:'total number of bytes to read',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a byte list with the data read if the call succeeds.',ext:'On failure, throws an exception or returns an empty list. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagReadBin':{syn:'Reads data from an RFID tag memory, as a binary buffer.',lib:'%.tagReadBin()',pro:'tagReadBin(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBytes</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads data from an RFID tag memory, as a binary buffer. The read operation may span accross multiple blocks if the requested number of bytes is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the read operation will be skipped automatically. If you rather want to read special blocks, use the <tt>EnableRawAccess</tt> field frrm the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where read should start',nBytes:'total number of bytes to read',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a binary object with the data read if the call succeeds.',ext:'On failure, throws an exception or returns an empty binary buffer. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagReadHex':{syn:'Reads data from an RFID tag memory, as an hexadecimal string.',lib:'%.tagReadHex()',pro:'tagReadHex(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nBytes</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads data from an RFID tag memory, as an hexadecimal string. The read operation may span accross multiple blocks if the requested number of bytes is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the read operation will be skipped automatically. If you rather want to read special blocks, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where read should start',nBytes:'total number of bytes to read',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'an hexadecimal string if the call succeeds.',ext:'On failure, throws an exception or returns an empty binary buffer. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagReadStr':{syn:'Reads data from an RFID tag memory, as a text string.',lib:'%.tagReadStr()',pro:'tagReadStr(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>nChars</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Reads data from an RFID tag memory, as a text string. The read operation may span accross multiple blocks if the requested number of bytes is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the read operation will be skipped automatically. If you rather want to read special blocks, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where read should start',nChars:'total number of characters to read',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'a text string with the data read if the call succeeds.',ext:'On failure, throws an exception or returns an empty string. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagSetAFI':{syn:'Changes an RFID tag AFI byte (ISO 15693 only).',lib:'%.tagSetAFI()',pro:'tagSetAFI(<span id=pn>tagId</span>, <span id=pn>afi</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Changes an RFID tag AFI byte (ISO 15693 only).</p>',par:{tagId:'identifier of the tag to use',afi:'the AFI value to write (0...255)',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagSetDSFID':{syn:'Changes an RFID tag DSFID byte (ISO 15693 only).',lib:'%.tagSetDSFID()',pro:'tagSetDSFID(<span id=pn>tagId</span>, <span id=pn>dsfid</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Changes an RFID tag DSFID byte (ISO 15693 only).</p>',par:{tagId:'identifier of the tag to use',dsfid:'the DSFID value to write (0...255)',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagWriteArray':{syn:'Writes data provided as a list of bytes to an RFID tag memory.',lib:'%.tagWriteArray()',pro:'tagWriteArray(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>byteList</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Writes data provided as a list of bytes to an RFID tag memory. The write operation may span accross multiple blocks if the number of bytes to write is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the write operation will be skipped automatically. The last data block affected by the operation will be automatically padded with zeros if neccessary. If you rather want to rewrite special blocks as well, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where write should start',byteList:'a list of byte to write',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagWriteBin':{syn:'Writes data provided as a binary buffer to an RFID tag memory.',lib:'%.tagWriteBin()',pro:'tagWriteBin(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>buff</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Writes data provided as a binary buffer to an RFID tag memory. The write operation may span accross multiple blocks if the number of bytes to write is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the write operation will be skipped automatically. The last data block affected by the operation will be automatically padded with zeros if neccessary. If you rather want to rewrite special blocks as well, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where write should start',buff:'the binary buffer to write',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagWriteHex':{syn:'Writes data provided as an hexadecimal string to an RFID tag memory.',lib:'%.tagWriteHex()',pro:'tagWriteHex(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>hexString</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Writes data provided as an hexadecimal string to an RFID tag memory. The write operation may span accross multiple blocks if the number of bytes to write is larger than the RFID tag block size. By default firstBlock cannot be a special block, and any special block encountered in the middle of the write operation will be skipped automatically. The last data block affected by the operation will be automatically padded with zeros if neccessary. If you rather want to rewrite special blocks as well, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter.</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where write should start',hexString:'a string of hexadecimal byte codes to write',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'tagWriteStr':{syn:'Writes data provided as an ASCII string to an RFID tag memory.',lib:'%.tagWriteStr()',pro:'tagWriteStr(<span id=pn>tagId</span>, <span id=pn>firstBlock</span>, <span id=pn>text</span>, <span id=pn>options</span>, <span id=pn>status</span>)',cmt:'<p>Writes data provided as an ASCII string to an RFID tag memory. The write operation may span accross multiple blocks if the number of bytes to write is larger than the RFID tag block size. Note that only the characters present in the provided string will be written, there is no notion of string length. If your string data have variable length, you\x27ll have to encode the string length yourself, with a terminal zero for instannce. This function only works with ISO-latin characters, if you wish to write strings encoded with alternate character sets, you\x27ll have to use tagWriteBin() function. By default firstBlock cannot be a special block, and any special block encountered in the middle of the write operation will be skipped automatically. The last data block affected by the operation will be automatically padded with zeros if neccessary. If you rather want to rewrite special blocks as well, use the <tt>EnableRawAccess</tt> field from the <tt>options</tt> parameter (definitely not recommanded).</p>',par:{tagId:'identifier of the tag to use',firstBlock:'block number where write should start',text:'the text string to write',options:'an <tt>YRfidOptions</tt> object with the optional command execution parameters, such as security key if required',status:'an <tt>RfidStatus</tt> object that will contain the detailled status of the operation'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code. When it happens, you can get more information from the <tt>status</tt> object.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: RfidReader)
//--- (generated code: RfidStatus)
doc['RfidStatus']={'':{syn:'Detailled information about the result of RFID tag operations, allowing to find out what happened exactly after a tag operation failure.',inc:'from yocto_rfidreader import *',cmt:'<p><tt>YRfidStatus</tt> objects provide additional information about operations on RFID tags, including the range of blocks affected by read/write operations and possible errors when communicating with RFID tags. This makes it possible, for example, to distinguish communication errors that can be recovered by an additional attempt, from security or other errors on the tag. Combined with the <tt>EnableDryRun</tt> option in <tt>RfidOptions</tt>, this structure can be used to predict which blocks will be affected by a write operation.</p>'}
,'get_errorBlock':{syn:'Returns the RFID tag memory block number where the error was encountered, or -1 if the error is not specific to a memory block.',lib:'%.get_errorBlock()',pro:'get_errorBlock()',cmt:'<p>Returns the RFID tag memory block number where the error was encountered, or -1 if the error is not specific to a memory block.</p>',ret:'an RFID tag block number'}
,'get_errorCode':{syn:'Returns the detailled error code, or 0 if no error happened.',lib:'%.get_errorCode()',pro:'get_errorCode()',cmt:'<p>Returns the detailled error code, or 0 if no error happened.</p>',ret:'a numeric error code'}
,'get_errorMessage':{syn:'Returns a string describing precisely the RFID commande result.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns a string describing precisely the RFID commande result.</p>',ret:'an error message string'}
,'get_firstAffectedBlock':{syn:'Returns the block number of the first RFID tag memory block affected by the operation.',lib:'%.get_firstAffectedBlock()',pro:'get_firstAffectedBlock()',cmt:'<p>Returns the block number of the first RFID tag memory block affected by the operation. Depending on the type of operation and on the tag memory granularity, this number may be smaller than the requested memory block index.</p>',ret:'an RFID tag block number'}
,'get_lastAffectedBlock':{syn:'Returns the block number of the last RFID tag memory block affected by the operation.',lib:'%.get_lastAffectedBlock()',pro:'get_lastAffectedBlock()',cmt:'<p>Returns the block number of the last RFID tag memory block affected by the operation. Depending on the type of operation and on the tag memory granularity, this number may be bigger than the requested memory block index.</p>',ret:'an RFID tag block number'}
,'get_tagId':{syn:'Returns RFID tag identifier related to the status.',lib:'%.get_tagId()',pro:'get_tagId()',cmt:'<p>Returns RFID tag identifier related to the status.</p>',ret:'a string with the RFID tag identifier.'}
};
//--- (end of generated code: RfidStatus)
//--- (generated code: RfidTagInfo)
doc['RfidTagInfo']={'':{syn:'RFID tag description, used by class <tt>YRfidReader</tt>',inc:'from yocto_rfidreader import *',cmt:'<p><tt>YRfidTagInfo</tt> objects are used to describe RFID tag attributes, such as the tag type and its storage size. These objects are returned by method <tt>get_tagInfo()</tt> of class <tt>YRfidReader</tt>.</p>'}
,'get_tagBlockSize':{syn:'Returns the block size of the RFID tag, in bytes.',lib:'%.get_tagBlockSize()',pro:'get_tagBlockSize()',cmt:'<p>Returns the block size of the RFID tag, in bytes.</p>',ret:'the block size of the RFID tag'}
,'get_tagFirstBlock':{syn:'Returns the index of the block available for data storage on the RFID tag.',lib:'%.get_tagFirstBlock()',pro:'get_tagFirstBlock()',cmt:'<p>Returns the index of the block available for data storage on the RFID tag. Some tags have special block used to configure the tag behavior, these blocks must be handled with precaution. However, the block return by <tt>get_tagFirstBlock()</tt> can be locked, use <tt>get_tagLockState()</tt> to find out which block are locked.</p>',ret:'the index of the first usable storage block on the RFID tag'}
,'get_tagId':{syn:'Returns the RFID tag identifier.',lib:'%.get_tagId()',pro:'get_tagId()',cmt:'<p>Returns the RFID tag identifier.</p>',ret:'a string with the RFID tag identifier.'}
,'get_tagLastBlock':{syn:'Returns the index of the last last black available for data storage on the RFID tag, However, this block can be locked, use <tt>get_tagLockState()</tt> to find out which block are locked.',lib:'%.get_tagLastBlock()',pro:'get_tagLastBlock()',cmt:'<p>Returns the index of the last last black available for data storage on the RFID tag, However, this block can be locked, use <tt>get_tagLockState()</tt> to find out which block are locked.</p>',ret:'the index of the last usable storage block on the RFID tag'}
,'get_tagMemorySize':{syn:'Returns the total memory size of the RFID tag, in bytes.',lib:'%.get_tagMemorySize()',pro:'get_tagMemorySize()',cmt:'<p>Returns the total memory size of the RFID tag, in bytes.</p>',ret:'the total memory size of the RFID tag'}
,'get_tagType':{syn:'Returns the type of the RFID tag, as a numeric constant.',lib:'%.get_tagType()',pro:'get_tagType()',cmt:'<p>Returns the type of the RFID tag, as a numeric constant. (<tt>IEC_14443_MIFARE_CLASSIC1K</tt>, ...).</p>',ret:'an integer corresponding to the RFID tag type'}
,'get_tagTypeStr':{syn:'Returns the type of the RFID tag, as a string.',lib:'%.get_tagTypeStr()',pro:'get_tagTypeStr()',cmt:'<p>Returns the type of the RFID tag, as a string.</p>',ret:'a string corresponding to the RFID tag type'}
,'get_tagUsableSize':{syn:'Returns the usable storage size of the RFID tag, in bytes.',lib:'%.get_tagUsableSize()',pro:'get_tagUsableSize()',cmt:'<p>Returns the usable storage size of the RFID tag, in bytes.</p>',ret:'the usable storage size of the RFID tag'}
};
//--- (end of generated code: RfidTagInfo)
//--- (generated code: Sdi12Port)
doc['Sdi12Port']={'':{syn:'SDI12 port control interface',inc:'from yocto_sdi12port import *',cmt:'<p>The <tt>YSdi12Port</tt> class allows you to fully drive a Yoctopuce SDI12 port. It can be used to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce SDI12 ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}
,'FindSdi12Port':{syn:'Retrieves an SDI12 port for a given identifier.',lib:'YSdi12Port.FindSdi12Port()',pro:'FindSdi12Port(<span id=pn>func</span>)',cmt:'<p>Retrieves an SDI12 port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the SDI12 port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSdi12Port.isOnline()</tt> to test if the SDI12 port is indeed online at a given time. In case of ambiguity when looking for an SDI12 port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the SDI12 port, for instance <tt>MyDevice.sdi12Port</tt>.'},ret:'a <tt>YSdi12Port</tt> object allowing you to drive the SDI12 port.'}
,'FirstSdi12Port':{syn:'Starts the enumeration of SDI12 ports currently accessible.',lib:'YSdi12Port.FirstSdi12Port()',pro:'FirstSdi12Port()',cmt:'<p>Starts the enumeration of SDI12 ports currently accessible. Use the method <tt>YSdi12Port.nextSdi12Port()</tt> to iterate on next SDI12 ports.</p>',ret:'a pointer to a <tt>YSdi12Port</tt> object, corresponding to the first SDI12 port currently online, or a <tt>null</tt> pointer if there are none.'}
,'changeAddress':{syn:'Changes the address of the selected sensor, and returns the sensor information with the new address.',lib:'%.changeAddress()',pro:'changeAddress(<span id=pn>oldAddress</span>, <span id=pn>newAddress</span>)',cmt:'<p>Changes the address of the selected sensor, and returns the sensor information with the new address. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{oldAddress:'Actual sensor address, as a string',newAddress:'New sensor address, as a string'},ret:'the sensor address and information , as a YSdi12SensorInfo object.',ext:'On failure, throws an exception or returns an empty string.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the SDI12 port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the SDI12 port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the SDI12 port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the SDI12 port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'discoverAllSensors':{syn:'Sends a discovery command to the bus, and reads all sensors information reply.',lib:'%.discoverAllSensors()',pro:'discoverAllSensors()',cmt:'<p>Sends a discovery command to the bus, and reads all sensors information reply. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',ret:'all the information from every connected sensor, as an array of YSdi12SensorInfo object.',ext:'On failure, throws an exception or returns an empty string.'}
,'discoverSingleSensor':{syn:'Sends a discovery command to the bus, and reads the sensor information reply.',lib:'%.discoverSingleSensor()',pro:'discoverSingleSensor()',cmt:'<p>Sends a discovery command to the bus, and reads the sensor information reply. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol. This function work when only one sensor is connected.</p>',ret:'the reply returned by the sensor, as a YSdi12SensorInfo object.',ext:'On failure, throws an exception or returns an empty string.'}
,'getSensorInformation':{syn:'Sends a information command to the bus, and reads sensors information selected.',lib:'%.getSensorInformation()',pro:'getSensorInformation(<span id=pn>sensorAddr</span>)',cmt:'<p>Sends a information command to the bus, and reads sensors information selected. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{sensorAddr:'Sensor address, as a string'},ret:'the reply returned by the sensor, as a YSdi12Port object.',ext:'On failure, throws an exception or returns an empty string.'}
,'get_advertisedValue':{syn:'Returns the current value of the SDI12 port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the SDI12 port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SDI12 port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSdi12Port.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentJob':{syn:'Returns the name of the job file currently in use.',lib:'%.get_currentJob()',pro:'get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>YSdi12Port.CURRENTJOB_INVALID</tt>.'}
,'get_errCount':{syn:'Returns the total number of communication errors detected since last reset.',lib:'%.get_errCount()',pro:'get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>YSdi12Port.ERRCOUNT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the SDI12 port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the SDI12 port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the SDI12 port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the SDI12 port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the SDI12 port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the SDI12 port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the SDI12 port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the SDI12 port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the SDI12 port if they are defined, otherwise the serial number of the module and the hardware identifier of the SDI12 port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the SDI12 port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSdi12Port.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the SDI12 port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the SDI12 port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the SDI12 port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSdi12Port.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the SDI12 port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the SDI12 port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the SDI12 port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the SDI12 port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSdi12Port.HARDWAREID_INVALID</tt>.'}
,'get_jobMaxSize':{syn:'Returns maximum size allowed for job files.',lib:'%.get_jobMaxSize()',pro:'get_jobMaxSize()',cmt:'<p>Returns maximum size allowed for job files.</p>',ret:'an integer corresponding to maximum size allowed for job files',ext:'On failure, throws an exception or returns <tt>YSdi12Port.JOBMAXSIZE_INVALID</tt>.'}
,'get_jobMaxTask':{syn:'Returns the maximum number of tasks in a job that the device can handle.',lib:'%.get_jobMaxTask()',pro:'get_jobMaxTask()',cmt:'<p>Returns the maximum number of tasks in a job that the device can handle.</p>',ret:'an integer corresponding to the maximum number of tasks in a job that the device can handle',ext:'On failure, throws an exception or returns <tt>YSdi12Port.JOBMAXTASK_INVALID</tt>.'}
,'get_lastMsg':{syn:'Returns the latest message fully received.',lib:'%.get_lastMsg()',pro:'get_lastMsg()',cmt:'<p>Returns the latest message fully received.</p>',ret:'a string corresponding to the latest message fully received',ext:'On failure, throws an exception or returns <tt>YSdi12Port.LASTMSG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the SDI12 port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the SDI12 port.</p>',ret:'a string corresponding to the logical name of the SDI12 port.',ext:'On failure, throws an exception or returns <tt>YSdi12Port.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_protocol':{syn:'Returns the type of protocol used over the serial line, as a string.',lib:'%.get_protocol()',pro:'get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>YSdi12Port.PROTOCOL_INVALID</tt>.'}
,'get_rxCount':{syn:'Returns the total number of bytes received since last reset.',lib:'%.get_rxCount()',pro:'get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>YSdi12Port.RXCOUNT_INVALID</tt>.'}
,'get_rxMsgCount':{syn:'Returns the total number of messages received since last reset.',lib:'%.get_rxMsgCount()',pro:'get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>YSdi12Port.RXMSGCOUNT_INVALID</tt>.'}
,'get_serialMode':{syn:'Returns the serial port communication parameters, as a string such as \x221200,7E1,Simplex\x22.',lib:'%.get_serialMode()',pro:'get_serialMode()',cmt:'<p>Returns the serial port communication parameters, as a string such as \x221200,7E1,Simplex\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. The suffix \x22Simplex\x22 denotes the fact that transmission in both directions is multiplexed on the same transmission line.</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x221200,7E1,Simplex\x22',ext:'On failure, throws an exception or returns <tt>YSdi12Port.SERIALMODE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_startupJob':{syn:'Returns the job file to use when the device is powered on.',lib:'%.get_startupJob()',pro:'get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>YSdi12Port.STARTUPJOB_INVALID</tt>.'}
,'get_txCount':{syn:'Returns the total number of bytes transmitted since last reset.',lib:'%.get_txCount()',pro:'get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>YSdi12Port.TXCOUNT_INVALID</tt>.'}
,'get_txMsgCount':{syn:'Returns the total number of messages send since last reset.',lib:'%.get_txMsgCount()',pro:'get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>YSdi12Port.TXMSGCOUNT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_voltageLevel':{syn:'Returns the voltage level used on the serial line.',lib:'%.get_voltageLevel()',pro:'get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>YSdi12Port.VOLTAGELEVEL_OFF</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL3V</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL5V</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSdi12Port.VOLTAGELEVEL_RS232</tt>, <tt>YSdi12Port.VOLTAGELEVEL_RS485</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSdi12Port.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>YSdi12Port.VOLTAGELEVEL_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the SDI12 port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the SDI12 port is currently reachable, without raising any error. If there is a cached value for the SDI12 port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the SDI12 port.</p>',ret:'<tt>true</tt> if the SDI12 port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the SDI12 port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the SDI12 port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextSdi12Port':{syn:'Continues the enumeration of SDI12 ports started using <tt>yFirstSdi12Port()</tt>.',lib:'%.nextSdi12Port()',pro:'nextSdi12Port()',cmt:'<p>Continues the enumeration of SDI12 ports started using <tt>yFirstSdi12Port()</tt>. Caution: You can\x27t make any assumption about the returned SDI12 ports order. If you want to find a specific an SDI12 port, use <tt>Sdi12Port.findSdi12Port()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSdi12Port</tt> object, corresponding to an SDI12 port currently online, or a <tt>null</tt> pointer if there are no more SDI12 ports to enumerate.'}
,'queryHex':{syn:'Sends a binary message to the serial port, and reads the reply, if any.',lib:'%.queryHex()',pro:'queryHex(<span id=pn>hexString</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a binary message to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for Frame-based protocol.</p>',par:{hexString:'the message to send, coded in hexadecimal',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next frame received after sending the message, as a hex string. Additional frames can be obtained by calling readHex or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'queryLine':{syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'%.queryLine()',pro:'queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'querySdi12':{syn:'Sends a SDI-12 query to the bus, and reads the sensor immediate reply.',lib:'%.querySdi12()',pro:'querySdi12(<span id=pn>sensorAddr</span>, <span id=pn>cmd</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a SDI-12 query to the bus, and reads the sensor immediate reply. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{sensorAddr:'the sensor address, as a string',cmd:'the SDI12 query to send (without address and exclamation point)',maxWait:'the maximum timeout to wait for a reply from sensor, in millisecond'},ret:'the reply returned by the sensor, without newline, as a string.',ext:'On failure, throws an exception or returns an empty string.'}
,'readArray':{syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'%.readArray()',pro:'readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns an empty array.'}
,'readBin':{syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'%.readBin()',pro:'readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'readByte':{syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'%.readByte()',pro:'readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'}
,'readConcurrentMeasurements':{syn:'Sends a information command to the bus, and reads sensors information selected.',lib:'%.readConcurrentMeasurements()',pro:'readConcurrentMeasurements(<span id=pn>sensorAddr</span>)',cmt:'<p>Sends a information command to the bus, and reads sensors information selected. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{sensorAddr:'Sensor address, as a string'},ret:'the reply returned by the sensor, as a YSdi12Port object.',ext:'On failure, throws an exception or returns an empty string.'}
,'readHex':{syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'%.readHex()',pro:'readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'}
,'readLine':{syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'%.readLine()',pro:'readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'}
,'readMessages':{syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'%.readMessages()',pro:'readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'readSensor':{syn:'Sends a mesurement command to the SDI-12 bus, and reads the sensor immediate reply.',lib:'%.readSensor()',pro:'readSensor(<span id=pn>sensorAddr</span>, <span id=pn>measCmd</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a mesurement command to the SDI-12 bus, and reads the sensor immediate reply. The supported commands are: M: Measurement start control M1...M9: Additional measurement start command D: Measurement reading control This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{sensorAddr:'the sensor address, as a string',measCmd:'the SDI12 query to send (without address and exclamation point)',maxWait:'the maximum timeout to wait for a reply from sensor, in millisecond'},ret:'the reply returned by the sensor, without newline, as a list of float.',ext:'On failure, throws an exception or returns an empty string.'}
,'readStr':{syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'%.readStr()',pro:'readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'read_avail':{syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'%.read_avail()',pro:'read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'}
,'read_seek':{syn:'Changes the current internal stream position to the specified value.',lib:'%.read_seek()',pro:'read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'}
,'read_tell':{syn:'Returns the current absolute stream position pointer of the API object.',lib:'%.read_tell()',pro:'read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'}
,'registerValueCallback':ds.registerValueCallback
,'requestConcurrentMeasurements':{syn:'Sends a information command to the bus, and reads sensors information selected.',lib:'%.requestConcurrentMeasurements()',pro:'requestConcurrentMeasurements(<span id=pn>sensorAddr</span>)',cmt:'<p>Sends a information command to the bus, and reads sensors information selected. This function is intended to be used when the serial port is configured for \x27SDI-12\x27 protocol.</p>',par:{sensorAddr:'Sensor address, as a string'},ret:'the reply returned by the sensor, as a YSdi12Port object.',ext:'On failure, throws an exception or returns an empty string.'}
,'reset':{syn:'Clears the serial port buffer and resets counters to zero.',lib:'%.reset()',pro:'reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectJob':{syn:'Load and start processing the specified job file.',lib:'%.selectJob()',pro:'selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentJob':{syn:'Selects a job file to run immediately.',lib:'%.set_currentJob()',pro:'set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Selects a job file to run immediately. If an empty string is given as argument, stops running current job file.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the SDI12 port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the SDI12 port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the SDI12 port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_protocol':{syn:'Changes the type of protocol used over the serial line.',lib:'%.set_protocol()',pro:'set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_serialMode':{syn:'Changes the serial port communication parameters, with a string such as \x221200,7E1,Simplex\x22.',lib:'%.set_serialMode()',pro:'set_serialMode(<span id=pn>newval</span>)',cmt:'<p>Changes the serial port communication parameters, with a string such as \x221200,7E1,Simplex\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. The suffix \x22Simplex\x22 denotes the fact that transmission in both directions is multiplexed on the same transmission line. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x221200,7E1,Simplex\x22'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupJob':{syn:'Changes the job to use when the device is powered on.',lib:'%.set_startupJob()',pro:'set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltageLevel':{syn:'Changes the voltage type used on the serial line.',lib:'%.set_voltageLevel()',pro:'set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. Trying to set an invalid value will have no effect. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YSdi12Port.VOLTAGELEVEL_OFF</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL3V</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL5V</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSdi12Port.VOLTAGELEVEL_RS232</tt>, <tt>YSdi12Port.VOLTAGELEVEL_RS485</tt>, <tt>YSdi12Port.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSdi12Port.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'snoopMessages':{syn:'Retrieves messages (both direction) in the SDI12 port buffer, starting at current position.',lib:'%.snoopMessages()',pro:'snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the SDI12 port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of <tt>YSdi12SnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'snoopMessagesEx':{syn:'Retrieves messages (both direction) in the SDI12 port buffer, starting at current position.',lib:'%.snoopMessagesEx()',pro:'snoopMessagesEx(<span id=pn>maxWait</span>, <span id=pn>maxMsg</span>)',cmt:'<p>Retrieves messages (both direction) in the SDI12 port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.',maxMsg:'the maximum number of messages to be returned by the function; up to 254.'},ret:'an array of <tt>YSdi12SnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'uploadJob':{syn:'Saves the job definition string (JSON data) into a job file.',lib:'%.uploadJob()',pro:'uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeArray':{syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'%.writeArray()',pro:'writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeBin':{syn:'Sends a binary buffer to the serial port, as is.',lib:'%.writeBin()',pro:'writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeByte':{syn:'Sends a single byte to the serial port.',lib:'%.writeByte()',pro:'writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeHex':{syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'%.writeHex()',pro:'writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeLine':{syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'%.writeLine()',pro:'writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeStr':{syn:'Sends an ASCII string to the serial port, as is.',lib:'%.writeStr()',pro:'writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Sdi12Port)
//--- (generated code: Sdi12SensorInfo)
doc['Sdi12SensorInfo']={'':{syn:'Description of a discovered SDI12 sensor, returned by <tt>sdi12Port.discoverSingleSensor</tt> and <tt>sdi12Port.discoverAllSensors</tt> methods',inc:'from yocto_sdi12port import *'}
,'get_measureCommand':{syn:'Returns the sensor measurement command.',lib:'%.get_measureCommand()',pro:'get_measureCommand(<span id=pn>measureIndex</span>)',cmt:'<p>Returns the sensor measurement command. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',par:{measureIndex:'measurement index'},ret:'the sensor measurement command. On failure, throws an exception or returns an empty string.'}
,'get_measureCount':{syn:'Returns the number of sensor measurements.',lib:'%.get_measureCount()',pro:'get_measureCount()',cmt:'<p>Returns the number of sensor measurements. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',ret:'the number of sensor measurements.'}
,'get_measureDescription':{syn:'Returns the description of the measured value.',lib:'%.get_measureDescription()',pro:'get_measureDescription(<span id=pn>measureIndex</span>)',cmt:'<p>Returns the description of the measured value. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',par:{measureIndex:'measurement index'},ret:'the sensor measurement command. On failure, throws an exception or returns an empty string.'}
,'get_measurePosition':{syn:'Returns sensor measurement position.',lib:'%.get_measurePosition()',pro:'get_measurePosition(<span id=pn>measureIndex</span>)',cmt:'<p>Returns sensor measurement position. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',par:{measureIndex:'measurement index'},ret:'the sensor measurement command. On failure, throws an exception or returns 0.'}
,'get_measureSymbol':{syn:'Returns the measured value symbol.',lib:'%.get_measureSymbol()',pro:'get_measureSymbol(<span id=pn>measureIndex</span>)',cmt:'<p>Returns the measured value symbol. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',par:{measureIndex:'measurement index'},ret:'the sensor measurement command. On failure, throws an exception or returns an empty string.'}
,'get_measureUnit':{syn:'Returns the unit of the measured value.',lib:'%.get_measureUnit()',pro:'get_measureUnit(<span id=pn>measureIndex</span>)',cmt:'<p>Returns the unit of the measured value. This function only works if the sensor is in version 1.4 SDI-12 and supports metadata commands.</p>',par:{measureIndex:'measurement index'},ret:'the sensor measurement command. On failure, throws an exception or returns an empty string.'}
,'get_sensorAddress':{syn:'Returns the sensor address.',lib:'%.get_sensorAddress()',pro:'get_sensorAddress()',cmt:'<p>Returns the sensor address.</p>',ret:'the sensor address.'}
,'get_sensorModel':{syn:'Returns the sensor model number.',lib:'%.get_sensorModel()',pro:'get_sensorModel()',cmt:'<p>Returns the sensor model number.</p>',ret:'the sensor model number.'}
,'get_sensorProtocol':{syn:'Returns the compatible SDI-12 version of the sensor.',lib:'%.get_sensorProtocol()',pro:'get_sensorProtocol()',cmt:'<p>Returns the compatible SDI-12 version of the sensor.</p>',ret:'the compatible SDI-12 version of the sensor.'}
,'get_sensorSerial':{syn:'Returns the sensor serial number.',lib:'%.get_sensorSerial()',pro:'get_sensorSerial()',cmt:'<p>Returns the sensor serial number.</p>',ret:'the sensor serial number.'}
,'get_sensorVendor':{syn:'Returns the sensor vendor identification.',lib:'%.get_sensorVendor()',pro:'get_sensorVendor()',cmt:'<p>Returns the sensor vendor identification.</p>',ret:'the sensor vendor identification.'}
,'get_sensorVersion':{syn:'Returns the sensor version.',lib:'%.get_sensorVersion()',pro:'get_sensorVersion()',cmt:'<p>Returns the sensor version.</p>',ret:'the sensor version.'}
,'isValid':{syn:'Returns the sensor state.',lib:'%.isValid()',pro:'isValid()',cmt:'<p>Returns the sensor state.</p>',ret:'the sensor state.'}
};
//--- (end of generated code: Sdi12SensorInfo)
//--- (generated code: Sdi12SnoopingRecord)
doc['Sdi12SnoopingRecord']={'':{syn:'Intercepted SDI12 message description, returned by <tt>sdi12Port.snoopMessages</tt> method',inc:'from yocto_sdi12port import *'}
,'get_direction':{syn:'Returns the message direction (RX=0, TX=1).',lib:'%.get_direction()',pro:'get_direction()',cmt:'<p>Returns the message direction (RX=0, TX=1).</p>',ret:'the message direction (RX=0, TX=1).'}
,'get_message':{syn:'Returns the message content.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the message content.</p>',ret:'the message content.'}
,'get_pos':{syn:'Returns the absolute position of the message end.',lib:'%.get_pos()',pro:'get_pos()',cmt:'<p>Returns the absolute position of the message end.</p>',ret:'the absolute position of the message end.'}
,'get_time':{syn:'Returns the elapsed time, in ms, since the beginning of the preceding message.',lib:'%.get_time()',pro:'get_time()',cmt:'<p>Returns the elapsed time, in ms, since the beginning of the preceding message.</p>',ret:'the elapsed time, in ms, since the beginning of the preceding message.'}
};
//--- (end of generated code: Sdi12SnoopingRecord)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'Segmented display control interface',inc:'from yocto_segmenteddisplay import *',cmt:'<p>The <tt>SegmentedDisplay</tt> class allows you to drive segmented displays.</p>'}
,'FindSegmentedDisplay':{syn:'Retrieves a segmented display for a given identifier.',lib:'YSegmentedDisplay.FindSegmentedDisplay()',pro:'FindSegmentedDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a segmented display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the segmented display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSegmentedDisplay.isOnline()</tt> to test if the segmented display is indeed online at a given time. In case of ambiguity when looking for a segmented display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the segmented display, for instance <tt>MyDevice.segmentedDisplay</tt>.'},ret:'a <tt>YSegmentedDisplay</tt> object allowing you to drive the segmented display.'}
,'FirstSegmentedDisplay':{syn:'Starts the enumeration of segmented displays currently accessible.',lib:'YSegmentedDisplay.FirstSegmentedDisplay()',pro:'FirstSegmentedDisplay()',cmt:'<p>Starts the enumeration of segmented displays currently accessible. Use the method <tt>YSegmentedDisplay.nextSegmentedDisplay()</tt> to iterate on next segmented displays.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to the first segmented display currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the segmented display attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the segmented display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the segmented display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the segmented display (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the segmented display (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the segmented display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented display (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_displayedText':{syn:'Returns the text currently displayed on the screen.',lib:'%.get_displayedText()',pro:'get_displayedText()',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.DISPLAYEDTEXT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the segmented display.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the segmented display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the segmented display object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the segmented display.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the segmented display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the segmented display object'}
,'get_friendlyName':{syn:'Returns a global identifier of the segmented display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the segmented display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the segmented display if they are defined, otherwise the serial number of the module and the hardware identifier of the segmented display (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the segmented display using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the segmented display, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the segmented display, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the segmented display (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the segmented display in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the segmented display in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the segmented display (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the segmented display (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the segmented display.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the segmented display.</p>',ret:'a string corresponding to the logical name of the segmented display.',ext:'On failure, throws an exception or returns <tt>YSegmentedDisplay.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the segmented display is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the segmented display is currently reachable, without raising any error. If there is a cached value for the segmented display in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the segmented display.</p>',ret:'<tt>true</tt> if the segmented display can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the segmented display cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the segmented display cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextSegmentedDisplay':{syn:'Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.',lib:'%.nextSegmentedDisplay()',pro:'nextSegmentedDisplay()',cmt:'<p>Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>. Caution: You can\x27t make any assumption about the returned segmented displays order. If you want to find a specific a segmented display, use <tt>SegmentedDisplay.findSegmentedDisplay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to a segmented display currently online, or a <tt>null</tt> pointer if there are no more segmented displays to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_displayedText':{syn:'Changes the text currently displayed on the screen.',lib:'%.set_displayedText()',pro:'set_displayedText(<span id=pn>newval</span>)',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the segmented display.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the segmented display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the segmented display.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'Serial port control interface, available for instance in the Yocto-RS232, the Yocto-RS485-V2 or the Yocto-Serial',inc:'from yocto_serialport import *',cmt:'<p>The <tt>YSerialPort</tt> class allows you to fully drive a Yoctopuce serial port. It can be used to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}
,'FindSerialPort':{syn:'Retrieves a serial port for a given identifier.',lib:'YSerialPort.FindSerialPort()',pro:'FindSerialPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a serial port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the serial port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSerialPort.isOnline()</tt> to test if the serial port is indeed online at a given time. In case of ambiguity when looking for a serial port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the serial port, for instance <tt>RS232MK1.serialPort</tt>.'},ret:'a <tt>YSerialPort</tt> object allowing you to drive the serial port.'}
,'FirstSerialPort':{syn:'Starts the enumeration of serial ports currently accessible.',lib:'YSerialPort.FirstSerialPort()',pro:'FirstSerialPort()',cmt:'<p>Starts the enumeration of serial ports currently accessible. Use the method <tt>YSerialPort.nextSerialPort()</tt> to iterate on next serial ports.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to the first serial port currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the serial port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the serial port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_CTS':{syn:'Reads the level of the CTS line.',lib:'%.get_CTS()',pro:'get_CTS()',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:'On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSerialPort.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentJob':{syn:'Returns the name of the job file currently in use.',lib:'%.get_currentJob()',pro:'get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>YSerialPort.CURRENTJOB_INVALID</tt>.'}
,'get_errCount':{syn:'Returns the total number of communication errors detected since last reset.',lib:'%.get_errCount()',pro:'get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>YSerialPort.ERRCOUNT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the serial port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the serial port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the serial port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the serial port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the serial port if they are defined, otherwise the serial number of the module and the hardware identifier of the serial port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the serial port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSerialPort.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the serial port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the serial port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the serial port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSerialPort.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the serial port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the serial port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSerialPort.HARDWAREID_INVALID</tt>.'}
,'get_jobMaxSize':{syn:'Returns maximum size allowed for job files.',lib:'%.get_jobMaxSize()',pro:'get_jobMaxSize()',cmt:'<p>Returns maximum size allowed for job files.</p>',ret:'an integer corresponding to maximum size allowed for job files',ext:'On failure, throws an exception or returns <tt>YSerialPort.JOBMAXSIZE_INVALID</tt>.'}
,'get_jobMaxTask':{syn:'Returns the maximum number of tasks in a job that the device can handle.',lib:'%.get_jobMaxTask()',pro:'get_jobMaxTask()',cmt:'<p>Returns the maximum number of tasks in a job that the device can handle.</p>',ret:'an integer corresponding to the maximum number of tasks in a job that the device can handle',ext:'On failure, throws an exception or returns <tt>YSerialPort.JOBMAXTASK_INVALID</tt>.'}
,'get_lastMsg':{syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'%.get_lastMsg()',pro:'get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:'On failure, throws an exception or returns <tt>YSerialPort.LASTMSG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the serial port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:'On failure, throws an exception or returns <tt>YSerialPort.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_protocol':{syn:'Returns the type of protocol used over the serial line, as a string.',lib:'%.get_protocol()',pro:'get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22StxEtx\x22 for ASCII messages delimited by STX/ETX codes, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>YSerialPort.PROTOCOL_INVALID</tt>.'}
,'get_rxCount':{syn:'Returns the total number of bytes received since last reset.',lib:'%.get_rxCount()',pro:'get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>YSerialPort.RXCOUNT_INVALID</tt>.'}
,'get_rxMsgCount':{syn:'Returns the total number of messages received since last reset.',lib:'%.get_rxMsgCount()',pro:'get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>YSerialPort.RXMSGCOUNT_INVALID</tt>.'}
,'get_serialMode':{syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'%.get_serialMode()',pro:'get_serialMode()',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:'On failure, throws an exception or returns <tt>YSerialPort.SERIALMODE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_startupJob':{syn:'Returns the job file to use when the device is powered on.',lib:'%.get_startupJob()',pro:'get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>YSerialPort.STARTUPJOB_INVALID</tt>.'}
,'get_txCount':{syn:'Returns the total number of bytes transmitted since last reset.',lib:'%.get_txCount()',pro:'get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>YSerialPort.TXCOUNT_INVALID</tt>.'}
,'get_txMsgCount':{syn:'Returns the total number of messages send since last reset.',lib:'%.get_txMsgCount()',pro:'get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>YSerialPort.TXMSGCOUNT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_voltageLevel':{syn:'Returns the voltage level used on the serial line.',lib:'%.get_voltageLevel()',pro:'get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>YSerialPort.VOLTAGELEVEL_OFF</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL3V</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL5V</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSerialPort.VOLTAGELEVEL_RS232</tt>, <tt>YSerialPort.VOLTAGELEVEL_RS485</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSerialPort.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>YSerialPort.VOLTAGELEVEL_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the serial port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the serial port is currently reachable, without raising any error. If there is a cached value for the serial port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the serial port.</p>',ret:'<tt>true</tt> if the serial port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the serial port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the serial port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'modbusReadBits':{syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'%.modbusReadBits()',pro:'modbusReadBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'}
,'modbusReadInputBits':{syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'%.modbusReadInputBits()',pro:'modbusReadInputBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'}
,'modbusReadInputRegisters':{syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'%.modbusReadInputRegisters()',pro:'modbusReadInputRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:'On failure, throws an exception or returns an empty array.'}
,'modbusReadRegisters':{syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'%.modbusReadRegisters()',pro:'modbusReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:'On failure, throws an exception or returns an empty array.'}
,'modbusWriteAndReadRegisters':{syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'%.modbusWriteAndReadRegisters()',pro:'modbusWriteAndReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduWriteAddr</span>, <span id=pn>values</span>, <span id=pn>pduReadAddr</span>, <span id=pn>nReadWords</span>)',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:'On failure, throws an exception or returns an empty array.'}
,'modbusWriteBit':{syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'%.modbusWriteBit()',pro:'modbusWriteBit(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:'On failure, throws an exception or returns zero.'}
,'modbusWriteBits':{syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'%.modbusWriteBits()',pro:'modbusWriteBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>bits</span>)',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:'On failure, throws an exception or returns zero.'}
,'modbusWriteRegister':{syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'%.modbusWriteRegister()',pro:'modbusWriteRegister(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:'On failure, throws an exception or returns zero.'}
,'modbusWriteRegisters':{syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'%.modbusWriteRegisters()',pro:'modbusWriteRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>values</span>)',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:'On failure, throws an exception or returns zero.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextSerialPort':{syn:'Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.',lib:'%.nextSerialPort()',pro:'nextSerialPort()',cmt:'<p>Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>. Caution: You can\x27t make any assumption about the returned serial ports order. If you want to find a specific a serial port, use <tt>SerialPort.findSerialPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to a serial port currently online, or a <tt>null</tt> pointer if there are no more serial ports to enumerate.'}
,'queryHex':{syn:'Sends a binary message to the serial port, and reads the reply, if any.',lib:'%.queryHex()',pro:'queryHex(<span id=pn>hexString</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a binary message to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for Frame-based protocol.</p>',par:{hexString:'the message to send, coded in hexadecimal',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next frame received after sending the message, as a hex string. Additional frames can be obtained by calling readHex or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'queryLine':{syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'%.queryLine()',pro:'queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'queryMODBUS':{syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'%.queryMODBUS()',pro:'queryMODBUS(<span id=pn>slaveNo</span>, <span id=pn>pduBytes</span>)',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:'On failure, throws an exception or returns an empty array (or a MODBUS error reply).'}
,'readArray':{syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'%.readArray()',pro:'readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns an empty array.'}
,'readBin':{syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'%.readBin()',pro:'readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'readByte':{syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'%.readByte()',pro:'readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'}
,'readHex':{syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'%.readHex()',pro:'readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'}
,'readLine':{syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'%.readLine()',pro:'readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'}
,'readMessages':{syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'%.readMessages()',pro:'readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'readStr':{syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'%.readStr()',pro:'readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'read_avail':{syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'%.read_avail()',pro:'read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'}
,'read_seek':{syn:'Changes the current internal stream position to the specified value.',lib:'%.read_seek()',pro:'read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'}
,'read_tell':{syn:'Returns the current absolute stream position pointer of the API object.',lib:'%.read_tell()',pro:'read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'}
,'registerSnoopingCallback':{syn:'Registers a callback function to be called each time that a message is sent or received by the serial port.',lib:'%.registerSnoopingCallback()',pro:'registerSnoopingCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function to be called each time that a message is sent or received by the serial port. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take four arguments: the <tt>YSerialPort</tt> object that emitted the event, and the <tt>YSnoopingRecord</tt> object that describes the message sent or received. On failure, throws an exception or returns a negative error code.'}}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Clears the serial port buffer and resets counters to zero.',lib:'%.reset()',pro:'reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectJob':{syn:'Load and start processing the specified job file.',lib:'%.selectJob()',pro:'selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'sendBreak':{syn:'Emits a BREAK condition on the serial interface.',lib:'%.sendBreak()',pro:'sendBreak(<span id=pn>duration</span>)',cmt:'<p>Emits a BREAK condition on the serial interface. When the specified duration is 0, the BREAK signal will be exactly one character wide. When the duration is between 1 and 100, the BREAK condition will be hold for the specified number of milliseconds.</p>',par:{duration:'0 for a standard BREAK, or duration between 1 and 100 ms'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_RTS':{syn:'Manually sets the state of the RTS line.',lib:'%.set_RTS()',pro:'set_RTS(<span id=pn>val</span>)',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentJob':{syn:'Selects a job file to run immediately.',lib:'%.set_currentJob()',pro:'set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Selects a job file to run immediately. If an empty string is given as argument, stops running current job file.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the serial port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the serial port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_protocol':{syn:'Changes the type of protocol used over the serial line.',lib:'%.set_protocol()',pro:'set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22StxEtx\x22 for ASCII messages delimited by STX/ETX codes, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_serialMode':{syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'%.set_serialMode()',pro:'set_serialMode(<span id=pn>newval</span>)',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupJob':{syn:'Changes the job to use when the device is powered on.',lib:'%.set_startupJob()',pro:'set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltageLevel':{syn:'Changes the voltage type used on the serial line.',lib:'%.set_voltageLevel()',pro:'set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. Trying to set an invalid value will have no effect. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YSerialPort.VOLTAGELEVEL_OFF</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL3V</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL5V</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSerialPort.VOLTAGELEVEL_RS232</tt>, <tt>YSerialPort.VOLTAGELEVEL_RS485</tt>, <tt>YSerialPort.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSerialPort.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'snoopMessages':{syn:'Retrieves messages (both direction) in the serial port buffer, starting at current position.',lib:'%.snoopMessages()',pro:'snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the serial port buffer, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of <tt>YSnoopingRecord</tt> objects containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'snoopMessagesEx':{syn:'Retrieves messages (both direction) in the serial port buffer, starting at current position.',lib:'%.snoopMessagesEx()',pro:'snoopMessagesEx(<span id=pn>maxWait</span>, <span id=pn>maxMsg</span>)',cmt:'<p>Retrieves messages (both direction) in the serial port buffer, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.',maxMsg:'the maximum number of messages to be returned by the function; up to 254.'},ret:'an array of <tt>YSnoopingRecord</tt> objects containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'uploadJob':{syn:'Saves the job definition string (JSON data) into a job file.',lib:'%.uploadJob()',pro:'uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeArray':{syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'%.writeArray()',pro:'writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeBin':{syn:'Sends a binary buffer to the serial port, as is.',lib:'%.writeBin()',pro:'writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeByte':{syn:'Sends a single byte to the serial port.',lib:'%.writeByte()',pro:'writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeHex':{syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'%.writeHex()',pro:'writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeLine':{syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'%.writeLine()',pro:'writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeMODBUS':{syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'%.writeMODBUS()',pro:'writeMODBUS(<span id=pn>hexString</span>)',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeStr':{syn:'Sends an ASCII string to the serial port, as is.',lib:'%.writeStr()',pro:'writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeStxEtx':{syn:'Sends an ASCII string to the serial port, preceeded with an STX code and followed by an ETX code.',lib:'%.writeStxEtx()',pro:'writeStxEtx(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, preceeded with an STX code and followed by an ETX code.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: SerialPort)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'RC servo motor control interface, available for instance in the Yocto-Servo',inc:'from yocto_servo import *',cmt:'<p>The <tt>YServo</tt> class is designed to drive remote-control servo motors outputs. This class allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}
,'FindServo':{syn:'Retrieves a RC servo motor for a given identifier.',lib:'YServo.FindServo()',pro:'FindServo(<span id=pn>func</span>)',cmt:'<p>Retrieves a RC servo motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RC servo motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the RC servo motor is indeed online at a given time. In case of ambiguity when looking for a RC servo motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RC servo motor, for instance <tt>SERVORC1.servo1</tt>.'},ret:'a <tt>YServo</tt> object allowing you to drive the RC servo motor.'}
,'FirstServo':{syn:'Starts the enumeration of RC servo motors currently accessible.',lib:'YServo.FirstServo()',pro:'FirstServo()',cmt:'<p>Starts the enumeration of RC servo motors currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next RC servo motors.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first RC servo motor currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RC servo motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the RC servo motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RC servo motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RC servo motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the RC servo motor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the RC servo motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RC servo motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YServo.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_enabled':{syn:'Returns the state of the RC servo motors.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns the state of the RC servo motors.</p>',ret:'either <tt>YServo.ENABLED_FALSE</tt> or <tt>YServo.ENABLED_TRUE</tt>, according to the state of the RC servo motors',ext:'On failure, throws an exception or returns <tt>YServo.ENABLED_INVALID</tt>.'}
,'get_enabledAtPowerOn':{syn:'Returns the servo signal generator state at power up.',lib:'%.get_enabledAtPowerOn()',pro:'get_enabledAtPowerOn()',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>YServo.ENABLEDATPOWERON_FALSE</tt> or <tt>YServo.ENABLEDATPOWERON_TRUE</tt>, according to the servo signal generator state at power up',ext:'On failure, throws an exception or returns <tt>YServo.ENABLEDATPOWERON_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the RC servo motor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RC servo motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RC servo motor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the RC servo motor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RC servo motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RC servo motor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the RC servo motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the RC servo motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RC servo motor if they are defined, otherwise the serial number of the module and the hardware identifier of the RC servo motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RC servo motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YServo.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the RC servo motor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the RC servo motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RC servo motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YServo.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the RC servo motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RC servo motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RC servo motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RC servo motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YServo.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the RC servo motor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the RC servo motor.</p>',ret:'a string corresponding to the logical name of the RC servo motor.',ext:'On failure, throws an exception or returns <tt>YServo.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_neutral':{syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'%.get_neutral()',pro:'get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>YServo.NEUTRAL_INVALID</tt>.'}
,'get_position':{syn:'Returns the current servo position.',lib:'%.get_position()',pro:'get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>YServo.POSITION_INVALID</tt>.'}
,'get_positionAtPowerOn':{syn:'Returns the servo position at device power up.',lib:'%.get_positionAtPowerOn()',pro:'get_positionAtPowerOn()',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:'On failure, throws an exception or returns <tt>YServo.POSITIONATPOWERON_INVALID</tt>.'}
,'get_range':{syn:'Returns the current range of use of the servo.',lib:'%.get_range()',pro:'get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>YServo.RANGE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the RC servo motor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the RC servo motor is currently reachable, without raising any error. If there is a cached value for the RC servo motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RC servo motor.</p>',ret:'<tt>true</tt> if the RC servo motor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the RC servo motor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RC servo motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'move':{syn:'Performs a smooth move at constant speed toward a given position.',lib:'%.move()',pro:'move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextServo':{syn:'Continues the enumeration of RC servo motors started using <tt>yFirstServo()</tt>.',lib:'%.nextServo()',pro:'nextServo()',cmt:'<p>Continues the enumeration of RC servo motors started using <tt>yFirstServo()</tt>. Caution: You can\x27t make any assumption about the returned RC servo motors order. If you want to find a specific a RC servo motor, use <tt>Servo.findServo()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a RC servo motor currently online, or a <tt>null</tt> pointer if there are no more RC servo motors to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_enabled':{syn:'Stops or starts the RC servo motor.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the RC servo motor.</p>',par:{newval:'either <tt>YServo.ENABLED_FALSE</tt> or <tt>YServo.ENABLED_TRUE</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabledAtPowerOn':{syn:'Configure the servo signal generator state at power up.',lib:'%.set_enabledAtPowerOn()',pro:'set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo signal generator state at power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>YServo.ENABLEDATPOWERON_FALSE</tt> or <tt>YServo.ENABLEDATPOWERON_TRUE</tt>'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the RC servo motor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RC servo motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RC servo motor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_neutral':{syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'%.set_neutral()',pro:'set_neutral(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_position':{syn:'Changes immediately the servo driving position.',lib:'%.set_position()',pro:'set_position(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_positionAtPowerOn':{syn:'Configure the servo position at device power up.',lib:'%.set_positionAtPowerOn()',pro:'set_positionAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo position at device power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_range':{syn:'Changes the range of use of the servo, specified in per cents.',lib:'%.set_range()',pro:'set_range(<span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Servo)
//--- (generated code: Sms)
doc['Sms']={'':{syn:'SMS message sent or received, returned by <tt>messageBox.get_messages</tt> or <tt>messageBox.newMessage</tt>',inc:'from yocto_messagebox import *',cmt:'<p><tt>YSms</tt> objects are used to describe an SMS message, received or to be sent. These objects are used in particular in conjunction with the <tt>YMessageBox</tt> class.</p>'}
,'addText':{syn:'Add a regular text to the SMS.',lib:'%.addText()',pro:'addText(<span id=pn>val</span>)',cmt:'<p>Add a regular text to the SMS. This function support messages of more than 160 characters. ISO-latin accented characters are supported. For messages with special unicode characters such as asian characters and emoticons, use the <tt>addUnicodeData</tt> method.</p>',par:{val:'the text to be sent in the message'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.'}
,'addUnicodeData':{syn:'Add a unicode text to the SMS.',lib:'%.addUnicodeData()',pro:'addUnicodeData(<span id=pn>val</span>)',cmt:'<p>Add a unicode text to the SMS. This function support messages of more than 160 characters, using SMS concatenation.</p>',par:{val:'an array of special unicode characters'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.'}
,'get_textData':{syn:'Returns the content of the message.',lib:'%.get_textData()',pro:'get_textData()',cmt:'<p>Returns the content of the message.</p>',ret:'a string with the content of the message.'}
,'send':{syn:'Sends the SMS to the recipient.',lib:'%.send()',pro:'send()',cmt:'<p>Sends the SMS to the recipient. Messages of more than 160 characters are supported using SMS concatenation.</p>',ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Sms)
//--- (generated code: SnoopingRecord)
doc['SnoopingRecord']={'':{syn:'Intercepted serial message description, returned by <tt>serialPort.snoopMessages</tt> method',inc:'from yocto_serialport import *'}
,'get_direction':{syn:'Returns the message direction (RX=0, TX=1).',lib:'%.get_direction()',pro:'get_direction()',cmt:'<p>Returns the message direction (RX=0, TX=1).</p>',ret:'the message direction (RX=0, TX=1).'}
,'get_message':{syn:'Returns the message content.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the message content.</p>',ret:'the message content.'}
,'get_pos':{syn:'Returns the absolute position of the message end.',lib:'%.get_pos()',pro:'get_pos()',cmt:'<p>Returns the absolute position of the message end.</p>',ret:'the absolute position of the message end.'}
,'get_time':{syn:'Returns the elapsed time, in ms, since the beginning of the preceding message.',lib:'%.get_time()',pro:'get_time()',cmt:'<p>Returns the elapsed time, in ms, since the beginning of the preceding message.</p>',ret:'the elapsed time, in ms, since the beginning of the preceding message.'}
};
//--- (end of generated code: SnoopingRecord)
//--- (generated code: SpectralChannel)
doc['SpectralChannel']={'':{syn:'Spectral analysis channel control interface',inc:'from yocto_spectralchannel import *',cmt:'<p>The <tt>YSpectralChannel</tt> class allows you to read and configure Yoctopuce spectral analysis channels. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindSpectralChannel':{syn:'Retrieves a spectral analysis channel for a given identifier.',lib:'YSpectralChannel.FindSpectralChannel()',pro:'FindSpectralChannel(<span id=pn>func</span>)',cmt:'<p>Retrieves a spectral analysis channel for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the spectral analysis channel is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSpectralChannel.isOnline()</tt> to test if the spectral analysis channel is indeed online at a given time. In case of ambiguity when looking for a spectral analysis channel by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the spectral analysis channel, for instance <tt>MyDevice.spectralChannel1</tt>.'},ret:'a <tt>YSpectralChannel</tt> object allowing you to drive the spectral analysis channel.'}
,'FirstSpectralChannel':{syn:'Starts the enumeration of spectral analysis channels currently accessible.',lib:'YSpectralChannel.FirstSpectralChannel()',pro:'FirstSpectralChannel()',cmt:'<p>Starts the enumeration of spectral analysis channels currently accessible. Use the method <tt>YSpectralChannel.nextSpectralChannel()</tt> to iterate on next spectral analysis channels.</p>',ret:'a pointer to a <tt>YSpectralChannel</tt> object, corresponding to the first spectral analysis channel currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the spectral analysis channel attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the spectral analysis channel in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the spectral analysis channel in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the spectral analysis channel (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YSpectralChannel.ADVMODE_IMMEDIATE</tt>, <tt>YSpectralChannel.ADVMODE_PERIOD_AVG</tt>, <tt>YSpectralChannel.ADVMODE_PERIOD_MIN</tt> and <tt>YSpectralChannel.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the spectral analysis channel (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the spectral analysis channel (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the spectral analysis channel (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_channelName':{syn:'Returns the target spectral band name.',lib:'%.get_channelName()',pro:'get_channelName()',cmt:'<p>Returns the target spectral band name.</p>',ret:'a string corresponding to the target spectral band name',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.CHANNELNAME_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in count, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in count, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in count, as a floating point number',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the spectral intensity, in count, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the spectral intensity, in count, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the spectral intensity, in count, as a floating point number',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the spectral analysis channel.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the spectral analysis channel. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the spectral analysis channel object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the spectral analysis channel.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the spectral analysis channel. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the spectral analysis channel object'}
,'get_friendlyName':{syn:'Returns a global identifier of the spectral analysis channel in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the spectral analysis channel in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the spectral analysis channel if they are defined, otherwise the serial number of the module and the hardware identifier of the spectral analysis channel (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the spectral analysis channel using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the spectral analysis channel, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the spectral analysis channel, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the spectral analysis channel (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the spectral analysis channel in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the spectral analysis channel in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the spectral analysis channel (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the spectral analysis channel (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the spectral intensity since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the spectral intensity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the spectral intensity since the device was started',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the spectral analysis channel.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the spectral analysis channel.</p>',ret:'a string corresponding to the logical name of the spectral analysis channel.',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the spectral intensity since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the spectral intensity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the spectral intensity since the device was started',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_peakWavelength':{syn:'Returns the target spectral band peak wavelength, in nm.',lib:'%.get_peakWavelength()',pro:'get_peakWavelength()',cmt:'<p>Returns the target spectral band peak wavelength, in nm.</p>',ret:'an integer corresponding to the target spectral band peak wavelength, in nm',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.PEAKWAVELENGTH_INVALID</tt>.'}
,'get_rawCount':{syn:'Retrieves the raw spectral intensity value as measured by the sensor, without any scaling or calibration.',lib:'%.get_rawCount()',pro:'get_rawCount()',cmt:'<p>Retrieves the raw spectral intensity value as measured by the sensor, without any scaling or calibration.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.RAWCOUNT_INVALID</tt>.'}
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the spectral intensity.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the spectral intensity.</p>',ret:'a string corresponding to the measuring unit for the spectral intensity',ext:'On failure, throws an exception or returns <tt>YSpectralChannel.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the spectral analysis channel is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the spectral analysis channel is currently reachable, without raising any error. If there is a cached value for the spectral analysis channel in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the spectral analysis channel.</p>',ret:'<tt>true</tt> if the spectral analysis channel can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the spectral analysis channel cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the spectral analysis channel cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextSpectralChannel':{syn:'Continues the enumeration of spectral analysis channels started using <tt>yFirstSpectralChannel()</tt>.',lib:'%.nextSpectralChannel()',pro:'nextSpectralChannel()',cmt:'<p>Continues the enumeration of spectral analysis channels started using <tt>yFirstSpectralChannel()</tt>. Caution: You can\x27t make any assumption about the returned spectral analysis channels order. If you want to find a specific a spectral analysis channel, use <tt>SpectralChannel.findSpectralChannel()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSpectralChannel</tt> object, corresponding to a spectral analysis channel currently online, or a <tt>null</tt> pointer if there are no more spectral analysis channels to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YSpectralChannel.ADVMODE_IMMEDIATE</tt>, <tt>YSpectralChannel.ADVMODE_PERIOD_AVG</tt>, <tt>YSpectralChannel.ADVMODE_PERIOD_MIN</tt> and <tt>YSpectralChannel.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the spectral analysis channel.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the spectral analysis channel. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the spectral analysis channel.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: SpectralChannel)
//--- (generated code: SpiPort)
doc['SpiPort']={'':{syn:'SPI port control interface, available for instance in the Yocto-SPI',inc:'from yocto_spiport import *',cmt:'<p>The <tt>YSpiPort</tt> class allows you to fully drive a Yoctopuce SPI port. It can be used to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce SPI ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}
,'FindSpiPort':{syn:'Retrieves an SPI port for a given identifier.',lib:'YSpiPort.FindSpiPort()',pro:'FindSpiPort(<span id=pn>func</span>)',cmt:'<p>Retrieves an SPI port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the SPI port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSpiPort.isOnline()</tt> to test if the SPI port is indeed online at a given time. In case of ambiguity when looking for an SPI port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the SPI port, for instance <tt>YSPIMK01.spiPort</tt>.'},ret:'a <tt>YSpiPort</tt> object allowing you to drive the SPI port.'}
,'FirstSpiPort':{syn:'Starts the enumeration of SPI ports currently accessible.',lib:'YSpiPort.FirstSpiPort()',pro:'FirstSpiPort()',cmt:'<p>Starts the enumeration of SPI ports currently accessible. Use the method <tt>YSpiPort.nextSpiPort()</tt> to iterate on next SPI ports.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to the first SPI port currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the SPI port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the SPI port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the SPI port (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the SPI port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SPI port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YSpiPort.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentJob':{syn:'Returns the name of the job file currently in use.',lib:'%.get_currentJob()',pro:'get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>YSpiPort.CURRENTJOB_INVALID</tt>.'}
,'get_errCount':{syn:'Returns the total number of communication errors detected since last reset.',lib:'%.get_errCount()',pro:'get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>YSpiPort.ERRCOUNT_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the SPI port.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the SPI port object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the SPI port.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the SPI port object'}
,'get_friendlyName':{syn:'Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the SPI port if they are defined, otherwise the serial number of the module and the hardware identifier of the SPI port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the SPI port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpiPort.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the SPI port, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the SPI port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the SPI port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpiPort.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the SPI port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the SPI port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YSpiPort.HARDWAREID_INVALID</tt>.'}
,'get_jobMaxSize':{syn:'Returns maximum size allowed for job files.',lib:'%.get_jobMaxSize()',pro:'get_jobMaxSize()',cmt:'<p>Returns maximum size allowed for job files.</p>',ret:'an integer corresponding to maximum size allowed for job files',ext:'On failure, throws an exception or returns <tt>YSpiPort.JOBMAXSIZE_INVALID</tt>.'}
,'get_jobMaxTask':{syn:'Returns the maximum number of tasks in a job that the device can handle.',lib:'%.get_jobMaxTask()',pro:'get_jobMaxTask()',cmt:'<p>Returns the maximum number of tasks in a job that the device can handle.</p>',ret:'an integer corresponding to the maximum number of tasks in a job that the device can handle',ext:'On failure, throws an exception or returns <tt>YSpiPort.JOBMAXTASK_INVALID</tt>.'}
,'get_lastMsg':{syn:'Returns the latest message fully received (for Line and Frame protocols).',lib:'%.get_lastMsg()',pro:'get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line and Frame protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line and Frame protocols)',ext:'On failure, throws an exception or returns <tt>YSpiPort.LASTMSG_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the SPI port.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the SPI port.</p>',ret:'a string corresponding to the logical name of the SPI port.',ext:'On failure, throws an exception or returns <tt>YSpiPort.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_protocol':{syn:'Returns the type of protocol used over the serial line, as a string.',lib:'%.get_protocol()',pro:'get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>YSpiPort.PROTOCOL_INVALID</tt>.'}
,'get_rxCount':{syn:'Returns the total number of bytes received since last reset.',lib:'%.get_rxCount()',pro:'get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>YSpiPort.RXCOUNT_INVALID</tt>.'}
,'get_rxMsgCount':{syn:'Returns the total number of messages received since last reset.',lib:'%.get_rxMsgCount()',pro:'get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>YSpiPort.RXMSGCOUNT_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_shiftSampling':{syn:'Returns true when the SDI line phase is shifted with regards to the SDO line.',lib:'%.get_shiftSampling()',pro:'get_shiftSampling()',cmt:'<p>Returns true when the SDI line phase is shifted with regards to the SDO line.</p>',ret:'either <tt>YSpiPort.SHIFTSAMPLING_OFF</tt> or <tt>YSpiPort.SHIFTSAMPLING_ON</tt>, according to true when the SDI line phase is shifted with regards to the SDO line',ext:'On failure, throws an exception or returns <tt>YSpiPort.SHIFTSAMPLING_INVALID</tt>.'}
,'get_spiMode':{syn:'Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22.',lib:'%.get_spiMode()',pro:'get_spiMode()',cmt:'<p>Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',ret:'a string corresponding to the SPI port communication parameters, as a string such as \x22125000,0,msb\x22',ext:'On failure, throws an exception or returns <tt>YSpiPort.SPIMODE_INVALID</tt>.'}
,'get_ssPolarity':{syn:'Returns the SS line polarity.',lib:'%.get_ssPolarity()',pro:'get_ssPolarity()',cmt:'<p>Returns the SS line polarity.</p>',ret:'either <tt>YSpiPort.SSPOLARITY_ACTIVE_LOW</tt> or <tt>YSpiPort.SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity',ext:'On failure, throws an exception or returns <tt>YSpiPort.SSPOLARITY_INVALID</tt>.'}
,'get_startupJob':{syn:'Returns the job file to use when the device is powered on.',lib:'%.get_startupJob()',pro:'get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>YSpiPort.STARTUPJOB_INVALID</tt>.'}
,'get_txCount':{syn:'Returns the total number of bytes transmitted since last reset.',lib:'%.get_txCount()',pro:'get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>YSpiPort.TXCOUNT_INVALID</tt>.'}
,'get_txMsgCount':{syn:'Returns the total number of messages send since last reset.',lib:'%.get_txMsgCount()',pro:'get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>YSpiPort.TXMSGCOUNT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_voltageLevel':{syn:'Returns the voltage level used on the serial line.',lib:'%.get_voltageLevel()',pro:'get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>YSpiPort.VOLTAGELEVEL_OFF</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL3V</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL5V</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSpiPort.VOLTAGELEVEL_RS232</tt>, <tt>YSpiPort.VOLTAGELEVEL_RS485</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSpiPort.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>YSpiPort.VOLTAGELEVEL_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the SPI port is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the SPI port is currently reachable, without raising any error. If there is a cached value for the SPI port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the SPI port.</p>',ret:'<tt>true</tt> if the SPI port can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the SPI port cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the SPI port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextSpiPort':{syn:'Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>.',lib:'%.nextSpiPort()',pro:'nextSpiPort()',cmt:'<p>Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>. Caution: You can\x27t make any assumption about the returned SPI ports order. If you want to find a specific an SPI port, use <tt>SpiPort.findSpiPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to an SPI port currently online, or a <tt>null</tt> pointer if there are no more SPI ports to enumerate.'}
,'queryHex':{syn:'Sends a binary message to the serial port, and reads the reply, if any.',lib:'%.queryHex()',pro:'queryHex(<span id=pn>hexString</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a binary message to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for Frame-based protocol.</p>',par:{hexString:'the message to send, coded in hexadecimal',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next frame received after sending the message, as a hex string. Additional frames can be obtained by calling readHex or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'queryLine':{syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'%.queryLine()',pro:'queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty string.'}
,'readArray':{syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'%.readArray()',pro:'readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns an empty array.'}
,'readBin':{syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'%.readBin()',pro:'readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'readByte':{syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'%.readByte()',pro:'readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'}
,'readHex':{syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'%.readHex()',pro:'readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'}
,'readLine':{syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'%.readLine()',pro:'readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'}
,'readMessages':{syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'%.readMessages()',pro:'readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'}
,'readStr':{syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'%.readStr()',pro:'readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'}
,'read_avail':{syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'%.read_avail()',pro:'read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'}
,'read_seek':{syn:'Changes the current internal stream position to the specified value.',lib:'%.read_seek()',pro:'read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'}
,'read_tell':{syn:'Returns the current absolute stream position pointer of the API object.',lib:'%.read_tell()',pro:'read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Clears the serial port buffer and resets counters to zero.',lib:'%.reset()',pro:'reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'selectJob':{syn:'Load and start processing the specified job file.',lib:'%.selectJob()',pro:'selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_SS':{syn:'Manually sets the state of the SS line.',lib:'%.set_SS()',pro:'set_SS(<span id=pn>val</span>)',cmt:'<p>Manually sets the state of the SS line. This function has no effect when the SS line is handled automatically.</p>',par:{val:'1 to turn SS active, 0 to release SS.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentJob':{syn:'Selects a job file to run immediately.',lib:'%.set_currentJob()',pro:'set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Selects a job file to run immediately. If an empty string is given as argument, stops running current job file.</p>',par:{newval:'a string'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the SPI port.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the SPI port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the SPI port.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_protocol':{syn:'Changes the type of protocol used over the serial line.',lib:'%.set_protocol()',pro:'set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_shiftSampling':{syn:'Changes the SDI line sampling shift.',lib:'%.set_shiftSampling()',pro:'set_shiftSampling(<span id=pn>newval</span>)',cmt:'<p>Changes the SDI line sampling shift. When disabled, SDI line is sampled in the middle of data output time. When enabled, SDI line is samples at the end of data output time. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YSpiPort.SHIFTSAMPLING_OFF</tt> or <tt>YSpiPort.SHIFTSAMPLING_ON</tt>, according to the SDI line sampling shift'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_spiMode':{syn:'Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22.',lib:'%.set_spiMode()',pro:'set_spiMode(<span id=pn>newval</span>)',cmt:'<p>Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the SPI port communication parameters, with a string such as \x22125000,0,msb\x22'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_ssPolarity':{syn:'Changes the SS line polarity.',lib:'%.set_ssPolarity()',pro:'set_ssPolarity(<span id=pn>newval</span>)',cmt:'<p>Changes the SS line polarity. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YSpiPort.SSPOLARITY_ACTIVE_LOW</tt> or <tt>YSpiPort.SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_startupJob':{syn:'Changes the job to use when the device is powered on.',lib:'%.set_startupJob()',pro:'set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltageLevel':{syn:'Changes the voltage type used on the serial line.',lib:'%.set_voltageLevel()',pro:'set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. Trying to set an invalid value will have no effect. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YSpiPort.VOLTAGELEVEL_OFF</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL3V</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL3VR</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL5V</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL5VR</tt>, <tt>YSpiPort.VOLTAGELEVEL_RS232</tt>, <tt>YSpiPort.VOLTAGELEVEL_RS485</tt>, <tt>YSpiPort.VOLTAGELEVEL_TTL1V8</tt> and <tt>YSpiPort.VOLTAGELEVEL_SDI12</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'snoopMessages':{syn:'Retrieves messages (both direction) in the SPI port buffer, starting at current position.',lib:'%.snoopMessages()',pro:'snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the SPI port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of <tt>YSpiSnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'snoopMessagesEx':{syn:'Retrieves messages (both direction) in the SPI port buffer, starting at current position.',lib:'%.snoopMessagesEx()',pro:'snoopMessagesEx(<span id=pn>maxWait</span>, <span id=pn>maxMsg</span>)',cmt:'<p>Retrieves messages (both direction) in the SPI port buffer, starting at current position.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.',maxMsg:'the maximum number of messages to be returned by the function; up to 254.'},ret:'an array of <tt>YSpiSnoopingRecord</tt> objects containing the messages found, if any.',ext:'On failure, throws an exception or returns an empty array.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'uploadJob':{syn:'Saves the job definition string (JSON data) into a job file.',lib:'%.uploadJob()',pro:'uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeArray':{syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'%.writeArray()',pro:'writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeBin':{syn:'Sends a binary buffer to the serial port, as is.',lib:'%.writeBin()',pro:'writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeByte':{syn:'Sends a single byte to the serial port.',lib:'%.writeByte()',pro:'writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeHex':{syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'%.writeHex()',pro:'writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeLine':{syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'%.writeLine()',pro:'writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'writeStr':{syn:'Sends an ASCII string to the serial port, as is.',lib:'%.writeStr()',pro:'writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: SpiPort)
//--- (generated code: SpiSnoopingRecord)
doc['SpiSnoopingRecord']={'':{syn:'Intercepted SPI message description, returned by <tt>spiPort.snoopMessages</tt> method',inc:'from yocto_spiport import *'}
,'get_direction':{syn:'Returns the message direction (RX=0, TX=1).',lib:'%.get_direction()',pro:'get_direction()',cmt:'<p>Returns the message direction (RX=0, TX=1).</p>',ret:'the message direction (RX=0, TX=1).'}
,'get_message':{syn:'Returns the message content.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the message content.</p>',ret:'the message content.'}
,'get_pos':{syn:'Returns the absolute position of the message end.',lib:'%.get_pos()',pro:'get_pos()',cmt:'<p>Returns the absolute position of the message end.</p>',ret:'the absolute position of the message end.'}
,'get_time':{syn:'Returns the elapsed time, in ms, since the beginning of the preceding message.',lib:'%.get_time()',pro:'get_time()',cmt:'<p>Returns the elapsed time, in ms, since the beginning of the preceding message.</p>',ret:'the elapsed time, in ms, since the beginning of the preceding message.'}
};
//--- (end of generated code: SpiSnoopingRecord)
//--- (generated code: StepperMotor)
doc['StepperMotor']={'':{syn:'Stepper motor control interface',inc:'from yocto_steppermotor import *',cmt:'<p>The <tt>YStepperMotor</tt> class allows you to drive a stepper motor.</p>'}
,'FindStepperMotor':{syn:'Retrieves a stepper motor for a given identifier.',lib:'YStepperMotor.FindStepperMotor()',pro:'FindStepperMotor(<span id=pn>func</span>)',cmt:'<p>Retrieves a stepper motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the stepper motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YStepperMotor.isOnline()</tt> to test if the stepper motor is indeed online at a given time. In case of ambiguity when looking for a stepper motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the stepper motor, for instance <tt>MyDevice.stepperMotor1</tt>.'},ret:'a <tt>YStepperMotor</tt> object allowing you to drive the stepper motor.'}
,'FirstStepperMotor':{syn:'Starts the enumeration of stepper motors currently accessible.',lib:'YStepperMotor.FirstStepperMotor()',pro:'FirstStepperMotor()',cmt:'<p>Starts the enumeration of stepper motors currently accessible. Use the method <tt>YStepperMotor.nextStepperMotor()</tt> to iterate on next stepper motors.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to the first stepper motor currently online, or a <tt>null</tt> pointer if there are none.'}
,'abortAndBrake':{syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'%.abortAndBrake()',pro:'abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'abortAndHiZ':{syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'%.abortAndHiZ()',pro:'abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'alertStepDir':{syn:'Move one single step in the selected direction without regards to end switches.',lib:'%.alertStepDir()',pro:'alertStepDir(<span id=pn>dir</span>)',cmt:'<p>Move one single step in the selected direction without regards to end switches. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',par:{dir:'Value +1 or -1, according to the desired direction of the move'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'alertStepOut':{syn:'Move one step in the direction opposite the direction set when the most recent alert was raised.',lib:'%.alertStepOut()',pro:'alertStepOut()',cmt:'<p>Move one step in the direction opposite the direction set when the most recent alert was raised. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'changeSpeed':{syn:'Starts the motor at a given speed.',lib:'%.changeSpeed()',pro:'changeSpeed(<span id=pn>speed</span>)',cmt:'<p>Starts the motor at a given speed. The time needed to reach the requested speed will depend on the acceleration parameters configured for the motor.</p>',par:{speed:'desired speed, in steps per second. The minimal non-zero speed is 0.001 pulse per second.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the stepper motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the stepper motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'emergencyStop':{syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'%.emergencyStop()',pro:'emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'findHomePosition':{syn:'Starts the motor backward at the specified speed, to search for the motor home position.',lib:'%.findHomePosition()',pro:'findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Starts the motor backward at the specified speed, to search for the motor home position.</p>',par:{speed:'desired speed, in steps per second.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'get_advertisedValue':{syn:'Returns the current value of the stepper motor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the stepper motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the stepper motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YStepperMotor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_auxSignal':{syn:'Returns the current value of the signal generated on the auxiliary output.',lib:'%.get_auxSignal()',pro:'get_auxSignal()',cmt:'<p>Returns the current value of the signal generated on the auxiliary output.</p>',ret:'an integer corresponding to the current value of the signal generated on the auxiliary output',ext:'On failure, throws an exception or returns <tt>YStepperMotor.AUXSIGNAL_INVALID</tt>.'}
,'get_diags':{syn:'Returns the stepper motor controller diagnostics, as a bitmap.',lib:'%.get_diags()',pro:'get_diags()',cmt:'<p>Returns the stepper motor controller diagnostics, as a bitmap.</p>',ret:'an integer corresponding to the stepper motor controller diagnostics, as a bitmap',ext:'On failure, throws an exception or returns <tt>YStepperMotor.DIAGS_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the stepper motor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the stepper motor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the stepper motor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the stepper motor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the stepper motor if they are defined, otherwise the serial number of the module and the hardware identifier of the stepper motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the stepper motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YStepperMotor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the stepper motor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the stepper motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the stepper motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YStepperMotor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the stepper motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the stepper motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YStepperMotor.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the stepper motor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the stepper motor.</p>',ret:'a string corresponding to the logical name of the stepper motor.',ext:'On failure, throws an exception or returns <tt>YStepperMotor.LOGICALNAME_INVALID</tt>.'}
,'get_maxAccel':{syn:'Returns the maximal motor acceleration, measured in steps per second^2.',lib:'%.get_maxAccel()',pro:'get_maxAccel()',cmt:'<p>Returns the maximal motor acceleration, measured in steps per second^2.</p>',ret:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2',ext:'On failure, throws an exception or returns <tt>YStepperMotor.MAXACCEL_INVALID</tt>.'}
,'get_maxSpeed':{syn:'Returns the maximal motor speed, measured in steps per second.',lib:'%.get_maxSpeed()',pro:'get_maxSpeed()',cmt:'<p>Returns the maximal motor speed, measured in steps per second.</p>',ret:'a floating point number corresponding to the maximal motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>YStepperMotor.MAXSPEED_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_motorState':{syn:'Returns the motor working state.',lib:'%.get_motorState()',pro:'get_motorState()',cmt:'<p>Returns the motor working state.</p>',ret:'a value among <tt>YStepperMotor.MOTORSTATE_ABSENT</tt>, <tt>YStepperMotor.MOTORSTATE_ALERT</tt>, <tt>YStepperMotor.MOTORSTATE_HI_Z</tt>, <tt>YStepperMotor.MOTORSTATE_STOP</tt>, <tt>YStepperMotor.MOTORSTATE_RUN</tt> and <tt>YStepperMotor.MOTORSTATE_BATCH</tt> corresponding to the motor working state',ext:'On failure, throws an exception or returns <tt>YStepperMotor.MOTORSTATE_INVALID</tt>.'}
,'get_overcurrent':{syn:'Returns the overcurrent alert and emergency stop threshold, measured in mA.',lib:'%.get_overcurrent()',pro:'get_overcurrent()',cmt:'<p>Returns the overcurrent alert and emergency stop threshold, measured in mA.</p>',ret:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA',ext:'On failure, throws an exception or returns <tt>YStepperMotor.OVERCURRENT_INVALID</tt>.'}
,'get_pullinSpeed':{syn:'Returns the motor speed immediately reachable from stop state, measured in steps per second.',lib:'%.get_pullinSpeed()',pro:'get_pullinSpeed()',cmt:'<p>Returns the motor speed immediately reachable from stop state, measured in steps per second.</p>',ret:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second',ext:'On failure, throws an exception or returns <tt>YStepperMotor.PULLINSPEED_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_speed':{syn:'Returns current motor speed, measured in steps per second.',lib:'%.get_speed()',pro:'get_speed()',cmt:'<p>Returns current motor speed, measured in steps per second. To change speed, use method <tt>changeSpeed()</tt>.</p>',ret:'a floating point number corresponding to current motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>YStepperMotor.SPEED_INVALID</tt>.'}
,'get_stepPos':{syn:'Returns the current logical motor position, measured in steps.',lib:'%.get_stepPos()',pro:'get_stepPos()',cmt:'<p>Returns the current logical motor position, measured in steps. The value may include a fractional part when micro-stepping is in use.</p>',ret:'a floating point number corresponding to the current logical motor position, measured in steps',ext:'On failure, throws an exception or returns <tt>YStepperMotor.STEPPOS_INVALID</tt>.'}
,'get_stepping':{syn:'Returns the stepping mode used to drive the motor.',lib:'%.get_stepping()',pro:'get_stepping()',cmt:'<p>Returns the stepping mode used to drive the motor.</p>',ret:'a value among <tt>YStepperMotor.STEPPING_MICROSTEP16</tt>, <tt>YStepperMotor.STEPPING_MICROSTEP8</tt>, <tt>YStepperMotor.STEPPING_MICROSTEP4</tt>, <tt>YStepperMotor.STEPPING_HALFSTEP</tt> and <tt>YStepperMotor.STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor',ext:'On failure, throws an exception or returns <tt>YStepperMotor.STEPPING_INVALID</tt>.'}
,'get_tCurrRun':{syn:'Returns the torque regulation current when the motor is running, measured in mA.',lib:'%.get_tCurrRun()',pro:'get_tCurrRun()',cmt:'<p>Returns the torque regulation current when the motor is running, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is running, measured in mA',ext:'On failure, throws an exception or returns <tt>YStepperMotor.TCURRRUN_INVALID</tt>.'}
,'get_tCurrStop':{syn:'Returns the torque regulation current when the motor is stopped, measured in mA.',lib:'%.get_tCurrStop()',pro:'get_tCurrStop()',cmt:'<p>Returns the torque regulation current when the motor is stopped, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA',ext:'On failure, throws an exception or returns <tt>YStepperMotor.TCURRSTOP_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the stepper motor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the stepper motor is currently reachable, without raising any error. If there is a cached value for the stepper motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the stepper motor.</p>',ret:'<tt>true</tt> if the stepper motor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the stepper motor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the stepper motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'moveRel':{syn:'Starts the motor to reach a given relative position.',lib:'%.moveRel()',pro:'moveRel(<span id=pn>relPos</span>)',cmt:'<p>Starts the motor to reach a given relative position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'moveRelSlow':{syn:'Starts the motor to reach a given relative position, keeping the speed under the specified limit.',lib:'%.moveRelSlow()',pro:'moveRelSlow(<span id=pn>relPos</span>, <span id=pn>maxSpeed</span>)',cmt:'<p>Starts the motor to reach a given relative position, keeping the speed under the specified limit. The time needed to reach the requested position will depend on the acceleration parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.',maxSpeed:'limit speed, in steps per second.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'moveTo':{syn:'Starts the motor to reach a given absolute position.',lib:'%.moveTo()',pro:'moveTo(<span id=pn>absPos</span>)',cmt:'<p>Starts the motor to reach a given absolute position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{absPos:'absolute position, measured in steps from the origin.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextStepperMotor':{syn:'Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>.',lib:'%.nextStepperMotor()',pro:'nextStepperMotor()',cmt:'<p>Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>. Caution: You can\x27t make any assumption about the returned stepper motors order. If you want to find a specific a stepper motor, use <tt>StepperMotor.findStepperMotor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to a stepper motor currently online, or a <tt>null</tt> pointer if there are no more stepper motors to enumerate.'}
,'pause':{syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'%.pause()',pro:'pause(<span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'reset':{syn:'Reinitialize the controller and clear all alert flags.',lib:'%.reset()',pro:'reset()',cmt:'<p>Reinitialize the controller and clear all alert flags.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'set_auxSignal':{syn:'Changes the value of the signal generated on the auxiliary output.',lib:'%.set_auxSignal()',pro:'set_auxSignal(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the signal generated on the auxiliary output. Acceptable values depend on the auxiliary output signal type configured.</p>',par:{newval:'an integer corresponding to the value of the signal generated on the auxiliary output'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the stepper motor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the stepper motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the stepper motor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxAccel':{syn:'Changes the maximal motor acceleration, measured in steps per second^2.',lib:'%.set_maxAccel()',pro:'set_maxAccel(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor acceleration, measured in steps per second^2.</p>',par:{newval:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxSpeed':{syn:'Changes the maximal motor speed, measured in steps per second.',lib:'%.set_maxSpeed()',pro:'set_maxSpeed(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor speed, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the maximal motor speed, measured in steps per second'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_overcurrent':{syn:'Changes the overcurrent alert and emergency stop threshold, measured in mA.',lib:'%.set_overcurrent()',pro:'set_overcurrent(<span id=pn>newval</span>)',cmt:'<p>Changes the overcurrent alert and emergency stop threshold, measured in mA.</p>',par:{newval:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_pullinSpeed':{syn:'Changes the motor speed immediately reachable from stop state, measured in steps per second.',lib:'%.set_pullinSpeed()',pro:'set_pullinSpeed(<span id=pn>newval</span>)',cmt:'<p>Changes the motor speed immediately reachable from stop state, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_stepPos':{syn:'Changes the current logical motor position, measured in steps.',lib:'%.set_stepPos()',pro:'set_stepPos(<span id=pn>newval</span>)',cmt:'<p>Changes the current logical motor position, measured in steps. This command does not cause any motor move, as its purpose is only to set up the origin of the position counter. The fractional part of the position, that corresponds to the physical position of the rotor, is not changed. To trigger a motor move, use methods <tt>moveTo()</tt> or <tt>moveRel()</tt> instead.</p>',par:{newval:'a floating point number corresponding to the current logical motor position, measured in steps'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_stepping':{syn:'Changes the stepping mode used to drive the motor.',lib:'%.set_stepping()',pro:'set_stepping(<span id=pn>newval</span>)',cmt:'<p>Changes the stepping mode used to drive the motor.</p>',par:{newval:'a value among <tt>YStepperMotor.STEPPING_MICROSTEP16</tt>, <tt>YStepperMotor.STEPPING_MICROSTEP8</tt>, <tt>YStepperMotor.STEPPING_MICROSTEP4</tt>, <tt>YStepperMotor.STEPPING_HALFSTEP</tt> and <tt>YStepperMotor.STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_tCurrRun':{syn:'Changes the torque regulation current when the motor is running, measured in mA.',lib:'%.set_tCurrRun()',pro:'set_tCurrRun(<span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is running, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is running, measured in mA'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_tCurrStop':{syn:'Changes the torque regulation current when the motor is stopped, measured in mA.',lib:'%.set_tCurrStop()',pro:'set_tCurrStop(<span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is stopped, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: StepperMotor)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature sensor control interface, available for instance in the Yocto-Meteo-V2, the Yocto-PT100, the Yocto-Temperature or the Yocto-Thermocouple',inc:'from yocto_temperature import *',cmt:'<p>The <tt>YTemperature</tt> class allows you to read and configure Yoctopuce temperature sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}
,'FindTemperature':{syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature.FindTemperature()',pro:'FindTemperature(<span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the temperature sensor, for instance <tt>METEOMK2.temperature</tt>.'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'}
,'FirstTemperature':{syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature.FirstTemperature()',pro:'FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the temperature sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the temperature sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YTemperature.ADVMODE_IMMEDIATE</tt>, <tt>YTemperature.ADVMODE_PERIOD_AVG</tt>, <tt>YTemperature.ADVMODE_PERIOD_MIN</tt> and <tt>YTemperature.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YTemperature.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YTemperature.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTemperature.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTemperature.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the temperature sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the temperature sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the temperature sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the temperature sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the temperature sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the temperature sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the temperature sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTemperature.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the temperature sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the temperature sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the temperature sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTemperature.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the temperature sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the temperature sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTemperature.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>YTemperature.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YTemperature.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the temperature sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:'On failure, throws an exception or returns <tt>YTemperature.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>YTemperature.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YTemperature.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YTemperature.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YTemperature.SENSORSTATE_INVALID</tt>.'}
,'get_sensorType':{syn:'Returns the temperature sensor type.',lib:'%.get_sensorType()',pro:'get_sensorType()',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>YTemperature.SENSORTYPE_DIGITAL</tt>, <tt>YTemperature.SENSORTYPE_TYPE_K</tt>, <tt>YTemperature.SENSORTYPE_TYPE_E</tt>, <tt>YTemperature.SENSORTYPE_TYPE_J</tt>, <tt>YTemperature.SENSORTYPE_TYPE_N</tt>, <tt>YTemperature.SENSORTYPE_TYPE_R</tt>, <tt>YTemperature.SENSORTYPE_TYPE_S</tt>, <tt>YTemperature.SENSORTYPE_TYPE_T</tt>, <tt>YTemperature.SENSORTYPE_PT100_4WIRES</tt>, <tt>YTemperature.SENSORTYPE_PT100_3WIRES</tt>, <tt>YTemperature.SENSORTYPE_PT100_2WIRES</tt>, <tt>YTemperature.SENSORTYPE_RES_OHM</tt>, <tt>YTemperature.SENSORTYPE_RES_NTC</tt>, <tt>YTemperature.SENSORTYPE_RES_LINEAR</tt>, <tt>YTemperature.SENSORTYPE_RES_INTERNAL</tt>, <tt>YTemperature.SENSORTYPE_IR</tt>, <tt>YTemperature.SENSORTYPE_RES_PT1000</tt> and <tt>YTemperature.SENSORTYPE_CHANNEL_OFF</tt> corresponding to the temperature sensor type',ext:'On failure, throws an exception or returns <tt>YTemperature.SENSORTYPE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signalUnit':{syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'%.get_signalUnit()',pro:'get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>YTemperature.SIGNALUNIT_INVALID</tt>.'}
,'get_signalValue':{syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'%.get_signalValue()',pro:'get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>YTemperature.SIGNALVALUE_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the temperature.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:'On failure, throws an exception or returns <tt>YTemperature.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the temperature sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the temperature sensor is currently reachable, without raising any error. If there is a cached value for the temperature sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the temperature sensor.</p>',ret:'<tt>true</tt> if the temperature sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the temperature sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the temperature sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'loadThermistorResponseTable':{syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'%.loadThermistorResponseTable()',pro:'loadThermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextTemperature':{syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'%.nextTemperature()',pro:'nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>. Caution: You can\x27t make any assumption about the returned temperature sensors order. If you want to find a specific a temperature sensor, use <tt>Temperature.findTemperature()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YTemperature.ADVMODE_IMMEDIATE</tt>, <tt>YTemperature.ADVMODE_PERIOD_AVG</tt>, <tt>YTemperature.ADVMODE_PERIOD_MIN</tt> and <tt>YTemperature.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the temperature sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_ntcParameters':{syn:'Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance.',lib:'%.set_ntcParameters()',pro:'set_ntcParameters(<span id=pn>res25</span>, <span id=pn>beta</span>)',cmt:'<p>Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance. For increased precision, you can enter a complete mapping table using set_thermistorResponseTable. This function can only be used with a temperature sensor based on thermistors.</p>',par:{res25:'thermistor resistance at 25 degrees Celsius',beta:'Beta value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_sensorType':{syn:'Changes the temperature sensor type.',lib:'%.set_sensorType()',pro:'set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YTemperature.SENSORTYPE_DIGITAL</tt>, <tt>YTemperature.SENSORTYPE_TYPE_K</tt>, <tt>YTemperature.SENSORTYPE_TYPE_E</tt>, <tt>YTemperature.SENSORTYPE_TYPE_J</tt>, <tt>YTemperature.SENSORTYPE_TYPE_N</tt>, <tt>YTemperature.SENSORTYPE_TYPE_R</tt>, <tt>YTemperature.SENSORTYPE_TYPE_S</tt>, <tt>YTemperature.SENSORTYPE_TYPE_T</tt>, <tt>YTemperature.SENSORTYPE_PT100_4WIRES</tt>, <tt>YTemperature.SENSORTYPE_PT100_3WIRES</tt>, <tt>YTemperature.SENSORTYPE_PT100_2WIRES</tt>, <tt>YTemperature.SENSORTYPE_RES_OHM</tt>, <tt>YTemperature.SENSORTYPE_RES_NTC</tt>, <tt>YTemperature.SENSORTYPE_RES_LINEAR</tt>, <tt>YTemperature.SENSORTYPE_RES_INTERNAL</tt>, <tt>YTemperature.SENSORTYPE_IR</tt>, <tt>YTemperature.SENSORTYPE_RES_PT1000</tt> and <tt>YTemperature.SENSORTYPE_CHANNEL_OFF</tt> corresponding to the temperature sensor type'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_thermistorResponseTable':{syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'%.set_thermistorResponseTable()',pro:'set_thermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the measured temperature.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that string ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Temperature)
//--- (generated code: Threshold)
doc['Threshold']={'':{syn:'Control interface to define a threshold',inc:'from yocto_threshold import *',cmt:'<p>The <tt>Threshold</tt> class allows you define a threshold on a Yoctopuce sensor to trigger a predefined action, on specific devices where this is implemented.</p>'}
,'FindThreshold':{syn:'Retrieves a threshold function for a given identifier.',lib:'YThreshold.FindThreshold()',pro:'FindThreshold(<span id=pn>func</span>)',cmt:'<p>Retrieves a threshold function for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the threshold function is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YThreshold.isOnline()</tt> to test if the threshold function is indeed online at a given time. In case of ambiguity when looking for a threshold function by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the threshold function, for instance <tt>MyDevice.threshold1</tt>.'},ret:'a <tt>YThreshold</tt> object allowing you to drive the threshold function.'}
,'FirstThreshold':{syn:'Starts the enumeration of threshold functions currently accessible.',lib:'YThreshold.FirstThreshold()',pro:'FirstThreshold()',cmt:'<p>Starts the enumeration of threshold functions currently accessible. Use the method <tt>YThreshold.nextThreshold()</tt> to iterate on next threshold functions.</p>',ret:'a pointer to a <tt>YThreshold</tt> object, corresponding to the first threshold function currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the threshold function attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the threshold function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the threshold function in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the threshold function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the threshold function (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the threshold function (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the threshold function (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YThreshold.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_alertLevel':{syn:'Returns the sensor alert level, triggering the threshold function.',lib:'%.get_alertLevel()',pro:'get_alertLevel()',cmt:'<p>Returns the sensor alert level, triggering the threshold function.</p>',ret:'a floating point number corresponding to the sensor alert level, triggering the threshold function',ext:'On failure, throws an exception or returns <tt>YThreshold.ALERTLEVEL_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the threshold function.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the threshold function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the threshold function object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the threshold function.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the threshold function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the threshold function object'}
,'get_friendlyName':{syn:'Returns a global identifier of the threshold function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the threshold function in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the threshold function if they are defined, otherwise the serial number of the module and the hardware identifier of the threshold function (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the threshold function using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YThreshold.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the threshold function, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the threshold function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the threshold function (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YThreshold.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the threshold function in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the threshold function in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the threshold function (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the threshold function (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YThreshold.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the threshold function.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the threshold function.</p>',ret:'a string corresponding to the logical name of the threshold function.',ext:'On failure, throws an exception or returns <tt>YThreshold.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_safeLevel':{syn:'Returns the sensor acceptable level for disabling the threshold function.',lib:'%.get_safeLevel()',pro:'get_safeLevel()',cmt:'<p>Returns the sensor acceptable level for disabling the threshold function.</p>',ret:'a floating point number corresponding to the sensor acceptable level for disabling the threshold function',ext:'On failure, throws an exception or returns <tt>YThreshold.SAFELEVEL_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_targetSensor':{syn:'Returns the name of the sensor monitored by the threshold function.',lib:'%.get_targetSensor()',pro:'get_targetSensor()',cmt:'<p>Returns the name of the sensor monitored by the threshold function.</p>',ret:'a string corresponding to the name of the sensor monitored by the threshold function',ext:'On failure, throws an exception or returns <tt>YThreshold.TARGETSENSOR_INVALID</tt>.'}
,'get_thresholdState':{syn:'Returns current state of the threshold function.',lib:'%.get_thresholdState()',pro:'get_thresholdState()',cmt:'<p>Returns current state of the threshold function.</p>',ret:'either <tt>YThreshold.THRESHOLDSTATE_SAFE</tt> or <tt>YThreshold.THRESHOLDSTATE_ALERT</tt>, according to current state of the threshold function',ext:'On failure, throws an exception or returns <tt>YThreshold.THRESHOLDSTATE_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the threshold function is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the threshold function is currently reachable, without raising any error. If there is a cached value for the threshold function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the threshold function.</p>',ret:'<tt>true</tt> if the threshold function can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the threshold function cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the threshold function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextThreshold':{syn:'Continues the enumeration of threshold functions started using <tt>yFirstThreshold()</tt>.',lib:'%.nextThreshold()',pro:'nextThreshold()',cmt:'<p>Continues the enumeration of threshold functions started using <tt>yFirstThreshold()</tt>. Caution: You can\x27t make any assumption about the returned threshold functions order. If you want to find a specific a threshold function, use <tt>Threshold.findThreshold()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YThreshold</tt> object, corresponding to a threshold function currently online, or a <tt>null</tt> pointer if there are no more threshold functions to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_alertLevel':{syn:'Changes the sensor alert level triggering the threshold function.',lib:'%.set_alertLevel()',pro:'set_alertLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the sensor alert level triggering the threshold function. Remember to call the matching module <tt>saveToFlash()</tt> method if you want to preserve the setting after reboot.</p>',par:{newval:'a floating point number corresponding to the sensor alert level triggering the threshold function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the threshold function.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the threshold function. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the threshold function.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_safeLevel':{syn:'Changes the sensor acceptable level for disabling the threshold function.',lib:'%.set_safeLevel()',pro:'set_safeLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the sensor acceptable level for disabling the threshold function. Remember to call the matching module <tt>saveToFlash()</tt> method if you want to preserve the setting after reboot.</p>',par:{newval:'a floating point number corresponding to the sensor acceptable level for disabling the threshold function'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Threshold)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt sensor control interface, available for instance in the Yocto-3D-V2 or the Yocto-Inclinometer',inc:'from yocto_tilt import *',cmt:'<p>The <tt>YSensor</tt> class is the parent class for all Yoctopuce sensor types. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provides a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The <tt>YAnButton</tt> class is the only analog input which does not inherit from <tt>YSensor</tt>.</p>'}
,'FindTilt':{syn:'Retrieves a tilt sensor for a given identifier.',lib:'YTilt.FindTilt()',pro:'FindTilt(<span id=pn>func</span>)',cmt:'<p>Retrieves a tilt sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the tilt sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTilt.isOnline()</tt> to test if the tilt sensor is indeed online at a given time. In case of ambiguity when looking for a tilt sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the tilt sensor, for instance <tt>Y3DMK002.tilt1</tt>.'},ret:'a <tt>YTilt</tt> object allowing you to drive the tilt sensor.'}
,'FirstTilt':{syn:'Starts the enumeration of tilt sensors currently accessible.',lib:'YTilt.FirstTilt()',pro:'FirstTilt()',cmt:'<p>Starts the enumeration of tilt sensors currently accessible. Use the method <tt>YTilt.nextTilt()</tt> to iterate on next tilt sensors.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to the first tilt sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'calibrateToZero':{syn:'Performs a zero calibration for the tilt measurement (Yocto-Inclinometer only).',lib:'%.calibrateToZero()',pro:'calibrateToZero()',cmt:'<p>Performs a zero calibration for the tilt measurement (Yocto-Inclinometer only). When this method is invoked, a simple shift (translation) is applied so that the current position is reported as a zero angle. Be aware that this shift will also affect the measurement boundaries.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the tilt sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the tilt sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YTilt.ADVMODE_IMMEDIATE</tt>, <tt>YTilt.ADVMODE_PERIOD_AVG</tt>, <tt>YTilt.ADVMODE_PERIOD_MIN</tt> and <tt>YTilt.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YTilt.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YTilt.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_bandwidth':{syn:'Returns the measure update frequency, measured in Hz.',lib:'%.get_bandwidth()',pro:'get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz.</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz',ext:'On failure, throws an exception or returns <tt>YTilt.BANDWIDTH_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTilt.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTilt.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the tilt sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the tilt sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the tilt sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the tilt sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the tilt sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the tilt sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the tilt sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTilt.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the tilt sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the tilt sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the tilt sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTilt.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the tilt sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the tilt sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTilt.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>YTilt.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YTilt.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the tilt sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:'On failure, throws an exception or returns <tt>YTilt.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>YTilt.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YTilt.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YTilt.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YTilt.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the inclination.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:'On failure, throws an exception or returns <tt>YTilt.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the tilt sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the tilt sensor is currently reachable, without raising any error. If there is a cached value for the tilt sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the tilt sensor.</p>',ret:'<tt>true</tt> if the tilt sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the tilt sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the tilt sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextTilt':{syn:'Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.',lib:'%.nextTilt()',pro:'nextTilt()',cmt:'<p>Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>. Caution: You can\x27t make any assumption about the returned tilt sensors order. If you want to find a specific a tilt sensor, use <tt>Tilt.findTilt()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to a tilt sensor currently online, or a <tt>null</tt> pointer if there are no more tilt sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'restoreZeroCalibration':{syn:'Cancels any previous zero calibration for the tilt measurement (Yocto-Inclinometer only).',lib:'%.restoreZeroCalibration()',pro:'restoreZeroCalibration()',cmt:'<p>Cancels any previous zero calibration for the tilt measurement (Yocto-Inclinometer only). This function restores the factory zero calibration.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YTilt.ADVMODE_IMMEDIATE</tt>, <tt>YTilt.ADVMODE_PERIOD_AVG</tt>, <tt>YTilt.ADVMODE_PERIOD_MIN</tt> and <tt>YTilt.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_bandwidth':{syn:'Changes the measure update frequency, measured in Hz.',lib:'%.set_bandwidth()',pro:'set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz. When the frequency is lower, the device performs averaging. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the tilt sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the tilt sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Tilt)
//--- (generated code: Tvoc)
doc['Tvoc']={'':{syn:'Total Volatile Organic Compound sensor control interface, available for instance in the Yocto-VOC-V3',inc:'from yocto_tvoc import *',cmt:'<p>The <tt>YTvoc</tt> class allows you to read and configure Yoctopuce Total Volatile Organic Compound sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindTvoc':{syn:'Retrieves a Total Volatile Organic Compound sensor for a given identifier.',lib:'YTvoc.FindTvoc()',pro:'FindTvoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Total Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Total Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTvoc.isOnline()</tt> to test if the Total Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Total Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Total Volatile Organic Compound sensor, for instance <tt>YVOCMK03.tvoc</tt>.'},ret:'a <tt>YTvoc</tt> object allowing you to drive the Total Volatile Organic Compound sensor.'}
,'FirstTvoc':{syn:'Starts the enumeration of Total Volatile Organic Compound sensors currently accessible.',lib:'YTvoc.FirstTvoc()',pro:'FirstTvoc()',cmt:'<p>Starts the enumeration of Total Volatile Organic Compound sensors currently accessible. Use the method <tt>YTvoc.nextTvoc()</tt> to iterate on next Total Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YTvoc</tt> object, corresponding to the first Total Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Total Volatile Organic Compound sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the Total Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Total Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Total Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YTvoc.ADVMODE_IMMEDIATE</tt>, <tt>YTvoc.ADVMODE_PERIOD_AVG</tt>, <tt>YTvoc.ADVMODE_PERIOD_MIN</tt> and <tt>YTvoc.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YTvoc.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YTvoc.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTvoc.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the estimated TVOC concentration, in ppb, as a floating point number',ext:'On failure, throws an exception or returns <tt>YTvoc.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the Total Volatile Organic Compound sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Total Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Total Volatile Organic Compound sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the Total Volatile Organic Compound sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Total Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Total Volatile Organic Compound sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the Total Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the Total Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Total Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Total Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Total Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTvoc.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the Total Volatile Organic Compound sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the Total Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Total Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTvoc.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the Total Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Total Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Total Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Total Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YTvoc.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the estimated TVOC concentration since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated TVOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YTvoc.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YTvoc.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the Total Volatile Organic Compound sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the Total Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>YTvoc.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the estimated TVOC concentration since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated TVOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YTvoc.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YTvoc.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YTvoc.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YTvoc.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the estimated TVOC concentration.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the estimated TVOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated TVOC concentration',ext:'On failure, throws an exception or returns <tt>YTvoc.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the Total Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the Total Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Total Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Total Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Total Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the Total Volatile Organic Compound sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Total Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextTvoc':{syn:'Continues the enumeration of Total Volatile Organic Compound sensors started using <tt>yFirstTvoc()</tt>.',lib:'%.nextTvoc()',pro:'nextTvoc()',cmt:'<p>Continues the enumeration of Total Volatile Organic Compound sensors started using <tt>yFirstTvoc()</tt>. Caution: You can\x27t make any assumption about the returned Total Volatile Organic Compound sensors order. If you want to find a specific a Total Volatile Organic Compound sensor, use <tt>Tvoc.findTvoc()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTvoc</tt> object, corresponding to a Total Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Total Volatile Organic Compound sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YTvoc.ADVMODE_IMMEDIATE</tt>, <tt>YTvoc.ADVMODE_PERIOD_AVG</tt>, <tt>YTvoc.ADVMODE_PERIOD_MIN</tt> and <tt>YTvoc.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the Total Volatile Organic Compound sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Total Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Tvoc)
//--- (generated code: VirtualSensor)
doc['VirtualSensor']={'':{syn:'Virtual sensor control interface',inc:'from yocto_virtualsensor import *',cmt:'<p>The <tt>YVirtualSensor</tt> class allows you to use Yoctopuce virtual sensors. These sensors make it possible to show external data collected by the user as a Yoctopuce Sensor. This class inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger. It adds the ability to change the sensor value as needed, or to mark current value as invalid.</p>'}
,'FindVirtualSensor':{syn:'Retrieves a virtual sensor for a given identifier.',lib:'YVirtualSensor.FindVirtualSensor()',pro:'FindVirtualSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a virtual sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the virtual sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVirtualSensor.isOnline()</tt> to test if the virtual sensor is indeed online at a given time. In case of ambiguity when looking for a virtual sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the virtual sensor, for instance <tt>MyDevice.virtualSensor1</tt>.'},ret:'a <tt>YVirtualSensor</tt> object allowing you to drive the virtual sensor.'}
,'FirstVirtualSensor':{syn:'Starts the enumeration of virtual sensors currently accessible.',lib:'YVirtualSensor.FirstVirtualSensor()',pro:'FirstVirtualSensor()',cmt:'<p>Starts the enumeration of virtual sensors currently accessible. Use the method <tt>YVirtualSensor.nextVirtualSensor()</tt> to iterate on next virtual sensors.</p>',ret:'a pointer to a <tt>YVirtualSensor</tt> object, corresponding to the first virtual sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the virtual sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the virtual sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the virtual sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the virtual sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YVirtualSensor.ADVMODE_IMMEDIATE</tt>, <tt>YVirtualSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YVirtualSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YVirtualSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the virtual sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the virtual sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the virtual sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value assigned to the sensor.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value assigned to the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value assigned to the sensor',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current measured value.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the virtual sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the virtual sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the virtual sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the virtual sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the virtual sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the virtual sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the virtual sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the virtual sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the virtual sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the virtual sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the virtual sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the virtual sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the virtual sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the virtual sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the virtual sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the virtual sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the virtual sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the virtual sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the external measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the external measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the external measure since the device was started',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.HIGHESTVALUE_INVALID</tt>.'}
,'get_invalidValue':{syn:'Returns the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set).',lib:'%.get_invalidValue()',pro:'get_invalidValue()',cmt:'<p>Returns the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set).</p>',ret:'a floating point number corresponding to the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set)',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.INVALIDVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the virtual sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the virtual sensor.</p>',ret:'a string corresponding to the logical name of the virtual sensor.',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the external measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the external measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the external measure since the device was started',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the external measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the external measure.</p>',ret:'a string corresponding to the measuring unit for the external measure',ext:'On failure, throws an exception or returns <tt>YVirtualSensor.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the virtual sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the virtual sensor is currently reachable, without raising any error. If there is a cached value for the virtual sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the virtual sensor.</p>',ret:'<tt>true</tt> if the virtual sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the virtual sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the virtual sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextVirtualSensor':{syn:'Continues the enumeration of virtual sensors started using <tt>yFirstVirtualSensor()</tt>.',lib:'%.nextVirtualSensor()',pro:'nextVirtualSensor()',cmt:'<p>Continues the enumeration of virtual sensors started using <tt>yFirstVirtualSensor()</tt>. Caution: You can\x27t make any assumption about the returned virtual sensors order. If you want to find a specific a virtual sensor, use <tt>VirtualSensor.findVirtualSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVirtualSensor</tt> object, corresponding to a virtual sensor currently online, or a <tt>null</tt> pointer if there are no more virtual sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YVirtualSensor.ADVMODE_IMMEDIATE</tt>, <tt>YVirtualSensor.ADVMODE_PERIOD_AVG</tt>, <tt>YVirtualSensor.ADVMODE_PERIOD_MIN</tt> and <tt>YVirtualSensor.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_currentRawValue':{syn:'Changes the current value of the sensor (raw value, before calibration).',lib:'%.set_currentRawValue()',pro:'set_currentRawValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current value of the sensor (raw value, before calibration).</p>',par:{newval:'a floating point number corresponding to the current value of the sensor (raw value, before calibration)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_invalidValue':{syn:'Changes the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set).',lib:'%.set_invalidValue()',pro:'set_invalidValue(<span id=pn>newval</span>)',cmt:'<p>Changes the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set). Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the invalid value of the sensor, returned if the sensor is read when in invalid state (for instance before having been set)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the virtual sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the virtual sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the virtual sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_sensorAsInvalid':{syn:'Changes the current sensor state to invalid (as if no value would have been ever set).',lib:'%.set_sensorAsInvalid()',pro:'set_sensorAsInvalid()',cmt:'<p>Changes the current sensor state to invalid (as if no value would have been ever set).</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the measured value.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: VirtualSensor)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Volatile Organic Compound sensor control interface, available for instance in the Yocto-VOC-V3',inc:'from yocto_voc import *',cmt:'<p>The <tt>YVoc</tt> class allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindVoc':{syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc.FindVoc()',pro:'FindVoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor, for instance <tt>YVOCMK03.voc</tt>.'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'}
,'FirstVoc':{syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc.FirstVoc()',pro:'FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Volatile Organic Compound sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YVoc.ADVMODE_IMMEDIATE</tt>, <tt>YVoc.ADVMODE_PERIOD_AVG</tt>, <tt>YVoc.ADVMODE_PERIOD_MIN</tt> and <tt>YVoc.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YVoc.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YVoc.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>YVoc.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>YVoc.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the Volatile Organic Compound sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Volatile Organic Compound sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the Volatile Organic Compound sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Volatile Organic Compound sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoc.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoc.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoc.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YVoc.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YVoc.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>YVoc.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>YVoc.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YVoc.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YVoc.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YVoc.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_unit':{syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:'On failure, throws an exception or returns <tt>YVoc.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the Volatile Organic Compound sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextVoc':{syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'%.nextVoc()',pro:'nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>. Caution: You can\x27t make any assumption about the returned Volatile Organic Compound sensors order. If you want to find a specific a Volatile Organic Compound sensor, use <tt>Voc.findVoc()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YVoc.ADVMODE_IMMEDIATE</tt>, <tt>YVoc.ADVMODE_PERIOD_AVG</tt>, <tt>YVoc.ADVMODE_PERIOD_MIN</tt> and <tt>YVoc.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Voc)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage sensor control interface, available for instance in the Yocto-Motor-DC, the Yocto-Volt or the Yocto-Watt',inc:'from yocto_voltage import *',cmt:'<p>The <tt>YVoltage</tt> class allows you to read and configure Yoctopuce voltage sensors. It inherits from <tt>YSensor</tt> class the core functions to read measurements, to register callback functions, and to access the autonomous datalogger.</p>'}
,'FindVoltage':{syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage.FindVoltage()',pro:'FindVoltage(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage sensor, for instance <tt>MOTORCTL.voltage</tt>.'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'}
,'FirstVoltage':{syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage.FirstVoltage()',pro:'FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YVoltage.ADVMODE_IMMEDIATE</tt>, <tt>YVoltage.ADVMODE_PERIOD_AVG</tt>, <tt>YVoltage.ADVMODE_PERIOD_MIN</tt> and <tt>YVoltage.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YVoltage.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YVoltage.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>YVoltage.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>YVoltage.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_enabled':{syn:'Returns the activation state of this input.',lib:'%.get_enabled()',pro:'get_enabled()',cmt:'<p>Returns the activation state of this input.</p>',ret:'either <tt>YVoltage.ENABLED_FALSE</tt> or <tt>YVoltage.ENABLED_TRUE</tt>, according to the activation state of this input',ext:'On failure, throws an exception or returns <tt>YVoltage.ENABLED_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the voltage sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the voltage sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage sensor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltage.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the voltage sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltage.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltage.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>YVoltage.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YVoltage.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the voltage sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:'On failure, throws an exception or returns <tt>YVoltage.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>YVoltage.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YVoltage.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YVoltage.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YVoltage.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_signalBias':{syn:'Returns the DC bias configured for zero shift adjustment.',lib:'%.get_signalBias()',pro:'get_signalBias()',cmt:'<p>Returns the DC bias configured for zero shift adjustment. A positive bias value is used to correct a positive DC bias, while a negative bias value is used to correct a negative DC bias.</p>',ret:'a floating point number corresponding to the DC bias configured for zero shift adjustment',ext:'On failure, throws an exception or returns <tt>YVoltage.SIGNALBIAS_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the voltage.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>YVoltage.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the voltage sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the voltage sensor is currently reachable, without raising any error. If there is a cached value for the voltage sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage sensor.</p>',ret:'<tt>true</tt> if the voltage sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the voltage sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextVoltage':{syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'%.nextVoltage()',pro:'nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>. Caution: You can\x27t make any assumption about the returned voltage sensors order. If you want to find a specific a voltage sensor, use <tt>Voltage.findVoltage()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YVoltage.ADVMODE_IMMEDIATE</tt>, <tt>YVoltage.ADVMODE_PERIOD_AVG</tt>, <tt>YVoltage.ADVMODE_PERIOD_MIN</tt> and <tt>YVoltage.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_enabled':{syn:'Changes the activation state of this voltage input.',lib:'%.set_enabled()',pro:'set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of this voltage input. When AC measurements are disabled, the device will always assume a DC signal, and vice-versa. When both AC and DC measurements are active, the device switches between AC and DC mode based on the relative amplitude of variations compared to the average value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>YVoltage.ENABLED_FALSE</tt> or <tt>YVoltage.ENABLED_TRUE</tt>, according to the activation state of this voltage input'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the voltage sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_signalBias':{syn:'Changes the DC bias configured for zero shift adjustment.',lib:'%.set_signalBias()',pro:'set_signalBias(<span id=pn>newval</span>)',cmt:'<p>Changes the DC bias configured for zero shift adjustment. If your DC current reads positive when it should be zero, set up a positive signalBias of the same value to fix the zero shift. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the DC bias configured for zero shift adjustment'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'zeroAdjust':{syn:'Calibrate the device by adjusting <tt>signalBias</tt> so that the current input voltage is precisely seen as zero.',lib:'%.zeroAdjust()',pro:'zeroAdjust()',cmt:'<p>Calibrate the device by adjusting <tt>signalBias</tt> so that the current input voltage is precisely seen as zero. Before calling this method, make sure to short the power source inputs as close as possible to the connector, and to disconnect the load to ensure the wires don\x27t capture radiated noise. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
};
//--- (end of generated code: Voltage)
//--- (generated code: VoltageOutput)
doc['VoltageOutput']={'':{syn:'Voltage output control interface, available for instance in the Yocto-0-10V-Tx',inc:'from yocto_voltageoutput import *',cmt:'<p>The <tt>YVoltageOutput</tt> class allows you to drive a voltage output.</p>'}
,'FindVoltageOutput':{syn:'Retrieves a voltage output for a given identifier.',lib:'YVoltageOutput.FindVoltageOutput()',pro:'FindVoltageOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltageOutput.isOnline()</tt> to test if the voltage output is indeed online at a given time. In case of ambiguity when looking for a voltage output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage output, for instance <tt>TX010V01.voltageOutput1</tt>.'},ret:'a <tt>YVoltageOutput</tt> object allowing you to drive the voltage output.'}
,'FirstVoltageOutput':{syn:'Starts the enumeration of voltage outputs currently accessible.',lib:'YVoltageOutput.FirstVoltageOutput()',pro:'FirstVoltageOutput()',cmt:'<p>Starts the enumeration of voltage outputs currently accessible. Use the method <tt>YVoltageOutput.nextVoltageOutput()</tt> to iterate on next voltage outputs.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to the first voltage output currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the voltage output (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the voltage output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_currentVoltage':{syn:'Returns the output voltage set point, in V.',lib:'%.get_currentVoltage()',pro:'get_currentVoltage()',cmt:'<p>Returns the output voltage set point, in V.</p>',ret:'a floating point number corresponding to the output voltage set point, in V',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.CURRENTVOLTAGE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the voltage output.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage output object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the voltage output.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage output object'}
,'get_friendlyName':{syn:'Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage output if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the voltage output, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the voltage output.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the voltage output.</p>',ret:'a string corresponding to the logical name of the voltage output.',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_voltageAtStartUp':{syn:'Returns the selected voltage output at device startup, in V.',lib:'%.get_voltageAtStartUp()',pro:'get_voltageAtStartUp()',cmt:'<p>Returns the selected voltage output at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage output at device startup, in V',ext:'On failure, throws an exception or returns <tt>YVoltageOutput.VOLTAGEATSTARTUP_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the voltage output is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the voltage output is currently reachable, without raising any error. If there is a cached value for the voltage output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage output.</p>',ret:'<tt>true</tt> if the voltage output can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the voltage output cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextVoltageOutput':{syn:'Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>.',lib:'%.nextVoltageOutput()',pro:'nextVoltageOutput()',cmt:'<p>Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>. Caution: You can\x27t make any assumption about the returned voltage outputs order. If you want to find a specific a voltage output, use <tt>VoltageOutput.findVoltageOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to a voltage output currently online, or a <tt>null</tt> pointer if there are no more voltage outputs to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_currentVoltage':{syn:'Changes the output voltage, in V.',lib:'%.set_currentVoltage()',pro:'set_currentVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the output voltage, in V. Valid range is from 0 to 10V.</p>',par:{newval:'a floating point number corresponding to the output voltage, in V'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the voltage output.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage output.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_voltageAtStartUp':{syn:'Changes the output voltage at device start up.',lib:'%.set_voltageAtStartUp()',pro:'set_voltageAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the output voltage at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the output voltage at device start up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'voltageMove':{syn:'Performs a smooth transition of output voltage.',lib:'%.voltageMove()',pro:'voltageMove(<span id=pn>V_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of output voltage. Any explicit voltage change cancels any ongoing transition process.</p>',par:{V_target:'new output voltage value at the end of the transition (floating-point number, representing the end voltage in V)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.'}
};
//--- (end of generated code: VoltageOutput)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'Wake-up monitor control interface, available for instance in the YoctoHub-GSM-4G, the YoctoHub-Wireless-SR, the YoctoHub-Wireless-g or the YoctoHub-Wireless-n',inc:'from yocto_wakeupmonitor import *',cmt:'<p>The <tt>YWakeUpMonitor</tt> class handles globally all wake-up sources, as well as automated sleep mode.</p>'}
,'FindWakeUpMonitor':{syn:'Retrieves a wake-up monitor for a given identifier.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Retrieves a wake-up monitor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wake-up monitor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpMonitor.isOnline()</tt> to test if the wake-up monitor is indeed online at a given time. In case of ambiguity when looking for a wake-up monitor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wake-up monitor, for instance <tt>YHUBGSM5.wakeUpMonitor</tt>.'},ret:'a <tt>YWakeUpMonitor</tt> object allowing you to drive the wake-up monitor.'}
,'FirstWakeUpMonitor':{syn:'Starts the enumeration of wake-up monitors currently accessible.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'FirstWakeUpMonitor()',cmt:'<p>Starts the enumeration of wake-up monitors currently accessible. Use the method <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> to iterate on next wake-up monitors.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to the first wake-up monitor currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wake-up monitor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the wake-up monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wake-up monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wake-up monitor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the wake-up monitor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the wake-up monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake-up monitor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the wake-up monitor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wake-up monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wake-up monitor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the wake-up monitor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wake-up monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wake-up monitor object'}
,'get_friendlyName':{syn:'Returns a global identifier of the wake-up monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the wake-up monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wake-up monitor if they are defined, otherwise the serial number of the module and the hardware identifier of the wake-up monitor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wake-up monitor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the wake-up monitor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the wake-up monitor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wake-up monitor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the wake-up monitor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wake-up monitor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wake-up monitor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wake-up monitor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.HARDWAREID_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the wake-up monitor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the wake-up monitor.</p>',ret:'a string corresponding to the logical name of the wake-up monitor.',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.LOGICALNAME_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_nextWakeUp':{syn:'Returns the next scheduled wake up date/time (UNIX format).',lib:'%.get_nextWakeUp()',pro:'get_nextWakeUp()',cmt:'<p>Returns the next scheduled wake up date/time (UNIX format).</p>',ret:'an integer corresponding to the next scheduled wake up date/time (UNIX format)',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.NEXTWAKEUP_INVALID</tt>.'}
,'get_powerDuration':{syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'%.get_powerDuration()',pro:'get_powerDuration()',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.POWERDURATION_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_sleepCountdown':{syn:'Returns the delay before the next sleep period.',lib:'%.get_sleepCountdown()',pro:'get_sleepCountdown()',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.SLEEPCOUNTDOWN_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_wakeUpReason':{syn:'Returns the latest wake up reason.',lib:'%.get_wakeUpReason()',pro:'get_wakeUpReason()',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>YWakeUpMonitor.WAKEUPREASON_USBPOWER</tt>, <tt>YWakeUpMonitor.WAKEUPREASON_EXTPOWER</tt>, <tt>YWakeUpMonitor.WAKEUPREASON_ENDOFSLEEP</tt>, <tt>YWakeUpMonitor.WAKEUPREASON_EXTSIG1</tt>, <tt>YWakeUpMonitor.WAKEUPREASON_SCHEDULE1</tt>, <tt>YWakeUpMonitor.WAKEUPREASON_SCHEDULE2</tt> and <tt>YWakeUpMonitor.WAKEUPREASON_SCHEDULE3</tt> corresponding to the latest wake up reason',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.WAKEUPREASON_INVALID</tt>.'}
,'get_wakeUpState':{syn:'Returns the current state of the monitor.',lib:'%.get_wakeUpState()',pro:'get_wakeUpState()',cmt:'<p>Returns the current state of the monitor.</p>',ret:'either <tt>YWakeUpMonitor.WAKEUPSTATE_SLEEPING</tt> or <tt>YWakeUpMonitor.WAKEUPSTATE_AWAKE</tt>, according to the current state of the monitor',ext:'On failure, throws an exception or returns <tt>YWakeUpMonitor.WAKEUPSTATE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the wake-up monitor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the wake-up monitor is currently reachable, without raising any error. If there is a cached value for the wake-up monitor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wake-up monitor.</p>',ret:'<tt>true</tt> if the wake-up monitor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the wake-up monitor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wake-up monitor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextWakeUpMonitor':{syn:'Continues the enumeration of wake-up monitors started using <tt>yFirstWakeUpMonitor()</tt>.',lib:'%.nextWakeUpMonitor()',pro:'nextWakeUpMonitor()',cmt:'<p>Continues the enumeration of wake-up monitors started using <tt>yFirstWakeUpMonitor()</tt>. Caution: You can\x27t make any assumption about the returned wake-up monitors order. If you want to find a specific a wake-up monitor, use <tt>WakeUpMonitor.findWakeUpMonitor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to a wake-up monitor currently online, or a <tt>null</tt> pointer if there are no more wake-up monitors to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'resetSleepCountDown':{syn:'Resets the sleep countdown.',lib:'%.resetSleepCountDown()',pro:'resetSleepCountDown()',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the wake-up monitor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake-up monitor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake-up monitor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_nextWakeUp':{syn:'Changes the days of the week when a wake up must take place.',lib:'%.set_nextWakeUp()',pro:'set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_powerDuration':{syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'%.set_powerDuration()',pro:'set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_sleepCountdown':{syn:'Changes the delay before the next sleep period.',lib:'%.set_sleepCountdown()',pro:'set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'sleep':{syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'%.sleep()',pro:'sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'sleepFor':{syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'%.sleepFor()',pro:'sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'sleepUntil':{syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'%.sleepUntil()',pro:'sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
,'wakeUp':{syn:'Forces a wake up.',lib:'%.wakeUp()',pro:'wakeUp()',cmt:'<p>Forces a wake up.</p>'}
};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'Wake up schedule control interface, available for instance in the YoctoHub-GSM-4G, the YoctoHub-Wireless-SR, the YoctoHub-Wireless-g or the YoctoHub-Wireless-n',inc:'from yocto_wakeupschedule import *',cmt:'<p>The <tt>YWakeUpSchedule</tt> class implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}
,'FindWakeUpSchedule':{syn:'Retrieves a wake up schedule for a given identifier.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Retrieves a wake up schedule for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wake up schedule is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpSchedule.isOnline()</tt> to test if the wake up schedule is indeed online at a given time. In case of ambiguity when looking for a wake up schedule by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wake up schedule, for instance <tt>YHUBGSM5.wakeUpSchedule1</tt>.'},ret:'a <tt>YWakeUpSchedule</tt> object allowing you to drive the wake up schedule.'}
,'FirstWakeUpSchedule':{syn:'Starts the enumeration of wake up schedules currently accessible.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'FirstWakeUpSchedule()',cmt:'<p>Starts the enumeration of wake up schedules currently accessible. Use the method <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> to iterate on next wake up schedules.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to the first wake up schedule currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wake up schedule attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wake up schedule (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the wake up schedule.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wake up schedule object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the wake up schedule.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wake up schedule object'}
,'get_friendlyName':{syn:'Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wake up schedule if they are defined, otherwise the serial number of the module and the hardware identifier of the wake up schedule (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wake up schedule using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the wake up schedule, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the wake up schedule, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wake up schedule (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wake up schedule (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wake up schedule (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.HARDWAREID_INVALID</tt>.'}
,'get_hours':{syn:'Returns the hours scheduled for wake up.',lib:'%.get_hours()',pro:'get_hours()',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.HOURS_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the wake up schedule.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.LOGICALNAME_INVALID</tt>.'}
,'get_minutes':{syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'%.get_minutes()',pro:'get_minutes()',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'}
,'get_minutesA':{syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'%.get_minutesA()',pro:'get_minutesA()',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.MINUTESA_INVALID</tt>.'}
,'get_minutesB':{syn:'Returns the minutes in the 30-59 interval of each hour scheduled for wake up.',lib:'%.get_minutesB()',pro:'get_minutesB()',cmt:'<p>Returns the minutes in the 30-59 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.MINUTESB_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_monthDays':{syn:'Returns the days of the month scheduled for wake up.',lib:'%.get_monthDays()',pro:'get_monthDays()',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.MONTHDAYS_INVALID</tt>.'}
,'get_months':{syn:'Returns the months scheduled for wake up.',lib:'%.get_months()',pro:'get_months()',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.MONTHS_INVALID</tt>.'}
,'get_nextOccurence':{syn:'Returns the date/time (seconds) of the next wake up occurrence.',lib:'%.get_nextOccurence()',pro:'get_nextOccurence()',cmt:'<p>Returns the date/time (seconds) of the next wake up occurrence.</p>',ret:'an integer corresponding to the date/time (seconds) of the next wake up occurrence',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.NEXTOCCURENCE_INVALID</tt>.'}
,'get_secondsBefore':{syn:'Returns the number of seconds to anticipate wake-up time to allow the system to power-up.',lib:'%.get_secondsBefore()',pro:'get_secondsBefore()',cmt:'<p>Returns the number of seconds to anticipate wake-up time to allow the system to power-up.</p>',ret:'an integer corresponding to the number of seconds to anticipate wake-up time to allow the system to power-up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.SECONDSBEFORE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_userData':dm.get_userData
,'get_weekDays':{syn:'Returns the days of the week scheduled for wake up.',lib:'%.get_weekDays()',pro:'get_weekDays()',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:'On failure, throws an exception or returns <tt>YWakeUpSchedule.WEEKDAYS_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the wake up schedule is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the wake up schedule is currently reachable, without raising any error. If there is a cached value for the wake up schedule in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wake up schedule.</p>',ret:'<tt>true</tt> if the wake up schedule can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the wake up schedule cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wake up schedule cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextWakeUpSchedule':{syn:'Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.',lib:'%.nextWakeUpSchedule()',pro:'nextWakeUpSchedule()',cmt:'<p>Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>. Caution: You can\x27t make any assumption about the returned wake up schedules order. If you want to find a specific a wake up schedule, use <tt>WakeUpSchedule.findWakeUpSchedule()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to a wake up schedule currently online, or a <tt>null</tt> pointer if there are no more wake up schedules to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_hours':{syn:'Changes the hours when a wake up must take place.',lib:'%.set_hours()',pro:'set_hours(<span id=pn>newval</span>)',cmt:'<p>Changes the hours when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the wake up schedule.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake up schedule. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_minutes':{syn:'Changes all the minutes where a wake up must take place.',lib:'%.set_minutes()',pro:'set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_minutesA':{syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'%.set_minutesA()',pro:'set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_minutesB':{syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'%.set_minutesB()',pro:'set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_monthDays':{syn:'Changes the days of the month when a wake up must take place.',lib:'%.set_monthDays()',pro:'set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the month when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_months':{syn:'Changes the months when a wake up must take place.',lib:'%.set_months()',pro:'set_months(<span id=pn>newval</span>)',cmt:'<p>Changes the months when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_secondsBefore':{syn:'Changes the number of seconds to anticipate wake-up time to allow the system to power-up.',lib:'%.set_secondsBefore()',pro:'set_secondsBefore(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds to anticipate wake-up time to allow the system to power-up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the number of seconds to anticipate wake-up time to allow the system to power-up'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_weekDays':{syn:'Changes the days of the week when a wake up must take place.',lib:'%.set_weekDays()',pro:'set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog control interface, available for instance in the Yocto-WatchdogDC',inc:'from yocto_watchdog import *',cmt:'<p>The <tt>YWatchdog</tt> class allows you to drive a Yoctopuce watchdog. A watchdog works like a relay, with an extra timer that can automatically trigger a brief power cycle to an appliance after a preset delay, to force this appliance to reset if a problem occurs. During normal use, the watchdog timer is reset periodically by the application to prevent the automated power cycle. Whenever the application dies, the watchdog will automatically trigger the power cycle. The watchdog can also be driven directly with <tt>pulse</tt> and <tt>delayedPulse</tt> methods to switch off an appliance for a given duration.</p>'}
,'FindWatchdog':{syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog.FindWatchdog()',pro:'FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the watchdog, for instance <tt>WDOGDC01.watchdog1</tt>.'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'}
,'FirstWatchdog':{syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog.FirstWatchdog()',pro:'FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the watchdog attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'delayedPulse':{syn:'Schedules a pulse.',lib:'%.delayedPulse()',pro:'delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the watchdog (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YWatchdog.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_autoStart':{syn:'Returns the watchdog running state at module power on.',lib:'%.get_autoStart()',pro:'get_autoStart()',cmt:'<p>Returns the watchdog running state at module power on.</p>',ret:'either <tt>YWatchdog.AUTOSTART_OFF</tt> or <tt>YWatchdog.AUTOSTART_ON</tt>, according to the watchdog running state at module power on',ext:'On failure, throws an exception or returns <tt>YWatchdog.AUTOSTART_INVALID</tt>.'}
,'get_countdown':{syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'%.get_countdown()',pro:'get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>YWatchdog.COUNTDOWN_INVALID</tt>.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the watchdog.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the watchdog object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the watchdog.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the watchdog object'}
,'get_friendlyName':{syn:'Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the watchdog if they are defined, otherwise the serial number of the module and the hardware identifier of the watchdog (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the watchdog using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWatchdog.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the watchdog, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the watchdog, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the watchdog (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWatchdog.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the watchdog (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the watchdog (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWatchdog.HARDWAREID_INVALID</tt>.'}
,'get_lastTrigger':{syn:'Returns the number of seconds spent since the last output power-up event.',lib:'%.get_lastTrigger()',pro:'get_lastTrigger()',cmt:'<p>Returns the number of seconds spent since the last output power-up event.</p>',ret:'an integer corresponding to the number of seconds spent since the last output power-up event',ext:'On failure, throws an exception or returns <tt>YWatchdog.LASTTRIGGER_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the watchdog.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:'On failure, throws an exception or returns <tt>YWatchdog.LOGICALNAME_INVALID</tt>.'}
,'get_maxTimeOnStateA':{syn:'Returns the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state.',lib:'%.get_maxTimeOnStateA()',pro:'get_maxTimeOnStateA()',cmt:'<p>Returns the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state. Zero means no time limit.</p>',ret:'an integer corresponding to the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state',ext:'On failure, throws an exception or returns <tt>YWatchdog.MAXTIMEONSTATEA_INVALID</tt>.'}
,'get_maxTimeOnStateB':{syn:'Retourne the maximum time (ms) allowed for the watchdog to stay in state B before automatically switching back in to A state.',lib:'%.get_maxTimeOnStateB()',pro:'get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for the watchdog to stay in state B before automatically switching back in to A state. Zero means no time limit.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>YWatchdog.MAXTIMEONSTATEB_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_output':{syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'%.get_output()',pro:'get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>YWatchdog.OUTPUT_OFF</tt> or <tt>YWatchdog.OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>YWatchdog.OUTPUT_INVALID</tt>.'}
,'get_pulseTimer':{syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'%.get_pulseTimer()',pro:'get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>YWatchdog.PULSETIMER_INVALID</tt>.'}
,'get_running':{syn:'Returns the watchdog running state.',lib:'%.get_running()',pro:'get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>YWatchdog.RUNNING_OFF</tt> or <tt>YWatchdog.RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>YWatchdog.RUNNING_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_state':{syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'%.get_state()',pro:'get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>YWatchdog.STATE_A</tt> or <tt>YWatchdog.STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>YWatchdog.STATE_INVALID</tt>.'}
,'get_stateAtPowerOn':{syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).',lib:'%.get_stateAtPowerOn()',pro:'get_stateAtPowerOn()',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).</p>',ret:'a value among <tt>YWatchdog.STATEATPOWERON_UNCHANGED</tt>, <tt>YWatchdog.STATEATPOWERON_A</tt> and <tt>YWatchdog.STATEATPOWERON_B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is)',ext:'On failure, throws an exception or returns <tt>YWatchdog.STATEATPOWERON_INVALID</tt>.'}
,'get_triggerDelay':{syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'%.get_triggerDelay()',pro:'get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>YWatchdog.TRIGGERDELAY_INVALID</tt>.'}
,'get_triggerDuration':{syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'%.get_triggerDuration()',pro:'get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>YWatchdog.TRIGGERDURATION_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'isOnline':{syn:'Checks if the watchdog is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the watchdog is currently reachable, without raising any error. If there is a cached value for the watchdog in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the watchdog.</p>',ret:'<tt>true</tt> if the watchdog can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the watchdog cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the watchdog cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextWatchdog':{syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'%.nextWatchdog()',pro:'nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>. Caution: You can\x27t make any assumption about the returned watchdog order. If you want to find a specific a watchdog, use <tt>Watchdog.findWatchdog()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'}
,'pulse':{syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'%.pulse()',pro:'pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'registerValueCallback':ds.registerValueCallback
,'resetWatchdog':{syn:'Resets the watchdog.',lib:'%.resetWatchdog()',pro:'resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchdog to trigger</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_autoStart':{syn:'Changes the watchdog running state at module power on.',lib:'%.set_autoStart()',pro:'set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the watchdog running state at module power on. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>YWatchdog.AUTOSTART_OFF</tt> or <tt>YWatchdog.AUTOSTART_ON</tt>, according to the watchdog running state at module power on'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_logicalName':{syn:'Changes the logical name of the watchdog.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxTimeOnStateA':{syn:'Changes the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state.',lib:'%.set_maxTimeOnStateA()',pro:'set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state. Use zero for no time limit. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximum time (ms) allowed for the watchdog to stay in state A before automatically switching back in to B state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_maxTimeOnStateB':{syn:'Changes the maximum time (ms) allowed for the watchdog to stay in state B before automatically switching back in to A state.',lib:'%.set_maxTimeOnStateB()',pro:'set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum time (ms) allowed for the watchdog to stay in state B before automatically switching back in to A state. Use zero for no time limit. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximum time (ms) allowed for the watchdog to stay in state B before automatically switching back in to A state'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_output':{syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'%.set_output()',pro:'set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>YWatchdog.OUTPUT_OFF</tt> or <tt>YWatchdog.OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_running':{syn:'Changes the running state of the watchdog.',lib:'%.set_running()',pro:'set_running(<span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>YWatchdog.RUNNING_OFF</tt> or <tt>YWatchdog.RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_state':{syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'%.set_state()',pro:'set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>YWatchdog.STATE_A</tt> or <tt>YWatchdog.STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_stateAtPowerOn':{syn:'Changes the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is).',lib:'%.set_stateAtPowerOn()',pro:'set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>YWatchdog.STATEATPOWERON_UNCHANGED</tt>, <tt>YWatchdog.STATEATPOWERON_A</tt> and <tt>YWatchdog.STATEATPOWERON_B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED to leave the relay state as is)'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_triggerDelay':{syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'%.set_triggerDelay()',pro:'set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_triggerDuration':{syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'%.set_triggerDuration()',pro:'set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'toggle':{syn:'Switch the relay to the opposite state.',lib:'%.toggle()',pro:'toggle()',cmt:'<p>Switch the relay to the opposite state.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Watchdog)
//--- (generated code: WeighScale)
doc['WeighScale']={'':{syn:'Weighing scale sensor control interface, available for instance in the Yocto-Bridge or the Yocto-MaxiBridge',inc:'from yocto_weighscale import *',cmt:'<p>The <tt>YWeighScale</tt> class provides a weight measurement from a ratiometric sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cell itself.</p>'}
,'FindWeighScale':{syn:'Retrieves a weighing scale sensor for a given identifier.',lib:'YWeighScale.FindWeighScale()',pro:'FindWeighScale(<span id=pn>func</span>)',cmt:'<p>Retrieves a weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWeighScale.isOnline()</tt> to test if the weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the weighing scale sensor, for instance <tt>YWBRIDG1.weighScale1</tt>.'},ret:'a <tt>YWeighScale</tt> object allowing you to drive the weighing scale sensor.'}
,'FirstWeighScale':{syn:'Starts the enumeration of weighing scale sensors currently accessible.',lib:'YWeighScale.FirstWeighScale()',pro:'FirstWeighScale()',cmt:'<p>Starts the enumeration of weighing scale sensors currently accessible. Use the method <tt>YWeighScale.nextWeighScale()</tt> to iterate on next weighing scale sensors.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to the first weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'}
,'calibrateFromPoints':ds.calibrateFromPoints
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advMode':{syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.get_advMode()',pro:'get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>YWeighScale.ADVMODE_IMMEDIATE</tt>, <tt>YWeighScale.ADVMODE_PERIOD_AVG</tt>, <tt>YWeighScale.ADVMODE_PERIOD_MIN</tt> and <tt>YWeighScale.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>YWeighScale.ADVMODE_INVALID</tt>.'}
,'get_advertisedValue':{syn:'Returns the current value of the weighing scale sensor (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YWeighScale.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_compTempAvg':{syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'%.get_compTempAvg()',pro:'get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>YWeighScale.COMPTEMPAVG_INVALID</tt>.'}
,'get_compTempChg':{syn:'Returns the current temperature variation, used for thermal compensation.',lib:'%.get_compTempChg()',pro:'get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>YWeighScale.COMPTEMPCHG_INVALID</tt>.'}
,'get_compensation':{syn:'Returns the current current thermal compensation value.',lib:'%.get_compensation()',pro:'get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>YWeighScale.COMPENSATION_INVALID</tt>.'}
,'get_currentRawValue':{syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'%.get_currentRawValue()',pro:'get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YWeighScale.CURRENTRAWVALUE_INVALID</tt>.'}
,'get_currentValue':{syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'%.get_currentValue()',pro:'get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number. Note that a get_currentValue() call will *not* start a measure in the device, it will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce devices is continuously making measurements at a hardware specific frequency.</p><p> If continuously calling get_currentValue() leads you to performances issues, then you might consider to switch to callback programming model. Check the \x22advanced programming\x22 chapter in in your device user manual for more information.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>YWeighScale.CURRENTVALUE_INVALID</tt>.'}
,'get_dataLogger':ds.get_dataLogger
,'get_errorMessage':{syn:'Returns the error message of the latest error with the weighing scale sensor.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the weighing scale sensor object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the weighing scale sensor.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the weighing scale sensor object'}
,'get_excitation':{syn:'Returns the current load cell bridge excitation method.',lib:'%.get_excitation()',pro:'get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>YWeighScale.EXCITATION_OFF</tt>, <tt>YWeighScale.EXCITATION_DC</tt> and <tt>YWeighScale.EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>YWeighScale.EXCITATION_INVALID</tt>.'}
,'get_friendlyName':{syn:'Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWeighScale.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the weighing scale sensor, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWeighScale.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWeighScale.HARDWAREID_INVALID</tt>.'}
,'get_highestValue':{syn:'Returns the maximal value observed for the measure since the device was started.',lib:'%.get_highestValue()',pro:'get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YWeighScale.HIGHESTVALUE_INVALID</tt>.'}
,'get_logFrequency':{syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'%.get_logFrequency()',pro:'get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>YWeighScale.LOGFREQUENCY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the weighing scale sensor.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>YWeighScale.LOGICALNAME_INVALID</tt>.'}
,'get_lowestValue':{syn:'Returns the minimal value observed for the measure since the device was started.',lib:'%.get_lowestValue()',pro:'get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>YWeighScale.LOWESTVALUE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_recordedData':ds.get_recordedData
,'get_reportFrequency':{syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'%.get_reportFrequency()',pro:'get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>YWeighScale.REPORTFREQUENCY_INVALID</tt>.'}
,'get_resolution':{syn:'Returns the resolution of the measured values.',lib:'%.get_resolution()',pro:'get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>YWeighScale.RESOLUTION_INVALID</tt>.'}
,'get_sensorState':{syn:'Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'%.get_sensorState()',pro:'get_sensorState()',cmt:'<p>Returns the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>YWeighScale.SENSORSTATE_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_tempAvgAdaptRatio':{syn:'Returns the averaged temperature update rate, in per mille.',lib:'%.get_tempAvgAdaptRatio()',pro:'get_tempAvgAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:'On failure, throws an exception or returns <tt>YWeighScale.TEMPAVGADAPTRATIO_INVALID</tt>.'}
,'get_tempChgAdaptRatio':{syn:'Returns the temperature change update rate, in per mille.',lib:'%.get_tempChgAdaptRatio()',pro:'get_tempChgAdaptRatio()',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:'On failure, throws an exception or returns <tt>YWeighScale.TEMPCHGADAPTRATIO_INVALID</tt>.'}
,'get_unit':{syn:'Returns the measuring unit for the measure.',lib:'%.get_unit()',pro:'get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>YWeighScale.UNIT_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_zeroTracking':{syn:'Returns the zero tracking threshold value.',lib:'%.get_zeroTracking()',pro:'get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>YWeighScale.ZEROTRACKING_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the weighing scale sensor is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the weighing scale sensor.</p>',ret:'<tt>true</tt> if the weighing scale sensor can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'load':{syn:'Preloads the weighing scale sensor cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'loadCalibrationPoints':ds.loadCalibrationPoints
,'loadOffsetAvgCompensationTable':{syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function.',lib:'%.loadOffsetAvgCompensationTable()',pro:'loadOffsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadOffsetChgCompensationTable':{syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function.',lib:'%.loadOffsetChgCompensationTable()',pro:'loadOffsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadSpanAvgCompensationTable':{syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function.',lib:'%.loadSpanAvgCompensationTable()',pro:'loadSpanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadSpanChgCompensationTable':{syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function.',lib:'%.loadSpanChgCompensationTable()',pro:'loadSpanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all variation of temperature for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of variation of temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextWeighScale':{syn:'Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>.',lib:'%.nextWeighScale()',pro:'nextWeighScale()',cmt:'<p>Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>. Caution: You can\x27t make any assumption about the returned weighing scale sensors order. If you want to find a specific a weighing scale sensor, use <tt>WeighScale.findWeighScale()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to a weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more weighing scale sensors to enumerate.'}
,'registerTimedReportCallback':ds.registerTimedReportCallback
,'registerValueCallback':ds.registerValueCallback
,'set_advMode':{syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'%.set_advMode()',pro:'set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YWeighScale.ADVMODE_IMMEDIATE</tt>, <tt>YWeighScale.ADVMODE_PERIOD_AVG</tt>, <tt>YWeighScale.ADVMODE_PERIOD_MIN</tt> and <tt>YWeighScale.ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_excitation':{syn:'Changes the current load cell bridge excitation method.',lib:'%.set_excitation()',pro:'set_excitation(<span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>YWeighScale.EXCITATION_OFF</tt>, <tt>YWeighScale.EXCITATION_DC</tt> and <tt>YWeighScale.EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_highestValue':ds.set_highestValue
,'set_logFrequency':ds.set_logFrequency
,'set_logicalName':{syn:'Changes the logical name of the weighing scale sensor.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the weighing scale sensor.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_lowestValue':ds.set_lowestValue
,'set_offsetAvgCompensationTable':{syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature.',lib:'%.set_offsetAvgCompensationTable()',pro:'set_offsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_offsetChgCompensationTable':{syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'%.set_offsetChgCompensationTable()',pro:'set_offsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_reportFrequency':ds.set_reportFrequency
,'set_resolution':ds.set_resolution
,'set_spanAvgCompensationTable':{syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature.',lib:'%.set_spanAvgCompensationTable()',pro:'set_spanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_spanChgCompensationTable':{syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'%.set_spanChgCompensationTable()',pro:'set_spanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all variations of temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_tempAvgAdaptRatio':{syn:'Changes the averaged temperature update rate, in per mille.',lib:'%.set_tempAvgAdaptRatio()',pro:'set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_tempChgAdaptRatio':{syn:'Changes the temperature change update rate, in per mille.',lib:'%.set_tempChgAdaptRatio()',pro:'set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 per mille. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_unit':{syn:'Changes the measuring unit for the weight.',lib:'%.set_unit()',pro:'set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'set_zeroTracking':{syn:'Changes the zero tracking threshold value.',lib:'%.set_zeroTracking()',pro:'set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'setupSpan':{syn:'Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.',lib:'%.setupSpan()',pro:'setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'startDataLogger':ds.startDataLogger
,'stopDataLogger':ds.stopDataLogger
,'tare':{syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'%.tare()',pro:'tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: WeighScale)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless LAN interface control interface, available for instance in the YoctoHub-Wireless, the YoctoHub-Wireless-SR, the YoctoHub-Wireless-g or the YoctoHub-Wireless-n',inc:'from yocto_wireless import *',cmt:'<p>The YWireless class provides control over wireless network parameters and status for devices that are wireless-enabled. Note that TCP/IP parameters are configured separately, using class <tt>YNetwork</tt>.</p>'}
,'FindWireless':{syn:'Retrieves a wireless LAN interface for a given identifier.',lib:'YWireless.FindWireless()',pro:'FindWireless(<span id=pn>func</span>)',cmt:'<p>Retrieves a wireless LAN interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wireless LAN interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless LAN interface is indeed online at a given time. In case of ambiguity when looking for a wireless LAN interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wireless LAN interface, for instance <tt>YHUBWLN1.wireless</tt>.'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless LAN interface.'}
,'FirstWireless':{syn:'Starts the enumeration of wireless LAN interfaces currently accessible.',lib:'YWireless.FirstWireless()',pro:'FirstWireless()',cmt:'<p>Starts the enumeration of wireless LAN interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless LAN interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless LAN interface currently online, or a <tt>null</tt> pointer if there are none.'}
,'adhocNetwork':{syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'%.adhocNetwork()',pro:'adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g and YoctoHub-Wireless-n, you should use <tt>softAPNetwork()</tt> instead, which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'clearCache':{syn:'Invalidates the cache.',lib:'%.clearCache()',pro:'clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wireless LAN interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'}
,'describe':{syn:'Returns a short text that describes unambiguously the instance of the wireless LAN interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'%.describe()',pro:'describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wireless LAN interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wireless LAN interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'}
,'get_advertisedValue':{syn:'Returns the current value of the wireless LAN interface (no more than 6 characters).',lib:'%.get_advertisedValue()',pro:'get_advertisedValue()',cmt:'<p>Returns the current value of the wireless LAN interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless LAN interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>YWireless.ADVERTISEDVALUE_INVALID</tt>.'}
,'get_channel':{syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'%.get_channel()',pro:'get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:'On failure, throws an exception or returns <tt>YWireless.CHANNEL_INVALID</tt>.'}
,'get_detectedWlans':{syn:'Returns a list of <tt>YWlanRecord</tt> objects that describe detected Wireless networks.',lib:'%.get_detectedWlans()',pro:'get_detectedWlans()',cmt:'<p>Returns a list of <tt>YWlanRecord</tt> objects that describe detected Wireless networks. This list is not updated when the module is already connected to an access point (infrastructure mode). To force an update of this list, <tt>startWlanScan()</tt> must be called. Note that an languages without garbage collections, the returned list must be freed by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:'On failure, throws an exception or returns an empty list.'}
,'get_errorMessage':{syn:'Returns the error message of the latest error with the wireless LAN interface.',lib:'%.get_errorMessage()',pro:'get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wireless LAN interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wireless LAN interface object'}
,'get_errorType':{syn:'Returns the numerical error code of the latest error with the wireless LAN interface.',lib:'%.get_errorType()',pro:'get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wireless LAN interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wireless LAN interface object'}
,'get_friendlyName':{syn:'Returns a global identifier of the wireless LAN interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'%.get_friendlyName()',pro:'get_friendlyName()',cmt:'<p>Returns a global identifier of the wireless LAN interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wireless LAN interface if they are defined, otherwise the serial number of the module and the hardware identifier of the wireless LAN interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wireless LAN interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWireless.FRIENDLYNAME_INVALID</tt>.'}
,'get_functionDescriptor':ds.get_functionDescriptor
,'get_functionId':{syn:'Returns the hardware identifier of the wireless LAN interface, without reference to the module.',lib:'%.get_functionId()',pro:'get_functionId()',cmt:'<p>Returns the hardware identifier of the wireless LAN interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wireless LAN interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWireless.FUNCTIONID_INVALID</tt>.'}
,'get_hardwareId':{syn:'Returns the unique hardware identifier of the wireless LAN interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'%.get_hardwareId()',pro:'get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wireless LAN interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wireless LAN interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wireless LAN interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>YWireless.HARDWAREID_INVALID</tt>.'}
,'get_linkQuality':{syn:'Returns the link quality, expressed in percent.',lib:'%.get_linkQuality()',pro:'get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>YWireless.LINKQUALITY_INVALID</tt>.'}
,'get_logicalName':{syn:'Returns the logical name of the wireless LAN interface.',lib:'%.get_logicalName()',pro:'get_logicalName()',cmt:'<p>Returns the logical name of the wireless LAN interface.</p>',ret:'a string corresponding to the logical name of the wireless LAN interface.',ext:'On failure, throws an exception or returns <tt>YWireless.LOGICALNAME_INVALID</tt>.'}
,'get_message':{syn:'Returns the latest status message from the wireless interface.',lib:'%.get_message()',pro:'get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>YWireless.MESSAGE_INVALID</tt>.'}
,'get_module':ds.get_module
,'get_security':{syn:'Returns the security algorithm used by the selected wireless network.',lib:'%.get_security()',pro:'get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>YWireless.SECURITY_UNKNOWN</tt>, <tt>YWireless.SECURITY_OPEN</tt>, <tt>YWireless.SECURITY_WEP</tt>, <tt>YWireless.SECURITY_WPA</tt> and <tt>YWireless.SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>YWireless.SECURITY_INVALID</tt>.'}
,'get_serialNumber':ds.get_serialNumber
,'get_ssid':{syn:'Returns the wireless network name (SSID).',lib:'%.get_ssid()',pro:'get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>YWireless.SSID_INVALID</tt>.'}
,'get_userData':dm.get_userData
,'get_wlanState':{syn:'Returns the current state of the wireless interface.',lib:'%.get_wlanState()',pro:'get_wlanState()',cmt:'<p>Returns the current state of the wireless interface. The state <tt>YWireless.WLANSTATE_DOWN</tt> means that the network interface is not connected to a network. The state <tt>YWireless.WLANSTATE_SCANNING</tt> means that the network interface is scanning available frequencies. During this stage, the device is not reachable, and the network settings are not yet applied. The state <tt>YWireless.WLANSTATE_CONNECTED</tt> means that the network settings have been successfully applied ant that the device is reachable from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that the wireless network is up and that other devices can join the network. The state <tt>YWireless.WLANSTATE_REJECTED</tt> means that the network interface has not been able to join the requested network. The description of the error can be obtain with the <tt>get_message()</tt> method.</p>',ret:'a value among <tt>YWireless.WLANSTATE_DOWN</tt>, <tt>YWireless.WLANSTATE_SCANNING</tt>, <tt>YWireless.WLANSTATE_CONNECTED</tt> and <tt>YWireless.WLANSTATE_REJECTED</tt> corresponding to the current state of the wireless interface',ext:'On failure, throws an exception or returns <tt>YWireless.WLANSTATE_INVALID</tt>.'}
,'isOnline':{syn:'Checks if the wireless LAN interface is currently reachable, without raising any error.',lib:'%.isOnline()',pro:'isOnline()',cmt:'<p>Checks if the wireless LAN interface is currently reachable, without raising any error. If there is a cached value for the wireless LAN interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wireless LAN interface.</p>',ret:'<tt>true</tt> if the wireless LAN interface can be reached, and <tt>false</tt> otherwise'}
,'isReadOnly':ds.isReadOnly
,'joinNetwork':{syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'%.joinNetwork()',pro:'joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'load':{syn:'Preloads the wireless LAN interface cache with a specified validity duration.',lib:'%.load()',pro:'load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wireless LAN interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'loadAttribute':ds.loadAttribute
,'muteValueCallbacks':ds.muteValueCallbacks
,'nextWireless':{syn:'Continues the enumeration of wireless LAN interfaces started using <tt>yFirstWireless()</tt>.',lib:'%.nextWireless()',pro:'nextWireless()',cmt:'<p>Continues the enumeration of wireless LAN interfaces started using <tt>yFirstWireless()</tt>. Caution: You can\x27t make any assumption about the returned wireless LAN interfaces order. If you want to find a specific a wireless LAN interface, use <tt>Wireless.findWireless()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless LAN interface currently online, or a <tt>null</tt> pointer if there are no more wireless LAN interfaces to enumerate.'}
,'registerValueCallback':ds.registerValueCallback
,'set_logicalName':{syn:'Changes the logical name of the wireless LAN interface.',lib:'%.set_logicalName()',pro:'set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless LAN interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless LAN interface.'},ret:'<tt>YAPI.SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'set_userData':dm.set_userData
,'softAPNetwork':{syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'%.softAPNetwork()',pro:'softAPNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g and the YoctoHub-Wireless-n.</p><p> On the YoctoHub-Wireless-g, when a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security.</p><p> On the YoctoHub-Wireless-n, when a security key is specified for a SoftAP network, the network will be protected by WPA2.</p><p> Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'}
,'startWlanScan':{syn:'Triggers a scan of the wireless frequency and builds the list of available networks.',lib:'%.startWlanScan()',pro:'startWlanScan()',cmt:'<p>Triggers a scan of the wireless frequency and builds the list of available networks. The scan forces a disconnection from the current network. At then end of the process, the the network interface attempts to reconnect to the previous network. During the scan, the <tt>wlanState</tt> switches to <tt>YWireless.WLANSTATE_DOWN</tt>, then to <tt>YWireless.WLANSTATE_SCANNING</tt>. When the scan is completed, <tt>get_wlanState()</tt> returns either <tt>YWireless.WLANSTATE_DOWN</tt> or <tt>YWireless.WLANSTATE_SCANNING</tt>. At this point, the list of detected network can be retrieved with the <tt>get_detectedWlans()</tt> method.</p><p> On failure, throws an exception or returns a negative error code.</p>'}
,'unmuteValueCallbacks':ds.unmuteValueCallbacks
};
//--- (end of generated code: Wireless)
//--- (generated code: WlanRecord)
doc['WlanRecord']={'':{syn:'Wireless network description, returned by <tt>wireless.get_detectedWlans</tt> method',inc:'from yocto_wireless import *',cmt:'<p><tt>YWlanRecord</tt> objects are used to describe a wireless network. These objects are used in particular in conjunction with the <tt>YWireless</tt> class.</p>'}
,'get_channel':{syn:'Returns the 802.11 b/g/n channel number used by this network.',lib:'%.get_channel()',pro:'get_channel()',cmt:'<p>Returns the 802.11 b/g/n channel number used by this network.</p>',ret:'an integer corresponding to the channel.'}
,'get_linkQuality':{syn:'Returns the quality of the wireless network link, in per cents.',lib:'%.get_linkQuality()',pro:'get_linkQuality()',cmt:'<p>Returns the quality of the wireless network link, in per cents.</p>',ret:'an integer between 0 and 100 corresponding to the signal quality.'}
,'get_security':{syn:'Returns the security algorithm used by the wireless network.',lib:'%.get_security()',pro:'get_security()',cmt:'<p>Returns the security algorithm used by the wireless network. If the network implements to security, the value is <tt>\x22OPEN\x22</tt>.</p>',ret:'a string with the security algorithm.'}
,'get_ssid':{syn:'Returns the name of the wireless network (SSID).',lib:'%.get_ssid()',pro:'get_ssid()',cmt:'<p>Returns the name of the wireless network (SSID).</p>',ret:'a string with the name of the wireless network (SSID).'}
};
//--- (end of generated code: WlanRecord)
//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'from yocto_api import *',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}
,'AddTrustedCertificates':{syn:'Adds a TLS/SSL certificate to the list of trusted certificates.',lib:'YAPI.AddTrustedCertificates()',pro:'AddTrustedCertificates(<span id=pn>certificate</span>)',cmt:'<p>Adds a TLS/SSL certificate to the list of trusted certificates. By default, the library library will reject TLS/SSL connections to servers whose certificate is not known. This function function allows to add a list of known certificates. It is also possible to disable the verification using the SetNetworkSecurityOptions method.</p>',par:{certificate:'a string containing one or more certificates.'},ret:'an empty string if the certificate has been added correctly. In case of error, returns a string starting with \x22error:\x22.'}
,'AddUdevRule':{syn:'Adds a UDEV rule which authorizes all users to access Yoctopuce modules connected to the USB ports.',lib:'YAPI.AddUdevRule()',pro:'AddUdevRule(<span id=pn>force</span>)',cmt:'<p>Adds a UDEV rule which authorizes all users to access Yoctopuce modules connected to the USB ports. This function works only under Linux. The process that calls this method must have root privileges because this method changes the Linux configuration.</p>',par:{force:'if true, overwrites any existing rule.'},ret:'an empty string if the rule has been added.',ext:'On failure, returns a string that starts with \x22error:\x22.'}
,'CheckLogicalName':{syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI.CheckLogicalName()',pro:'CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A...Z</tt>, <tt>a...z</tt>, <tt>0...9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'}
,'DisableExceptions':{syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI.DisableExceptions()',pro:'DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'}
,'DownloadHostCertificate':{syn:'Download the TLS/SSL certificate from the hub.',lib:'YAPI.DownloadHostCertificate()',pro:'DownloadHostCertificate(<span id=pn>url</span>, <span id=pn>mstimeout</span>)',cmt:'<p>Download the TLS/SSL certificate from the hub. This function allows to download a TLS/SSL certificate to add it to the list of trusted certificates using the AddTrustedCertificates method.</p>',par:{url:'the root URL of the VirtualHub V2 or HTTP server.',mstimeout:'the number of milliseconds available to download the certificate.'},ret:'a string containing the certificate. In case of error, returns a string starting with \x22error:\x22.'}
,'EnableExceptions':{syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI.EnableExceptions()',pro:'EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program.</p>'}
,'FreeAPI':{syn:'Waits for all pending communications with Yoctopuce devices to be completed then frees dynamically allocated resources used by the Yoctopuce library.',lib:'YAPI.FreeAPI()',pro:'FreeAPI()',cmt:'<p>Waits for all pending communications with Yoctopuce devices to be completed then frees dynamically allocated resources used by the Yoctopuce library.</p><p> From an operating system standpoint, it is generally not required to call this function since the OS will automatically free allocated resources once your program is completed. However, there are two situations when you may really want to use that function:</p><p> - Free all dynamically allocated memory blocks in order to track a memory leak.</p><p> - Send commands to devices right before the end of the program. Since commands are sent in an asynchronous way the program could exit before all commands are effectively sent.</p><p> You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'}
,'GetAPIVersion':{syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI.GetAPIVersion()',pro:'GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'}
,'GetCacheValidity':{syn:'Returns the validity period of the data loaded by the library.',lib:'YAPI.GetCacheValidity()',pro:'GetCacheValidity()',cmt:'<p>Returns the validity period of the data loaded by the library. This method returns the cache validity of all attributes module functions. Note: This function must be called after <tt>yInitAPI </tt>.</p>',ret:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'}
,'GetDeviceListValidity':{syn:'Returns the delay between each forced enumeration of the used YoctoHubs.',lib:'YAPI.GetDeviceListValidity()',pro:'GetDeviceListValidity()',cmt:'<p>Returns the delay between each forced enumeration of the used YoctoHubs. Note: you must call this function after <tt>yInitAPI</tt>.</p>',ret:'the number of seconds between each enumeration.'}
,'GetNetworkTimeout':{syn:'Returns the network connection delay for <tt>yRegisterHub()</tt> and <tt>yUpdateDeviceList()</tt>.',lib:'YAPI.GetNetworkTimeout()',pro:'GetNetworkTimeout()',cmt:'<p>Returns the network connection delay for <tt>yRegisterHub()</tt> and <tt>yUpdateDeviceList()</tt>. This delay impacts only the YoctoHubs and VirtualHub which are accessible through the network. By default, this delay is of 20000 milliseconds, but depending on your network you may want to change this delay, for example if your network infrastructure is based on a GSM connection.</p>',ret:'the network connection delay in milliseconds.'}
,'GetTickCount':{syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI.GetTickCount()',pro:'GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the millisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'}
,'GetYAPISharedLibraryPath':{syn:'Returns the path to the dynamic YAPI library.',lib:'YAPI.GetYAPISharedLibraryPath()',pro:'GetYAPISharedLibraryPath()',cmt:'<p>Returns the path to the dynamic YAPI library. This function is useful for debugging problems loading the dynamic library YAPI. This function is supported by the C#, Python and VB languages. The other libraries return an empty string.</p>',ret:'a string containing the path of the YAPI dynamic library.'}
,'HandleEvents':{syn:'Maintains the device-to-library communication channel.',lib:'YAPI.HandleEvents()',pro:'HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'InitAPI':{syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI.InitAPI()',pro:'InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>YAPI.DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>YAPI.DETECT_NONE</tt>, <tt>YAPI.DETECT_USB</tt>, <tt>YAPI.DETECT_NET</tt>, and <tt>YAPI.DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'PreregisterHub':{syn:'Fault-tolerant alternative to <tt>yRegisterHub()</tt>.',lib:'YAPI.PreregisterHub()',pro:'PreregisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Fault-tolerant alternative to <tt>yRegisterHub()</tt>. This function has the same purpose and same arguments as <tt>yRegisterHub()</tt>, but does not trigger an error when the selected hub is not available at the time of the function call. If the connexion cannot be established immediately, a background task will automatically perform periodic retries. This makes it possible to register a network hub independently of the current connectivity, and to try to contact it only when a device is actively needed.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'RegisterDeviceArrivalCallback':{syn:'Register a callback function, to be called each time a device is plugged.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is plugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}}
,'RegisterDeviceRemovalCallback':{syn:'Register a callback function, to be called each time a device is unplugged.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unplugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}}
,'RegisterHub':{syn:'Set up the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI.RegisterHub()',pro:'RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Set up the Yoctopuce library to use modules connected on a given machine. Idealy this call will be made once at the begining of your application. The parameter will determine how the API will work. Use the following values:</p><p> <b>usb</b>: When the <ui>usb</ui> keyword is used, the API will work with devices connected directly to the USB bus. Some programming languages such a JavaScript, PHP, and Java don\x27t provide direct access to USB hardware, so <ui>usb</ui> will not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).</p><p> <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the host with the given IP address or hostname. That host can be a regular computer running a <i>native VirtualHub</i>, a <i>VirtualHub for web</i> hosted on a server, or a networked YoctoHub such as YoctoHub-Ethernet or YoctoHub-Wireless. If you want to use the VirtualHub running on you local computer, use the IP address 127.0.0.1. If the given IP is unresponsive, <tt>yRegisterHub</tt> will not return until a time-out defined by <tt>ySetNetworkTimeout</tt> has elapsed. However, it is possible to preventively test a connection with <tt>yTestHub</tt>. If you cannot afford a network time-out, you can use the non-blocking <tt>yPregisterHub</tt> function that will establish the connection as soon as it is available. </p><p> <b>callback</b>: that keyword make the API run in \x22<i>HTTP Callback</i>\x22 mode. This a special mode allowing to take control of Yoctopuce devices through a NAT filter when using a VirtualHub or a networked YoctoHub. You only need to configure your hub to call your server script on a regular basis. This mode is currently available for PHP and Node.JS only.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to set up the library to use the VirtualHub rather than direct USB access.</p><p> If access control has been activated on the hub, virtual or not, you want to reach, the URL parameter should look like:</p><p> <tt>http://username:password@address:port</tt></p><p> You can call <i>RegisterHub</i> several times to connect to several machines. On the other hand, it is useless and even counterproductive to call <i>RegisterHub</i> with to same address multiple times during the life of the application.\x09\x09 </p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'RegisterHubDiscoveryCallback':{syn:'Register a callback function, to be called each time an Network Hub send an SSDP message.',lib:'YAPI.RegisterHubDiscoveryCallback()',pro:'RegisterHubDiscoveryCallback(<span id=pn>hubDiscoveryCallback</span>)',cmt:'<p>Register a callback function, to be called each time an Network Hub send an SSDP message. The callback has two string parameter, the first one contain the serial number of the hub and the second contain the URL of the network hub (this URL can be passed to RegisterHub). This callback will be invoked while yUpdateDeviceList is running. You will have to call this function on a regular basis.</p>',par:{hubDiscoveryCallback:'a procedure taking two string parameter, the serial number and the hub URL. Use <tt>null</tt> to unregister a previously registered callback.'}}
,'RegisterLogFunction':{syn:'Registers a log callback function.',lib:'YAPI.RegisterLogFunction()',pro:'RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite useful to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}}
,'SelectArchitecture':{syn:'Select the architecture or the library to be loaded to access to USB.',lib:'YAPI.SelectArchitecture()',pro:'SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>Select the architecture or the library to be loaded to access to USB. By default, the Python library automatically detects the appropriate library to use. However, for Linux ARM, it not possible to reliably distinguish between a Hard Float (armhf) and a Soft Float (armel) install. For in this case, it is therefore recommended to manually select the proper architecture by calling <tt>SelectArchitecture()</tt> before any other call to the library.</p>',par:{arch:'A string containing the architecture to use. Possibles value are: <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22aarch64\x22</tt>,<tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>, <tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'nothing.',ext:'On failure, throws an exception.'}
,'SetCacheValidity':{syn:'Change the validity period of the data loaded by the library.',lib:'YAPI.SetCacheValidity()',pro:'SetCacheValidity(<span id=pn>cacheValidityMs</span>)',cmt:'<p>Change the validity period of the data loaded by the library. By default, when accessing a module, all the attributes of the module functions are automatically kept in cache for the standard duration (5 ms). This method can be used to change this standard duration, for example in order to reduce network or USB traffic. This parameter does not affect value change callbacks Note: This function must be called after <tt>yInitAPI</tt>.</p>',par:{cacheValidityMs:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds.'}}
,'SetDeviceListValidity':{syn:'Modifies the delay between each forced enumeration of the used YoctoHubs.',lib:'YAPI.SetDeviceListValidity()',pro:'SetDeviceListValidity(<span id=pn>deviceListValidity</span>)',cmt:'<p>Modifies the delay between each forced enumeration of the used YoctoHubs. By default, the library performs a full enumeration every 10 seconds. To reduce network traffic, you can increase this delay. It\x27s particularly useful when a YoctoHub is connected to the GSM network where traffic is billed. This parameter doesn\x27t impact modules connected by USB, nor the working of module arrival/removal callbacks. Note: you must call this function after <tt>yInitAPI</tt>.</p>',par:{deviceListValidity:'nubmer of seconds between each enumeration.'}}
,'SetNetworkSecurityOptions':{syn:'Enables or disables certain TLS/SSL certificate checks.',lib:'YAPI.SetNetworkSecurityOptions()',pro:'SetNetworkSecurityOptions(<span id=pn>opts</span>)',cmt:'<p>Enables or disables certain TLS/SSL certificate checks.</p>',par:{opts:'The options are <tt>YAPI.NO_TRUSTED_CA_CHECK</tt>, <tt>YAPI.NO_EXPIRATION_CHECK</tt>, <tt>YAPI.NO_HOSTNAME_CHECK</tt>.'},ret:'an empty string if the options are taken into account. On error, returns a string beginning with \x22error:\x22.'}
,'SetNetworkTimeout':{syn:'Modifies the network connection delay for <tt>yRegisterHub()</tt> and <tt>yUpdateDeviceList()</tt>.',lib:'YAPI.SetNetworkTimeout()',pro:'SetNetworkTimeout(<span id=pn>networkMsTimeout</span>)',cmt:'<p>Modifies the network connection delay for <tt>yRegisterHub()</tt> and <tt>yUpdateDeviceList()</tt>. This delay impacts only the YoctoHubs and VirtualHub which are accessible through the network. By default, this delay is of 20000 milliseconds, but depending on your network you may want to change this delay, gor example if your network infrastructure is based on a GSM connection.</p>',par:{networkMsTimeout:'the network connection delay in milliseconds.'}}
,'SetTrustedCertificatesList':{syn:'Set the path of Certificate Authority file on local filesystem.',lib:'YAPI.SetTrustedCertificatesList()',pro:'SetTrustedCertificatesList(<span id=pn>certificatePath</span>)',cmt:'<p>Set the path of Certificate Authority file on local filesystem. This method takes as a parameter the path of a file containing all certificates in PEM format. For technical reasons, only one file can be specified. So if you need to connect to several Hubs instances with self-signed certificates, you\x27ll need to use a single file containing all the certificates end-to-end. Passing a empty string will restore the default settings. This option is only supported by PHP library.</p>',par:{certificatePath:'the path of the file containing all certificates in PEM format.'},ret:'an empty string if the certificate has been added correctly. In case of error, returns a string starting with \x22error:\x22.'}
,'Sleep':{syn:'Pauses the execution flow for a specified duration.',lib:'YAPI.Sleep()',pro:'Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significantly. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'TestHub':{syn:'Test if the hub is reachable.',lib:'YAPI.TestHub()',pro:'TestHub(<span id=pn>url</span>, <span id=pn>mstimeout</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Test if the hub is reachable. This method do not register the hub, it only test if the hub is usable. The url parameter follow the same convention as the <tt>yRegisterHub</tt> method. This method is useful to verify the authentication parameters for a hub. It is possible to force this method to return after mstimeout milliseconds.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',mstimeout:'the number of millisecond available to test the connection.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
,'TriggerHubDiscovery':{syn:'Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.',lib:'YAPI.TriggerHubDiscovery()',pro:'TriggerHubDiscovery(<span id=pn>errmsg</span>=None)',cmt:'<p>Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds. On failure returns a negative error code.'}
,'UnregisterHub':{syn:'Set up the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Set up the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}}
,'UpdateDeviceList':{syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI.UpdateDeviceList()',pro:'UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events. However, since device detection is quite a heavy process, UpdateDeviceList shouldn\x27t be called more than once every two seconds.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI.SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'}
};
//--- (end of generated code: YAPI)
//--- (end of generated code)
function isProperty(clname,m){return doc[clname][m].lib.indexOf('(')==-1&&Language!='Objective-C';}
function isClassMethod(clname,m){return(clname=='YAPI'&&doc[clname][m].pro?doc[clname][m].pro.indexOf('static')>=0:/^[A-Z].*/.test(m));}
function MethodType(clname,m){return(isProperty(clname,m)?'property':isClassMethod(clname,m)?'static':'method');}
var isCmdLine=(Language.substr(0,3)=='Cmd');var isProxy=(Language.substr(-5)=='Proxy');function ApplySub(text,clname,attrname){var pos,endpos=0,key,rep,prefix,skip,cname,aprefix;if(!text)return'';prefix=(clname.substr(0,1)!='Y'?'Y'+clname:clname);if(/^[gs]et_.*/.test(attrname))attrname=attrname.substr(4);skip=2;if(isProxy){prefix=clname.toLowerCase()+'._';if(attrname!='mountPosition'&&attrname!='drawText'){skip+=attrname.length;prefix+=attrname.substr(0,1).toUpperCase()+attrname.substr(1);}}else if(sub['YAPI_SUCCESS']&&!isCmdLine){prefix=sub['YAPI_SUCCESS'].replace('YAPI',prefix).replace('SUCCESS','');}else{prefix+='.';}
while((pos=text.toLowerCase().indexOf('<tt>',endpos))>=endpos){pos+=4;endpos=text.indexOf('</',pos);inside=text.substr(pos,endpos-pos);rep=false;if(isCmdLine&&inside.startsWith('YDisplayLayer.ALIGN')){rep=inside.replace(/YDisplayLayer.ALIGN(_)*/,'');}else if(sub[inside]){rep=sub[inside];}else if((key=inside.match(/^(\w+_)+\w+$/))!==null){key=key[0];rep=sub[key];if(!rep&&key.substr(0,2)=='Y_'&&!UseShortcuts){if(isCmdLine){rep=key.substr(2+attrname.length,key.length);}else{rep=prefix+key.substr(skip,key.length);}}}else if(isCmdLine&&inside.startsWith(prefix+attrname.toUpperCase()+'_')){rep=inside.substr(prefix.length+attrname.length+1);}else if((key=inside.match(/^Y[A-Za-z0-9]+$/))!==null){key=key[0].substr(1);if(doc[key]){cname='Y'+key;if(doc.Files.get_module&&doc.Files.get_module.pro.indexOf('Proxy')>0&&text.substr(pos-7,2)!='VI'&&text.substr(endpos+6,2)!='VI'){cname+='Proxy';}
rep='<a href="javascript:Show(\''+key+'\',\'\')">'+cname+'</a>';}}else if((key=inside.match(/^y([A-Z][A-Za-z0-9]+).*/))!==null){ident=key[1];key=key[0].substr(1);if(key.match(/(First|Find)[A-Za-z0-9]+.*/)){if(!UseShortcuts)rep=inside.substr(1);}else{if(!UseShortcuts){rep=sub['YAPI_SUCCESS'].replace('SUCCESS',inside.substr(1));if(doc['YAPI'][ident]){rep='<a href="javascript:Show(\'YAPI\',\''+ident+'\')">'+rep+'</a>';}}else{if(doc['YAPI'][ident]){rep='<a href="javascript:Show(\'YAPI\',\''+ident+'\')">'+inside+'</a>';}}}}else if((key=inside.match(/^([A-Za-z][A-Za-z0-9]+)(\.|::)([A-Za-z_0-9]+).*/))!==null){cident=key[1].substr(0,1).toUpperCase()+key[1].substr(1);mident=key[3];if(cident.substr(0,4)!='YAPI'&&cident[0]=='Y')cident=cident.substr(1);if(cident.match(/.*Proxy$/))cident=cident.slice(0,-5);if(!UseShortcuts){rep=inside;}else if(mident.match(/(First|Find)[A-Za-z0-9]+.*/)||cident=='YAPI'){rep='y'+mident;}
if(doc[cident]&&doc[cident][mident]){rep='<a href="javascript:Show(\''+cident+'\',\''+mident+'\')">'+rep+'</a>';}}else if((key=inside.match(/^(saveToFlash|isOnline).*/))!==null){rep='<a href="javascript:Show(\'Module\',\''+key[1]+'\')">'+inside+'</a>';}
if(rep){text=text.substr(0,pos)+rep+text.substr(endpos);endpos=pos+rep.length;}}
return text;}
function wdg(n){return document.getElementById(n);}
function SetPosition(o,x,y){var it=wdg(o);it.style.top=y;it.style.left=x;}
function GetPositionX(o){var it=wdg(o);return parseInt(it.style.left);}
function GetPositionY(o){var it=wdg(o);return parseInt(it.style.top);}
function GetWidth(o){var it=wdg(o);return parseInt(it.style.width);}
function GetHeight(o){var it=wdg(o);return parseInt(it.style.height);}
function SetHeight(o,h){var it=wdg(o);h=parseInt(h);if(h<0)h=0;it.style.height=h+"px";}
function SetWidth(o,w){var it=wdg(o);w=parseInt(w);if(w<0)w=0;it.style.width=parseInt(w)+"px";}
function SetLeft(o,l){var it=wdg(o);it.style.left=parseInt(l)+"px";}
function SetTop(o,t){var it=wdg(o);it.style.top=parseInt(t)+"px";}
function SetSize(o,w,h){var it=wdg(o);w=parseInt(w);if(w<0)w=0;h=parseInt(h);if(h<0)h=0;it.style.width=w;it.style.height=h;}
function GetWindowWidth(){return parseInt(document.body.clientWidth);}
function GetWindowHeight(){return parseInt(document.body.clientHeight);}
function computeWinWH(){WinW=GetWindowWidth()-2;if(WinW<600)WinW=600;WinH=GetWindowHeight()-2;if(WinH<400)WinH=400;}
function getInnerHeight(){var D=document;return Math.max(Math.max(D.body.scrollHeight,D.documentElement.scrollHeight),Math.max(D.body.offsetHeight,D.documentElement.offsetHeight),Math.max(D.body.clientHeight,D.documentElement.clientHeight));}
function getInnerWidth(){var D=document;return Math.max(Math.max(D.body.scrollWidth,D.documentElement.scrollWidth),Math.max(D.body.offsetWidth,D.documentElement.offsetWidth),Math.max(D.body.clientWidth,D.documentElement.clientWidth));}
function onResize(fct){fct();resizeCallBacks[resizeCallBacks.length]=fct;}
function windowResized(){computeWinWH()
for(var i=0;i<resizeCallBacks.length;i++)
resizeCallBacks[i]();}
function jsQuote(str_in){str_in=str_in+'';var str_out='';for(i=0;i<str_in.length;i++){var ascii=str_in.charCodeAt(i);if((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39))str_out=str_out+str_in.charAt(i);else{var hex=ascii.toString(16).toUpperCase();if(hex.length==1)hex='0'+hex;str_out=str_out+String.fromCharCode(92)+'x'+hex;}}
return str_out;}
function resizeMargin(){SetSize("MarginLayer",marginSize,WinH-110);SetLeft("FunctionsLayer",marginSize);SetSize("FunctionsLayer",WinW-marginSize,WinH-110);}
function resizeSeparator(){SetHeight("separatorLayer",WinH-110);}
function positionObject(int_x,int_y){this.x=int_x;this.y=int_y;}
function GetEventPosition(event){var x,y;if(event.changedTouches){x=event.changedTouches[0].pageX;y=event.changedTouches[0].pageY;}
else{x=event.PageX;y=event.PageY;if(!x){x=event.clientX+document.body.scrollLeft;y=event.clientY+document.body.scrollTop;}}
return new positionObject(x,y);}
function EnableDrag(var_element,onDragMove,onDragEnd){if(document.addEventListener){var_element.addEventListener("mousedown",Drag_start,false);var_element.addEventListener("touchstart",Drag_start,false);}
else
if(document.attachEvent)
var_element.attachEvent("onmousedown",Drag_start);if(onDragMove)var_element.onDragMove=onDragMove;if(onDragEnd)var_element.onDragEnd=onDragEnd;}
var LastDraggedObject=null;function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos){this.element=obj_element;this.elmtInitialPos=obj_elmtInitialPos;this.elmtCurrentPos=new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);this.mouseInitialPos=obj_mouseInitalPos;}
function Drag_start(event){if(!event)event=window.event;var source=event.srcElement;if(event.button!=undefined){if((event.button!=1)&&(document.attachEvent))return;if((event.button!=0)&&(document.addEventListener))return;}
if(!source)source=this;if(!source)return;var originalsource=source;while(source.tagName!="DIV"){if(source.tagName=="A")return false;source=source.parentNode;}
if(event.preventDefault)event.preventDefault();source.style.cursor="col-resize";lastDraggedObject=new DraggedObject(source,new positionObject(parseInt(source.style.left),parseInt(source.style.top)),GetEventPosition(event));if(document.addEventListener){document.addEventListener("mousemove",Drag_mouseCapture,false);document.addEventListener("mouseup",Drag_stopMouseCapture,false);document.addEventListener("touchmove",Drag_mouseCapture,false);document.addEventListener("touchend",Drag_stopMouseCapture,false);}
else
if(document.attachEvent){document.attachEvent("onmousemove",Drag_mouseCapture);document.attachEvent("onmouseup",Drag_stopMouseCapture);}
document.onmouseup=Drag_stopMouseCapture;}
function Drag_mouseCapture(event){if(!event)event=window.event;var position=GetEventPosition(event);if(event.preventDefault)event.preventDefault();var x=(lastDraggedObject.elmtInitialPos.x+position.x-lastDraggedObject.mouseInitialPos.x);var y=(lastDraggedObject.elmtInitialPos.y+position.y-lastDraggedObject.mouseInitialPos.y);var iw=getInnerWidth()
var ih=getInnerHeight();var w=lastDraggedObject.element.offsetWidth;var h=lastDraggedObject.element.offsetHeight;if(x>iw-w)x=iw-w;if(y>ih-h)y=ih-h;if(x<0)x=0;if(y<0)y=0;var p={x:x,y:y};if(lastDraggedObject.element.onDragMove)
lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);lastDraggedObject.elmtCurrentPos.x=p.x;lastDraggedObject.elmtCurrentPos.y=p.y;lastDraggedObject.element.style.left=p.x+"px";lastDraggedObject.element.style.top=p.y+"px";}
function Drag_stopMouseCapture(){if(document.removeEventListener){document.removeEventListener("mousemove",Drag_mouseCapture,false);document.removeEventListener("mouseup",Drag_stopMouseCapture,false);document.removeEventListener("touchmove",Drag_mouseCapture,false);document.removeEventListener("touchend",Drag_stopMouseCapture,false);}
else
if(document.detachEvent){document.detachEvent("onmousemove",Drag_mouseCapture);document.detachEvent("onmouseup",Drag_stopMouseCapture);}
if(lastDraggedObject){lastDraggedObject.element.style.cursor='col-resize';if(lastDraggedObject.element.onDragEnd)
lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});}
lastDraggedObject=null;}
function marginMove(el,pos){pos.y=80;if(pos.x<100)pos.x=100;if(pos.x>WinW-100)pos.x=WinW-100;marginSize=pos.x;resizeMargin()}
function proto(clname,m){var funcproto=doc[clname][m].pro;if(isClassMethod(clname,m)){if(UseShortcuts){funcproto=funcproto.replace(m,'y'+m);}else if(doc[clname][m].lib.substr(0,1)=='['&&funcproto.substr(0,1)!='+'){var params=doc[clname][m].par;var methodpos=funcproto.search(m);var endrettype=methodpos;while(endrettype>0&&funcproto.substr(endrettype-1,1)==' ')endrettype--;var newproto="+("+funcproto.substr(0,endrettype)+") "+m;var pos=methodpos+m.length;for(var p in params){pos+=funcproto.slice(pos).search(/[A-Za-z]/);var argpos=pos+funcproto.slice(pos).search('<span');var endargtype=argpos;while(endargtype>pos&&funcproto.substr(endargtype-1,1)==' ')endargtype--;var endarg=argpos+funcproto.slice(argpos).search(/[,)]/);newproto+=": ("+funcproto.slice(pos,endargtype)+") "+funcproto.slice(argpos,endarg)+" ";pos=endarg;}
funcproto=newproto;}}
return funcproto}
var lastindex_shown="";var lastname_shown=null;function Show(clname,str_name,nohist){if(!clname&&!str_name){wdg("FunctionsLayerInner").innerHTML=NotFound;return;}
var fcthtml=NotFound;lastindex_shown=clname;if(clname&&str_name&&doc[clname]&&doc[clname][str_name]){lastname_shown=str_name;var fct=doc[clname][str_name];var funcname=fct.lib.replace('%',clname.toLowerCase());var funcproto=proto(clname,str_name);if(UseShortcuts&&isClassMethod(clname,str_name)){funcname='y'+str_name+'()';}
fcthtml="<a class='funcHeader' href='#"+clname+"."+str_name+"'>"+funcname+'</a>'
+"<br><br><span class='prototype'>"+funcproto+'</span>'
+'<br><br>'+ApplySub(fct.cmt,clname,str_name);if(fct.par){fcthtml+="<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';fcthtml+='<table class="paramtable">'
for(var p in fct.par)
fcthtml+='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],clname,str_name)+'</td></tr>\n';fcthtml+='</table><br>'}
if(fct.ret){fcthtml+="<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';fcthtml+='<p class="paramtable">'+ApplySub(fct.ret,clname,str_name)+'</p>\n';}
if(fct.ext)fcthtml+=ApplySub(fct.ext,clname,str_name);var newstate=clname+'.'+str_name;if(newstate!=history.state&&!nohist){history.pushState(newstate,newstate,'#'+newstate);}}
else
if(clname&&doc[clname]){fcthtml="<a class='funcHeader' href='#"+clname+"'>"+clname+'</a><br>'
+"<p>"+ApplySub(doc[clname][''].syn,clname,str_name)+"</p>"
+(doc[clname][''].inc!=""?"<p>"+IncludeLabel+"</p><p class='include'>"+doc[clname][''].inc+"</p>":"")
+"<p>"+ApplySub(doc[clname][''].cmt,clname,str_name)+"</p>";var prevmtype='';for(m in doc[clname]){if(m!=''){var funcproto=proto(clname,m);var mtype=MethodType(clname,m);if(prevmtype!=mtype){prevmtype=mtype;fcthtml+="<span class='subHeader'>"+MethodTypes[mtype]+"</span>";if(clname!='YAPI'){fcthtml+="<p>"+MethodExtra[mtype]+"</p>";}}
fcthtml+="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+clname+"\",\""+m+"\")'>"+funcproto+'</a><br>'
+"<span class='synlist'>"+ApplySub(doc[clname][m].syn,clname,str_name)+'</span></p>';}}
var newstate=clname;if(newstate!=history.state&&!nohist){history.pushState(newstate,newstate,'#'+newstate);}}
wdg("FunctionsLayerInner").innerHTML=fcthtml;setTimeout("wdg('FunctionsLayer').scrollTop=0;",20);}
function expand(source,openonly){if(wdg(source.id+"List").style.display==''&&!openonly){wdg(source.id+"List").style.display='none';wdg(source.id).src=plusimage;}
else{wdg(source.id+"List").style.display='';wdg(source.id).src=minusimage;}}
function ShowFunctions(str_currentclname){var marginhtml="";for(var clname in doc){var icon=plusimage;var onck=" onclick='expand(this";var iclass="expandColapse";var display="none";var methodlist="";for(var method in doc[clname]){if(method!=''){var funcname=doc[clname][method].lib.replace('%',clname.toLowerCase());var mclass=(ShowIcons?MethodType(clname,method):'noicon');if(UseShortcuts&&mclass=='static')funcname='y'+method+'()';methodlist+="<a id="+clname+'.'+method+" class='"+mclass+"' href='javascript:Show(\""+clname+"\",\""+method+"\");'>"+funcname+'</a>';}}
if(methodlist==""){iclass="noExpand";onck=" ony='(";}else if(str_currentclname==clname){icon=minusimage;onck=" onclick='expand(this";display=""}
marginhtml+="<span class='classheader'><img class='"+iclass+"' id='"+clname+"' "+onck+")'' src='"+icon+"'/> ";marginhtml+="<a href='javascript:Show(\""+clname+"\",\"\");' id='"+clname+"' "+onck+",true)'>"+clname+'</a></span><br>';if(methodlist!="")marginhtml+="<div id='"+clname+"List' class='methodsList' style='display:"+display+"'>"+methodlist+"</div>";if(clname=='YAPI'||clname=='FreeAPI')marginhtml+='<hr>';}
wdg("MarginLayer").innerHTML=marginhtml;}
function fctMatch(clname,method,values){var found=new Array()
var tosearch=new Array()
for(var i=0;i<values.length;i++)
if(values[i]!=''&&values[i]!='y'){if(values[i].substr(0,3)=='[y]')
tosearch[tosearch.length]=values[i].substr(3,values[i].length);else
tosearch[tosearch.length]=values[i];}
for(var i=0;i<tosearch.length;i++){var expr=new RegExp(tosearch[i],"i");var fct=doc[clname][method]
var found=clname.search(expr)>=0;if(!found)found=method.search(expr)>=0;if(!found&&fct.inc){if(!found&&fct.syn)found=fct.syn.search(expr)>=0;if(!found)found=fct.inc.search(expr)>=0;}
if(!found&&fct.pro)found=fct.pro.search(expr)>=0;if(fct.par)
for(var p in fct.par){if(!found)found=p.search(expr)>=0;if(!found)found=fct.par[p].search(expr)>=0;}
if(fct.ret){if(!found)found=fct.ret.search(expr)>=0;}
if(!found&&fct.cmt)found=fct.cmt.search(expr)>=0;if(!found&&fct.ext)found=fct.ext.search(expr)>=0;if(!found)return false;}
return true;}
var searchTimer=null;function doSearch(){searchTimer=null;var value=document.forms['yoctoForm'].elements['search'].value;if(value==''){for(var clname in doc){var container=wdg(clname+"List");for(var method in doc[clname])
if(method!=''){var it=wdg(clname+'.'+method);if(it)it.style.display="block";}
wdg(clname).style.visibility='visible';var container=wdg(clname+"List");if(container){if(container["originalDisplay"]!=""){wdg(clname+"List").style.display='none';wdg(clname).src=plusimage;}
else{wdg(clname+"List").style.display='';wdg(clname).src=minusimage;}
container["originalDisplay"]=null;}}
Show(lastindex_shown,lastname_shown);return;}
var firstindex='';var firstname='';qvalue=value;value='';for(var i=0;i<qvalue.length;i++){var c=qvalue.charAt(i);if(c=='\\'||c=='['||c==']'||c=='('||c==')'){value+='.';}else{if(c!=' ')value+='['+qvalue.charAt(i)+']';else value+=' ';}}
for(var clname in doc){var matchfound=false;var container=wdg(clname+"List");if(container){if(!container["originalDisplay"])container["originalDisplay"]=null;if(container["originalDisplay"]==null)container["originalDisplay"]=container.style.display;}
values=value.split(' ');for(var method in doc[clname]){var it=wdg(clname+'.'+method);var match=fctMatch(clname,method,values);if(match){if(it)it.style.display="block";matchfound=true;if(firstindex==''){firstindex=clname;firstname=method;}}
else{if(it)it.style.display="none";}}
listwdg=wdg(clname+"List");if(matchfound){if(listwdg)listwdg.style.display='';wdg(clname).src=minusimage;wdg(clname).style.visibility='visible';}
else{if(listwdg)listwdg.style.display='none';wdg(clname).style.visibility='hidden';wdg(clname).src=plusimage;}}
Show(firstindex,firstname);}
function initSearch(){if(searchTimer!=null)clearTimeout(searchTimer);searchTimer=setTimeout('doSearch()',500);}
function sortObject(o){var sorted={},key,newkey,a=[];for(key in o){if(o.hasOwnProperty(key))a.push(key);}
a.sort();for(key=0;key<a.length;key++){newkey=a[key];if(newkey.substr(0,1)=='*'){newkey=newkey.substr(3);}
sorted[newkey]=o[a[key]];}
return sorted;}
function OOcheckboxChange(){UseShortcuts=document.forms["yoctoForm"].elements["OOcheckbox"].checked;ShowFunctions(lastindex_shown);Show(lastindex_shown,lastname_shown);}
function parseHash(arg){var defclass="Introduction";var defmethod="";if(window.location.hash.length>1){var words=window.location.hash.substr(1).split('.');var cname=words[0];if(cname!="YAPI"&&cname[0]=='Y')cname=cname.substr(1);if(doc[cname]){defclass=words[0];ShowFunctions(defclass);if(words.length>1&&doc[defclass][words[1]]){defmethod=words[1];var idxwdg=wdg('MarginLayer');var itemwdg=wdg(defclass+'.'+defmethod);var scrollTop=Math.max(itemwdg.offsetTop-(idxwdg.clientHeight>>1),0);setTimeout("wdg('MarginLayer').scrollTop="+scrollTop+";",20);}}else{ShowFunctions();}}else{ShowFunctions();}
Show(defclass,defmethod,(arg==='NoH'));}
function InitHTMLRef(){wdg('langdt').innerHTML=Language;computeWinWH();onResize(function(){SetWidth("BannerLayer",WinW)});onResize(resizeMargin);onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});onResize(resizeSeparator);EnableDrag(wdg("separatorLayer"),marginMove,marginMove);if(UseShortcuts!=null){var td=wdg("oosyntax");var widget='<input type="checkbox" id="OOcheckbox" onclick="OOcheckboxChange(this);"> '+AbbrevLabel;td.innerHTML=widget;td.title=AbbrevHint;td.alt=AbbrevHint;}
if(Language!='LabVIEW'){var rule='';var types=['int','obj','dbl','str','arr','bool'];for(var i=0;i<types.length;i++){rule+=', span#'+types[i]+', td.'+types[i];}
if(isCmdLine){rule+=', span#pn, td.pn';}
rule=rule.substr(2)+'{ color: #196719 !important;}';document.styleSheets[0].insertRule(rule,1);doc['*Y.YAPI']=doc['YAPI'];delete doc['YAPI'];}
var specialClasses=[];for(clname in doc){if(!doc[clname].isReadOnly){specialClasses.push(clname);}
for(funcname in doc[clname]){if(isClassMethod(clname,funcname)){sub['y'+funcname]=doc[clname][funcname].lib;}}}
if(isCmdLine){for(funcname in doc['DisplayLayer']){if(!doc['Display'][funcname]){doc['Display'][funcname]=doc['DisplayLayer'][funcname];}}
for(clname of specialClasses){if(clname.substr(0,2)!='*0'){delete doc[clname];}}}
doc=sortObject(doc);parseHash('NoH');window.onresize=windowResized;window.onhashchange=parseHash;}
</SCRIPT>
</HEAD>
<BODY>
<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>2.1.11416</td>
</table>
</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>
<SCRIPT type="text/JavaScript" >
InitHTMLRef();
</SCRIPT>
</BODY>
</HTML>
