<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-python-EN.html 33736 2018-12-14 16:23:49Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-python-EN.html 33736 2018-12-14 16:23:49Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: Module)
var Language='Python';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'YAPI.FILE_NOT_FOUND',null:'None'};
doc['Module']={'':{syn:'Module control interface',inc:'from yocto_api import *',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule.FindModule()',pro:'def FindModule(<span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule.FirstModule()',pro:'def FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'module.checkFirmware()',pro:'def checkFirmware(<span id=pn>path</span>, <span id=pn>onlynew</span>)',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate <tt>.byn</tt> file. If the parameter <tt>onlynew</tt> is true, the function discards firmwares that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:'the path of the byn file to use or a empty string if no byn files matches the requirement',ext:'On failure, throws an exception or returns a string that start with \x22error:\x22.'};
doc['Module']['clearCache']={syn:'Invalidates the cache.',lib:'module.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Module']['describe']={syn:'Returns a descriptive text that identifies the module.',lib:'module.describe()',pro:'def describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'module.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['functionBaseType']={syn:'Retrieves the base type of the <i>n</i>th function on the module.',lib:'module.functionBaseType()',pro:'def functionBaseType(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the base type of the <i>n</i>th function on the module. For instance, the base type of all measuring functions is \x22Sensor\x22.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the base type of the function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module.functionCount()',pro:'def functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module.functionId()',pro:'def functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module.functionName()',pro:'def functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionType']={syn:'Retrieves the type of the <i>n</i>th function on the module.',lib:'module.functionType()',pro:'def functionType(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the type of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the type of the function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module.functionValue()',pro:'def functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_allSettings']={syn:'Returns all the settings and uploaded files of the module.',lib:'module.get_allSettings()',pro:'def get_allSettings()',cmt:'<p>Returns all the settings and uploaded files of the module. Useful to backup all the logical names, calibrations parameters, and uploaded files of a device.</p>',ret:'a binary buffer with all the settings.',ext:'On failure, throws an exception or returns an binary object of size 0.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module.get_beacon()',pro:'def get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the latest error with this module object.',lib:'module.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occurred while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the latest error with this module object.',lib:'module.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module.get_firmwareRelease()',pro:'def get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionIds']={syn:'Retrieve all hardware identifier that match the type passed in argument.',lib:'module.get_functionIds()',pro:'def get_functionIds(<span id=pn>funType</span>)',cmt:'<p>Retrieve all hardware identifier that match the type passed in argument.</p>',par:{funType:'The type of function (Relay, LightSensor, Voltage,...)'},ret:'an array of strings.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'module.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module.get_icon2d()',pro:'def get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'module.get_lastLogs()',pro:'def get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'module.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_parentHub']={syn:'Returns the serial number of the YoctoHub on which this module is connected.',lib:'module.get_parentHub()',pro:'def get_parentHub()',cmt:'<p>Returns the serial number of the YoctoHub on which this module is connected. If the module is connected by USB, or if the module is the root YoctoHub, an empty string is returned.</p>',ret:'a string with the serial number of the YoctoHub or an empty string'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module.get_persistentSettings()',pro:'def get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module.get_productId()',pro:'def get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module.get_productName()',pro:'def get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module.get_productRelease()',pro:'def get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module.get_rebootCountdown()',pro:'def get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module.get_serialNumber()',pro:'def get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_subDevices']={syn:'Returns a list of all the modules that are plugged into the current module.',lib:'module.get_subDevices()',pro:'def get_subDevices()',cmt:'<p>Returns a list of all the modules that are plugged into the current module. This method only makes sense when called for a YoctoHub/VirtualHub. Otherwise, an empty array will be returned.</p>',ret:'an array of strings containing the sub modules.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module.get_upTime()',pro:'def get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_url']={syn:'Returns the URL used to access the module.',lib:'module.get_url()',pro:'def get_url()',cmt:'<p>Returns the URL used to access the module. If the module is connected by USB, the string \x27usb\x27 is returned.</p>',ret:'a string with the URL of the module.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module.get_usbCurrent()',pro:'def get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module.get_userVar()',pro:'def get_userVar()',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:'On failure, throws an exception or returns <tt>Y_USERVAR_INVALID</tt>.'};
doc['Module']['hasFunction']={syn:'Tests if the device includes a specific function.',lib:'module.hasFunction()',pro:'def hasFunction(<span id=pn>funcId</span>)',cmt:'<p>Tests if the device includes a specific function. This method takes a function identifier and returns a boolean.</p>',par:{funcId:'the requested function identifier'},ret:'true if the device has the function identifier'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['log']={syn:'Adds a text message to the device logs.',lib:'module.log()',pro:'def log(<span id=pn>text</span>)',cmt:'<p>Adds a text message to the device logs. This function is useful in particular to trace the execution of HTTP callbacks. If a newline is desired after the message, it must be included in the string.</p>',par:{text:'the string to append to the logs.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'def nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>. Caution: You can\x27t make any assumption about the returned modules order. \x09 If you want to find a specific module, use <tt>Module.findModule()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module.reboot()',pro:'def reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['registerBeaconCallback']={syn:'Register a callback function, to be called when the localization beacon of the module has been changed.',lib:'module.registerBeaconCallback()',pro:'def registerBeaconCallback(<span id=pn>callback</span>)',cmt:'<p>Register a callback function, to be called when the localization beacon of the module has been changed. The callback function should take two arguments: the YModule object of which the beacon has changed, and an integer describing the new beacon state.</p>',par:{callback:'The callback function to call, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['Module']['registerConfigChangeCallback']={syn:'Register a callback function, to be called when a persistent settings in a device configuration has been changed (e.g.',lib:'module.registerConfigChangeCallback()',pro:'def registerConfigChangeCallback(<span id=pn>callback</span>)',cmt:'<p>Register a callback function, to be called when a persistent settings in a device configuration has been changed (e.g. change of unit, etc).</p>',par:{callback:'a procedure taking a YModule parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['Module']['registerLogCallback']={syn:'Registers a device log callback function.',lib:'module.registerLogCallback()',pro:'def registerLogCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a device log callback function. This callback will be called each time that a module sends a new log message. Mostly useful to debug a Yoctopuce module.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the module object that emitted the log message, and the character string containing the log. On failure, throws an exception or returns a negative error code.'}};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module.revertFromFlash()',pro:'def revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module.saveToFlash()',pro:'def saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the device.',lib:'module.set_allSettings()',pro:'def set_allSettings(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettingsAndFiles']={syn:'Restores all the settings and uploaded files to the module.',lib:'module.set_allSettingsAndFiles()',pro:'def set_allSettingsAndFiles(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings and uploaded files to the module. This method is useful to restore all the logical names and calibrations parameters, uploaded files etc. of a device from a backup. Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module.set_beacon()',pro:'def set_beacon(<span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['set_userVar']={syn:'Stores a 32 bit value in the device RAM.',lib:'module.set_userVar()',pro:'def set_userVar(<span id=pn>newval</span>)',cmt:'<p>Stores a 32 bit value in the device RAM. This attribute is at programmer disposal, should he need to store a state variable. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['triggerConfigChangeCallback']={syn:'Triggers a configuration change callback, to check if they are supported or not.',lib:'module.triggerConfigChangeCallback()',pro:'def triggerConfigChangeCallback()',cmt:'<p>Triggers a configuration change callback, to check if they are supported or not.</p>'};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module.triggerFirmwareUpdate()',pro:'def triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'module.updateFirmware()',pro:'def updateFirmware(<span id=pn>path</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
doc['Module']['updateFirmwareEx']={syn:'Prepares a firmware update of the module.',lib:'module.updateFirmwareEx()',pro:'def updateFirmwareEx(<span id=pn>path</span>, <span id=pn>force</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.',force:'true to force the firmware update even if some prerequisites appear not to be met'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
//--- (end of generated code: Module)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'from yocto_colorled import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Retrieves an RGB LED for a given identifier.',lib:'YColorLed.FindColorLed()',pro:'def FindColorLed(<span id=pn>func</span>)',cmt:'<p>Retrieves an RGB LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB LED is indeed online at a given time. In case of ambiguity when looking for an RGB LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB LED.'};
doc['ColorLed']['FirstColorLed']={syn:'Starts the enumeration of RGB LEDs currently accessible.',lib:'YColorLed.FirstColorLed()',pro:'def FirstColorLed()',cmt:'<p>Starts the enumeration of RGB LEDs currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB LEDs.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB LED currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'colorled.addHslMoveToBlinkSeq()',pro:'def addHslMoveToBlinkSeq(<span id=pn>HSLcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Adds a new transition to the blinking sequence, the move is performed in the RGB space.',lib:'colorled.addRgbMoveToBlinkSeq()',pro:'def addRgbMoveToBlinkSeq(<span id=pn>RGBcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Adds a new transition to the blinking sequence, the move is performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['clearCache']={syn:'Invalidates the cache.',lib:'colorled.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['ColorLed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB LED (no more than 6 characters).',lib:'colorled.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of the blinking sequence.',lib:'colorled.get_blinkSeqMaxSize()',pro:'def get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of the blinking sequence.</p>',ret:'an integer corresponding to the maximum length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Return the blinking sequence signature.',lib:'colorled.get_blinkSeqSignature()',pro:'def get_blinkSeqSignature()',cmt:'<p>Return the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIGNATURE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSize']={syn:'Returns the current length of the blinking sequence.',lib:'colorled.get_blinkSeqSize()',pro:'def get_blinkSeqSize()',cmt:'<p>Returns the current length of the blinking sequence.</p>',ret:'an integer corresponding to the current length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIZE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Returns the error message of the latest error with the RGB LED.',lib:'colorled.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED object'};
doc['ColorLed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the RGB LED.',lib:'colorled.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED object'};
doc['ColorLed']['get_friendlyName']={syn:'Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorled.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorled.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLed']['get_functionId']={syn:'Returns the hardware identifier of the RGB LED, without reference to the module.',lib:'colorled.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorled.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the LED.',lib:'colorled.get_hslColor()',pro:'def get_hslColor()',cmt:'<p>Returns the current HSL color of the LED.</p>',ret:'an integer corresponding to the current HSL color of the LED',ext:'On failure, throws an exception or returns <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB LED.',lib:'colorled.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED.</p>',ret:'a string corresponding to the logical name of the RGB LED.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorled.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the LED.',lib:'colorled.get_rgbColor()',pro:'def get_rgbColor()',cmt:'<p>Returns the current RGB color of the LED.</p>',ret:'an integer corresponding to the current RGB color of the LED',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'def get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'colorled.hslMove()',pro:'def hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['isOnline']={syn:'Checks if the RGB LED is currently reachable, without raising any error.',lib:'colorled.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the RGB LED is currently reachable, without raising any error. If there is a cached value for the RGB LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED.</p>',ret:'<tt>true</tt> if the RGB LED can be reached, and <tt>false</tt> otherwise'};
doc['ColorLed']['load']={syn:'Preloads the RGB LED cache with a specified validity duration.',lib:'colorled.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'colorled.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['ColorLed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'colorled.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['nextColorLed']={syn:'Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>.',lib:'colorled.nextColorLed()',pro:'def nextColorLed()',cmt:'<p>Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>. Caution: You can\x27t make any assumption about the returned RGB LEDs order. If you want to find a specific an RGB LED, use <tt>ColorLed.findColorLed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB LED currently online, or a <tt>null</tt> pointer if there are no more RGB LEDs to enumerate.'};
doc['ColorLed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorled.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLed']['resetBlinkSeq']={syn:'Resets the preprogrammed blinking sequence.',lib:'colorled.resetBlinkSeq()',pro:'def resetBlinkSeq()',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'colorled.rgbMove()',pro:'def rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the LED, using a color HSL.',lib:'colorled.set_hslColor()',pro:'def set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the LED, using a color HSL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB LED.',lib:'colorled.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the LED, using an RGB color.',lib:'colorled.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the LED, using an RGB color'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the LED will display by default when the module is turned on.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the color that the LED will display by default when the module is turned on.</p>',par:{newval:'an integer corresponding to the color that the LED will display by default when the module is turned on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorled.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['ColorLed']['startBlinkSeq']={syn:'Starts the preprogrammed blinking sequence.',lib:'colorled.startBlinkSeq()',pro:'def startBlinkSeq()',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence is run in a loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Stops the preprogrammed blinking sequence.',lib:'colorled.stopBlinkSeq()',pro:'def stopBlinkSeq()',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'colorled.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLed)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'from yocto_temperature import *',cmt:'<p>The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}};
doc['Temperature']['FindTemperature']={syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature.FindTemperature()',pro:'def FindTemperature(<span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the temperature sensor'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'};
doc['Temperature']['FirstTemperature']={syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature.FirstTemperature()',pro:'def FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'temperature.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['clearCache']={syn:'Invalidates the cache.',lib:'temperature.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the temperature sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Temperature']['describe']={syn:'Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the temperature sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'temperature.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'temperature.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'temperature.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'temperature.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'temperature.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Temperature']['get_errorMessage']={syn:'Returns the error message of the latest error with the temperature sensor.',lib:'temperature.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the temperature sensor object'};
doc['Temperature']['get_errorType']={syn:'Returns the numerical error code of the latest error with the temperature sensor.',lib:'temperature.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the temperature sensor object'};
doc['Temperature']['get_friendlyName']={syn:'Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'temperature.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the temperature sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the temperature sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the temperature sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'temperature.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Temperature']['get_functionId']={syn:'Returns the hardware identifier of the temperature sensor, without reference to the module.',lib:'temperature.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the temperature sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the temperature sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'temperature.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the temperature sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the temperature sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'temperature.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'temperature.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'temperature.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'temperature.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'temperature.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Temperature']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'temperature.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Temperature']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'temperature.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'temperature.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'temperature.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'temperature.get_sensorType()',pro:'def get_sensorType()',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt>, <tt>Y_SENSORTYPE_RES_INTERNAL</tt> and <tt>Y_SENSORTYPE_IR</tt> corresponding to the temperature sensor type',ext:'On failure, throws an exception or returns <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'temperature.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['Temperature']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'temperature.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the temperature.',lib:'temperature.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Temperature']['isOnline']={syn:'Checks if the temperature sensor is currently reachable, without raising any error.',lib:'temperature.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the temperature sensor is currently reachable, without raising any error. If there is a cached value for the temperature sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the temperature sensor.</p>',ret:'<tt>true</tt> if the temperature sensor can be reached, and <tt>false</tt> otherwise'};
doc['Temperature']['load']={syn:'Preloads the temperature sensor cache with a specified validity duration.',lib:'temperature.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the temperature sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'temperature.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Temperature']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'temperature.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadThermistorResponseTable']={syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'temperature.loadThermistorResponseTable()',pro:'def loadThermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'temperature.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['nextTemperature']={syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'temperature.nextTemperature()',pro:'def nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>. Caution: You can\x27t make any assumption about the returned temperature sensors order. If you want to find a specific a temperature sensor, use <tt>Temperature.findTemperature()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'};
doc['Temperature']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'temperature.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Temperature']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'temperature.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Temperature']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'temperature.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'temperature.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'temperature.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'temperature.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'temperature.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_ntcParameters']={syn:'Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance.',lib:'temperature.set_ntcParameters()',pro:'def set_ntcParameters(<span id=pn>res25</span>, <span id=pn>beta</span>)',cmt:'<p>Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance. For increased precision, you can enter a complete mapping table using set_thermistorResponseTable. This function can only be used with a temperature sensor based on thermistors.</p>',par:{res25:'thermistor resistance at 25 degrees Celsius',beta:'Beta value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'temperature.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'temperature.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_sensorType']={syn:'Changes the temperature sensor type.',lib:'temperature.set_sensorType()',pro:'def set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt>, <tt>Y_SENSORTYPE_RES_INTERNAL</tt> and <tt>Y_SENSORTYPE_IR</tt> corresponding to the temperature sensor type'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_thermistorResponseTable']={syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'temperature.set_thermistorResponseTable()',pro:'def set_thermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celsius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_unit']={syn:'Changes the measuring unit for the measured temperature.',lib:'temperature.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that string ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'temperature.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Temperature']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'temperature.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Temperature']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'temperature.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Temperature']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'temperature.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'from yocto_api import *',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The DataLogger function controls the global parameters of the internal data logger.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger.FindDataLogger()',pro:'def FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the data logger'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'};
doc['DataLogger']['FirstDataLogger']={syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger.FirstDataLogger()',pro:'def FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DataLogger']['clearCache']={syn:'Invalidates the cache.',lib:'datalogger.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the data logger attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DataLogger']['describe']={syn:'Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the data logger (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'datalogger.forgetAllDataStreams()',pro:'def forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'datalogger.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'datalogger.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_beaconDriven']={syn:'Returns true if the data logger is synchronised with the localization beacon.',lib:'datalogger.get_beaconDriven()',pro:'def get_beaconDriven()',cmt:'<p>Returns true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>, according to true if the data logger is synchronised with the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACONDRIVEN_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'datalogger.get_currentRunIndex()',pro:'def get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataSets']={syn:'Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.',lib:'datalogger.get_dataSets()',pro:'def get_dataSets()',cmt:'<p>Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>',ret:'a list of YDataSet object.',ext:'On failure, throws an exception or returns an empty list.'};
doc['DataLogger']['get_errorMessage']={syn:'Returns the error message of the latest error with the data logger.',lib:'datalogger.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the data logger object'};
doc['DataLogger']['get_errorType']={syn:'Returns the numerical error code of the latest error with the data logger.',lib:'datalogger.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the data logger object'};
doc['DataLogger']['get_friendlyName']={syn:'Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'datalogger.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the data logger if they are defined, otherwise the serial number of the module and the hardware identifier of the data logger (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the data logger using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'datalogger.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DataLogger']['get_functionId']={syn:'Returns the hardware identifier of the data logger, without reference to the module.',lib:'datalogger.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the data logger, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the data logger (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'datalogger.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the data logger (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the data logger (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'datalogger.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'datalogger.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'datalogger.get_recording()',pro:'def get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'a value among <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> and <tt>Y_RECORDING_PENDING</tt> corresponding to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'datalogger.get_timeUTC()',pro:'def get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_usage']={syn:'Returns the percentage of datalogger memory in use.',lib:'datalogger.get_usage()',pro:'def get_usage()',cmt:'<p>Returns the percentage of datalogger memory in use.</p>',ret:'an integer corresponding to the percentage of datalogger memory in use',ext:'On failure, throws an exception or returns <tt>Y_USAGE_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DataLogger']['isOnline']={syn:'Checks if the data logger is currently reachable, without raising any error.',lib:'datalogger.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the data logger is currently reachable, without raising any error. If there is a cached value for the data logger in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the data logger.</p>',ret:'<tt>true</tt> if the data logger can be reached, and <tt>false</tt> otherwise'};
doc['DataLogger']['load']={syn:'Preloads the data logger cache with a specified validity duration.',lib:'datalogger.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the data logger cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'datalogger.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DataLogger']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'datalogger.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['nextDataLogger']={syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'datalogger.nextDataLogger()',pro:'def nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>. Caution: You can\x27t make any assumption about the returned data loggers order. If you want to find a specific a data logger, use <tt>DataLogger.findDataLogger()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'};
doc['DataLogger']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'datalogger.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'datalogger.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_beaconDriven']={syn:'Changes the type of synchronisation of the data logger.',lib:'datalogger.set_beaconDriven()',pro:'def set_beaconDriven(<span id=pn>newval</span>)',cmt:'<p>Changes the type of synchronisation of the data logger. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'datalogger.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'datalogger.set_recording()',pro:'def set_recording(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'a value among <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> and <tt>Y_RECORDING_PENDING</tt> corresponding to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'datalogger.set_timeUTC()',pro:'def set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'datalogger.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DataLogger']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'datalogger.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'from yocto_dualpower import *',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Retrieves a dual power control for a given identifier.',lib:'YDualPower.FindDualPower()',pro:'def FindDualPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the power control is indeed online at a given time. In case of ambiguity when looking for a dual power control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the power control'},ret:'a <tt>YDualPower</tt> object allowing you to drive the power control.'};
doc['DualPower']['FirstDualPower']={syn:'Starts the enumeration of dual power controls currently accessible.',lib:'YDualPower.FirstDualPower()',pro:'def FirstDualPower()',cmt:'<p>Starts the enumeration of dual power controls currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power controls.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DualPower']['clearCache']={syn:'Invalidates the cache.',lib:'dualpower.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the power control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DualPower']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'dualpower.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Returns the error message of the latest error with the power control.',lib:'dualpower.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power control object'};
doc['DualPower']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power control.',lib:'dualpower.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power control object'};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'dualpower.get_extVoltage()',pro:'def get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'dualpower.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power control if they are defined, otherwise the serial number of the module and the hardware identifier of the power control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'dualpower.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DualPower']['get_functionId']={syn:'Returns the hardware identifier of the power control, without reference to the module.',lib:'dualpower.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the power control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dualpower.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'dualpower.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'dualpower.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'dualpower.get_powerControl()',pro:'def get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'dualpower.get_powerState()',pro:'def get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> and <tt>Y_POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DualPower']['isOnline']={syn:'Checks if the power control is currently reachable, without raising any error.',lib:'dualpower.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the power control is currently reachable, without raising any error. If there is a cached value for the power control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power control.</p>',ret:'<tt>true</tt> if the power control can be reached, and <tt>false</tt> otherwise'};
doc['DualPower']['load']={syn:'Preloads the power control cache with a specified validity duration.',lib:'dualpower.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the power control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'dualpower.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DualPower']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'dualpower.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['nextDualPower']={syn:'Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.',lib:'dualpower.nextDualPower()',pro:'def nextDualPower()',cmt:'<p>Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>. Caution: You can\x27t make any assumption about the returned dual power controls order. If you want to find a specific a dual power control, use <tt>DualPower.findDualPower()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power control currently online, or a <tt>null</tt> pointer if there are no more dual power controls to enumerate.'};
doc['DualPower']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'dualpower.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'dualpower.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'dualpower.set_powerControl()',pro:'def set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'dualpower.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DualPower']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'dualpower.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'from yocto_servo import *',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['FindServo']={syn:'Retrieves a servo for a given identifier.',lib:'YServo.FindServo()',pro:'def FindServo(<span id=pn>func</span>)',cmt:'<p>Retrieves a servo for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the servo is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the servo is indeed online at a given time. In case of ambiguity when looking for a servo by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the servo'},ret:'a <tt>YServo</tt> object allowing you to drive the servo.'};
doc['Servo']['FirstServo']={syn:'Starts the enumeration of servos currently accessible.',lib:'YServo.FirstServo()',pro:'def FirstServo()',cmt:'<p>Starts the enumeration of servos currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next servos.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first servo currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Servo']['clearCache']={syn:'Invalidates the cache.',lib:'servo.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the servo attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Servo']['describe']={syn:'Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the servo (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'servo.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_enabled']={syn:'Returns the state of the servos.',lib:'servo.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns the state of the servos.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the servos',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Servo']['get_enabledAtPowerOn']={syn:'Returns the servo signal generator state at power up.',lib:'servo.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the servo signal generator state at power up',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Returns the error message of the latest error with the servo.',lib:'servo.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the servo object'};
doc['Servo']['get_errorType']={syn:'Returns the numerical error code of the latest error with the servo.',lib:'servo.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the servo object'};
doc['Servo']['get_friendlyName']={syn:'Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'servo.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the servo if they are defined, otherwise the serial number of the module and the hardware identifier of the servo (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the servo using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'servo.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Servo']['get_functionId']={syn:'Returns the hardware identifier of the servo, without reference to the module.',lib:'servo.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the servo, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the servo (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'servo.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the servo (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the servo (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'servo.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'servo.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'servo.get_neutral()',pro:'def get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'servo.get_position()',pro:'def get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_positionAtPowerOn']={syn:'Returns the servo position at device power up.',lib:'servo.get_positionAtPowerOn()',pro:'def get_positionAtPowerOn()',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:'On failure, throws an exception or returns <tt>Y_POSITIONATPOWERON_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'servo.get_range()',pro:'def get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Servo']['isOnline']={syn:'Checks if the servo is currently reachable, without raising any error.',lib:'servo.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the servo is currently reachable, without raising any error. If there is a cached value for the servo in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the servo.</p>',ret:'<tt>true</tt> if the servo can be reached, and <tt>false</tt> otherwise'};
doc['Servo']['load']={syn:'Preloads the servo cache with a specified validity duration.',lib:'servo.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the servo cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'servo.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'servo.move()',pro:'def move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'servo.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['nextServo']={syn:'Continues the enumeration of servos started using <tt>yFirstServo()</tt>.',lib:'servo.nextServo()',pro:'def nextServo()',cmt:'<p>Continues the enumeration of servos started using <tt>yFirstServo()</tt>. Caution: You can\x27t make any assumption about the returned servos order. If you want to find a specific a servo, use <tt>Servo.findServo()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a servo currently online, or a <tt>null</tt> pointer if there are no more servos to enumerate.'};
doc['Servo']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'servo.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Servo']['set_enabled']={syn:'Stops or starts the servo.',lib:'servo.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the servo.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure the servo signal generator state at power up.',lib:'servo.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo signal generator state at power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'servo.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the servo. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the servo.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'servo.set_neutral()',pro:'def set_neutral(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'servo.set_position()',pro:'def set_position(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure the servo position at device power up.',lib:'servo.set_positionAtPowerOn()',pro:'def set_positionAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo position at device power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'servo.set_range()',pro:'def set_range(<span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'servo.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Servo']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'servo.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'from yocto_relay import *',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['FindRelay']={syn:'Retrieves a relay for a given identifier.',lib:'YRelay.FindRelay()',pro:'def FindRelay(<span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the relay'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'};
doc['Relay']['FirstRelay']={syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay.FirstRelay()',pro:'def FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Relay']['clearCache']={syn:'Invalidates the cache.',lib:'relay.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the relay attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'relay.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the relay (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'relay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'relay.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Returns the error message of the latest error with the relay.',lib:'relay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the relay object'};
doc['Relay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the relay.',lib:'relay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the relay object'};
doc['Relay']['get_friendlyName']={syn:'Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'relay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the relay if they are defined, otherwise the serial number of the module and the hardware identifier of the relay (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the relay using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'relay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Relay']['get_functionId']={syn:'Returns the hardware identifier of the relay, without reference to the module.',lib:'relay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the relay, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the relay (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'relay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the relay (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the relay (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'relay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'relay.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'relay.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'relay.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'relay.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_stateAtPowerOn']={syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'relay.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Relay']['isOnline']={syn:'Checks if the relay is currently reachable, without raising any error.',lib:'relay.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the relay is currently reachable, without raising any error. If there is a cached value for the relay in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the relay.</p>',ret:'<tt>true</tt> if the relay can be reached, and <tt>false</tt> otherwise'};
doc['Relay']['load']={syn:'Preloads the relay cache with a specified validity duration.',lib:'relay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the relay cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'relay.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Relay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'relay.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['nextRelay']={syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'relay.nextRelay()',pro:'def nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>. Caution: You can\x27t make any assumption about the returned relays order. If you want to find a specific a relay, use <tt>Relay.findRelay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'relay.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'relay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'relay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'relay.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'relay.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_stateAtPowerOn']={syn:'Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'relay.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'relay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Relay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'relay.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Relay)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'from yocto_humidity import *',cmt:'<p>The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity.FindHumidity()',pro:'def FindHumidity(<span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the humidity sensor'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'};
doc['Humidity']['FirstHumidity']={syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity.FirstHumidity()',pro:'def FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'humidity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['clearCache']={syn:'Invalidates the cache.',lib:'humidity.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the humidity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Humidity']['describe']={syn:'Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the humidity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_absHum']={syn:'Returns the current absolute humidity, in grams per cubic meter of air.',lib:'humidity.get_absHum()',pro:'def get_absHum()',cmt:'<p>Returns the current absolute humidity, in grams per cubic meter of air.</p>',ret:'a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air',ext:'On failure, throws an exception or returns <tt>Y_ABSHUM_INVALID</tt>.'};
doc['Humidity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'humidity.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'humidity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'humidity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'humidity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'humidity.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Humidity']['get_errorMessage']={syn:'Returns the error message of the latest error with the humidity sensor.',lib:'humidity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the humidity sensor object'};
doc['Humidity']['get_errorType']={syn:'Returns the numerical error code of the latest error with the humidity sensor.',lib:'humidity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the humidity sensor object'};
doc['Humidity']['get_friendlyName']={syn:'Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'humidity.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the humidity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the humidity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the humidity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'humidity.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Humidity']['get_functionId']={syn:'Returns the hardware identifier of the humidity sensor, without reference to the module.',lib:'humidity.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the humidity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the humidity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'humidity.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the humidity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the humidity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'humidity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'humidity.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'humidity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'humidity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'humidity.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Humidity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'humidity.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Humidity']['get_relHum']={syn:'Returns the current relative humidity, in per cents.',lib:'humidity.get_relHum()',pro:'def get_relHum()',cmt:'<p>Returns the current relative humidity, in per cents.</p>',ret:'a floating point number corresponding to the current relative humidity, in per cents',ext:'On failure, throws an exception or returns <tt>Y_RELHUM_INVALID</tt>.'};
doc['Humidity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'humidity.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'humidity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'humidity.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the humidity.',lib:'humidity.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Humidity']['isOnline']={syn:'Checks if the humidity sensor is currently reachable, without raising any error.',lib:'humidity.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the humidity sensor is currently reachable, without raising any error. If there is a cached value for the humidity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the humidity sensor.</p>',ret:'<tt>true</tt> if the humidity sensor can be reached, and <tt>false</tt> otherwise'};
doc['Humidity']['load']={syn:'Preloads the humidity sensor cache with a specified validity duration.',lib:'humidity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the humidity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'humidity.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Humidity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'humidity.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'humidity.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['nextHumidity']={syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'humidity.nextHumidity()',pro:'def nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>. Caution: You can\x27t make any assumption about the returned humidity sensors order. If you want to find a specific a humidity sensor, use <tt>Humidity.findHumidity()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'};
doc['Humidity']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'humidity.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Humidity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'humidity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Humidity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'humidity.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'humidity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'humidity.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'humidity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'humidity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'humidity.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'humidity.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_unit']={syn:'Changes the primary unit for measuring humidity.',lib:'humidity.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the primary unit for measuring humidity. That unit is a string. If that strings starts with the letter \x27g\x27, the primary measured value is the absolute humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity (RH), in per cents.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the primary unit for measuring humidity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'humidity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Humidity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'humidity.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Humidity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'humidity.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Humidity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'humidity.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'from yocto_pressure import *',cmt:'<p>The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Pressure']['FindPressure']={syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure.FindPressure()',pro:'def FindPressure(<span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the pressure sensor'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'};
doc['Pressure']['FirstPressure']={syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure.FirstPressure()',pro:'def FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pressure.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['clearCache']={syn:'Invalidates the cache.',lib:'pressure.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the pressure sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Pressure']['describe']={syn:'Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the pressure sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'pressure.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'pressure.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'pressure.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'pressure.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'pressure.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Pressure']['get_errorMessage']={syn:'Returns the error message of the latest error with the pressure sensor.',lib:'pressure.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the pressure sensor object'};
doc['Pressure']['get_errorType']={syn:'Returns the numerical error code of the latest error with the pressure sensor.',lib:'pressure.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the pressure sensor object'};
doc['Pressure']['get_friendlyName']={syn:'Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pressure.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the pressure sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the pressure sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the pressure sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pressure.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Pressure']['get_functionId']={syn:'Returns the hardware identifier of the pressure sensor, without reference to the module.',lib:'pressure.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the pressure sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the pressure sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pressure.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the pressure sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the pressure sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'pressure.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pressure.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'pressure.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'pressure.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pressure.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Pressure']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pressure.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Pressure']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pressure.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pressure.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'pressure.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the pressure.',lib:'pressure.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Pressure']['isOnline']={syn:'Checks if the pressure sensor is currently reachable, without raising any error.',lib:'pressure.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the pressure sensor is currently reachable, without raising any error. If there is a cached value for the pressure sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the pressure sensor.</p>',ret:'<tt>true</tt> if the pressure sensor can be reached, and <tt>false</tt> otherwise'};
doc['Pressure']['load']={syn:'Preloads the pressure sensor cache with a specified validity duration.',lib:'pressure.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the pressure sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pressure.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Pressure']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pressure.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pressure.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['nextPressure']={syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'pressure.nextPressure()',pro:'def nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>. Caution: You can\x27t make any assumption about the returned pressure sensors order. If you want to find a specific a pressure sensor, use <tt>Pressure.findPressure()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'};
doc['Pressure']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pressure.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Pressure']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pressure.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Pressure']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'pressure.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pressure.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pressure.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'pressure.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pressure.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pressure.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pressure.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pressure.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Pressure']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pressure.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Pressure']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pressure.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Pressure']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pressure.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'from yocto_lightsensor import *',cmt:'<p>The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor.FindLightSensor()',pro:'def FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the light sensor'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'};
doc['LightSensor']['FirstLightSensor']={syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor.FirstLightSensor()',pro:'def FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'lightsensor.calibrate()',pro:'def calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'lightsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['clearCache']={syn:'Invalidates the cache.',lib:'lightsensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the light sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['LightSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the light sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'lightsensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'lightsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'lightsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Returns the current value of the ambient light, in the specified unit, as a floating point number.',lib:'lightsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the ambient light, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'lightsensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['LightSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the light sensor.',lib:'lightsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the light sensor object'};
doc['LightSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the light sensor.',lib:'lightsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the light sensor object'};
doc['LightSensor']['get_friendlyName']={syn:'Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'lightsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the light sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the light sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the light sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'lightsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['LightSensor']['get_functionId']={syn:'Returns the hardware identifier of the light sensor, without reference to the module.',lib:'lightsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the light sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the light sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'lightsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the light sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the light sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'lightsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'lightsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'lightsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'lightsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_measureType']={syn:'Returns the type of light measure.',lib:'lightsensor.get_measureType()',pro:'def get_measureType()',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> corresponding to the type of light measure',ext:'On failure, throws an exception or returns <tt>Y_MEASURETYPE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'lightsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['LightSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'lightsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['LightSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'lightsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'lightsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'lightsensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the ambient light.',lib:'lightsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['LightSensor']['isOnline']={syn:'Checks if the light sensor is currently reachable, without raising any error.',lib:'lightsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the light sensor is currently reachable, without raising any error. If there is a cached value for the light sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the light sensor.</p>',ret:'<tt>true</tt> if the light sensor can be reached, and <tt>false</tt> otherwise'};
doc['LightSensor']['load']={syn:'Preloads the light sensor cache with a specified validity duration.',lib:'lightsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the light sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'lightsensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['LightSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'lightsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'lightsensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['nextLightSensor']={syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'lightsensor.nextLightSensor()',pro:'def nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>. Caution: You can\x27t make any assumption about the returned light sensors order. If you want to find a specific a light sensor, use <tt>LightSensor.findLightSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'};
doc['LightSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'lightsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['LightSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'lightsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['LightSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'lightsensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'lightsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'lightsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'lightsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'lightsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_measureType']={syn:'Changes the light sensor type used in the device.',lib:'lightsensor.set_measureType()',pro:'def set_measureType(<span id=pn>newval</span>)',cmt:'<p>Changes the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> corresponding to the light sensor type used in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'lightsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'lightsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'lightsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['LightSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'lightsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['LightSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'lightsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['LightSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'lightsensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: LightSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'from yocto_hubport import *',cmt:'<p>YHubPort objects provide control over the power supply for every YoctoHub port and provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}};
doc['HubPort']['FindHubPort']={syn:'Retrieves a Yocto-hub port for a given identifier.',lib:'YHubPort.FindHubPort()',pro:'def FindHubPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a Yocto-hub port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Yocto-hub port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the Yocto-hub port is indeed online at a given time. In case of ambiguity when looking for a Yocto-hub port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Yocto-hub port'},ret:'a <tt>YHubPort</tt> object allowing you to drive the Yocto-hub port.'};
doc['HubPort']['FirstHubPort']={syn:'Starts the enumeration of Yocto-hub ports currently accessible.',lib:'YHubPort.FirstHubPort()',pro:'def FirstHubPort()',cmt:'<p>Starts the enumeration of Yocto-hub ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next Yocto-hub ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first Yocto-hub port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['HubPort']['clearCache']={syn:'Invalidates the cache.',lib:'hubport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Yocto-hub port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['HubPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Yocto-hub port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'hubport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'hubport.get_baudRate()',pro:'def get_baudRate()',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:'On failure, throws an exception or returns <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'hubport.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the Yocto-hub port.',lib:'hubport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Yocto-hub port object'};
doc['HubPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Yocto-hub port.',lib:'hubport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Yocto-hub port object'};
doc['HubPort']['get_friendlyName']={syn:'Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'hubport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Yocto-hub port if they are defined, otherwise the serial number of the module and the hardware identifier of the Yocto-hub port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Yocto-hub port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'hubport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['HubPort']['get_functionId']={syn:'Returns the hardware identifier of the Yocto-hub port, without reference to the module.',lib:'hubport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the Yocto-hub port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Yocto-hub port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'hubport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Yocto-hub port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Yocto-hub port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port.',lib:'hubport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Yocto-hub port.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'hubport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'hubport.get_portState()',pro:'def get_portState()',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> and <tt>Y_PORTSTATE_PROG</tt> corresponding to the current state of the Yocto-hub port',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['HubPort']['isOnline']={syn:'Checks if the Yocto-hub port is currently reachable, without raising any error.',lib:'hubport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the Yocto-hub port is currently reachable, without raising any error. If there is a cached value for the Yocto-hub port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Yocto-hub port.</p>',ret:'<tt>true</tt> if the Yocto-hub port can be reached, and <tt>false</tt> otherwise'};
doc['HubPort']['load']={syn:'Preloads the Yocto-hub port cache with a specified validity duration.',lib:'hubport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Yocto-hub port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'hubport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['HubPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'hubport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['nextHubPort']={syn:'Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.',lib:'hubport.nextHubPort()',pro:'def nextHubPort()',cmt:'<p>Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>. Caution: You can\x27t make any assumption about the returned Yocto-hub ports order. If you want to find a specific a Yocto-hub port, use <tt>HubPort.findHubPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a Yocto-hub port currently online, or a <tt>null</tt> pointer if there are no more Yocto-hub ports to enumerate.'};
doc['HubPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'hubport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'hubport.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_logicalName']={syn:'Changes the logical name of the Yocto-hub port.',lib:'hubport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Yocto-hub port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Yocto-hub port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'hubport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['HubPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'hubport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'from yocto_anbutton import *',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton.FindAnButton()',pro:'def FindAnButton(<span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the analog input'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'};
doc['AnButton']['FirstAnButton']={syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton.FirstAnButton()',pro:'def FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AnButton']['clearCache']={syn:'Invalidates the cache.',lib:'anbutton.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the analog input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AnButton']['describe']={syn:'Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the analog input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'anbutton.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'anbutton.get_analogCalibration()',pro:'def get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'anbutton.get_calibratedValue()',pro:'def get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMax()',pro:'def get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMin()',pro:'def get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Returns the error message of the latest error with the analog input.',lib:'anbutton.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the analog input object'};
doc['AnButton']['get_errorType']={syn:'Returns the numerical error code of the latest error with the analog input.',lib:'anbutton.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the analog input object'};
doc['AnButton']['get_friendlyName']={syn:'Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'anbutton.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the analog input if they are defined, otherwise the serial number of the module and the hardware identifier of the analog input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the analog input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'anbutton.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AnButton']['get_functionId']={syn:'Returns the hardware identifier of the analog input, without reference to the module.',lib:'anbutton.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the analog input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the analog input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'anbutton.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the analog input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the analog input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'anbutton.get_isPressed()',pro:'def get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>Y_ISPRESSED_FALSE</tt> or <tt>Y_ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'anbutton.get_lastTimePressed()',pro:'def get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'anbutton.get_lastTimeReleased()',pro:'def get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'anbutton.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'anbutton.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'anbutton.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'anbutton.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'anbutton.get_rawValue()',pro:'def get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.get_sensitivity()',pro:'def get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AnButton']['isOnline']={syn:'Checks if the analog input is currently reachable, without raising any error.',lib:'anbutton.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the analog input is currently reachable, without raising any error. If there is a cached value for the analog input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the analog input.</p>',ret:'<tt>true</tt> if the analog input can be reached, and <tt>false</tt> otherwise'};
doc['AnButton']['load']={syn:'Preloads the analog input cache with a specified validity duration.',lib:'anbutton.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the analog input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'anbutton.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AnButton']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'anbutton.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['nextAnButton']={syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'anbutton.nextAnButton()',pro:'def nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>. Caution: You can\x27t make any assumption about the returned analog inputs order. If you want to find a specific an analog input, use <tt>AnButton.findAnButton()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'};
doc['AnButton']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'anbutton.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'anbutton.resetCounter()',pro:'def resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'anbutton.set_analogCalibration()',pro:'def set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMax()',pro:'def set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMin()',pro:'def set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'anbutton.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.set_sensitivity()',pro:'def set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'anbutton.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AnButton']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'anbutton.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'from yocto_voltage import *',cmt:'<p>The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage.FindVoltage()',pro:'def FindVoltage(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage sensor'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'};
doc['Voltage']['FirstVoltage']={syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage.FirstVoltage()',pro:'def FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voltage.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['clearCache']={syn:'Invalidates the cache.',lib:'voltage.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Voltage']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'voltage.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'voltage.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'voltage.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'voltage.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'voltage.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Voltage']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage sensor.',lib:'voltage.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage sensor object'};
doc['Voltage']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage sensor.',lib:'voltage.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage sensor object'};
doc['Voltage']['get_friendlyName']={syn:'Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltage.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltage.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voltage']['get_functionId']={syn:'Returns the hardware identifier of the voltage sensor, without reference to the module.',lib:'voltage.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltage.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'voltage.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voltage.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'voltage.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'voltage.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltage.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voltage']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voltage.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voltage']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voltage.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voltage.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'voltage.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'voltage.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voltage']['isOnline']={syn:'Checks if the voltage sensor is currently reachable, without raising any error.',lib:'voltage.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the voltage sensor is currently reachable, without raising any error. If there is a cached value for the voltage sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage sensor.</p>',ret:'<tt>true</tt> if the voltage sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voltage']['load']={syn:'Preloads the voltage sensor cache with a specified validity duration.',lib:'voltage.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voltage.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Voltage']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voltage.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voltage.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['nextVoltage']={syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'voltage.nextVoltage()',pro:'def nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>. Caution: You can\x27t make any assumption about the returned voltage sensors order. If you want to find a specific a voltage sensor, use <tt>Voltage.findVoltage()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'};
doc['Voltage']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voltage.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voltage']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltage.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voltage']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'voltage.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voltage.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voltage.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'voltage.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voltage.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voltage.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voltage.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltage.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voltage']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voltage.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voltage']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voltage.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voltage']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voltage.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'from yocto_current import *',cmt:'<p>The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Current']['FindCurrent']={syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent.FindCurrent()',pro:'def FindCurrent(<span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the current sensor'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'};
doc['Current']['FirstCurrent']={syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent.FirstCurrent()',pro:'def FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'current.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['clearCache']={syn:'Invalidates the cache.',lib:'current.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the current sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Current']['describe']={syn:'Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the current sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'current.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'current.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'current.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'current.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the current, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'current.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Current']['get_errorMessage']={syn:'Returns the error message of the latest error with the current sensor.',lib:'current.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the current sensor object'};
doc['Current']['get_errorType']={syn:'Returns the numerical error code of the latest error with the current sensor.',lib:'current.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the current sensor object'};
doc['Current']['get_friendlyName']={syn:'Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'current.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the current sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the current sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the current sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'current.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Current']['get_functionId']={syn:'Returns the hardware identifier of the current sensor, without reference to the module.',lib:'current.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the current sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the current sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'current.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the current sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the current sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed for the current since the device was started.',lib:'current.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'current.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'current.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed for the current since the device was started.',lib:'current.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'current.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Current']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'current.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Current']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'current.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'current.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'current.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the current.',lib:'current.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Current']['isOnline']={syn:'Checks if the current sensor is currently reachable, without raising any error.',lib:'current.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the current sensor is currently reachable, without raising any error. If there is a cached value for the current sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the current sensor.</p>',ret:'<tt>true</tt> if the current sensor can be reached, and <tt>false</tt> otherwise'};
doc['Current']['load']={syn:'Preloads the current sensor cache with a specified validity duration.',lib:'current.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the current sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'current.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Current']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'current.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'current.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['nextCurrent']={syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'current.nextCurrent()',pro:'def nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>. Caution: You can\x27t make any assumption about the returned current sensors order. If you want to find a specific a current sensor, use <tt>Current.findCurrent()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'};
doc['Current']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'current.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Current']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'current.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Current']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'current.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'current.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'current.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'current.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'current.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'current.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'current.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'current.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Current']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'current.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Current']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'current.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Current']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'current.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'from yocto_carbondioxide import *',cmt:'<p>The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2 sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to perform manual calibration if required.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'def FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'def FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'carbondioxide.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['clearCache']={syn:'Invalidates the cache.',lib:'carbondioxide.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the CO2 sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['CarbonDioxide']['describe']={syn:'Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the CO2 sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'carbondioxide.get_abcPeriod()',pro:'def get_abcPeriod()',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:'On failure, throws an exception or returns <tt>Y_ABCPERIOD_INVALID</tt>.'};
doc['CarbonDioxide']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'carbondioxide.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'carbondioxide.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'carbondioxide.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'carbondioxide.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'carbondioxide.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Returns the error message of the latest error with the CO2 sensor.',lib:'carbondioxide.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the CO2 sensor object'};
doc['CarbonDioxide']['get_errorType']={syn:'Returns the numerical error code of the latest error with the CO2 sensor.',lib:'carbondioxide.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the CO2 sensor object'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'carbondioxide.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the CO2 sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the CO2 sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the CO2 sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'carbondioxide.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionId']={syn:'Returns the hardware identifier of the CO2 sensor, without reference to the module.',lib:'carbondioxide.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the CO2 sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the CO2 sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'carbondioxide.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the CO2 sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the CO2 sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'carbondioxide.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'carbondioxide.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'carbondioxide.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CarbonDioxide']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'carbondioxide.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'carbondioxide.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'carbondioxide.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'carbondioxide.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the CO2 concentration.',lib:'carbondioxide.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CarbonDioxide']['isOnline']={syn:'Checks if the CO2 sensor is currently reachable, without raising any error.',lib:'carbondioxide.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the CO2 sensor is currently reachable, without raising any error. If there is a cached value for the CO2 sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the CO2 sensor.</p>',ret:'<tt>true</tt> if the CO2 sensor can be reached, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['load']={syn:'Preloads the CO2 sensor cache with a specified validity duration.',lib:'carbondioxide.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the CO2 sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'carbondioxide.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'carbondioxide.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'carbondioxide.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide.nextCarbonDioxide()',pro:'def nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>. Caution: You can\x27t make any assumption about the returned CO2 sensors order. If you want to find a specific a CO2 sensor, use <tt>CarbonDioxide.findCarbonDioxide()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'};
doc['CarbonDioxide']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'carbondioxide.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['CarbonDioxide']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'carbondioxide.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Changes Automatic Baseline Calibration period, in hours.',lib:'carbondioxide.set_abcPeriod()',pro:'def set_abcPeriod(<span id=pn>newval</span>)',cmt:'<p>Changes Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400 ppm CO2), set the period to -1. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to Automatic Baseline Calibration period, in hours'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'carbondioxide.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'carbondioxide.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'carbondioxide.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'carbondioxide.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'carbondioxide.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'carbondioxide.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'carbondioxide.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'carbondioxide.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['CarbonDioxide']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'carbondioxide.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'carbondioxide.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['triggerBaselineCalibration']={syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'carbondioxide.triggerBaselineCalibration()',pro:'def triggerBaselineCalibration()',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400 ppm.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['triggerZeroCalibration']={syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air.',lib:'carbondioxide.triggerZeroCalibration()',pro:'def triggerZeroCalibration()',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'carbondioxide.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'from yocto_led import *',cmt:'<p>The Yoctopuce application programming interface allows you not only to drive the intensity of the LED, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['FindLed']={syn:'Retrieves a LED for a given identifier.',lib:'YLed.FindLed()',pro:'def FindLed(<span id=pn>func</span>)',cmt:'<p>Retrieves a LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the LED is indeed online at a given time. In case of ambiguity when looking for a LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the LED'},ret:'a <tt>YLed</tt> object allowing you to drive the LED.'};
doc['Led']['FirstLed']={syn:'Starts the enumeration of LEDs currently accessible.',lib:'YLed.FirstLed()',pro:'def FirstLed()',cmt:'<p>Starts the enumeration of LEDs currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next LEDs.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first LED currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Led']['clearCache']={syn:'Invalidates the cache.',lib:'led.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Led']['describe']={syn:'Returns a short text that describes unambiguously the instance of the LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the LED (no more than 6 characters).',lib:'led.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Returns the current LED signaling mode.',lib:'led.get_blinking()',pro:'def get_blinking()',cmt:'<p>Returns the current LED signaling mode.</p>',ret:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current LED signaling mode',ext:'On failure, throws an exception or returns <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Returns the error message of the latest error with the LED.',lib:'led.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the LED object'};
doc['Led']['get_errorType']={syn:'Returns the numerical error code of the latest error with the LED.',lib:'led.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the LED object'};
doc['Led']['get_friendlyName']={syn:'Returns a global identifier of the LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'led.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the LED if they are defined, otherwise the serial number of the module and the hardware identifier of the LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'led.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Led']['get_functionId']={syn:'Returns the hardware identifier of the LED, without reference to the module.',lib:'led.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Returns the unique hardware identifier of the LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'led.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the LED.',lib:'led.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the LED.</p>',ret:'a string corresponding to the logical name of the LED.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Returns the current LED intensity (in per cent).',lib:'led.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the current LED intensity (in per cent).</p>',ret:'an integer corresponding to the current LED intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'led.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Returns the current LED state.',lib:'led.get_power()',pro:'def get_power()',cmt:'<p>Returns the current LED state.</p>',ret:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the current LED state',ext:'On failure, throws an exception or returns <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Led']['isOnline']={syn:'Checks if the LED is currently reachable, without raising any error.',lib:'led.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the LED is currently reachable, without raising any error. If there is a cached value for the LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the LED.</p>',ret:'<tt>true</tt> if the LED can be reached, and <tt>false</tt> otherwise'};
doc['Led']['load']={syn:'Preloads the LED cache with a specified validity duration.',lib:'led.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'led.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Led']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'led.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['nextLed']={syn:'Continues the enumeration of LEDs started using <tt>yFirstLed()</tt>.',lib:'led.nextLed()',pro:'def nextLed()',cmt:'<p>Continues the enumeration of LEDs started using <tt>yFirstLed()</tt>. Caution: You can\x27t make any assumption about the returned LEDs order. If you want to find a specific a LED, use <tt>Led.findLed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a LED currently online, or a <tt>null</tt> pointer if there are no more LEDs to enumerate.'};
doc['Led']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'led.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Led']['set_blinking']={syn:'Changes the current LED signaling mode.',lib:'led.set_blinking()',pro:'def set_blinking(<span id=pn>newval</span>)',cmt:'<p>Changes the current LED signaling mode.</p>',par:{newval:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current LED signaling mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the LED.',lib:'led.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the LED.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_luminosity']={syn:'Changes the current LED intensity (in per cent).',lib:'led.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the current LED intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current LED intensity (in per cent)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_power']={syn:'Changes the state of the LED.',lib:'led.set_power()',pro:'def set_power(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the LED.</p>',par:{newval:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the state of the LED'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'led.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Led']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'led.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Led)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'from yocto_vsource import *',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['FindVSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YVSource.FindVSource()',pro:'def FindVSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YVSource</tt> object allowing you to drive the voltage source.'};
doc['VSource']['FirstVSource']={syn:'Starts the enumeration of voltage sources currently accessible.',lib:'YVSource.FirstVSource()',pro:'def FirstVSource()',cmt:'<p>Starts the enumeration of voltage sources currently accessible. Use the method <tt>YVSource.nextVSource()</tt> to iterate on next voltage sources.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to the first voltage source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'vsource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'vsource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['VSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'vsource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'vsource.get_extPowerFailure()',pro:'def get_extPowerFailure()',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>Y_EXTPOWERFAILURE_FALSE</tt> or <tt>Y_EXTPOWERFAILURE_TRUE</tt>, according to true if external power supply voltage is too low',ext:'On failure, throws an exception or returns <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'vsource.get_failure()',pro:'def get_failure()',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>Y_FAILURE_FALSE</tt> or <tt>Y_FAILURE_TRUE</tt>, according to true if the module is in failure mode',ext:'On failure, throws an exception or returns <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'vsource.get_vsourceDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'vsource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'vsource.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'vsource.get_overCurrent()',pro:'def get_overCurrent()',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>Y_OVERCURRENT_FALSE</tt> or <tt>Y_OVERCURRENT_TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'vsource.get_overHeat()',pro:'def get_overHeat()',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>Y_OVERHEAT_FALSE</tt> or <tt>Y_OVERHEAT_TRUE</tt>, according to TRUE if the module is overheating',ext:'On failure, throws an exception or returns <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'vsource.get_overLoad()',pro:'def get_overLoad()',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>Y_OVERLOAD_FALSE</tt> or <tt>Y_OVERLOAD_TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:'On failure, throws an exception or returns <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'vsource.get_regulationFailure()',pro:'def get_regulationFailure()',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>Y_REGULATIONFAILURE_FALSE</tt> or <tt>Y_REGULATIONFAILURE_TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:'On failure, throws an exception or returns <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'vsource.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VSource']['get_voltage']={syn:'Returns the voltage output command (mV) ',lib:'vsource.get_voltage()',pro:'def get_voltage()',cmt:'<p>Returns the voltage output command (mV)</p>',ret:'an integer corresponding to the voltage output command (mV)',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'vsource.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['VSource']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'vsource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['VSource']['nextVSource']={syn:'Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'def nextVSource()',cmt:'<p>Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more voltage sources to enumerate.'};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'vsource.pulse()',pro:'def pulse(<span id=pn>voltage</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'vsource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'vsource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'vsource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'vsource.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'vsource.voltageMove()',pro:'def voltageMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'from yocto_network import *',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork.FindNetwork()',pro:'def FindNetwork(<span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork.FirstNetwork()',pro:'def FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'network.callbackLogin()',pro:'def callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['clearCache']={syn:'Invalidates the cache.',lib:'network.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the network interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Network']['describe']={syn:'Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the network interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network.get_adminPassword()',pro:'def get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network.get_callbackCredentials()',pro:'def get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network.get_callbackEncoding()',pro:'def get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> and <tt>Y_CALLBACKENCODING_PRTG</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackInitialDelay']={syn:'Returns the initial waiting time before first callback notifications, in seconds.',lib:'network.get_callbackInitialDelay()',pro:'def get_callbackInitialDelay()',cmt:'<p>Returns the initial waiting time before first callback notifications, in seconds.</p>',ret:'an integer corresponding to the initial waiting time before first callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKINITIALDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the waiting time between two HTTP callbacks when there is nothing new.',lib:'network.get_callbackMaxDelay()',pro:'def get_callbackMaxDelay()',cmt:'<p>Returns the waiting time between two HTTP callbacks when there is nothing new.</p>',ret:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'network.get_callbackMethod()',pro:'def get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two HTTP callbacks, in seconds.',lib:'network.get_callbackMinDelay()',pro:'def get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two HTTP callbacks, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackSchedule']={syn:'Returns the HTTP callback schedule strategy, as a text string.',lib:'network.get_callbackSchedule()',pro:'def get_callbackSchedule()',cmt:'<p>Returns the HTTP callback schedule strategy, as a text string.</p>',ret:'a string corresponding to the HTTP callback schedule strategy, as a text string',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKSCHEDULE_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network.get_callbackUrl()',pro:'def get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_defaultPage']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network.get_defaultPage()',pro:'def get_defaultPage()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_DEFAULTPAGE_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.get_discoverable()',pro:'def get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with the network interface.',lib:'network.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the network interface object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with the network interface.',lib:'network.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the network interface object'};
doc['Network']['get_friendlyName']={syn:'Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'network.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the network interface if they are defined, otherwise the serial number of the module and the hardware identifier of the network interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the network interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_functionId']={syn:'Returns the hardware identifier of the network interface, without reference to the module.',lib:'network.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the network interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the network interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'network.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the network interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the network interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_httpPort']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network.get_httpPort()',pro:'def get_httpPort()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'an integer corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_HTTPPORT_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network.get_ipAddress()',pro:'def get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_ipConfig']={syn:'Returns the IP configuration of the network interface.',lib:'network.get_ipConfig()',pro:'def get_ipConfig()',cmt:'<p>Returns the IP configuration of the network interface.</p><p> If the network interface is setup to use a static IP address, the string starts with \x22STATIC:\x22 and is followed by three parameters, separated by \x22/\x22. The first is the device IP address, followed by the subnet mask length, and finally the router IP address (default gateway). For instance: \x22STATIC:192.168.1.14/16/192.168.1.1\x22</p><p> If the network interface is configured to receive its IP from a DHCP server, the string start with \x22DHCP:\x22 and is followed by three parameters separated by \x22/\x22. The first is the fallback IP address, then the fallback subnet mask length and finally the fallback router IP address. These three parameters are used when no DHCP reply is received.</p>',ret:'a string corresponding to the IP configuration of the network interface',ext:'On failure, throws an exception or returns <tt>Y_IPCONFIG_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'network.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network.get_macAddress()',pro:'def get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_ntpServer']={syn:'Returns the IP address of the NTP server to be used by the device.',lib:'network.get_ntpServer()',pro:'def get_ntpServer()',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:'On failure, throws an exception or returns <tt>Y_NTPSERVER_INVALID</tt>.'};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.',lib:'network.get_poeCurrent()',pro:'def get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milliamps',ext:'On failure, throws an exception or returns <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network.get_primaryDNS()',pro:'def get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network.get_readiness()',pro:'def get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network.get_router()',pro:'def get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network.get_secondaryDNS()',pro:'def get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network.get_subnetMask()',pro:'def get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'network.get_userPassword()',pro:'def get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.get_wwwWatchdogDelay()',pro:'def get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the network interface is currently reachable, without raising any error.',lib:'network.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the network interface is currently reachable, without raising any error. If there is a cached value for the network interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the network interface.</p>',ret:'<tt>true</tt> if the network interface can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the network interface cache with a specified validity duration.',lib:'network.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the network interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'network.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Network']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'network.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'def nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>. Caution: You can\x27t make any assumption about the returned network interfaces order. If you want to find a specific a network interface, use <tt>Network.findNetwork()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['ping']={syn:'Pings host to test the network connectivity.',lib:'network.ping()',pro:'def ping(<span id=pn>host</span>)',cmt:'<p>Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network.set_adminPassword()',pro:'def set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network.set_callbackCredentials()',pro:'def set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network.set_callbackEncoding()',pro:'def set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> and <tt>Y_CALLBACKENCODING_PRTG</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackInitialDelay']={syn:'Changes the initial waiting time before first callback notifications, in seconds.',lib:'network.set_callbackInitialDelay()',pro:'def set_callbackInitialDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the initial waiting time before first callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the initial waiting time before first callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the waiting time between two HTTP callbacks when there is nothing new.',lib:'network.set_callbackMaxDelay()',pro:'def set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting time between two HTTP callbacks when there is nothing new.</p>',par:{newval:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'network.set_callbackMethod()',pro:'def set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two HTTP callbacks, in seconds.',lib:'network.set_callbackMinDelay()',pro:'def set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two HTTP callbacks, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackSchedule']={syn:'Changes the HTTP callback schedule strategy, as a text string.',lib:'network.set_callbackSchedule()',pro:'def set_callbackSchedule(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP callback schedule strategy, as a text string.</p>',par:{newval:'a string corresponding to the HTTP callback schedule strategy, as a text string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'network.set_callbackUrl()',pro:'def set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_defaultPage']={syn:'Changes the default HTML page returned by the hub.',lib:'network.set_defaultPage()',pro:'def set_defaultPage(<span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible to change this page for file that has been uploaded on the hub.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.set_discoverable()',pro:'def set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_httpPort']={syn:'Changes the default HTML page returned by the hub.',lib:'network.set_httpPort()',pro:'def set_httpPort(<span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible to change this page for file that has been uploaded on the hub.</p>',par:{newval:'an integer corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'network.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_ntpServer']={syn:'Changes the IP address of the NTP server to be used by the module.',lib:'network.set_ntpServer()',pro:'def set_ntpServer(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the NTP server to be used by the module. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_periodicCallbackSchedule']={syn:'Setup periodic HTTP callbacks (simplified function).',lib:'network.set_periodicCallbackSchedule()',pro:'def set_periodicCallbackSchedule(<span id=pn>interval</span>, <span id=pn>offset</span>)',cmt:'<p>Setup periodic HTTP callbacks (simplified function).</p>',par:{interval:'a string representing the callback periodicity, expressed in seconds, minutes or hours, eg. \x2260s\x22, \x225m\x22, \x221h\x22, \x2248h\x22.',offset:'an integer representing the time offset relative to the period when the callback should occur. For instance, if the periodicity is 24h, an offset of 7 will make the callback occur each day at 7AM.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network.set_primaryDNS()',pro:'def set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'network.set_secondaryDNS()',pro:'def set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network.set_userPassword()',pro:'def set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.set_wwwWatchdogDelay()',pro:'def set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['triggerCallback']={syn:'Trigger an HTTP callback quickly.',lib:'network.triggerCallback()',pro:'def triggerCallback()',cmt:'<p>Trigger an HTTP callback quickly. This function can even be called within an HTTP callback, in which case the next callback will be triggered 5 seconds after the end of the current callback, regardless if the minimum time between callbacks configured in the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'network.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network.useDHCP()',pro:'def useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (e.g. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCPauto']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network.useDHCPauto()',pro:'def useDHCPauto()',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses an IP of the network 169.254.0.0/16 (APIPA). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network.useStaticIP()',pro:'def useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (e.g. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'from yocto_wireless import *',cmt:'<p>YWireless functions provides control over wireless network parameters and status for devices that are wireless-enabled.</p>'}};
doc['Wireless']['FindWireless']={syn:'Retrieves a wireless lan interface for a given identifier.',lib:'YWireless.FindWireless()',pro:'def FindWireless(<span id=pn>func</span>)',cmt:'<p>Retrieves a wireless lan interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wireless lan interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless lan interface is indeed online at a given time. In case of ambiguity when looking for a wireless lan interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wireless lan interface'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless lan interface.'};
doc['Wireless']['FirstWireless']={syn:'Starts the enumeration of wireless lan interfaces currently accessible.',lib:'YWireless.FirstWireless()',pro:'def FirstWireless()',cmt:'<p>Starts the enumeration of wireless lan interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless lan interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless lan interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'wireless.adhocNetwork()',pro:'def adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g, it is best to use softAPNetworkInstead(), which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['clearCache']={syn:'Invalidates the cache.',lib:'wireless.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wireless lan interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Wireless']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wireless lan interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'wireless.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'wireless.get_channel()',pro:'def get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:'On failure, throws an exception or returns <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects that describe detected Wireless networks.',lib:'wireless.get_detectedWlans()',pro:'def get_detectedWlans()',cmt:'<p>Returns a list of YWlanRecord objects that describe detected Wireless networks. This list is not updated when the module is already connected to an access point (infrastructure mode). To force an update of this list, <tt>startWlanScan()</tt> must be called. Note that an languages without garbage collections, the returned list must be freed by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Wireless']['get_errorMessage']={syn:'Returns the error message of the latest error with the wireless lan interface.',lib:'wireless.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wireless lan interface object'};
doc['Wireless']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wireless lan interface.',lib:'wireless.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wireless lan interface object'};
doc['Wireless']['get_friendlyName']={syn:'Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wireless.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wireless lan interface if they are defined, otherwise the serial number of the module and the hardware identifier of the wireless lan interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wireless lan interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wireless.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Wireless']['get_functionId']={syn:'Returns the hardware identifier of the wireless lan interface, without reference to the module.',lib:'wireless.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the wireless lan interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wireless lan interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wireless.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wireless lan interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wireless lan interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'wireless.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'wireless.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'wireless.get_message()',pro:'def get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wireless.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'wireless.get_security()',pro:'def get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> and <tt>Y_SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'wireless.get_ssid()',pro:'def get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Wireless']['get_wlanState']={syn:'Returns the current state of the wireless interface.',lib:'wireless.get_wlanState()',pro:'def get_wlanState()',cmt:'<p>Returns the current state of the wireless interface. The state <tt>Y_WLANSTATE_DOWN</tt> means that the network interface is not connected to a network. The state <tt>Y_WLANSTATE_SCANNING</tt> means that the network interface is scanning available frequencies. During this stage, the device is not reachable, and the network settings are not yet applied. The state <tt>Y_WLANSTATE_CONNECTED</tt> means that the network settings have been successfully applied ant that the device is reachable from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that the wireless network is up and that other devices can join the network. The state <tt>Y_WLANSTATE_REJECTED</tt> means that the network interface has not been able to join the requested network. The description of the error can be obtain with the <tt>get_message()</tt> method.</p>',ret:'a value among <tt>Y_WLANSTATE_DOWN</tt>, <tt>Y_WLANSTATE_SCANNING</tt>, <tt>Y_WLANSTATE_CONNECTED</tt> and <tt>Y_WLANSTATE_REJECTED</tt> corresponding to the current state of the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_WLANSTATE_INVALID</tt>.'};
doc['Wireless']['isOnline']={syn:'Checks if the wireless lan interface is currently reachable, without raising any error.',lib:'wireless.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the wireless lan interface is currently reachable, without raising any error. If there is a cached value for the wireless lan interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wireless lan interface.</p>',ret:'<tt>true</tt> if the wireless lan interface can be reached, and <tt>false</tt> otherwise'};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'wireless.joinNetwork()',pro:'def joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['load']={syn:'Preloads the wireless lan interface cache with a specified validity duration.',lib:'wireless.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wireless lan interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wireless.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Wireless']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wireless.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['nextWireless']={syn:'Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.',lib:'wireless.nextWireless()',pro:'def nextWireless()',cmt:'<p>Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>. Caution: You can\x27t make any assumption about the returned wireless lan interfaces order. If you want to find a specific a wireless lan interface, use <tt>Wireless.findWireless()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless lan interface currently online, or a <tt>null</tt> pointer if there are no more wireless lan interfaces to enumerate.'};
doc['Wireless']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wireless.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'wireless.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless lan interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wireless.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Wireless']['softAPNetwork']={syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'wireless.softAPNetwork()',pro:'def softAPNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g.</p><p> When a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['startWlanScan']={syn:'Triggers a scan of the wireless frequency and builds the list of available networks.',lib:'wireless.startWlanScan()',pro:'def startWlanScan()',cmt:'<p>Triggers a scan of the wireless frequency and builds the list of available networks. The scan forces a disconnection from the current network. At then end of the process, the the network interface attempts to reconnect to the previous network. During the scan, the <tt>wlanState</tt> switches to <tt>Y_WLANSTATE_DOWN</tt>, then to <tt>Y_WLANSTATE_SCANNING</tt>. When the scan is completed, <tt>get_wlanState()</tt> returns either <tt>Y_WLANSTATE_DOWN</tt> or <tt>Y_WLANSTATE_SCANNING</tt>. At this point, the list of detected network can be retrieved with the <tt>get_detectedWlans()</tt> method.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['Wireless']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wireless.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'from yocto_voc import *',cmt:'<p>The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voc']['FindVoc']={syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc.FindVoc()',pro:'def FindVoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'};
doc['Voc']['FirstVoc']={syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc.FirstVoc()',pro:'def FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['clearCache']={syn:'Invalidates the cache.',lib:'voc.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Volatile Organic Compound sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Voc']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'voc.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'voc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'voc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'voc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'voc.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Voc']['get_errorMessage']={syn:'Returns the error message of the latest error with the Volatile Organic Compound sensor.',lib:'voc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Volatile Organic Compound sensor.',lib:'voc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_friendlyName']={syn:'Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voc.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voc.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voc']['get_functionId']={syn:'Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module.',lib:'voc.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voc.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'voc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voc.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'voc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'voc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voc.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voc.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voc.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'voc.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'voc.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voc']['isOnline']={syn:'Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'voc.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voc']['load']={syn:'Preloads the Volatile Organic Compound sensor cache with a specified validity duration.',lib:'voc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voc.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Voc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voc.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voc.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['nextVoc']={syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'voc.nextVoc()',pro:'def nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>. Caution: You can\x27t make any assumption about the returned Volatile Organic Compound sensors order. If you want to find a specific a Volatile Organic Compound sensor, use <tt>Voc.findVoc()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'};
doc['Voc']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voc.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voc']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'voc.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voc.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'voc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voc.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voc.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voc.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voc.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voc']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voc.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'from yocto_watchdog import *',cmt:'<p>The watchdog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven directly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog.FindWatchdog()',pro:'def FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the watchdog'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog.FirstWatchdog()',pro:'def FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Watchdog']['clearCache']={syn:'Invalidates the cache.',lib:'watchdog.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the watchdog attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'watchdog.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['describe']={syn:'Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the watchdog (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'watchdog.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog running state at module power on.',lib:'watchdog.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the watchdog running state at module power on.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog running state at module power on',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'watchdog.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Returns the error message of the latest error with the watchdog.',lib:'watchdog.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the watchdog object'};
doc['Watchdog']['get_errorType']={syn:'Returns the numerical error code of the latest error with the watchdog.',lib:'watchdog.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the watchdog object'};
doc['Watchdog']['get_friendlyName']={syn:'Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'watchdog.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the watchdog if they are defined, otherwise the serial number of the module and the hardware identifier of the watchdog (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the watchdog using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'watchdog.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Watchdog']['get_functionId']={syn:'Returns the hardware identifier of the watchdog, without reference to the module.',lib:'watchdog.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the watchdog, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the watchdog (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'watchdog.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the watchdog (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the watchdog (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'watchdog.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'watchdog.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'watchdog.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'watchdog.get_running()',pro:'def get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'watchdog.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDelay()',pro:'def get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDuration()',pro:'def get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Watchdog']['isOnline']={syn:'Checks if the watchdog is currently reachable, without raising any error.',lib:'watchdog.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the watchdog is currently reachable, without raising any error. If there is a cached value for the watchdog in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the watchdog.</p>',ret:'<tt>true</tt> if the watchdog can be reached, and <tt>false</tt> otherwise'};
doc['Watchdog']['load']={syn:'Preloads the watchdog cache with a specified validity duration.',lib:'watchdog.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the watchdog cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'watchdog.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Watchdog']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'watchdog.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['nextWatchdog']={syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'watchdog.nextWatchdog()',pro:'def nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>. Caution: You can\x27t make any assumption about the returned watchdog order. If you want to find a specific a watchdog, use <tt>Watchdog.findWatchdog()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'watchdog.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'watchdog.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'watchdog.resetWatchdog()',pro:'def resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchdog to trigger</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog running state at module power on.',lib:'watchdog.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the watchdog running state at module power on. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog running state at module power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'watchdog.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'watchdog.set_running()',pro:'def set_running(<span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'watchdog.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDelay()',pro:'def set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDuration()',pro:'def set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'watchdog.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Watchdog']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'watchdog.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'from yocto_power import *',cmt:'<p>The Yoctopuce class YPower allows you to read and configure Yoctopuce power sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}};
doc['Power']['FindPower']={syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower.FindPower()',pro:'def FindPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'};
doc['Power']['FirstPower']={syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower.FirstPower()',pro:'def FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'power.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['clearCache']={syn:'Invalidates the cache.',lib:'power.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the electrical power sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Power']['describe']={syn:'Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the electrical power sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'power.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'power.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'power.get_cosPhi()',pro:'def get_cosPhi()',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:'On failure, throws an exception or returns <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'power.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'power.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'power.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Power']['get_errorMessage']={syn:'Returns the error message of the latest error with the electrical power sensor.',lib:'power.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the electrical power sensor object'};
doc['Power']['get_errorType']={syn:'Returns the numerical error code of the latest error with the electrical power sensor.',lib:'power.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the electrical power sensor object'};
doc['Power']['get_friendlyName']={syn:'Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'power.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the electrical power sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the electrical power sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the electrical power sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'power.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Power']['get_functionId']={syn:'Returns the hardware identifier of the electrical power sensor, without reference to the module.',lib:'power.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the electrical power sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the electrical power sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'power.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the electrical power sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the electrical power sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'power.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'power.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'power.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'power.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'power.get_meter()',pro:'def get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'power.get_meterTimer()',pro:'def get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'power.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Power']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'power.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Power']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'power.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'power.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'power.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the electrical power.',lib:'power.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Power']['isOnline']={syn:'Checks if the electrical power sensor is currently reachable, without raising any error.',lib:'power.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the electrical power sensor is currently reachable, without raising any error. If there is a cached value for the electrical power sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the electrical power sensor.</p>',ret:'<tt>true</tt> if the electrical power sensor can be reached, and <tt>false</tt> otherwise'};
doc['Power']['load']={syn:'Preloads the electrical power sensor cache with a specified validity duration.',lib:'power.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the electrical power sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'power.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Power']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'power.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'power.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['nextPower']={syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'power.nextPower()',pro:'def nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>. Caution: You can\x27t make any assumption about the returned electrical power sensors order. If you want to find a specific a electrical power sensor, use <tt>Power.findPower()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'};
doc['Power']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'power.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Power']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'power.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Power']['reset']={syn:'Resets the energy counter.',lib:'power.reset()',pro:'def reset()',cmt:'<p>Resets the energy counter.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'power.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'power.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'power.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'power.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'power.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'power.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'power.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'power.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Power']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'power.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Power']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'power.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Power']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'power.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'from yocto_display import *',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Retrieves a display for a given identifier.',lib:'YDisplay.FindDisplay()',pro:'def FindDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the display'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'};
doc['Display']['FirstDisplay']={syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay.FirstDisplay()',pro:'def FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Display']['clearCache']={syn:'Invalidates the cache.',lib:'display.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the display attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'display.copyLayerContent()',pro:'def copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['describe']={syn:'Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the display (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'display.fade()',pro:'def fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'display.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative LEDs (from 0 to 100).',lib:'display.get_brightness()',pro:'def get_brightness()',cmt:'<p>Returns the luminosity of the module informative LEDs (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative LEDs (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'display.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Returns a YDisplayLayer object that can be used to draw on the specified layer.',lib:'display.get_displayLayer()',pro:'def get_displayLayer(<span id=pn>layerId</span>)',cmt:'<p>Returns a YDisplayLayer object that can be used to draw on the specified layer. The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>',par:{layerId:'the identifier of the layer (a number in range 0..layerCount-1)'},ret:'an <tt>YDisplayLayer</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'display.get_displayType()',pro:'def get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> and <tt>Y_DISPLAYTYPE_RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'display.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_enabled']={syn:'Returns true if the screen is powered, false otherwise.',lib:'display.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the screen is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Returns the error message of the latest error with the display.',lib:'display.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the display object'};
doc['Display']['get_errorType']={syn:'Returns the numerical error code of the latest error with the display.',lib:'display.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the display object'};
doc['Display']['get_friendlyName']={syn:'Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'display.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the display if they are defined, otherwise the serial number of the module and the hardware identifier of the display (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the display using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'display.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Display']['get_functionId']={syn:'Returns the hardware identifier of the display, without reference to the module.',lib:'display.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the display, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the display (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'display.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the display (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the display (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'display.get_layerCount()',pro:'def get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'display.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'display.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'display.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'display.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'display.get_orientation()',pro:'def get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'display.get_startupSeq()',pro:'def get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Display']['isOnline']={syn:'Checks if the display is currently reachable, without raising any error.',lib:'display.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the display is currently reachable, without raising any error. If there is a cached value for the display in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the display.</p>',ret:'<tt>true</tt> if the display can be reached, and <tt>false</tt> otherwise'};
doc['Display']['load']={syn:'Preloads the display cache with a specified validity duration.',lib:'display.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the display cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'display.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Display']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'display.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'display.newSequence()',pro:'def newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['nextDisplay']={syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'display.nextDisplay()',pro:'def nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>. Caution: You can\x27t make any assumption about the returned displays order. If you want to find a specific a display, use <tt>Display.findDisplay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'display.pauseSequence()',pro:'def pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'def playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'display.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'display.resetAll()',pro:'def resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'display.saveSequence()',pro:'def saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'display.set_brightness()',pro:'def set_brightness(<span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_enabled']={syn:'Changes the power state of the display.',lib:'display.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the power state of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'display.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'display.set_orientation()',pro:'def set_orientation(<span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'display.set_startupSeq()',pro:'def set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'display.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'display.stopSequence()',pro:'def stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'display.swapLayerContent()',pro:'def swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between one hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'display.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'display.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Display)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'from yocto_files import *',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['FindFiles']={syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles.FindFiles()',pro:'def FindFiles(<span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the filesystem'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'};
doc['Files']['FirstFiles']={syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles.FirstFiles()',pro:'def FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Files']['clearCache']={syn:'Invalidates the cache.',lib:'files.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the filesystem attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Files']['describe']={syn:'Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the filesystem (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'files.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'};
doc['Files']['fileExist']={syn:'Test if a file exist on the filesystem of the module.',lib:'files.fileExist()',pro:'def fileExist(<span id=pn>filename</span>)',cmt:'<p>Test if a file exist on the filesystem of the module.</p>',par:{filename:'the file name to test.'},ret:'a true if the file exist, false otherwise.',ext:'On failure, throws an exception.'};
doc['Files']['format_fs']={syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'files.format_fs()',pro:'def format_fs()',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'files.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Returns the error message of the latest error with the filesystem.',lib:'files.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the filesystem object'};
doc['Files']['get_errorType']={syn:'Returns the numerical error code of the latest error with the filesystem.',lib:'files.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the filesystem object'};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'files.get_filesCount()',pro:'def get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'files.get_freeSpace()',pro:'def get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'files.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the filesystem if they are defined, otherwise the serial number of the module and the hardware identifier of the filesystem (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the filesystem using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'files.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Files']['get_functionId']={syn:'Returns the hardware identifier of the filesystem, without reference to the module.',lib:'files.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the filesystem, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the filesystem (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'files.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the filesystem (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the filesystem (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'files.get_list()',pro:'def get_list(<span id=pn>pattern</span>)',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wild cards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'files.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'files.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Files']['isOnline']={syn:'Checks if the filesystem is currently reachable, without raising any error.',lib:'files.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the filesystem is currently reachable, without raising any error. If there is a cached value for the filesystem in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the filesystem.</p>',ret:'<tt>true</tt> if the filesystem can be reached, and <tt>false</tt> otherwise'};
doc['Files']['load']={syn:'Preloads the filesystem cache with a specified validity duration.',lib:'files.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the filesystem cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'files.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Files']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'files.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['nextFiles']={syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'files.nextFiles()',pro:'def nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>. Caution: You can\x27t make any assumption about the returned filesystems order. If you want to find a specific a filesystem, use <tt>Files.findFiles()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'};
doc['Files']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'files.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'files.remove()',pro:'def remove(<span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'files.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'files.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Files']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'files.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'files.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'from yocto_realtimeclock import *',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Retrieves a clock for a given identifier.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'def FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Retrieves a clock for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the clock is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRealTimeClock.isOnline()</tt> to test if the clock is indeed online at a given time. In case of ambiguity when looking for a clock by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the clock'},ret:'a <tt>YRealTimeClock</tt> object allowing you to drive the clock.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Starts the enumeration of clocks currently accessible.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'def FirstRealTimeClock()',cmt:'<p>Starts the enumeration of clocks currently accessible. Use the method <tt>YRealTimeClock.nextRealTimeClock()</tt> to iterate on next clocks.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to the first clock currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RealTimeClock']['clearCache']={syn:'Invalidates the cache.',lib:'realtimeclock.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the clock attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RealTimeClock']['describe']={syn:'Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'realtimeclock.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the clock (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'realtimeclock.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'realtimeclock.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Returns the error message of the latest error with the clock.',lib:'realtimeclock.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the clock object'};
doc['RealTimeClock']['get_errorType']={syn:'Returns the numerical error code of the latest error with the clock.',lib:'realtimeclock.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the clock object'};
doc['RealTimeClock']['get_friendlyName']={syn:'Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'realtimeclock.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the clock if they are defined, otherwise the serial number of the module and the hardware identifier of the clock (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the clock using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'realtimeclock.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RealTimeClock']['get_functionId']={syn:'Returns the hardware identifier of the clock, without reference to the module.',lib:'realtimeclock.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the clock, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the clock (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RealTimeClock']['get_hardwareId']={syn:'Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'realtimeclock.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the clock (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the clock (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'realtimeclock.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'realtimeclock.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'realtimeclock.get_timeSet()',pro:'def get_timeSet()',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>Y_TIMESET_FALSE</tt> or <tt>Y_TIMESET_TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'realtimeclock.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'realtimeclock.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'Checks if the clock is currently reachable, without raising any error.',lib:'realtimeclock.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the clock is currently reachable, without raising any error. If there is a cached value for the clock in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the clock.</p>',ret:'<tt>true</tt> if the clock can be reached, and <tt>false</tt> otherwise'};
doc['RealTimeClock']['load']={syn:'Preloads the clock cache with a specified validity duration.',lib:'realtimeclock.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the clock cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'realtimeclock.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RealTimeClock']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'realtimeclock.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.',lib:'realtimeclock.nextRealTimeClock()',pro:'def nextRealTimeClock()',cmt:'<p>Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>. Caution: You can\x27t make any assumption about the returned clocks order. If you want to find a specific a clock, use <tt>RealTimeClock.findRealTimeClock()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to a clock currently online, or a <tt>null</tt> pointer if there are no more clocks to enumerate.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'realtimeclock.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'realtimeclock.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the clock. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the clock.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'realtimeclock.set_unixTime()',pro:'def set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'realtimeclock.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'realtimeclock.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'from yocto_wakeupmonitor import *',cmt:'<p>The WakeUpMonitor function handles globally all wake-up sources, as well as automated sleep mode.</p>'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Retrieves a monitor for a given identifier.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'def FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Retrieves a monitor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the monitor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpMonitor.isOnline()</tt> to test if the monitor is indeed online at a given time. In case of ambiguity when looking for a monitor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the monitor'},ret:'a <tt>YWakeUpMonitor</tt> object allowing you to drive the monitor.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Starts the enumeration of monitors currently accessible.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'def FirstWakeUpMonitor()',cmt:'<p>Starts the enumeration of monitors currently accessible. Use the method <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> to iterate on next monitors.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to the first monitor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpMonitor']['clearCache']={syn:'Invalidates the cache.',lib:'wakeupmonitor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the monitor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WakeUpMonitor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupmonitor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the monitor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'wakeupmonitor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Returns the error message of the latest error with the monitor.',lib:'wakeupmonitor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the monitor object'};
doc['WakeUpMonitor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the monitor.',lib:'wakeupmonitor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the monitor object'};
doc['WakeUpMonitor']['get_friendlyName']={syn:'Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupmonitor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the monitor if they are defined, otherwise the serial number of the module and the hardware identifier of the monitor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the monitor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupmonitor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionId']={syn:'Returns the hardware identifier of the monitor, without reference to the module.',lib:'wakeupmonitor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the monitor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the monitor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupmonitor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the monitor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the monitor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'wakeupmonitor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupmonitor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Returns the next scheduled wake up date/time (UNIX format).',lib:'wakeupmonitor.get_nextWakeUp()',pro:'def get_nextWakeUp()',cmt:'<p>Returns the next scheduled wake up date/time (UNIX format).</p>',ret:'an integer corresponding to the next scheduled wake up date/time (UNIX format)',ext:'On failure, throws an exception or returns <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'wakeupmonitor.get_powerDuration()',pro:'def get_powerDuration()',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:'On failure, throws an exception or returns <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before the next sleep period.',lib:'wakeupmonitor.get_sleepCountdown()',pro:'def get_sleepCountdown()',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:'On failure, throws an exception or returns <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupmonitor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Returns the latest wake up reason.',lib:'wakeupmonitor.get_wakeUpReason()',pro:'def get_wakeUpReason()',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt> and <tt>Y_WAKEUPREASON_SCHEDULE2</tt> corresponding to the latest wake up reason',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Returns the current state of the monitor.',lib:'wakeupmonitor.get_wakeUpState()',pro:'def get_wakeUpState()',cmt:'<p>Returns the current state of the monitor.</p>',ret:'either <tt>Y_WAKEUPSTATE_SLEEPING</tt> or <tt>Y_WAKEUPSTATE_AWAKE</tt>, according to the current state of the monitor',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'Checks if the monitor is currently reachable, without raising any error.',lib:'wakeupmonitor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the monitor is currently reachable, without raising any error. If there is a cached value for the monitor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the monitor.</p>',ret:'<tt>true</tt> if the monitor can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpMonitor']['load']={syn:'Preloads the monitor cache with a specified validity duration.',lib:'wakeupmonitor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the monitor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wakeupmonitor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WakeUpMonitor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wakeupmonitor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.',lib:'wakeupmonitor.nextWakeUpMonitor()',pro:'def nextWakeUpMonitor()',cmt:'<p>Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>. Caution: You can\x27t make any assumption about the returned monitors order. If you want to find a specific a monitor, use <tt>WakeUpMonitor.findWakeUpMonitor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to a monitor currently online, or a <tt>null</tt> pointer if there are no more monitors to enumerate.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupmonitor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Resets the sleep countdown.',lib:'wakeupmonitor.resetSleepCountDown()',pro:'def resetSleepCountDown()',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'wakeupmonitor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the monitor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the monitor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupmonitor.set_nextWakeUp()',pro:'def set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'wakeupmonitor.set_powerDuration()',pro:'def set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before the next sleep period.',lib:'wakeupmonitor.set_sleepCountdown()',pro:'def set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupmonitor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpMonitor']['sleep']={syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleep()',pro:'def sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepFor']={syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepFor()',pro:'def sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepUntil()',pro:'def sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wakeupmonitor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wake up.',lib:'wakeupmonitor.wakeUp()',pro:'def wakeUp()',cmt:'<p>Forces a wake up.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'from yocto_wakeupschedule import *',cmt:'<p>The WakeUpSchedule function implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Retrieves a wake up schedule for a given identifier.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'def FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Retrieves a wake up schedule for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wake up schedule is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpSchedule.isOnline()</tt> to test if the wake up schedule is indeed online at a given time. In case of ambiguity when looking for a wake up schedule by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wake up schedule'},ret:'a <tt>YWakeUpSchedule</tt> object allowing you to drive the wake up schedule.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Starts the enumeration of wake up schedules currently accessible.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'def FirstWakeUpSchedule()',cmt:'<p>Starts the enumeration of wake up schedules currently accessible. Use the method <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> to iterate on next wake up schedules.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to the first wake up schedule currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpSchedule']['clearCache']={syn:'Invalidates the cache.',lib:'wakeupschedule.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wake up schedule attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WakeUpSchedule']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupschedule.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wake up schedule (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'wakeupschedule.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Returns the error message of the latest error with the wake up schedule.',lib:'wakeupschedule.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wake up schedule object'};
doc['WakeUpSchedule']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wake up schedule.',lib:'wakeupschedule.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wake up schedule object'};
doc['WakeUpSchedule']['get_friendlyName']={syn:'Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupschedule.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wake up schedule if they are defined, otherwise the serial number of the module and the hardware identifier of the wake up schedule (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wake up schedule using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupschedule.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionId']={syn:'Returns the hardware identifier of the wake up schedule, without reference to the module.',lib:'wakeupschedule.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the wake up schedule, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wake up schedule (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupschedule.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wake up schedule (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wake up schedule (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake up.',lib:'wakeupschedule.get_hours()',pro:'def get_hours()',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake up schedule.',lib:'wakeupschedule.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'wakeupschedule.get_minutes()',pro:'def get_minutes()',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'wakeupschedule.get_minutesA()',pro:'def get_minutesA()',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes in the 30-59 interval of each hour scheduled for wake up.',lib:'wakeupschedule.get_minutesB()',pro:'def get_minutesB()',cmt:'<p>Returns the minutes in the 30-59 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupschedule.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of the month scheduled for wake up.',lib:'wakeupschedule.get_monthDays()',pro:'def get_monthDays()',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Returns the months scheduled for wake up.',lib:'wakeupschedule.get_months()',pro:'def get_months()',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Returns the date/time (seconds) of the next wake up occurrence.',lib:'wakeupschedule.get_nextOccurence()',pro:'def get_nextOccurence()',cmt:'<p>Returns the date/time (seconds) of the next wake up occurrence.</p>',ret:'an integer corresponding to the date/time (seconds) of the next wake up occurrence',ext:'On failure, throws an exception or returns <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupschedule.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of the week scheduled for wake up.',lib:'wakeupschedule.get_weekDays()',pro:'def get_weekDays()',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'Checks if the wake up schedule is currently reachable, without raising any error.',lib:'wakeupschedule.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the wake up schedule is currently reachable, without raising any error. If there is a cached value for the wake up schedule in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wake up schedule.</p>',ret:'<tt>true</tt> if the wake up schedule can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpSchedule']['load']={syn:'Preloads the wake up schedule cache with a specified validity duration.',lib:'wakeupschedule.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wake up schedule cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wakeupschedule.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WakeUpSchedule']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wakeupschedule.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.',lib:'wakeupschedule.nextWakeUpSchedule()',pro:'def nextWakeUpSchedule()',cmt:'<p>Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>. Caution: You can\x27t make any assumption about the returned wake up schedules order. If you want to find a specific a wake up schedule, use <tt>WakeUpSchedule.findWakeUpSchedule()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to a wake up schedule currently online, or a <tt>null</tt> pointer if there are no more wake up schedules to enumerate.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupschedule.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours when a wake up must take place.',lib:'wakeupschedule.set_hours()',pro:'def set_hours(<span id=pn>newval</span>)',cmt:'<p>Changes the hours when a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake up schedule.',lib:'wakeupschedule.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake up schedule. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'wakeupschedule.set_minutes()',pro:'def set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'wakeupschedule.set_minutesA()',pro:'def set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'wakeupschedule.set_minutesB()',pro:'def set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the month when a wake up must take place.',lib:'wakeupschedule.set_monthDays()',pro:'def set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the month when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_months']={syn:'Changes the months when a wake up must take place.',lib:'wakeupschedule.set_months()',pro:'def set_months(<span id=pn>newval</span>)',cmt:'<p>Changes the months when a wake up must take place.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupschedule.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupschedule.set_weekDays()',pro:'def set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wakeupschedule.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'from yocto_genericsensor import *',cmt:'<p>The YGenericSensor class allows you to read and configure Yoctopuce signal transducers. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Retrieves a generic sensor for a given identifier.',lib:'YGenericSensor.FindGenericSensor()',pro:'def FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a generic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the generic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGenericSensor.isOnline()</tt> to test if the generic sensor is indeed online at a given time. In case of ambiguity when looking for a generic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the generic sensor'},ret:'a <tt>YGenericSensor</tt> object allowing you to drive the generic sensor.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Starts the enumeration of generic sensors currently accessible.',lib:'YGenericSensor.FirstGenericSensor()',pro:'def FirstGenericSensor()',cmt:'<p>Starts the enumeration of generic sensors currently accessible. Use the method <tt>YGenericSensor.nextGenericSensor()</tt> to iterate on next generic sensors.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to the first generic sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'genericsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['clearCache']={syn:'Invalidates the cache.',lib:'genericsensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the generic sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['GenericSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'genericsensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the generic sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GenericSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'genericsensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'genericsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'genericsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'genericsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'genericsensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['GenericSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the generic sensor.',lib:'genericsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the generic sensor object'};
doc['GenericSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the generic sensor.',lib:'genericsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the generic sensor object'};
doc['GenericSensor']['get_friendlyName']={syn:'Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'genericsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the generic sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the generic sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the generic sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'genericsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GenericSensor']['get_functionId']={syn:'Returns the hardware identifier of the generic sensor, without reference to the module.',lib:'genericsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the generic sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the generic sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GenericSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'genericsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the generic sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the generic sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'genericsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'genericsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'genericsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'genericsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'genericsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GenericSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'genericsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'genericsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'genericsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'genericsensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GenericSensor']['get_signalBias']={syn:'Returns the electric signal bias for zero shift adjustment.',lib:'genericsensor.get_signalBias()',pro:'def get_signalBias()',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is under-reporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:'On failure, throws an exception or returns <tt>Y_SIGNALBIAS_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'genericsensor.get_signalRange()',pro:'def get_signalRange()',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalSampling']={syn:'Returns the electric signal sampling method to use.',lib:'genericsensor.get_signalSampling()',pro:'def get_signalSampling()',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> and <tt>Y_SIGNALSAMPLING_HIGHEST_RATE</tt> corresponding to the electric signal sampling method to use',ext:'On failure, throws an exception or returns <tt>Y_SIGNALSAMPLING_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'genericsensor.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'genericsensor.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'genericsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'genericsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'genericsensor.get_valueRange()',pro:'def get_valueRange()',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'Checks if the generic sensor is currently reachable, without raising any error.',lib:'genericsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the generic sensor is currently reachable, without raising any error. If there is a cached value for the generic sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the generic sensor.</p>',ret:'<tt>true</tt> if the generic sensor can be reached, and <tt>false</tt> otherwise'};
doc['GenericSensor']['load']={syn:'Preloads the generic sensor cache with a specified validity duration.',lib:'genericsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the generic sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'genericsensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'genericsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'genericsensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.',lib:'genericsensor.nextGenericSensor()',pro:'def nextGenericSensor()',cmt:'<p>Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>. Caution: You can\x27t make any assumption about the returned generic sensors order. If you want to find a specific a generic sensor, use <tt>GenericSensor.findGenericSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to a generic sensor currently online, or a <tt>null</tt> pointer if there are no more generic sensors to enumerate.'};
doc['GenericSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'genericsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GenericSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'genericsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GenericSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'genericsensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'genericsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'genericsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'genericsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the generic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'genericsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'genericsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'genericsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalBias']={syn:'Changes the electric signal bias for zero shift adjustment.',lib:'genericsensor.set_signalBias()',pro:'def set_signalBias(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positive when it should be zero, setup a positive signalBias of the same value to fix the zero shift.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'genericsensor.set_signalRange()',pro:'def set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal range used by the sensor. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalSampling']={syn:'Changes the electric signal sampling method to use.',lib:'genericsensor.set_signalSampling()',pro:'def set_signalSampling(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',par:{newval:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> and <tt>Y_SIGNALSAMPLING_HIGHEST_RATE</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'genericsensor.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'genericsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'genericsensor.set_valueRange()',pro:'def set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Changes the physical value range measured by the sensor. As a side effect, the range modification may automatically modify the display resolution. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'genericsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'genericsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'genericsensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['zeroAdjust']={syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'genericsensor.zeroAdjust()',pro:'def zeroAdjust()',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO function interface',inc:'from yocto_digitalio import *',cmt:'<p>The Yoctopuce application programming interface allows you to switch the state of each channel of the I/O port. You can switch all channels at once, or one by one. Most functions \x09 use a binary representation for channels where bit 0 matches channel #0 , bit 1 matches channel \x09 #1 and so on.... If you are not familiar with numbers binary representation, you will find more \x09 information here: en.wikipedia.org/wiki/Binary_number#Representation . The library can also automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}};
doc['DigitalIO']['FindDigitalIO']={syn:'Retrieves a digital IO port for a given identifier.',lib:'YDigitalIO.FindDigitalIO()',pro:'def FindDigitalIO(<span id=pn>func</span>)',cmt:'<p>Retrieves a digital IO port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the digital IO port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDigitalIO.isOnline()</tt> to test if the digital IO port is indeed online at a given time. In case of ambiguity when looking for a digital IO port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the digital IO port'},ret:'a <tt>YDigitalIO</tt> object allowing you to drive the digital IO port.'};
doc['DigitalIO']['FirstDigitalIO']={syn:'Starts the enumeration of digital IO ports currently accessible.',lib:'YDigitalIO.FirstDigitalIO()',pro:'def FirstDigitalIO()',cmt:'<p>Starts the enumeration of digital IO ports currently accessible. Use the method <tt>YDigitalIO.nextDigitalIO()</tt> to iterate on next digital IO ports.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to the first digital IO port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DigitalIO']['clearCache']={syn:'Invalidates the cache.',lib:'digitalio.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the digital IO port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DigitalIO']['delayedPulse']={syn:'Schedules a pulse on a single bit for a specified duration.',lib:'digitalio.delayedPulse()',pro:'def delayedPulse(<span id=pn>bitno</span>, <span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['describe']={syn:'Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'digitalio.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the digital IO port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DigitalIO']['get_advertisedValue']={syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'digitalio.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DigitalIO']['get_bitDirection']={syn:'Returns the direction of a single bit (i.e.',lib:'digitalio.get_bitDirection()',pro:'def get_bitDirection(<span id=pn>bitno</span>)',cmt:'<p>Returns the direction of a single bit (i.e. channel) from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'digitalio.get_bitOpenDrain()',pro:'def get_bitOpenDrain(<span id=pn>bitno</span>)',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitPolarity']={syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'digitalio.get_bitPolarity()',pro:'def get_bitPolarity(<span id=pn>bitno</span>)',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitState']={syn:'Returns the state of a single bit (i.e.',lib:'digitalio.get_bitState()',pro:'def get_bitState(<span id=pn>bitno</span>)',cmt:'<p>Returns the state of a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_errorMessage']={syn:'Returns the error message of the latest error with the digital IO port.',lib:'digitalio.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the digital IO port object'};
doc['DigitalIO']['get_errorType']={syn:'Returns the numerical error code of the latest error with the digital IO port.',lib:'digitalio.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the digital IO port object'};
doc['DigitalIO']['get_friendlyName']={syn:'Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'digitalio.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the digital IO port if they are defined, otherwise the serial number of the module and the hardware identifier of the digital IO port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the digital IO port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DigitalIO']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'digitalio.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DigitalIO']['get_functionId']={syn:'Returns the hardware identifier of the digital IO port, without reference to the module.',lib:'digitalio.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the digital IO port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the digital IO port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DigitalIO']['get_hardwareId']={syn:'Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'digitalio.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the digital IO port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the digital IO port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DigitalIO']['get_logicalName']={syn:'Returns the logical name of the digital IO port.',lib:'digitalio.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DigitalIO']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'digitalio.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DigitalIO']['get_outputVoltage']={syn:'Returns the voltage source used to drive output bits.',lib:'digitalio.get_outputVoltage()',pro:'def get_outputVoltage()',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:'On failure, throws an exception or returns <tt>Y_OUTPUTVOLTAGE_INVALID</tt>.'};
doc['DigitalIO']['get_portDiags']={syn:'Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only).',lib:'digitalio.get_portDiags()',pro:'def get_portDiags()',cmt:'<p>Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only). Bit 0 indicates a shortcut on output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent). During normal use, all diagnostic bits should stay clear.</p>',ret:'an integer corresponding to the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_PORTDIAGS_INVALID</tt>.'};
doc['DigitalIO']['get_portDirection']={syn:'Returns the IO direction of all bits (i.e.',lib:'digitalio.get_portDirection()',pro:'def get_portDirection()',cmt:'<p>Returns the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the IO direction of all bits (i.e',ext:'On failure, throws an exception or returns <tt>Y_PORTDIRECTION_INVALID</tt>.'};
doc['DigitalIO']['get_portOpenDrain']={syn:'Returns the electrical interface for each bit of the port.',lib:'digitalio.get_portOpenDrain()',pro:'def get_portOpenDrain()',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTOPENDRAIN_INVALID</tt>.'};
doc['DigitalIO']['get_portPolarity']={syn:'Returns the polarity of all the bits of the port.',lib:'digitalio.get_portPolarity()',pro:'def get_portPolarity()',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTPOLARITY_INVALID</tt>.'};
doc['DigitalIO']['get_portSize']={syn:'Returns the number of bits (i.e.',lib:'digitalio.get_portSize()',pro:'def get_portSize()',cmt:'<p>Returns the number of bits (i.e. channels)implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits (i.e',ext:'On failure, throws an exception or returns <tt>Y_PORTSIZE_INVALID</tt>.'};
doc['DigitalIO']['get_portState']={syn:'Returns the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on..',lib:'digitalio.get_portState()',pro:'def get_portState()',cmt:'<p>Returns the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on...</p>',ret:'an integer corresponding to the digital IO port state as an integer with each bit representing a channel value 0 = <tt>0b00000000</tt> -> all channels are OFF value 1 = <tt>0b00000001</tt> -> channel #0 is ON value 2 = <tt>0b00000010</tt> -> channel #1 is ON value 3 = <tt>0b00000011</tt> -> channels #0 and #1 are ON value 4 = <tt>0b00000100</tt> -> channel #2 is ON and so on.',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['DigitalIO']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'digitalio.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DigitalIO']['isOnline']={syn:'Checks if the digital IO port is currently reachable, without raising any error.',lib:'digitalio.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the digital IO port is currently reachable, without raising any error. If there is a cached value for the digital IO port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the digital IO port.</p>',ret:'<tt>true</tt> if the digital IO port can be reached, and <tt>false</tt> otherwise'};
doc['DigitalIO']['load']={syn:'Preloads the digital IO port cache with a specified validity duration.',lib:'digitalio.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the digital IO port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'digitalio.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DigitalIO']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'digitalio.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['nextDigitalIO']={syn:'Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.',lib:'digitalio.nextDigitalIO()',pro:'def nextDigitalIO()',cmt:'<p>Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>. Caution: You can\x27t make any assumption about the returned digital IO ports order. If you want to find a specific a digital IO port, use <tt>DigitalIO.findDigitalIO()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to a digital IO port currently online, or a <tt>null</tt> pointer if there are no more digital IO ports to enumerate.'};
doc['DigitalIO']['pulse']={syn:'Triggers a pulse on a single bit for a specified duration.',lib:'digitalio.pulse()',pro:'def pulse(<span id=pn>bitno</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'digitalio.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DigitalIO']['set_bitDirection']={syn:'Changes the direction of a single bit (i.e.',lib:'digitalio.set_bitDirection()',pro:'def set_bitDirection(<span id=pn>bitno</span>, <span id=pn>bitdirection</span>)',cmt:'<p>Changes the direction of a single bit (i.e. channel) from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'digitalio.set_bitOpenDrain()',pro:'def set_bitOpenDrain(<span id=pn>bitno</span>, <span id=pn>opendrain</span>)',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitPolarity']={syn:'Changes the polarity of a single bit from the I/O port.',lib:'digitalio.set_bitPolarity()',pro:'def set_bitPolarity(<span id=pn>bitno</span>, <span id=pn>bitpolarity</span>)',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitState']={syn:'Sets a single bit (i.e.',lib:'digitalio.set_bitState()',pro:'def set_bitState(<span id=pn>bitno</span>, <span id=pn>bitstate</span>)',cmt:'<p>Sets a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_logicalName']={syn:'Changes the logical name of the digital IO port.',lib:'digitalio.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the digital IO port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_outputVoltage']={syn:'Changes the voltage source used to drive output bits.',lib:'digitalio.set_outputVoltage()',pro:'def set_outputVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage source used to drive output bits. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portDirection']={syn:'Changes the IO direction of all bits (i.e.',lib:'digitalio.set_portDirection()',pro:'def set_portDirection(<span id=pn>newval</span>)',cmt:'<p>Changes the IO direction of all bits (i.e. channels) of the port: 0 makes a bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the IO direction of all bits (i.e'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portOpenDrain']={syn:'Changes the electrical interface for each bit of the port.',lib:'digitalio.set_portOpenDrain()',pro:'def set_portOpenDrain(<span id=pn>newval</span>)',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portPolarity']={syn:'Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.',lib:'digitalio.set_portPolarity()',pro:'def set_portPolarity(<span id=pn>newval</span>)',cmt:'<p>Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting will be kept after a reboot.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portState']={syn:'Changes the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel.',lib:'digitalio.set_portState()',pro:'def set_portState(<span id=pn>newval</span>)',cmt:'<p>Changes the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel. Bit 0 matches channel #0. So: To set all channels to 0 -> <tt>0b00000000</tt> -> parameter = 0 To set channel #0 to 1 -> <tt>0b00000001</tt> -> parameter = 1 To set channel #1 to 1 -> <tt>0b00000010</tt> -> parameter = 2 To set channel #0 and #1 -> <tt>0b00000011</tt> -> parameter = 3 To set channel #2 to 1 -> <tt>0b00000100</tt> -> parameter = 4 an so on.... Only channels configured as output, thanks to <tt>portDirection</tt>, are affected.</p>',par:{newval:'an integer corresponding to the state of all digital IO port\x27s channels at once, the parameter is an integer with each bit representing a channel'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'digitalio.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DigitalIO']['toggle_bitState']={syn:'Reverts a single bit (i.e.',lib:'digitalio.toggle_bitState()',pro:'def toggle_bitState(<span id=pn>bitno</span>)',cmt:'<p>Reverts a single bit (i.e. channel) of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'digitalio.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DigitalIO)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'from yocto_oscontrol import *',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Retrieves OS control for a given identifier.',lib:'YOsControl.FindOsControl()',pro:'def FindOsControl(<span id=pn>func</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the OS control'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'};
doc['OsControl']['FirstOsControl']={syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl.FirstOsControl()',pro:'def FirstOsControl()',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['OsControl']['clearCache']={syn:'Invalidates the cache.',lib:'oscontrol.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the OS control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['OsControl']['describe']={syn:'Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'oscontrol.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the OS control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'oscontrol.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Returns the error message of the latest error with the OS control.',lib:'oscontrol.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the OS control object'};
doc['OsControl']['get_errorType']={syn:'Returns the numerical error code of the latest error with the OS control.',lib:'oscontrol.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the OS control object'};
doc['OsControl']['get_friendlyName']={syn:'Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'oscontrol.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the OS control if they are defined, otherwise the serial number of the module and the hardware identifier of the OS control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the OS control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['OsControl']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'oscontrol.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['OsControl']['get_functionId']={syn:'Returns the hardware identifier of the OS control, without reference to the module.',lib:'oscontrol.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the OS control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the OS control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['OsControl']['get_hardwareId']={syn:'Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'oscontrol.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the OS control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the OS control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control.',lib:'oscontrol.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'oscontrol.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'oscontrol.get_shutdownCountdown()',pro:'def get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['OsControl']['isOnline']={syn:'Checks if the OS control is currently reachable, without raising any error.',lib:'oscontrol.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the OS control is currently reachable, without raising any error. If there is a cached value for the OS control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the OS control.</p>',ret:'<tt>true</tt> if the OS control can be reached, and <tt>false</tt> otherwise'};
doc['OsControl']['load']={syn:'Preloads the OS control cache with a specified validity duration.',lib:'oscontrol.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the OS control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'oscontrol.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['OsControl']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'oscontrol.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['nextOsControl']={syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'oscontrol.nextOsControl()',pro:'def nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>. Caution: You can\x27t make any assumption about the returned OS control order. If you want to find a specific OS control, use <tt>OsControl.findOsControl()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'};
doc['OsControl']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'oscontrol.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'oscontrol.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'oscontrol.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'oscontrol.shutdown()',pro:'def shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'oscontrol.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: OsControl)
//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'from yocto_api import *',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI.CheckLogicalName()',pro:'def CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI.DisableExceptions()',pro:'def DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI.EnableExceptions()',pro:'def EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI.FreeAPI()',pro:'def FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI.GetAPIVersion()',pro:'def GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetCacheValidity']={syn:'Returns the validity period of the data loaded by the library.',lib:'YAPI.GetCacheValidity()',pro:'def GetCacheValidity()',cmt:'<p>Returns the validity period of the data loaded by the library. This method returns the cache validity of all attributes module functions. Note: This function must be called after <tt>yInitAPI </tt>.</p>',ret:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'};
doc['YAPI']['GetDeviceListValidity']={syn:'Returns the time between each forced enumeration of the YoctoHub used.',lib:'YAPI.GetDeviceListValidity()',pro:'def GetDeviceListValidity()',cmt:'<p>Returns the time between each forced enumeration of the YoctoHub used. Note: This function must be called after <tt>yInitAPI</tt>.</p>',ret:'the number of seconds between each enumeration.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI.GetTickCount()',pro:'def GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the millisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI.HandleEvents()',pro:'def HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI.InitAPI()',pro:'def InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['PreregisterHub']={syn:'Fault-tolerant alternative to <tt>RegisterHub()</tt>.',lib:'YAPI.PreregisterHub()',pro:'def PreregisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Fault-tolerant alternative to <tt>RegisterHub()</tt>. This function has the same purpose and same arguments as <tt>RegisterHub()</tt>, but does not trigger an error when the selected hub is not available at the time of the function call. This makes it possible to register a network hub independently of the current connectivity, and to try to contact it only when a device is actively needed.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is plugged.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'def RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is plugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unplugged.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'def RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unplugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI.RegisterHub()',pro:'def RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. The parameter will determine how the API will work. Use the following values:</p><p> <b>usb</b>: When the <ui>usb</ui> keyword is used, the API will work with devices connected directly to the USB bus. Some programming languages such a JavaScript, PHP, and Java don\x27t provide direct access to USB hardware, so <ui>usb</ui> will not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).</p><p> <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the host with the given IP address or hostname. That host can be a regular computer running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or YoctoHub-Wireless. If you want to use the VirtualHub running on you local computer, use the IP address 127.0.0.1.</p><p> <b>callback</b>: that keyword make the API run in \x22<i>HTTP Callback</i>\x22 mode. This a special mode allowing to take control of Yoctopuce devices through a NAT filter when using a VirtualHub or a networked YoctoHub. You only need to configure your hub to call your server script on a regular basis. This mode is currently available for PHP and Node.JS only.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access.</p><p> If access control has been activated on the hub, virtual or not, you want to reach, the URL parameter should look like:</p><p> <tt>http://username:password@address:port</tt></p><p> You can call <i>RegisterHub</i> several times to connect to several machines.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterHubDiscoveryCallback']={syn:'Register a callback function, to be called each time an Network Hub send an SSDP message.',lib:'YAPI.RegisterHubDiscoveryCallback()',pro:'def RegisterHubDiscoveryCallback(<span id=pn>hubDiscoveryCallback</span>)',cmt:'<p>Register a callback function, to be called each time an Network Hub send an SSDP message. The callback has two string parameter, the first one contain the serial number of the hub and the second contain the URL of the network hub (this URL can be passed to RegisterHub). This callback will be invoked while yUpdateDeviceList is running. You will have to call this function on a regular basis.</p>',par:{hubDiscoveryCallback:'a procedure taking two string parameter, the serial number and the hub URL. Use <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterLogFunction']={syn:'Registers a log callback function.',lib:'YAPI.RegisterLogFunction()',pro:'def RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite useful to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['SelectArchitecture']={syn:'Select the architecture or the library to be loaded to access to USB.',lib:'YAPI.SelectArchitecture()',pro:'def SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>Select the architecture or the library to be loaded to access to USB. By default, the Python library automatically detects the appropriate library to use. However, for Linux ARM, it not possible to reliably distinguish between a Hard Float (armhf) and a Soft Float (armel) install. For in this case, it is therefore recommended to manually select the proper architecture by calling <tt>SelectArchitecture()</tt> before any other call to the library.</p>',par:{arch:'A string containing the architecture to use. Possibles value are: <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>,<tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'nothing.',ext:'On failure, throws an exception.'};
doc['YAPI']['SetCacheValidity']={syn:'Change the validity period of the data loaded by the library.',lib:'YAPI.SetCacheValidity()',pro:'def SetCacheValidity(<span id=pn>cacheValidityMs</span>)',cmt:'<p>Change the validity period of the data loaded by the library. By default, when accessing a module, all the attributes of the module functions are automatically kept in cache for the standard duration (5 ms). This method can be used to change this standard duration, for example in order to reduce network or USB traffic. This parameter does not affect value change callbacks Note: This function must be called after <tt>yInitAPI</tt>.</p>',par:{cacheValidityMs:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds.'}};
doc['YAPI']['SetDeviceListValidity']={syn:'Change the time between each forced enumeration of the YoctoHub used.',lib:'YAPI.SetDeviceListValidity()',pro:'def SetDeviceListValidity(<span id=pn>deviceListValidity</span>)',cmt:'<p>Change the time between each forced enumeration of the YoctoHub used. By default, the library performs a complete enumeration every 10 seconds. To reduce network traffic it is possible to increase this delay. This is particularly useful when a YoctoHub is connected to a GSM network where the traffic is charged. This setting does not affect modules connected by USB, nor the operation of arrival/removal callbacks. Note: This function must be called after <tt>yInitAPI</tt>.</p>',par:{deviceListValidity:'number of seconds between each enumeration.'}};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI.Sleep()',pro:'def Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significantly. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['TestHub']={syn:'Test if the hub is reachable.',lib:'YAPI.TestHub()',pro:'def TestHub(<span id=pn>url</span>, <span id=pn>mstimeout</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Test if the hub is reachable. This method do not register the hub, it only test if the hub is usable. The url parameter follow the same convention as the <tt>RegisterHub</tt> method. This method is useful to verify the authentication parameters for a hub. It is possible to force this method to return after mstimeout milliseconds.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',mstimeout:'the number of millisecond available to test the connection.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'};
doc['YAPI']['TriggerHubDiscovery']={syn:'Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.',lib:'YAPI.TriggerHubDiscovery()',pro:'def TriggerHubDiscovery(<span id=pn>errmsg</span>=None)',cmt:'<p>Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'def UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI.UpdateDeviceList()',pro:'def UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'Unformatted data sequence',inc:'from yocto_api import *',cmt:'<p>YDataStream objects represent bare recorded measure sequences, exactly as found within the data logger present on Yoctopuce sensors.</p><p> In most cases, it is not necessary to use YDataStream objects directly, as the YDataSet objects (returned by the <tt>get_recordedData()</tt> method from sensors and the <tt>get_dataSets()</tt> method from the data logger) provide a more convenient interface.</p>'}};
doc['DataStream']['get_averageValue']={syn:'Returns the average of all measures observed within this stream.',lib:'datastream.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Returns the average of all measures observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the average value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_columnCount']={syn:'Returns the number of data columns present in this stream.',lib:'datastream.get_columnCount()',pro:'def get_columnCount()',cmt:'<p>Returns the number of data columns present in this stream. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of columns.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_columnNames']={syn:'Returns the title (or meaning) of each data column present in this stream.',lib:'datastream.get_columnNames()',pro:'def get_columnNames()',cmt:'<p>Returns the title (or meaning) of each data column present in this stream. In most case, the title of the data column is the hardware identifier of the sensor that produced the data. For streams recorded at a lower recording rate, the dataLogger stores the min, average and max value during each measure interval into three columns with suffixes _min, _avg and _max respectively.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'a list containing as many strings as there are columns in the data stream.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_data']={syn:'Returns a single measure from the data stream, specified by its row and column index.',lib:'datastream.get_data()',pro:'def get_data(<span id=pn>row</span>, <span id=pn>col</span>)',cmt:'<p>Returns a single measure from the data stream, specified by its row and column index. The meaning of the values present in each column can be obtained using the method get_columnNames().</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',par:{row:'row index',col:'column index'},ret:'a floating-point number',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Returns the whole data set contained in the stream, as a bidimensional table of numbers.',lib:'datastream.get_dataRows()',pro:'def get_dataRows()',cmt:'<p>Returns the whole data set contained in the stream, as a bidimensional table of numbers. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many elements as there are rows in the data stream. Each row itself is a list of floating-point numbers.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_dataSamplesIntervalMs']={syn:'Returns the number of milliseconds between two consecutive rows of this data stream.',lib:'datastream.get_dataSamplesIntervalMs()',pro:'def get_dataSamplesIntervalMs()',cmt:'<p>Returns the number of milliseconds between two consecutive rows of this data stream. By default, the data logger records one row per second, but the recording frequency can be changed for each device function</p>',ret:'an unsigned number corresponding to a number of milliseconds.'};
doc['DataStream']['get_maxValue']={syn:'Returns the largest measure observed within this stream.',lib:'datastream.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Returns the largest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the largest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_minValue']={syn:'Returns the smallest measure observed within this stream.',lib:'datastream.get_minValue()',pro:'def get_minValue()',cmt:'<p>Returns the smallest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the smallest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_realStartTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream.get_realStartTimeUTC()',pro:'def get_realStartTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p>',ret:'a floating-point number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
doc['DataStream']['get_rowCount']={syn:'Returns the number of data rows present in this stream.',lib:'datastream.get_rowCount()',pro:'def get_rowCount()',cmt:'<p>Returns the number of data rows present in this stream.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of rows.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_runIndex']={syn:'Returns the run index of the data stream.',lib:'datastream.get_runIndex()',pro:'def get_runIndex()',cmt:'<p>Returns the run index of the data stream. A run can be made of multiple datastreams, for different time intervals.</p>',ret:'an unsigned number corresponding to the run index.'};
doc['DataStream']['get_startTime']={syn:'Returns the relative start time of the data stream, measured in seconds.',lib:'datastream.get_startTime()',pro:'def get_startTime()',cmt:'<p>Returns the relative start time of the data stream, measured in seconds. For recent firmwares, the value is relative to the present time, which means the value is always negative. If the device uses a firmware older than version 13000, value is relative to the start of the time the device was powered on, and is always positive. If you need an absolute UTC timestamp, use <tt>get_realStartTimeUTC()</tt>.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_realStartTimeUTC()</tt>.</p>',ret:'an unsigned number corresponding to the number of seconds between the start of the run and the beginning of this data stream.'};
doc['DataStream']['get_startTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_realStartTimeUTC()</tt>.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
//--- (end of generated code: DataStream)
//--- (generated code: DataSet)
doc['DataSet']={'':{syn:'Recorded data sequence',inc:'from yocto_api import *',cmt:'<p>YDataSet objects make it possible to retrieve a set of recorded measures for a given sensor and a specified time interval. They can be used to load data points with a progress report. When the YDataSet object is instantiated by the <tt>get_recordedData()</tt> function, no data is yet loaded from the module. It is only when the <tt>loadMore()</tt> method is called over and over than data will be effectively loaded from the dataLogger.</p><p> A preview of available measures is available using the function <tt>get_preview()</tt> as soon as <tt>loadMore()</tt> has been called once. Measures themselves are available using function <tt>get_measures()</tt> when loaded by subsequent calls to <tt>loadMore()</tt>.</p><p> This class can only be used on devices that use a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>'}};
doc['DataSet']['get_endTimeUTC']={syn:'Returns the end time of the dataset, relative to the Jan 1, 1970.',lib:'dataset.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Returns the end time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the end time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the end time is updated to reflect the timestamp of the last measure actually found in the dataLogger within the specified range.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_summary()</tt> which contain more precise informations on the YDataSet.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the end of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_functionId']={syn:'Returns the hardware identifier of the function that performed the measure, without reference to the module.',lib:'dataset.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the function that performed the measure, without reference to the module. For example <tt>temperature1</tt>.</p>',ret:'a string that identifies the function (ex: <tt>temperature1</tt>)'};
doc['DataSet']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dataset.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function (for example <tt>THRMCPL1-123456.temperature1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>THRMCPL1-123456.temperature1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataSet']['get_measures']={syn:'Returns all measured values currently available for this DataSet, as a list of YMeasure objects.',lib:'dataset.get_measures()',pro:'def get_measures()',cmt:'<p>Returns all measured values currently available for this DataSet, as a list of YMeasure objects. Each item includes: - the start of the measure time interval - the end of the measure time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> Before calling this method, you should call <tt>loadMore()</tt> to load data from the device. You may have to call loadMore() several time until all rows are loaded, but you can start looking at available data rows before the load is complete.</p><p> The oldest measures are always loaded first, and the most recent measures will be loaded last. As a result, timestamps are normally sorted in ascending order within the measure table, unless there was an unexpected adjustment of the datalogger UTC clock.</p>',ret:'a table of records, where each record depicts the measured value for a given time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_measuresAt']={syn:'Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>.',lib:'dataset.get_measuresAt()',pro:'def get_measuresAt(<span id=pn>measure</span>)',cmt:'<p>Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>. The result is provided as a list of YMeasure objects.</p>',par:{measure:'condensed measure from the list previously returned by <tt>get_preview()</tt>.'},ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_preview']={syn:'Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects.',lib:'dataset.get_preview()',pro:'def get_preview()',cmt:'<p>Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects. Each item includes: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This preview is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_progress']={syn:'Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100.',lib:'dataset.get_progress()',pro:'def get_progress()',cmt:'<p>Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100. When the object is instantiated by <tt>get_dataSet</tt>, the progress is zero. Each time <tt>loadMore()</tt> is invoked, the progress is updated, to reach the value 100 only once all measures have been loaded.</p>',ret:'an integer in the range 0 to 100 (percentage of completion).'};
doc['DataSet']['get_startTimeUTC']={syn:'Returns the start time of the dataset, relative to the Jan 1, 1970.',lib:'dataset.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the start time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the start time is updated to reflect the timestamp of the first measure actually found in the dataLogger within the specified range.</p><p> <b>DEPRECATED</b>: This method has been replaced by <tt>get_summary()</tt> which contain more precise informations on the YDataSet.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_summary']={syn:'Returns an YMeasure object which summarizes the whole DataSet.',lib:'dataset.get_summary()',pro:'def get_summary()',cmt:'<p>Returns an YMeasure object which summarizes the whole DataSet. In includes the following information: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This summary is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'an YMeasure object'};
doc['DataSet']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'dataset.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string that represents a physical unit.',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['DataSet']['loadMore']={syn:'Loads the the next block of measures from the dataLogger, and updates the progress indicator.',lib:'dataset.loadMore()',pro:'def loadMore()',cmt:'<p>Loads the the next block of measures from the dataLogger, and updates the progress indicator.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DataSet)
//--- (generated code: Measure)
doc['Measure']={'':{syn:'Measured value',inc:'from yocto_api import *',cmt:'<p>YMeasure objects are used within the API to represent a value measured at a specified time. These objects are used in particular in conjunction with the YDataSet class.</p>'}};
doc['Measure']['get_averageValue']={syn:'Returns the average value observed during the time interval covered by this measure.',lib:'measure.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Returns the average value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the average value observed.'};
doc['Measure']['get_endTimeUTC']={syn:'Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher than 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the end of this measure.'};
doc['Measure']['get_maxValue']={syn:'Returns the largest value observed during the time interval covered by this measure.',lib:'measure.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Returns the largest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the largest value observed.'};
doc['Measure']['get_minValue']={syn:'Returns the smallest value observed during the time interval covered by this measure.',lib:'measure.get_minValue()',pro:'def get_minValue()',cmt:'<p>Returns the smallest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the smallest value observed.'};
doc['Measure']['get_startTimeUTC']={syn:'Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher then 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the beginning of this measure.'};
//--- (end of generated code: Measure)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'from yocto_display import *',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'displaylayer.clear()',pro:'def clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'displaylayer.clearConsole()',pro:'def clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'displaylayer.consoleOut()',pro:'def consoleOut(<span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'displaylayer.drawBar()',pro:'def drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'displaylayer.drawBitmap()',pro:'def drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'displaylayer.drawCircle()',pro:'def drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'displaylayer.drawDisc()',pro:'def drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'displaylayer.drawImage()',pro:'def drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'displaylayer.drawPixel()',pro:'def drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'displaylayer.drawRect()',pro:'def drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'displaylayer.drawText()',pro:'def drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['get_display']={syn:'Gets parent YDisplay.',lib:'displaylayer.get_display()',pro:'def get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'};
doc['DisplayLayer']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'displaylayer.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.'};
doc['DisplayLayer']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'displaylayer.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.'};
doc['DisplayLayer']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'displaylayer.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.'};
doc['DisplayLayer']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'displaylayer.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.'};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'displaylayer.hide()',pro:'def hide()',cmt:'<p>Hides the layer. The state of the layer is preserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'displaylayer.lineTo()',pro:'def lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'displaylayer.moveTo()',pro:'def moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'displaylayer.reset()',pro:'def reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectColorPen()',pro:'def selectColorPen(<span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'displaylayer.selectEraser()',pro:'def selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'displaylayer.selectFont()',pro:'def selectFont(<span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectGrayPen()',pro:'def selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lightest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'displaylayer.setAntialiasingMode()',pro:'def setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzziness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<tt>true</tt> to enable anti-aliasing, <tt>false</tt> to disable it.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'displaylayer.setConsoleBackground()',pro:'def setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleMargins()',pro:'def setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleWordWrap()',pro:'def setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behavior used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'displaylayer.setLayerPosition()',pro:'def setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'displaylayer.unhide()',pro:'def unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'from yocto_api import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['FindSensor']={syn:'Retrieves a sensor for a given identifier.',lib:'YSensor.FindSensor()',pro:'def FindSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSensor.isOnline()</tt> to test if the sensor is indeed online at a given time. In case of ambiguity when looking for a sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the sensor'},ret:'a <tt>YSensor</tt> object allowing you to drive the sensor.'};
doc['Sensor']['FirstSensor']={syn:'Starts the enumeration of sensors currently accessible.',lib:'YSensor.FirstSensor()',pro:'def FirstSensor()',cmt:'<p>Starts the enumeration of sensors currently accessible. Use the method <tt>YSensor.nextSensor()</tt> to iterate on next sensors.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to the first sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'sensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['clearCache']={syn:'Invalidates the cache.',lib:'sensor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Sensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'sensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Sensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'sensor.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Sensor']['get_advertisedValue']={syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'sensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'sensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'sensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Sensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'sensor.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Sensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the sensor.',lib:'sensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the sensor object'};
doc['Sensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the sensor.',lib:'sensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the sensor object'};
doc['Sensor']['get_friendlyName']={syn:'Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'sensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Sensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'sensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Sensor']['get_functionId']={syn:'Returns the hardware identifier of the sensor, without reference to the module.',lib:'sensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Sensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'sensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Sensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'sensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'sensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_logicalName']={syn:'Returns the logical name of the sensor.',lib:'sensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Sensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'sensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'sensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'sensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'sensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'sensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Sensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'sensor.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Sensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'sensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Sensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'sensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Sensor']['isOnline']={syn:'Checks if the sensor is currently reachable, without raising any error.',lib:'sensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the sensor is currently reachable, without raising any error. If there is a cached value for the sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the sensor.</p>',ret:'<tt>true</tt> if the sensor can be reached, and <tt>false</tt> otherwise'};
doc['Sensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'sensor.isSensorReady()',pro:'def isSensorReady()',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Sensor']['load']={syn:'Preloads the sensor cache with a specified validity duration.',lib:'sensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'sensor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'sensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'sensor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['nextSensor']={syn:'Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.',lib:'sensor.nextSensor()',pro:'def nextSensor()',cmt:'<p>Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>. Caution: You can\x27t make any assumption about the returned sensors order. If you want to find a specific a sensor, use <tt>Sensor.findSensor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to a sensor currently online, or a <tt>null</tt> pointer if there are no more sensors to enumerate.'};
doc['Sensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'sensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Sensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'sensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Sensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'sensor.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'sensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'sensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logicalName']={syn:'Changes the logical name of the sensor.',lib:'sensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'sensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'sensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'sensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'sensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'sensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'sensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'sensor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Sensor)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer function interface',inc:'from yocto_accelerometer import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Accelerometer']['FindAccelerometer']={syn:'Retrieves an accelerometer for a given identifier.',lib:'YAccelerometer.FindAccelerometer()',pro:'def FindAccelerometer(<span id=pn>func</span>)',cmt:'<p>Retrieves an accelerometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the accelerometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAccelerometer.isOnline()</tt> to test if the accelerometer is indeed online at a given time. In case of ambiguity when looking for an accelerometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the accelerometer'},ret:'a <tt>YAccelerometer</tt> object allowing you to drive the accelerometer.'};
doc['Accelerometer']['FirstAccelerometer']={syn:'Starts the enumeration of accelerometers currently accessible.',lib:'YAccelerometer.FirstAccelerometer()',pro:'def FirstAccelerometer()',cmt:'<p>Starts the enumeration of accelerometers currently accessible. Use the method <tt>YAccelerometer.nextAccelerometer()</tt> to iterate on next accelerometers.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to the first accelerometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Accelerometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'accelerometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['clearCache']={syn:'Invalidates the cache.',lib:'accelerometer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the accelerometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Accelerometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'accelerometer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the accelerometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Accelerometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'accelerometer.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Accelerometer']['get_advertisedValue']={syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'accelerometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'accelerometer.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Accelerometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'accelerometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_currentValue']={syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'accelerometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'accelerometer.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Accelerometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the accelerometer.',lib:'accelerometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the accelerometer object'};
doc['Accelerometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the accelerometer.',lib:'accelerometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the accelerometer object'};
doc['Accelerometer']['get_friendlyName']={syn:'Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'accelerometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the accelerometer if they are defined, otherwise the serial number of the module and the hardware identifier of the accelerometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the accelerometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Accelerometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'accelerometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Accelerometer']['get_functionId']={syn:'Returns the hardware identifier of the accelerometer, without reference to the module.',lib:'accelerometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the accelerometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the accelerometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Accelerometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'accelerometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the accelerometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the accelerometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Accelerometer']['get_highestValue']={syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'accelerometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'accelerometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_logicalName']={syn:'Returns the logical name of the accelerometer.',lib:'accelerometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Accelerometer']['get_lowestValue']={syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'accelerometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'accelerometer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Accelerometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'accelerometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'accelerometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'accelerometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Accelerometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'accelerometer.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Accelerometer']['get_unit']={syn:'Returns the measuring unit for the acceleration.',lib:'accelerometer.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Accelerometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'accelerometer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Accelerometer']['get_xValue']={syn:'Returns the X component of the acceleration, as a floating point number.',lib:'accelerometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_yValue']={syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'accelerometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_zValue']={syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'accelerometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Accelerometer']['isOnline']={syn:'Checks if the accelerometer is currently reachable, without raising any error.',lib:'accelerometer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the accelerometer is currently reachable, without raising any error. If there is a cached value for the accelerometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the accelerometer.</p>',ret:'<tt>true</tt> if the accelerometer can be reached, and <tt>false</tt> otherwise'};
doc['Accelerometer']['load']={syn:'Preloads the accelerometer cache with a specified validity duration.',lib:'accelerometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the accelerometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'accelerometer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'accelerometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'accelerometer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['nextAccelerometer']={syn:'Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.',lib:'accelerometer.nextAccelerometer()',pro:'def nextAccelerometer()',cmt:'<p>Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>. Caution: You can\x27t make any assumption about the returned accelerometers order. If you want to find a specific an accelerometer, use <tt>Accelerometer.findAccelerometer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to an accelerometer currently online, or a <tt>null</tt> pointer if there are no more accelerometers to enumerate.'};
doc['Accelerometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'accelerometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Accelerometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'accelerometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Accelerometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'accelerometer.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'accelerometer.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'accelerometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'accelerometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logicalName']={syn:'Changes the logical name of the accelerometer.',lib:'accelerometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the accelerometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'accelerometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'accelerometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'accelerometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'accelerometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Accelerometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'accelerometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Accelerometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'accelerometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Accelerometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'accelerometer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer function interface',inc:'from yocto_magnetometer import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Magnetometer']['FindMagnetometer']={syn:'Retrieves a magnetometer for a given identifier.',lib:'YMagnetometer.FindMagnetometer()',pro:'def FindMagnetometer(<span id=pn>func</span>)',cmt:'<p>Retrieves a magnetometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the magnetometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMagnetometer.isOnline()</tt> to test if the magnetometer is indeed online at a given time. In case of ambiguity when looking for a magnetometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the magnetometer'},ret:'a <tt>YMagnetometer</tt> object allowing you to drive the magnetometer.'};
doc['Magnetometer']['FirstMagnetometer']={syn:'Starts the enumeration of magnetometers currently accessible.',lib:'YMagnetometer.FirstMagnetometer()',pro:'def FirstMagnetometer()',cmt:'<p>Starts the enumeration of magnetometers currently accessible. Use the method <tt>YMagnetometer.nextMagnetometer()</tt> to iterate on next magnetometers.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to the first magnetometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Magnetometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'magnetometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['clearCache']={syn:'Invalidates the cache.',lib:'magnetometer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the magnetometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Magnetometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'magnetometer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the magnetometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Magnetometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'magnetometer.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Magnetometer']['get_advertisedValue']={syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'magnetometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'magnetometer.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Magnetometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'magnetometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_currentValue']={syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'magnetometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'magnetometer.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Magnetometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the magnetometer.',lib:'magnetometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the magnetometer object'};
doc['Magnetometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the magnetometer.',lib:'magnetometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the magnetometer object'};
doc['Magnetometer']['get_friendlyName']={syn:'Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'magnetometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the magnetometer if they are defined, otherwise the serial number of the module and the hardware identifier of the magnetometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the magnetometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Magnetometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'magnetometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Magnetometer']['get_functionId']={syn:'Returns the hardware identifier of the magnetometer, without reference to the module.',lib:'magnetometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the magnetometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the magnetometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Magnetometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'magnetometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the magnetometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the magnetometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Magnetometer']['get_highestValue']={syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'magnetometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'magnetometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_logicalName']={syn:'Returns the logical name of the magnetometer.',lib:'magnetometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Magnetometer']['get_lowestValue']={syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'magnetometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'magnetometer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Magnetometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'magnetometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'magnetometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'magnetometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Magnetometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'magnetometer.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Magnetometer']['get_unit']={syn:'Returns the measuring unit for the magnetic field.',lib:'magnetometer.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Magnetometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'magnetometer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Magnetometer']['get_xValue']={syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'magnetometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_yValue']={syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'magnetometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_zValue']={syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'magnetometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Magnetometer']['isOnline']={syn:'Checks if the magnetometer is currently reachable, without raising any error.',lib:'magnetometer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the magnetometer is currently reachable, without raising any error. If there is a cached value for the magnetometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the magnetometer.</p>',ret:'<tt>true</tt> if the magnetometer can be reached, and <tt>false</tt> otherwise'};
doc['Magnetometer']['load']={syn:'Preloads the magnetometer cache with a specified validity duration.',lib:'magnetometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the magnetometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'magnetometer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'magnetometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'magnetometer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['nextMagnetometer']={syn:'Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.',lib:'magnetometer.nextMagnetometer()',pro:'def nextMagnetometer()',cmt:'<p>Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>. Caution: You can\x27t make any assumption about the returned magnetometers order. If you want to find a specific a magnetometer, use <tt>Magnetometer.findMagnetometer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to a magnetometer currently online, or a <tt>null</tt> pointer if there are no more magnetometers to enumerate.'};
doc['Magnetometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'magnetometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Magnetometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'magnetometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Magnetometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'magnetometer.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'magnetometer.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'magnetometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'magnetometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logicalName']={syn:'Changes the logical name of the magnetometer.',lib:'magnetometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the magnetometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'magnetometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'magnetometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'magnetometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'magnetometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Magnetometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'magnetometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Magnetometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'magnetometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Magnetometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'magnetometer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Magnetometer)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Reference frame configuration',inc:'from yocto_refframe import *',cmt:'<p>This class is used to setup the base orientation of the Yocto-3D, so that the orientation functions, relative to the earth surface plane, use the proper reference frame. The class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}};
doc['RefFrame']['FindRefFrame']={syn:'Retrieves a reference frame for a given identifier.',lib:'YRefFrame.FindRefFrame()',pro:'def FindRefFrame(<span id=pn>func</span>)',cmt:'<p>Retrieves a reference frame for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the reference frame is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRefFrame.isOnline()</tt> to test if the reference frame is indeed online at a given time. In case of ambiguity when looking for a reference frame by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the reference frame'},ret:'a <tt>YRefFrame</tt> object allowing you to drive the reference frame.'};
doc['RefFrame']['FirstRefFrame']={syn:'Starts the enumeration of reference frames currently accessible.',lib:'YRefFrame.FirstRefFrame()',pro:'def FirstRefFrame()',cmt:'<p>Starts the enumeration of reference frames currently accessible. Use the method <tt>YRefFrame.nextRefFrame()</tt> to iterate on next reference frames.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to the first reference frame currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RefFrame']['cancel3DCalibration']={syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'refframe.cancel3DCalibration()',pro:'def cancel3DCalibration()',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['clearCache']={syn:'Invalidates the cache.',lib:'refframe.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the reference frame attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RefFrame']['describe']={syn:'Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'refframe.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the reference frame (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationHint()',pro:'def get_3DCalibrationHint()',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Returns the latest log message from the calibration process.',lib:'refframe.get_3DCalibrationLogMsg()',pro:'def get_3DCalibrationLogMsg()',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationProgress()',pro:'def get_3DCalibrationProgress()',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStage()',pro:'def get_3DCalibrationStage()',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStageProgress()',pro:'def get_3DCalibrationStageProgress()',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_advertisedValue']={syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'refframe.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RefFrame']['get_bearing']={syn:'Returns the reference bearing used by the compass.',lib:'refframe.get_bearing()',pro:'def get_bearing()',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:'On failure, throws an exception or returns <tt>Y_BEARING_INVALID</tt>.'};
doc['RefFrame']['get_calibrationState']={syn:'Returns the 3D sensor calibration state (Yocto-3D-V2 only).',lib:'refframe.get_calibrationState()',pro:'def get_calibrationState()',cmt:'<p>Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns an integer representing the calibration state of the 3 inertial sensors of the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state of the accelerometer, tenths show the calibration state of the magnetometer while units show the calibration state of the gyroscope. For each sensor, the value 0 means no calibration and the value 3 means full calibration.</p>',ret:'an integer representing the calibration state of Yocto-3D-V2: 333 when fully calibrated, 0 when not calibrated at all.',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'};
doc['RefFrame']['get_errorMessage']={syn:'Returns the error message of the latest error with the reference frame.',lib:'refframe.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the reference frame object'};
doc['RefFrame']['get_errorType']={syn:'Returns the numerical error code of the latest error with the reference frame.',lib:'refframe.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the reference frame object'};
doc['RefFrame']['get_friendlyName']={syn:'Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'refframe.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the reference frame if they are defined, otherwise the serial number of the module and the hardware identifier of the reference frame (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the reference frame using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RefFrame']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'refframe.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RefFrame']['get_functionId']={syn:'Returns the hardware identifier of the reference frame, without reference to the module.',lib:'refframe.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the reference frame, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the reference frame (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RefFrame']['get_hardwareId']={syn:'Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'refframe.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the reference frame (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the reference frame (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RefFrame']['get_logicalName']={syn:'Returns the logical name of the reference frame.',lib:'refframe.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RefFrame']['get_measureQuality']={syn:'Returns estimated quality of the orientation (Yocto-3D-V2 only).',lib:'refframe.get_measureQuality()',pro:'def get_measureQuality()',cmt:'<p>Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns an integer between 0 and 3 representing the degree of confidence of the position estimate. When the value is 3, the estimation is reliable. Below 3, one should expect sudden corrections, in particular for heading (<tt>compass</tt> function). The most frequent causes for values below 3 are magnetic interferences, and accelerations or rotations beyond the sensor range.</p>',ret:'an integer between 0 and 3 (3 when the measure is reliable)',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'};
doc['RefFrame']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'refframe.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RefFrame']['get_mountOrientation']={syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe.get_mountOrientation()',pro:'def get_mountOrientation()',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:'On failure, throws an exception or returns Y_MOUNTORIENTATION_INVALID.'};
doc['RefFrame']['get_mountPosition']={syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe.get_mountPosition()',pro:'def get_mountPosition()',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:'On failure, throws an exception or returns Y_MOUNTPOSITION_INVALID.'};
doc['RefFrame']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'refframe.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RefFrame']['isOnline']={syn:'Checks if the reference frame is currently reachable, without raising any error.',lib:'refframe.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the reference frame is currently reachable, without raising any error. If there is a cached value for the reference frame in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the reference frame.</p>',ret:'<tt>true</tt> if the reference frame can be reached, and <tt>false</tt> otherwise'};
doc['RefFrame']['load']={syn:'Preloads the reference frame cache with a specified validity duration.',lib:'refframe.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the reference frame cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'refframe.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RefFrame']['more3DCalibration']={syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'refframe.more3DCalibration()',pro:'def more3DCalibration()',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'refframe.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['nextRefFrame']={syn:'Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.',lib:'refframe.nextRefFrame()',pro:'def nextRefFrame()',cmt:'<p>Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>. Caution: You can\x27t make any assumption about the returned reference frames order. If you want to find a specific a reference frame, use <tt>RefFrame.findRefFrame()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to a reference frame currently online, or a <tt>null</tt> pointer if there are no more reference frames to enumerate.'};
doc['RefFrame']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'refframe.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RefFrame']['save3DCalibration']={syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'refframe.save3DCalibration()',pro:'def save3DCalibration()',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed. Remember to call the <tt>saveToFlash()</tt> method of the module if the changes must be kept when the device is restarted.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['set_bearing']={syn:'Changes the reference bearing used by the compass.',lib:'refframe.set_bearing()',pro:'def set_bearing(<span id=pn>newval</span>)',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p><p> For instance, if you setup as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North.</p><p> Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_logicalName']={syn:'Changes the logical name of the reference frame.',lib:'refframe.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the reference frame. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_mountPosition']={syn:'Changes the compass and tilt sensor frame of reference.',lib:'refframe.set_mountPosition()',pro:'def set_mountPosition(<span id=pn>position</span>, <span id=pn>orientation</span>)',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.'},ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'refframe.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RefFrame']['start3DCalibration']={syn:'Initiates the sensors tridimensional calibration process.',lib:'refframe.start3DCalibration()',pro:'def start3DCalibration()',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors.</p><p> After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be cancelled at any time using method <tt>cancel3DCalibration</tt>.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'refframe.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RefFrame)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function interface',inc:'from yocto_compass import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Compass']['FindCompass']={syn:'Retrieves a compass for a given identifier.',lib:'YCompass.FindCompass()',pro:'def FindCompass(<span id=pn>func</span>)',cmt:'<p>Retrieves a compass for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the compass is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCompass.isOnline()</tt> to test if the compass is indeed online at a given time. In case of ambiguity when looking for a compass by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the compass'},ret:'a <tt>YCompass</tt> object allowing you to drive the compass.'};
doc['Compass']['FirstCompass']={syn:'Starts the enumeration of compasses currently accessible.',lib:'YCompass.FirstCompass()',pro:'def FirstCompass()',cmt:'<p>Starts the enumeration of compasses currently accessible. Use the method <tt>YCompass.nextCompass()</tt> to iterate on next compasses.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to the first compass currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Compass']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'compass.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['clearCache']={syn:'Invalidates the cache.',lib:'compass.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the compass attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Compass']['describe']={syn:'Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'compass.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the compass (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Compass']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'compass.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Compass']['get_advertisedValue']={syn:'Returns the current value of the compass (no more than 6 characters).',lib:'compass.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the compass (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Compass']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'compass.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Compass']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'compass.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Compass']['get_currentValue']={syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'compass.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Compass']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'compass.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Compass']['get_errorMessage']={syn:'Returns the error message of the latest error with the compass.',lib:'compass.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the compass object'};
doc['Compass']['get_errorType']={syn:'Returns the numerical error code of the latest error with the compass.',lib:'compass.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the compass object'};
doc['Compass']['get_friendlyName']={syn:'Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'compass.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the compass if they are defined, otherwise the serial number of the module and the hardware identifier of the compass (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the compass using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Compass']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'compass.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Compass']['get_functionId']={syn:'Returns the hardware identifier of the compass, without reference to the module.',lib:'compass.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the compass, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the compass (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Compass']['get_hardwareId']={syn:'Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'compass.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the compass (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the compass (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Compass']['get_highestValue']={syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'compass.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Compass']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'compass.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_logicalName']={syn:'Returns the logical name of the compass.',lib:'compass.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the compass.</p>',ret:'a string corresponding to the logical name of the compass.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Compass']['get_lowestValue']={syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'compass.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Compass']['get_magneticHeading']={syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'compass.get_magneticHeading()',pro:'def get_magneticHeading()',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:'On failure, throws an exception or returns <tt>Y_MAGNETICHEADING_INVALID</tt>.'};
doc['Compass']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'compass.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Compass']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'compass.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Compass']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'compass.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'compass.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Compass']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'compass.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Compass']['get_unit']={syn:'Returns the measuring unit for the relative bearing.',lib:'compass.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Compass']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'compass.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Compass']['isOnline']={syn:'Checks if the compass is currently reachable, without raising any error.',lib:'compass.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the compass is currently reachable, without raising any error. If there is a cached value for the compass in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the compass.</p>',ret:'<tt>true</tt> if the compass can be reached, and <tt>false</tt> otherwise'};
doc['Compass']['load']={syn:'Preloads the compass cache with a specified validity duration.',lib:'compass.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the compass cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'compass.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Compass']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'compass.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'compass.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['nextCompass']={syn:'Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>.',lib:'compass.nextCompass()',pro:'def nextCompass()',cmt:'<p>Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>. Caution: You can\x27t make any assumption about the returned compasses order. If you want to find a specific a compass, use <tt>Compass.findCompass()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to a compass currently online, or a <tt>null</tt> pointer if there are no more compasses to enumerate.'};
doc['Compass']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'compass.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Compass']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'compass.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Compass']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'compass.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'compass.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'compass.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'compass.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logicalName']={syn:'Changes the logical name of the compass.',lib:'compass.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the compass. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the compass.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'compass.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'compass.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'compass.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'compass.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Compass']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'compass.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Compass']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'compass.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Compass']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'compass.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope function interface',inc:'from yocto_gyro import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Gyro']['FindGyro']={syn:'Retrieves a gyroscope for a given identifier.',lib:'YGyro.FindGyro()',pro:'def FindGyro(<span id=pn>func</span>)',cmt:'<p>Retrieves a gyroscope for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the gyroscope is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGyro.isOnline()</tt> to test if the gyroscope is indeed online at a given time. In case of ambiguity when looking for a gyroscope by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the gyroscope'},ret:'a <tt>YGyro</tt> object allowing you to drive the gyroscope.'};
doc['Gyro']['FirstGyro']={syn:'Starts the enumeration of gyroscopes currently accessible.',lib:'YGyro.FirstGyro()',pro:'def FirstGyro()',cmt:'<p>Starts the enumeration of gyroscopes currently accessible. Use the method <tt>YGyro.nextGyro()</tt> to iterate on next gyroscopes.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to the first gyro currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gyro']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'gyro.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['clearCache']={syn:'Invalidates the cache.',lib:'gyro.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the gyroscope attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Gyro']['describe']={syn:'Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gyro.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the gyroscope (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gyro']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'gyro.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Gyro']['get_advertisedValue']={syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'gyro.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gyro']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'gyro.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Gyro']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'gyro.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Gyro']['get_currentValue']={syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'gyro.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Gyro']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'gyro.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Gyro']['get_errorMessage']={syn:'Returns the error message of the latest error with the gyroscope.',lib:'gyro.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the gyroscope object'};
doc['Gyro']['get_errorType']={syn:'Returns the numerical error code of the latest error with the gyroscope.',lib:'gyro.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the gyroscope object'};
doc['Gyro']['get_friendlyName']={syn:'Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gyro.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the gyroscope if they are defined, otherwise the serial number of the module and the hardware identifier of the gyroscope (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the gyroscope using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gyro']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gyro.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gyro']['get_functionId']={syn:'Returns the hardware identifier of the gyroscope, without reference to the module.',lib:'gyro.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the gyroscope, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the gyroscope (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gyro']['get_hardwareId']={syn:'Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gyro.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the gyroscope (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the gyroscope (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gyro']['get_heading']={syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_heading()',pro:'def get_heading()',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'};
doc['Gyro']['get_highestValue']={syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'gyro.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'gyro.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_logicalName']={syn:'Returns the logical name of the gyroscope.',lib:'gyro.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gyro']['get_lowestValue']={syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'gyro.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gyro.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gyro']['get_pitch']={syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_pitch()',pro:'def get_pitch()',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'};
doc['Gyro']['get_quaternionW']={syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionW()',pro:'def get_quaternionW()',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.</p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionX()',pro:'def get_quaternionX()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionY()',pro:'def get_quaternionY()',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionZ()',pro:'def get_quaternionZ()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'gyro.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Gyro']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'gyro.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'gyro.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Gyro']['get_roll']={syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_roll()',pro:'def get_roll()',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'};
doc['Gyro']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'gyro.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Gyro']['get_unit']={syn:'Returns the measuring unit for the angular velocity.',lib:'gyro.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Gyro']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gyro.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gyro']['get_xValue']={syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'gyro.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Gyro']['get_yValue']={syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'gyro.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Gyro']['get_zValue']={syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'gyro.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Gyro']['isOnline']={syn:'Checks if the gyroscope is currently reachable, without raising any error.',lib:'gyro.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the gyroscope is currently reachable, without raising any error. If there is a cached value for the gyroscope in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the gyroscope.</p>',ret:'<tt>true</tt> if the gyroscope can be reached, and <tt>false</tt> otherwise'};
doc['Gyro']['load']={syn:'Preloads the gyroscope cache with a specified validity duration.',lib:'gyro.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the gyroscope cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'gyro.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Gyro']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'gyro.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'gyro.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['nextGyro']={syn:'Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.',lib:'gyro.nextGyro()',pro:'def nextGyro()',cmt:'<p>Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>. Caution: You can\x27t make any assumption about the returned gyroscopes order. If you want to find a specific a gyroscope, use <tt>Gyro.findGyro()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to a gyroscope currently online, or a <tt>null</tt> pointer if there are no more gyroscopes to enumerate.'};
doc['Gyro']['registerAnglesCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro.registerAnglesCallback()',pro:'def registerAnglesCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take four arguments: the YGyro object of the turning device, and the floating point values of the three angles roll, pitch and heading in degrees (as floating-point numbers).'}};
doc['Gyro']['registerQuaternionCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro.registerQuaternionCallback()',pro:'def registerQuaternionCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take five arguments: the YGyro object of the turning device, and the floating point values of the four components w, x, y and z (as floating-point numbers).'}};
doc['Gyro']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'gyro.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Gyro']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gyro.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gyro']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'gyro.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'gyro.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'gyro.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'gyro.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logicalName']={syn:'Changes the logical name of the gyroscope.',lib:'gyro.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the gyroscope. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'gyro.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'gyro.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'gyro.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gyro.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gyro']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'gyro.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Gyro']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'gyro.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Gyro']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'gyro.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt function interface',inc:'from yocto_tilt import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Tilt']['FindTilt']={syn:'Retrieves a tilt sensor for a given identifier.',lib:'YTilt.FindTilt()',pro:'def FindTilt(<span id=pn>func</span>)',cmt:'<p>Retrieves a tilt sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the tilt sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTilt.isOnline()</tt> to test if the tilt sensor is indeed online at a given time. In case of ambiguity when looking for a tilt sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the tilt sensor'},ret:'a <tt>YTilt</tt> object allowing you to drive the tilt sensor.'};
doc['Tilt']['FirstTilt']={syn:'Starts the enumeration of tilt sensors currently accessible.',lib:'YTilt.FirstTilt()',pro:'def FirstTilt()',cmt:'<p>Starts the enumeration of tilt sensors currently accessible. Use the method <tt>YTilt.nextTilt()</tt> to iterate on next tilt sensors.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to the first tilt sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Tilt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'tilt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['clearCache']={syn:'Invalidates the cache.',lib:'tilt.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the tilt sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Tilt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tilt.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the tilt sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tilt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'tilt.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Tilt']['get_advertisedValue']={syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'tilt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tilt']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'tilt.get_bandwidth()',pro:'def get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Tilt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'tilt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tilt']['get_currentValue']={syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'tilt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tilt']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'tilt.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Tilt']['get_errorMessage']={syn:'Returns the error message of the latest error with the tilt sensor.',lib:'tilt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the tilt sensor object'};
doc['Tilt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the tilt sensor.',lib:'tilt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the tilt sensor object'};
doc['Tilt']['get_friendlyName']={syn:'Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'tilt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the tilt sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the tilt sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the tilt sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tilt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'tilt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Tilt']['get_functionId']={syn:'Returns the hardware identifier of the tilt sensor, without reference to the module.',lib:'tilt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the tilt sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the tilt sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tilt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'tilt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the tilt sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the tilt sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tilt']['get_highestValue']={syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'tilt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'tilt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_logicalName']={syn:'Returns the logical name of the tilt sensor.',lib:'tilt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tilt']['get_lowestValue']={syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'tilt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'tilt.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Tilt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'tilt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tilt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'tilt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'tilt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tilt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'tilt.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Tilt']['get_unit']={syn:'Returns the measuring unit for the inclination.',lib:'tilt.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Tilt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'tilt.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Tilt']['isOnline']={syn:'Checks if the tilt sensor is currently reachable, without raising any error.',lib:'tilt.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the tilt sensor is currently reachable, without raising any error. If there is a cached value for the tilt sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the tilt sensor.</p>',ret:'<tt>true</tt> if the tilt sensor can be reached, and <tt>false</tt> otherwise'};
doc['Tilt']['load']={syn:'Preloads the tilt sensor cache with a specified validity duration.',lib:'tilt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the tilt sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'tilt.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Tilt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'tilt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'tilt.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['nextTilt']={syn:'Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.',lib:'tilt.nextTilt()',pro:'def nextTilt()',cmt:'<p>Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>. Caution: You can\x27t make any assumption about the returned tilt sensors order. If you want to find a specific a tilt sensor, use <tt>Tilt.findTilt()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to a tilt sensor currently online, or a <tt>null</tt> pointer if there are no more tilt sensors to enumerate.'};
doc['Tilt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'tilt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Tilt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'tilt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Tilt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'tilt.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'tilt.set_bandwidth()',pro:'def set_bandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'tilt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'tilt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logicalName']={syn:'Changes the logical name of the tilt sensor.',lib:'tilt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the tilt sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'tilt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'tilt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'tilt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'tilt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Tilt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'tilt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tilt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'tilt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tilt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'tilt.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Tilt)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Quaternion interface',inc:'from yocto_gyro import *',cmt:'<p>The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation using a quaternion. It is usually not needed to use the YQt class directly, as the YGyro class provides a more convenient higher-level interface.</p>'}};
doc['Qt']['FindQt']={syn:'Retrieves a quaternion component for a given identifier.',lib:'YQt.FindQt()',pro:'def FindQt(<span id=pn>func</span>)',cmt:'<p>Retrieves a quaternion component for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quaternion component is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQt.isOnline()</tt> to test if the quaternion component is indeed online at a given time. In case of ambiguity when looking for a quaternion component by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quaternion component'},ret:'a <tt>YQt</tt> object allowing you to drive the quaternion component.'};
doc['Qt']['FirstQt']={syn:'Starts the enumeration of quaternion components currently accessible.',lib:'YQt.FirstQt()',pro:'def FirstQt()',cmt:'<p>Starts the enumeration of quaternion components currently accessible. Use the method <tt>YQt.nextQt()</tt> to iterate on next quaternion components.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to the first quaternion component currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Qt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'qt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['clearCache']={syn:'Invalidates the cache.',lib:'qt.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quaternion component attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Qt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'qt.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quaternion component (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Qt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'qt.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Qt']['get_advertisedValue']={syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'qt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Qt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'qt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Qt']['get_currentValue']={syn:'Returns the current value of the value, in units, as a floating point number.',lib:'qt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the value, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Qt']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'qt.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Qt']['get_errorMessage']={syn:'Returns the error message of the latest error with the quaternion component.',lib:'qt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quaternion component object'};
doc['Qt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the quaternion component.',lib:'qt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quaternion component object'};
doc['Qt']['get_friendlyName']={syn:'Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'qt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quaternion component if they are defined, otherwise the serial number of the module and the hardware identifier of the quaternion component (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quaternion component using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Qt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'qt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Qt']['get_functionId']={syn:'Returns the hardware identifier of the quaternion component, without reference to the module.',lib:'qt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the quaternion component, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quaternion component (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Qt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'qt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quaternion component (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quaternion component (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Qt']['get_highestValue']={syn:'Returns the maximal value observed for the value since the device was started.',lib:'qt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Qt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'qt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_logicalName']={syn:'Returns the logical name of the quaternion component.',lib:'qt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Qt']['get_lowestValue']={syn:'Returns the minimal value observed for the value since the device was started.',lib:'qt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Qt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'qt.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Qt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'qt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Qt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'qt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'qt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Qt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'qt.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Qt']['get_unit']={syn:'Returns the measuring unit for the value.',lib:'qt.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Qt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'qt.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Qt']['isOnline']={syn:'Checks if the quaternion component is currently reachable, without raising any error.',lib:'qt.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the quaternion component is currently reachable, without raising any error. If there is a cached value for the quaternion component in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quaternion component.</p>',ret:'<tt>true</tt> if the quaternion component can be reached, and <tt>false</tt> otherwise'};
doc['Qt']['load']={syn:'Preloads the quaternion component cache with a specified validity duration.',lib:'qt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the quaternion component cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'qt.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Qt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'qt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'qt.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['nextQt']={syn:'Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.',lib:'qt.nextQt()',pro:'def nextQt()',cmt:'<p>Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>. Caution: You can\x27t make any assumption about the returned quaternion components order. If you want to find a specific a quaternion component, use <tt>Qt.findQt()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to a quaternion component currently online, or a <tt>null</tt> pointer if there are no more quaternion components to enumerate.'};
doc['Qt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'qt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Qt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'qt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Qt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'qt.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'qt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'qt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logicalName']={syn:'Changes the logical name of the quaternion component.',lib:'qt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quaternion component. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'qt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'qt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'qt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'qt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Qt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'qt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Qt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'qt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Qt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'qt.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Qt)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'PwmOutput function interface',inc:'from yocto_pwmoutput import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.</p>'}};
doc['PwmOutput']['FindPwmOutput']={syn:'Retrieves a PWM for a given identifier.',lib:'YPwmOutput.FindPwmOutput()',pro:'def FindPwmOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmOutput.isOnline()</tt> to test if the PWM is indeed online at a given time. In case of ambiguity when looking for a PWM by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM'},ret:'a <tt>YPwmOutput</tt> object allowing you to drive the PWM.'};
doc['PwmOutput']['FirstPwmOutput']={syn:'Starts the enumeration of PWMs currently accessible.',lib:'YPwmOutput.FirstPwmOutput()',pro:'def FirstPwmOutput()',cmt:'<p>Starts the enumeration of PWMs currently accessible. Use the method <tt>YPwmOutput.nextPwmOutput()</tt> to iterate on next PWMs.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to the first PWM currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmOutput']['clearCache']={syn:'Invalidates the cache.',lib:'pwmoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmoutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmOutput']['dutyCycleMove']={syn:'Performs a smooth change of the duty cycle toward a given value.',lib:'pwmoutput.dutyCycleMove()',pro:'def dutyCycleMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth change of the duty cycle toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new duty cycle at the end of the transition (percentage, floating-point number between 0 and 100)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['frequencyMove']={syn:'Performs a smooth frequency change toward a given value.',lib:'pwmoutput.frequencyMove()',pro:'def frequencyMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth frequency change toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'new frequency at the end of the transition (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['get_advertisedValue']={syn:'Returns the current value of the PWM (no more than 6 characters).',lib:'pwmoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the PWM (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwmoutput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycleAtPowerOn']={syn:'Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.',lib:'pwmoutput.get_dutyCycleAtPowerOn()',pro:'def get_dutyCycleAtPowerOn()',cmt:'<p>Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.</p>',ret:'a floating point number corresponding to the PWMs duty cycle at device power on as a floating point number between 0 and 100',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLEATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_enabled']={syn:'Returns the state of the PWMs.',lib:'pwmoutput.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns the state of the PWMs.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the PWMs',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Returns the state of the PWM at device power on.',lib:'pwmoutput.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM.',lib:'pwmoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM object'};
doc['PwmOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM.',lib:'pwmoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM object'};
doc['PwmOutput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwmoutput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmOutput']['get_friendlyName']={syn:'Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmOutput']['get_functionId']={syn:'Returns the hardware identifier of the PWM, without reference to the module.',lib:'pwmoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmOutput']['get_logicalName']={syn:'Returns the logical name of the PWM.',lib:'pwmoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the PWM.</p>',ret:'a string corresponding to the logical name of the PWM.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmoutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmOutput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwmoutput.get_period()',pro:'def get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmOutput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwmoutput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmOutput']['isOnline']={syn:'Checks if the PWM is currently reachable, without raising any error.',lib:'pwmoutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the PWM is currently reachable, without raising any error. If there is a cached value for the PWM in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM.</p>',ret:'<tt>true</tt> if the PWM can be reached, and <tt>false</tt> otherwise'};
doc['PwmOutput']['load']={syn:'Preloads the PWM cache with a specified validity duration.',lib:'pwmoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwmoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwmoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['nextPwmOutput']={syn:'Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>.',lib:'pwmoutput.nextPwmOutput()',pro:'def nextPwmOutput()',cmt:'<p>Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>. Caution: You can\x27t make any assumption about the returned PWMs order. If you want to find a specific a PWM, use <tt>PwmOutput.findPwmOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to a PWM currently online, or a <tt>null</tt> pointer if there are no more PWMs to enumerate.'};
doc['PwmOutput']['phaseMove']={syn:'Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel.',lib:'pwmoutput.phaseMove()',pro:'def phaseMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition toward a specified value of the phase shift between this channel and the other channel. The phase shift is executed by slightly changing the frequency temporarily during the specified duration. This function only makes sense when both channels are running, either at the same frequency, or at a multiple of the channel frequency. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{target:'phase shift at the end of the transition, in milliseconds (floating-point number)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['pulseDurationMove']={syn:'Performs a smooth transition of the pulse duration toward a given value.',lib:'pwmoutput.pulseDurationMove()',pro:'def pulseDurationMove(<span id=pn>ms_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmOutput']['set_dutyCycle']={syn:'Changes the PWM duty cycle, in per cents.',lib:'pwmoutput.set_dutyCycle()',pro:'def set_dutyCycle(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Changes the PWM duty cycle at device power on.',lib:'pwmoutput.set_dutyCycleAtPowerOn()',pro:'def set_dutyCycleAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabled']={syn:'Stops or starts the PWM.',lib:'pwmoutput.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Changes the state of the PWM at device power on.',lib:'pwmoutput.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the PWM at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_frequency']={syn:'Changes the PWM frequency.',lib:'pwmoutput.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change, in other words, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies. To stop the PWM signal, do not set the frequency to zero, use the set_enabled() method instead.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_logicalName']={syn:'Changes the logical name of the PWM.',lib:'pwmoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_period']={syn:'Changes the PWM period in milliseconds.',lib:'pwmoutput.set_period()',pro:'def set_period(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM period in milliseconds. Caution: in order to avoid random truncation of the current pulse, the change will not be applied before the end of the current period. This can significantly affect reaction time at low frequencies.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_pulseDuration']={syn:'Changes the PWM pulse length, in milliseconds.',lib:'pwmoutput.set_pulseDuration()',pro:'def set_pulseDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmOutput']['triggerPulsesByDuration']={syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'pwmoutput.triggerPulsesByDuration()',pro:'def triggerPulsesByDuration(<span id=pn>ms_target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{ms_target:'desired pulse duration (floating-point number, representing the pulse duration in milliseconds)',n_pulses:'desired pulse count'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['triggerPulsesByDutyCycle']={syn:'Trigger a given number of pulses of specified duration, at current frequency.',lib:'pwmoutput.triggerPulsesByDutyCycle()',pro:'def triggerPulsesByDutyCycle(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses of specified duration, at current frequency. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired duty cycle for the generated pulses (percentage, floating-point number between 0 and 100)',n_pulses:'desired pulse count'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['triggerPulsesByFrequency']={syn:'Trigger a given number of pulses at the specified frequency, using current duty cycle.',lib:'pwmoutput.triggerPulsesByFrequency()',pro:'def triggerPulsesByFrequency(<span id=pn>target</span>, <span id=pn>n_pulses</span>)',cmt:'<p>Trigger a given number of pulses at the specified frequency, using current duty cycle. At the end of the pulse train, revert to the original state of the PWM generator.</p>',par:{target:'desired frequency for the generated pulses (floating-point number)',n_pulses:'desired pulse count'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwmoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PwmPowerSource function interface',inc:'from yocto_pwmpowersource import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure the voltage source used by all PWM on the same device.</p>'}};
doc['PwmPowerSource']['FindPwmPowerSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YPwmPowerSource.FindPwmPowerSource()',pro:'def FindPwmPowerSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmPowerSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YPwmPowerSource</tt> object allowing you to drive the voltage source.'};
doc['PwmPowerSource']['FirstPwmPowerSource']={syn:'Starts the enumeration of Voltage sources currently accessible.',lib:'YPwmPowerSource.FirstPwmPowerSource()',pro:'def FirstPwmPowerSource()',cmt:'<p>Starts the enumeration of Voltage sources currently accessible. Use the method <tt>YPwmPowerSource.nextPwmPowerSource()</tt> to iterate on next Voltage sources.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to the first source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmPowerSource']['clearCache']={syn:'Invalidates the cache.',lib:'pwmpowersource.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage source attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmPowerSource']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmpowersource.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage source (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'pwmpowersource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmPowerSource']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage source.',lib:'pwmpowersource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage source object'};
doc['PwmPowerSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage source.',lib:'pwmpowersource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage source object'};
doc['PwmPowerSource']['get_friendlyName']={syn:'Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmpowersource.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage source if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage source (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage source using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmpowersource.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionId']={syn:'Returns the hardware identifier of the voltage source, without reference to the module.',lib:'pwmpowersource.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage source, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage source (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmPowerSource']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmpowersource.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage source (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage source (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmPowerSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'pwmpowersource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmpowersource.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmPowerSource']['get_powerMode']={syn:'Returns the selected power source for the PWM on the same device.',lib:'pwmpowersource.get_powerMode()',pro:'def get_powerMode()',cmt:'<p>Returns the selected power source for the PWM on the same device.</p>',ret:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the selected power source for the PWM on the same device',ext:'On failure, throws an exception or returns <tt>Y_POWERMODE_INVALID</tt>.'};
doc['PwmPowerSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmpowersource.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmPowerSource']['isOnline']={syn:'Checks if the voltage source is currently reachable, without raising any error.',lib:'pwmpowersource.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the voltage source is currently reachable, without raising any error. If there is a cached value for the voltage source in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage source.</p>',ret:'<tt>true</tt> if the voltage source can be reached, and <tt>false</tt> otherwise'};
doc['PwmPowerSource']['load']={syn:'Preloads the voltage source cache with a specified validity duration.',lib:'pwmpowersource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage source cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwmpowersource.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmPowerSource']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwmpowersource.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['nextPwmPowerSource']={syn:'Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>.',lib:'pwmpowersource.nextPwmPowerSource()',pro:'def nextPwmPowerSource()',cmt:'<p>Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>. Caution: You can\x27t make any assumption about the returned Voltage sources order. If you want to find a specific a voltage source, use <tt>PwmPowerSource.findPwmPowerSource()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more Voltage sources to enumerate.'};
doc['PwmPowerSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmpowersource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmPowerSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'pwmpowersource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_powerMode']={syn:'Changes the PWM power source.',lib:'pwmpowersource.set_powerMode()',pro:'def set_powerMode(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmpowersource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmPowerSource']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwmpowersource.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altitude function interface',inc:'from yocto_altitude import *',cmt:'<p>The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}};
doc['Altitude']['FindAltitude']={syn:'Retrieves an altimeter for a given identifier.',lib:'YAltitude.FindAltitude()',pro:'def FindAltitude(<span id=pn>func</span>)',cmt:'<p>Retrieves an altimeter for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the altimeter is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAltitude.isOnline()</tt> to test if the altimeter is indeed online at a given time. In case of ambiguity when looking for an altimeter by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the altimeter'},ret:'a <tt>YAltitude</tt> object allowing you to drive the altimeter.'};
doc['Altitude']['FirstAltitude']={syn:'Starts the enumeration of altimeters currently accessible.',lib:'YAltitude.FirstAltitude()',pro:'def FirstAltitude()',cmt:'<p>Starts the enumeration of altimeters currently accessible. Use the method <tt>YAltitude.nextAltitude()</tt> to iterate on next altimeters.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to the first altimeter currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Altitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'altitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['clearCache']={syn:'Invalidates the cache.',lib:'altitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the altimeter attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Altitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'altitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the altimeter (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Altitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'altitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Altitude']['get_advertisedValue']={syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'altitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'altitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentValue']={syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'altitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Altitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'altitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Altitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the altimeter.',lib:'altitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the altimeter object'};
doc['Altitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the altimeter.',lib:'altitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the altimeter object'};
doc['Altitude']['get_friendlyName']={syn:'Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'altitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the altimeter if they are defined, otherwise the serial number of the module and the hardware identifier of the altimeter (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the altimeter using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Altitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'altitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Altitude']['get_functionId']={syn:'Returns the hardware identifier of the altimeter, without reference to the module.',lib:'altitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the altimeter, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the altimeter (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Altitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'altitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the altimeter (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the altimeter (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Altitude']['get_highestValue']={syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'altitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'altitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_logicalName']={syn:'Returns the logical name of the altimeter.',lib:'altitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Altitude']['get_lowestValue']={syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'altitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'altitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Altitude']['get_qnh']={syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude.get_qnh()',pro:'def get_qnh()',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH). Applicable to barometric altimeters only.</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:'On failure, throws an exception or returns <tt>Y_QNH_INVALID</tt>.'};
doc['Altitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'altitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Altitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'altitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'altitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Altitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'altitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Altitude']['get_technology']={syn:'Returns the technology used by the sesnor to compute altitude.',lib:'altitude.get_technology()',pro:'def get_technology()',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:'On failure, throws an exception or returns <tt>Y_TECHNOLOGY_INVALID</tt>.'};
doc['Altitude']['get_unit']={syn:'Returns the measuring unit for the altitude.',lib:'altitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Altitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'altitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Altitude']['isOnline']={syn:'Checks if the altimeter is currently reachable, without raising any error.',lib:'altitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the altimeter is currently reachable, without raising any error. If there is a cached value for the altimeter in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the altimeter.</p>',ret:'<tt>true</tt> if the altimeter can be reached, and <tt>false</tt> otherwise'};
doc['Altitude']['load']={syn:'Preloads the altimeter cache with a specified validity duration.',lib:'altitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the altimeter cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'altitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Altitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'altitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'altitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['nextAltitude']={syn:'Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.',lib:'altitude.nextAltitude()',pro:'def nextAltitude()',cmt:'<p>Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>. Caution: You can\x27t make any assumption about the returned altimeters order. If you want to find a specific an altimeter, use <tt>Altitude.findAltitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to an altimeter currently online, or a <tt>null</tt> pointer if there are no more altimeters to enumerate.'};
doc['Altitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'altitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Altitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'altitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Altitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'altitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_currentValue']={syn:'Changes the current estimated altitude.',lib:'altitude.set_currentValue()',pro:'def set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current estimated altitude. This allows to compensate for ambient pressure variations and to work in relative mode.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'altitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'altitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logicalName']={syn:'Changes the logical name of the altimeter.',lib:'altitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the altimeter. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'altitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_qnh']={syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude.set_qnh()',pro:'def set_qnh(<span id=pn>newval</span>)',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions. Applicable to barometric altimeters only.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'altitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'altitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'altitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Altitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'altitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Altitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'altitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Altitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'altitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Altitude)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor function interface',inc:'from yocto_motor import *',cmt:'<p>Yoctopuce application programming interface allows you to drive the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}};
doc['Motor']['FindMotor']={syn:'Retrieves a motor for a given identifier.',lib:'YMotor.FindMotor()',pro:'def FindMotor(<span id=pn>func</span>)',cmt:'<p>Retrieves a motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMotor.isOnline()</tt> to test if the motor is indeed online at a given time. In case of ambiguity when looking for a motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the motor'},ret:'a <tt>YMotor</tt> object allowing you to drive the motor.'};
doc['Motor']['FirstMotor']={syn:'Starts the enumeration of motors currently accessible.',lib:'YMotor.FirstMotor()',pro:'def FirstMotor()',cmt:'<p>Starts the enumeration of motors currently accessible. Use the method <tt>YMotor.nextMotor()</tt> to iterate on next motors.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to the first motor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Motor']['brakingForceMove']={syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'motor.brakingForceMove()',pro:'def brakingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['clearCache']={syn:'Invalidates the cache.',lib:'motor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Motor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'motor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Motor']['drivingForceMove']={syn:'Changes progressively the power sent to the motor for a specific duration.',lib:'motor.drivingForceMove()',pro:'def drivingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the power sent to the motor for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['get_advertisedValue']={syn:'Returns the current value of the motor (no more than 6 characters).',lib:'motor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Motor']['get_brakingForce']={syn:'Returns the braking force applied to the motor, as a percentage.',lib:'motor.get_brakingForce()',pro:'def get_brakingForce()',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:'On failure, throws an exception or returns <tt>Y_BRAKINGFORCE_INVALID</tt>.'};
doc['Motor']['get_cutOffVoltage']={syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor.get_cutOffVoltage()',pro:'def get_cutOffVoltage()',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:'On failure, throws an exception or returns <tt>Y_CUTOFFVOLTAGE_INVALID</tt>.'};
doc['Motor']['get_drivingForce']={syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'motor.get_drivingForce()',pro:'def get_drivingForce()',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:'On failure, throws an exception or returns <tt>Y_DRIVINGFORCE_INVALID</tt>.'};
doc['Motor']['get_errorMessage']={syn:'Returns the error message of the latest error with the motor.',lib:'motor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the motor object'};
doc['Motor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the motor.',lib:'motor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the motor object'};
doc['Motor']['get_failSafeTimeout']={syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor.get_failSafeTimeout()',pro:'def get_failSafeTimeout()',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:'On failure, throws an exception or returns <tt>Y_FAILSAFETIMEOUT_INVALID</tt>.'};
doc['Motor']['get_frequency']={syn:'Returns the PWM frequency used to control the motor.',lib:'motor.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Motor']['get_friendlyName']={syn:'Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'motor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the motor if they are defined, otherwise the serial number of the module and the hardware identifier of the motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Motor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'motor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Motor']['get_functionId']={syn:'Returns the hardware identifier of the motor, without reference to the module.',lib:'motor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Motor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'motor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Motor']['get_logicalName']={syn:'Returns the logical name of the motor.',lib:'motor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Motor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'motor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Motor']['get_motorStatus']={syn:'Return the controller state.',lib:'motor.get_motorStatus()',pro:'def get_motorStatus()',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an over current condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>Y_MOTORSTATUS_IDLE</tt>, <tt>Y_MOTORSTATUS_BRAKE</tt>, <tt>Y_MOTORSTATUS_FORWD</tt>, <tt>Y_MOTORSTATUS_BACKWD</tt>, <tt>Y_MOTORSTATUS_LOVOLT</tt>, <tt>Y_MOTORSTATUS_HICURR</tt>, <tt>Y_MOTORSTATUS_HIHEAT</tt> and <tt>Y_MOTORSTATUS_FAILSF</tt>',ext:'On failure, throws an exception or returns <tt>Y_MOTORSTATUS_INVALID</tt>.'};
doc['Motor']['get_overCurrentLimit']={syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor.get_overCurrentLimit()',pro:'def get_overCurrentLimit()',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENTLIMIT_INVALID</tt>.'};
doc['Motor']['get_starterTime']={syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor.get_starterTime()',pro:'def get_starterTime()',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:'On failure, throws an exception or returns <tt>Y_STARTERTIME_INVALID</tt>.'};
doc['Motor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'motor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Motor']['isOnline']={syn:'Checks if the motor is currently reachable, without raising any error.',lib:'motor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the motor is currently reachable, without raising any error. If there is a cached value for the motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the motor.</p>',ret:'<tt>true</tt> if the motor can be reached, and <tt>false</tt> otherwise'};
doc['Motor']['keepALive']={syn:'Rearms the controller failsafe timer.',lib:'motor.keepALive()',pro:'def keepALive()',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitly rearms the failsafe timer.</p>'};
doc['Motor']['load']={syn:'Preloads the motor cache with a specified validity duration.',lib:'motor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'motor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Motor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'motor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['nextMotor']={syn:'Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.',lib:'motor.nextMotor()',pro:'def nextMotor()',cmt:'<p>Continues the enumeration of motors started using <tt>yFirstMotor()</tt>. Caution: You can\x27t make any assumption about the returned motors order. If you want to find a specific a motor, use <tt>Motor.findMotor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to a motor currently online, or a <tt>null</tt> pointer if there are no more motors to enumerate.'};
doc['Motor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'motor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Motor']['resetStatus']={syn:'Reset the controller state to IDLE.',lib:'motor.resetStatus()',pro:'def resetStatus()',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitly after any error condition is signaled.</p>'};
doc['Motor']['set_brakingForce']={syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'motor.set_brakingForce()',pro:'def set_brakingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_cutOffVoltage']={syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor.set_cutOffVoltage()',pro:'def set_cutOffVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_drivingForce']={syn:'Changes immediately the power sent to the motor.',lib:'motor.set_drivingForce()',pro:'def set_drivingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_failSafeTimeout']={syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor.set_failSafeTimeout()',pro:'def set_failSafeTimeout(<span id=pn>newval</span>)',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_frequency']={syn:'Changes the PWM frequency used to control the motor.',lib:'motor.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_logicalName']={syn:'Changes the logical name of the motor.',lib:'motor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_overCurrentLimit']={syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor.set_overCurrentLimit()',pro:'def set_overCurrentLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_starterTime']={syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor.set_starterTime()',pro:'def set_starterTime(<span id=pn>newval</span>)',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'motor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Motor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'motor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Motor)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'SerialPort function interface',inc:'from yocto_serialport import *',cmt:'<p>The SerialPort function interface allows you to fully drive a Yoctopuce serial port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SerialPort']['FindSerialPort']={syn:'Retrieves a serial port for a given identifier.',lib:'YSerialPort.FindSerialPort()',pro:'def FindSerialPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a serial port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the serial port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSerialPort.isOnline()</tt> to test if the serial port is indeed online at a given time. In case of ambiguity when looking for a serial port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the serial port'},ret:'a <tt>YSerialPort</tt> object allowing you to drive the serial port.'};
doc['SerialPort']['FirstSerialPort']={syn:'Starts the enumeration of serial ports currently accessible.',lib:'YSerialPort.FirstSerialPort()',pro:'def FirstSerialPort()',cmt:'<p>Starts the enumeration of serial ports currently accessible. Use the method <tt>YSerialPort.nextSerialPort()</tt> to iterate on next serial ports.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to the first serial port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SerialPort']['clearCache']={syn:'Invalidates the cache.',lib:'serialport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the serial port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SerialPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'serialport.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the serial port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SerialPort']['get_CTS']={syn:'Reads the level of the CTS line.',lib:'serialport.get_CTS()',pro:'def get_CTS()',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['get_advertisedValue']={syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'serialport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SerialPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'serialport.get_currentJob()',pro:'def get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SerialPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'serialport.get_errCount()',pro:'def get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the serial port.',lib:'serialport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the serial port object'};
doc['SerialPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the serial port.',lib:'serialport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the serial port object'};
doc['SerialPort']['get_friendlyName']={syn:'Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'serialport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the serial port if they are defined, otherwise the serial number of the module and the hardware identifier of the serial port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the serial port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SerialPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'serialport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SerialPort']['get_functionId']={syn:'Returns the hardware identifier of the serial port, without reference to the module.',lib:'serialport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the serial port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the serial port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SerialPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'serialport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the serial port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the serial port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SerialPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'serialport.get_lastMsg()',pro:'def get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:'On failure, throws an exception or returns <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SerialPort']['get_logicalName']={syn:'Returns the logical name of the serial port.',lib:'serialport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SerialPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'serialport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SerialPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'serialport.get_protocol()',pro:'def get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SerialPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'serialport.get_rxCount()',pro:'def get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'serialport.get_rxMsgCount()',pro:'def get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_serialMode']={syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'serialport.get_serialMode()',pro:'def get_serialMode()',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:'On failure, throws an exception or returns <tt>Y_SERIALMODE_INVALID</tt>.'};
doc['SerialPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'serialport.get_startupJob()',pro:'def get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SerialPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'serialport.get_txCount()',pro:'def get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'serialport.get_txMsgCount()',pro:'def get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'serialport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SerialPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'serialport.get_voltageLevel()',pro:'def get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SerialPort']['isOnline']={syn:'Checks if the serial port is currently reachable, without raising any error.',lib:'serialport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the serial port is currently reachable, without raising any error. If there is a cached value for the serial port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the serial port.</p>',ret:'<tt>true</tt> if the serial port can be reached, and <tt>false</tt> otherwise'};
doc['SerialPort']['load']={syn:'Preloads the serial port cache with a specified validity duration.',lib:'serialport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the serial port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'serialport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SerialPort']['modbusReadBits']={syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'serialport.modbusReadBits()',pro:'def modbusReadBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputBits']={syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'serialport.modbusReadInputBits()',pro:'def modbusReadInputBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'serialport.modbusReadInputRegisters()',pro:'def modbusReadInputRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadRegisters']={syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'serialport.modbusReadRegisters()',pro:'def modbusReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'serialport.modbusWriteAndReadRegisters()',pro:'def modbusWriteAndReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduWriteAddr</span>, <span id=pn>values</span>, <span id=pn>pduReadAddr</span>, <span id=pn>nReadWords</span>)',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteBit']={syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'serialport.modbusWriteBit()',pro:'def modbusWriteBit(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteBits']={syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'serialport.modbusWriteBits()',pro:'def modbusWriteBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>bits</span>)',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegister']={syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'serialport.modbusWriteRegister()',pro:'def modbusWriteRegister(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegisters']={syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'serialport.modbusWriteRegisters()',pro:'def modbusWriteRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>values</span>)',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'serialport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['nextSerialPort']={syn:'Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.',lib:'serialport.nextSerialPort()',pro:'def nextSerialPort()',cmt:'<p>Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>. Caution: You can\x27t make any assumption about the returned serial ports order. If you want to find a specific a serial port, use <tt>SerialPort.findSerialPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to a serial port currently online, or a <tt>null</tt> pointer if there are no more serial ports to enumerate.'};
doc['SerialPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'serialport.queryLine()',pro:'def queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['queryMODBUS']={syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'serialport.queryMODBUS()',pro:'def queryMODBUS(<span id=pn>slaveNo</span>, <span id=pn>pduBytes</span>)',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:'On failure, throws an exception or returns an empty array (or a MODBUS error reply).'};
doc['SerialPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'serialport.readArray()',pro:'def readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'serialport.readBin()',pro:'def readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'serialport.readByte()',pro:'def readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'serialport.readHex()',pro:'def readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'serialport.readLine()',pro:'def readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'serialport.readMessages()',pro:'def readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'serialport.readStr()',pro:'def readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'serialport.read_avail()',pro:'def read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SerialPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'serialport.read_seek()',pro:'def read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SerialPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'serialport.read_tell()',pro:'def read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SerialPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'serialport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SerialPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'serialport.reset()',pro:'def reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'serialport.selectJob()',pro:'def selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_RTS']={syn:'Manually sets the state of the RTS line.',lib:'serialport.set_RTS()',pro:'def set_RTS(<span id=pn>val</span>)',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport.set_currentJob()',pro:'def set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_logicalName']={syn:'Changes the logical name of the serial port.',lib:'serialport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the serial port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'serialport.set_protocol()',pro:'def set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_serialMode']={syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'serialport.set_serialMode()',pro:'def set_serialMode(<span id=pn>newval</span>)',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport.set_startupJob()',pro:'def set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'serialport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SerialPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'serialport.set_voltageLevel()',pro:'def set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['snoopMessages']={syn:'Retrieves messages (both direction) in the serial port buffer, starting at current position.',lib:'serialport.snoopMessages()',pro:'def snoopMessages(<span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the serial port buffer, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of YSnoopingRecord objects containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'serialport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'serialport.uploadJob()',pro:'def uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'serialport.writeArray()',pro:'def writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'serialport.writeBin()',pro:'def writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'serialport.writeByte()',pro:'def writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'serialport.writeHex()',pro:'def writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'serialport.writeLine()',pro:'def writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeMODBUS']={syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'serialport.writeMODBUS()',pro:'def writeMODBUS(<span id=pn>hexString</span>)',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'serialport.writeStr()',pro:'def writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SerialPort)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PwmInput function interface',inc:'from yocto_pwminput import *',cmt:'<p>The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cycle, the frequency or the pulse width.</p>'}};
doc['PwmInput']['FindPwmInput']={syn:'Retrieves a PWM input for a given identifier.',lib:'YPwmInput.FindPwmInput()',pro:'def FindPwmInput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmInput.isOnline()</tt> to test if the PWM input is indeed online at a given time. In case of ambiguity when looking for a PWM input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM input'},ret:'a <tt>YPwmInput</tt> object allowing you to drive the PWM input.'};
doc['PwmInput']['FirstPwmInput']={syn:'Starts the enumeration of PWM inputs currently accessible.',lib:'YPwmInput.FirstPwmInput()',pro:'def FirstPwmInput()',cmt:'<p>Starts the enumeration of PWM inputs currently accessible. Use the method <tt>YPwmInput.nextPwmInput()</tt> to iterate on next PWM inputs.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to the first PWM input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmInput']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pwminput.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['clearCache']={syn:'Invalidates the cache.',lib:'pwminput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmInput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwminput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmInput']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'pwminput.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['PwmInput']['get_advertisedValue']={syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'pwminput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'pwminput.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentValue']={syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'pwminput.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in %, the pulse length in ms, etc.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'pwminput.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['PwmInput']['get_debouncePeriod']={syn:'Returns the shortest expected pulse duration, in ms.',lib:'pwminput.get_debouncePeriod()',pro:'def get_debouncePeriod()',cmt:'<p>Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',ret:'an integer corresponding to the shortest expected pulse duration, in ms',ext:'On failure, throws an exception or returns <tt>Y_DEBOUNCEPERIOD_INVALID</tt>.'};
doc['PwmInput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwminput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmInput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM input.',lib:'pwminput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM input object'};
doc['PwmInput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM input.',lib:'pwminput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM input object'};
doc['PwmInput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwminput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_friendlyName']={syn:'Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwminput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM input if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmInput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwminput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmInput']['get_functionId']={syn:'Returns the hardware identifier of the PWM input, without reference to the module.',lib:'pwminput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmInput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwminput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmInput']['get_highestValue']={syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'pwminput.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pwminput.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_logicalName']={syn:'Returns the logical name of the PWM input.',lib:'pwminput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmInput']['get_lowestValue']={syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'pwminput.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwminput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmInput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwminput.get_period()',pro:'def get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmInput']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'pwminput.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['PwmInput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwminput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmInput']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'pwminput.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['PwmInput']['get_pwmReportMode']={syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'pwminput.get_pwmReportMode()',pro:'def get_pwmReportMode()',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt>, <tt>Y_PWMREPORTMODE_PWM_STATE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQ_CPS</tt> and <tt>Y_PWMREPORTMODE_PWM_FREQ_CPM</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>Y_PWMREPORTMODE_INVALID</tt>.'};
doc['PwmInput']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pwminput.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['PwmInput']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pwminput.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pwminput.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['PwmInput']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'pwminput.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['PwmInput']['get_unit']={syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'pwminput.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings but can be modified if needed.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['PwmInput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwminput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmInput']['isOnline']={syn:'Checks if the PWM input is currently reachable, without raising any error.',lib:'pwminput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the PWM input is currently reachable, without raising any error. If there is a cached value for the PWM input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM input.</p>',ret:'<tt>true</tt> if the PWM input can be reached, and <tt>false</tt> otherwise'};
doc['PwmInput']['load']={syn:'Preloads the PWM input cache with a specified validity duration.',lib:'pwminput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwminput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmInput']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pwminput.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwminput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['nextPwmInput']={syn:'Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.',lib:'pwminput.nextPwmInput()',pro:'def nextPwmInput()',cmt:'<p>Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>. Caution: You can\x27t make any assumption about the returned PWM inputs order. If you want to find a specific a PWM input, use <tt>PwmInput.findPwmInput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to a PWM input currently online, or a <tt>null</tt> pointer if there are no more PWM inputs to enumerate.'};
doc['PwmInput']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pwminput.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['PwmInput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwminput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmInput']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'pwminput.resetCounter()',pro:'def resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'pwminput.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_debouncePeriod']={syn:'Changes the shortest expected pulse duration, in ms.',lib:'pwminput.set_debouncePeriod()',pro:'def set_debouncePeriod(<span id=pn>newval</span>)',cmt:'<p>Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',par:{newval:'an integer corresponding to the shortest expected pulse duration, in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pwminput.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pwminput.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logicalName']={syn:'Changes the logical name of the PWM input.',lib:'pwminput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pwminput.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_pwmReportMode']={syn:'Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'pwminput.set_pwmReportMode()',pro:'def set_pwmReportMode(<span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt>, <tt>Y_PWMREPORTMODE_PWM_STATE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQ_CPS</tt> and <tt>Y_PWMREPORTMODE_PWM_FREQ_CPM</tt> corresponding to the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pwminput.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pwminput.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_unit']={syn:'Changes the measuring unit for the measured quantity.',lib:'pwminput.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured quantity. That unit is just a string which is automatically initialized each time the measurement mode is changed. But is can be set to an arbitrary value.</p>',par:{newval:'a string corresponding to the measuring unit for the measured quantity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwminput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmInput']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pwminput.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['PwmInput']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pwminput.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['PwmInput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwminput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmInput)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'SegmentedDisplay function interface',inc:'from yocto_segmenteddisplay import *',cmt:'<p>The SegmentedDisplay class allows you to drive segmented displays.</p>'}};
doc['SegmentedDisplay']['FindSegmentedDisplay']={syn:'Retrieves a segmented display for a given identifier.',lib:'YSegmentedDisplay.FindSegmentedDisplay()',pro:'def FindSegmentedDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a segmented display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the segmented displays is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSegmentedDisplay.isOnline()</tt> to test if the segmented displays is indeed online at a given time. In case of ambiguity when looking for a segmented display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the segmented displays'},ret:'a <tt>YSegmentedDisplay</tt> object allowing you to drive the segmented displays.'};
doc['SegmentedDisplay']['FirstSegmentedDisplay']={syn:'Starts the enumeration of segmented displays currently accessible.',lib:'YSegmentedDisplay.FirstSegmentedDisplay()',pro:'def FirstSegmentedDisplay()',cmt:'<p>Starts the enumeration of segmented displays currently accessible. Use the method <tt>YSegmentedDisplay.nextSegmentedDisplay()</tt> to iterate on next segmented displays.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to the first segmented displays currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SegmentedDisplay']['clearCache']={syn:'Invalidates the cache.',lib:'segmenteddisplay.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the segmented displays attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SegmentedDisplay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'segmenteddisplay.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the segmented displays (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Returns the current value of the segmented displays (no more than 6 characters).',lib:'segmenteddisplay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the segmented displays (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented displays (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SegmentedDisplay']['get_displayedText']={syn:'Returns the text currently displayed on the screen.',lib:'segmenteddisplay.get_displayedText()',pro:'def get_displayedText()',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYEDTEXT_INVALID</tt>.'};
doc['SegmentedDisplay']['get_errorMessage']={syn:'Returns the error message of the latest error with the segmented displays.',lib:'segmenteddisplay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the segmented displays object'};
doc['SegmentedDisplay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the segmented displays.',lib:'segmenteddisplay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the segmented displays object'};
doc['SegmentedDisplay']['get_friendlyName']={syn:'Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'segmenteddisplay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the segmented displays if they are defined, otherwise the serial number of the module and the hardware identifier of the segmented displays (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the segmented displays using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'segmenteddisplay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionId']={syn:'Returns the hardware identifier of the segmented displays, without reference to the module.',lib:'segmenteddisplay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the segmented displays, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the segmented displays (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'segmenteddisplay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the segmented displays (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the segmented displays (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_logicalName']={syn:'Returns the logical name of the segmented displays.',lib:'segmenteddisplay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the segmented displays.</p>',ret:'a string corresponding to the logical name of the segmented displays.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'segmenteddisplay.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SegmentedDisplay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'segmenteddisplay.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SegmentedDisplay']['isOnline']={syn:'Checks if the segmented displays is currently reachable, without raising any error.',lib:'segmenteddisplay.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the segmented displays is currently reachable, without raising any error. If there is a cached value for the segmented displays in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the segmented displays.</p>',ret:'<tt>true</tt> if the segmented displays can be reached, and <tt>false</tt> otherwise'};
doc['SegmentedDisplay']['load']={syn:'Preloads the segmented displays cache with a specified validity duration.',lib:'segmenteddisplay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the segmented displays cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'segmenteddisplay.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SegmentedDisplay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'segmenteddisplay.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['nextSegmentedDisplay']={syn:'Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.',lib:'segmenteddisplay.nextSegmentedDisplay()',pro:'def nextSegmentedDisplay()',cmt:'<p>Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>. Caution: You can\x27t make any assumption about the returned segmented displays order. If you want to find a specific a segmented display, use <tt>SegmentedDisplay.findSegmentedDisplay()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to a segmented display currently online, or a <tt>null</tt> pointer if there are no more segmented displays to enumerate.'};
doc['SegmentedDisplay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'segmenteddisplay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SegmentedDisplay']['set_displayedText']={syn:'Changes the text currently displayed on the screen.',lib:'segmenteddisplay.set_displayedText()',pro:'def set_displayedText(<span id=pn>newval</span>)',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_logicalName']={syn:'Changes the logical name of the segmented displays.',lib:'segmenteddisplay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the segmented displays. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the segmented displays.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'segmenteddisplay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SegmentedDisplay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'segmenteddisplay.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer function interface',inc:'from yocto_buzzer import *',cmt:'<p>The Yoctopuce application programming interface allows you to choose the frequency and volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}};
doc['Buzzer']['FindBuzzer']={syn:'Retrieves a buzzer for a given identifier.',lib:'YBuzzer.FindBuzzer()',pro:'def FindBuzzer(<span id=pn>func</span>)',cmt:'<p>Retrieves a buzzer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the buzzer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBuzzer.isOnline()</tt> to test if the buzzer is indeed online at a given time. In case of ambiguity when looking for a buzzer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the buzzer'},ret:'a <tt>YBuzzer</tt> object allowing you to drive the buzzer.'};
doc['Buzzer']['FirstBuzzer']={syn:'Starts the enumeration of buzzers currently accessible.',lib:'YBuzzer.FirstBuzzer()',pro:'def FirstBuzzer()',cmt:'<p>Starts the enumeration of buzzers currently accessible. Use the method <tt>YBuzzer.nextBuzzer()</tt> to iterate on next buzzers.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to the first buzzer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Adds a new frequency transition to the playing sequence.',lib:'buzzer.addFreqMoveToPlaySeq()',pro:'def addFreqMoveToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDelay</span>)',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addNotesToPlaySeq']={syn:'Adds notes to the playing sequence.',lib:'buzzer.addNotesToPlaySeq()',pro:'def addNotesToPlaySeq(<span id=pn>notes</span>)',cmt:'<p>Adds notes to the playing sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Adds a pulse to the playing sequence.',lib:'buzzer.addPulseToPlaySeq()',pro:'def addPulseToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Adds a new volume transition to the playing sequence.',lib:'buzzer.addVolMoveToPlaySeq()',pro:'def addVolMoveToPlaySeq(<span id=pn>volume</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['clearCache']={syn:'Invalidates the cache.',lib:'buzzer.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the buzzer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Buzzer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'buzzer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the buzzer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Buzzer']['freqMove']={syn:'Makes the buzzer frequency change over a period of time.',lib:'buzzer.freqMove()',pro:'def freqMove(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['get_advertisedValue']={syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'buzzer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Buzzer']['get_errorMessage']={syn:'Returns the error message of the latest error with the buzzer.',lib:'buzzer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the buzzer object'};
doc['Buzzer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the buzzer.',lib:'buzzer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the buzzer object'};
doc['Buzzer']['get_frequency']={syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'buzzer.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Buzzer']['get_friendlyName']={syn:'Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'buzzer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the buzzer if they are defined, otherwise the serial number of the module and the hardware identifier of the buzzer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the buzzer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Buzzer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'buzzer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Buzzer']['get_functionId']={syn:'Returns the hardware identifier of the buzzer, without reference to the module.',lib:'buzzer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the buzzer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the buzzer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Buzzer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'buzzer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the buzzer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the buzzer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Buzzer']['get_logicalName']={syn:'Returns the logical name of the buzzer.',lib:'buzzer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Buzzer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'buzzer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Buzzer']['get_playSeqMaxSize']={syn:'Returns the maximum length of the playing sequence.',lib:'buzzer.get_playSeqMaxSize()',pro:'def get_playSeqMaxSize()',cmt:'<p>Returns the maximum length of the playing sequence.</p>',ret:'an integer corresponding to the maximum length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQMAXSIZE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSignature']={syn:'Returns the playing sequence signature.',lib:'buzzer.get_playSeqSignature()',pro:'def get_playSeqSignature()',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIGNATURE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSize']={syn:'Returns the current length of the playing sequence.',lib:'buzzer.get_playSeqSize()',pro:'def get_playSeqSize()',cmt:'<p>Returns the current length of the playing sequence.</p>',ret:'an integer corresponding to the current length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIZE_INVALID</tt>.'};
doc['Buzzer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'buzzer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Buzzer']['get_volume']={syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'buzzer.get_volume()',pro:'def get_volume()',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['Buzzer']['isOnline']={syn:'Checks if the buzzer is currently reachable, without raising any error.',lib:'buzzer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the buzzer is currently reachable, without raising any error. If there is a cached value for the buzzer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the buzzer.</p>',ret:'<tt>true</tt> if the buzzer can be reached, and <tt>false</tt> otherwise'};
doc['Buzzer']['load']={syn:'Preloads the buzzer cache with a specified validity duration.',lib:'buzzer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the buzzer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'buzzer.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Buzzer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'buzzer.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['nextBuzzer']={syn:'Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.',lib:'buzzer.nextBuzzer()',pro:'def nextBuzzer()',cmt:'<p>Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>. Caution: You can\x27t make any assumption about the returned buzzers order. If you want to find a specific a buzzer, use <tt>Buzzer.findBuzzer()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to a buzzer currently online, or a <tt>null</tt> pointer if there are no more buzzers to enumerate.'};
doc['Buzzer']['oncePlaySeq']={syn:'Starts the preprogrammed playing sequence and run it once only.',lib:'buzzer.oncePlaySeq()',pro:'def oncePlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence and run it once only.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['playNotes']={syn:'Immediately play a note sequence.',lib:'buzzer.playNotes()',pro:'def playNotes(<span id=pn>notes</span>)',cmt:'<p>Immediately play a note sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['pulse']={syn:'Activates the buzzer for a short duration.',lib:'buzzer.pulse()',pro:'def pulse(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'buzzer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Buzzer']['resetPlaySeq']={syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer.resetPlaySeq()',pro:'def resetPlaySeq()',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_frequency']={syn:'Changes the frequency of the signal sent to the buzzer.',lib:'buzzer.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_logicalName']={syn:'Changes the logical name of the buzzer.',lib:'buzzer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the buzzer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'buzzer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Buzzer']['set_volume']={syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'buzzer.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['startPlaySeq']={syn:'Starts the preprogrammed playing sequence.',lib:'buzzer.startPlaySeq()',pro:'def startPlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change. To play the sequence only once, use <tt>oncePlaySeq()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['stopPlaySeq']={syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer.stopPlaySeq()',pro:'def stopPlaySeq()',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'buzzer.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['volumeMove']={syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'buzzer.volumeMove()',pro:'def volumeMove(<span id=pn>volume</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Buzzer)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Control interface for the firmware update process',inc:'from yocto_api import *',cmt:'<p>The YFirmwareUpdate class let you control the firmware update of a Yoctopuce module. This class should not be instantiate directly, instead the method <tt>updateFirmware</tt> should be called to get an instance of YFirmwareUpdate.</p>'}};
doc['FirmwareUpdate']['CheckFirmware']={syn:'Test if the byn file is valid for this module.',lib:'YFirmwareUpdate.CheckFirmware()',pro:'def CheckFirmware(<span id=pn>serial</span>, <span id=pn>path</span>, <span id=pn>minrelease</span>)',cmt:'<p>Test if the byn file is valid for this module. It is possible to pass a directory instead of a file. In that case, this method returns the path of the most recent appropriate byn file. This method will ignore any firmware older than minrelease.</p>',par:{serial:'the serial number of the module to update',path:'the path of a byn file or a directory that contains byn files',minrelease:'a positive integer'},ret:': the path of the byn file to use, or an empty string if no byn files matches the requirement',ext:'On failure, returns a string that starts with \x22error:\x22.'};
doc['FirmwareUpdate']['GetAllBootLoaders']={syn:'Returns a list of all the modules in \x22firmware update\x22 mode.',lib:'YFirmwareUpdate.GetAllBootLoaders()',pro:'def GetAllBootLoaders()',cmt:'<p>Returns a list of all the modules in \x22firmware update\x22 mode. Only devices connected over USB are listed. For devices connected to a YoctoHub, you must connect yourself to the YoctoHub web interface.</p>',ret:'an array of strings containing the serial numbers of devices in \x22firmware update\x22 mode.'};
doc['FirmwareUpdate']['get_progress']={syn:'Returns the progress of the firmware update, on a scale from 0 to 100.',lib:'firmwareupdate.get_progress()',pro:'def get_progress()',cmt:'<p>Returns the progress of the firmware update, on a scale from 0 to 100. When the object is instantiated, the progress is zero. The value is updated during the firmware update process until the value of 100 is reached. The 100 value means that the firmware update was completed successfully. If an error occurs during the firmware update, a negative value is returned, and the error message can be retrieved with <tt>get_progressMessage</tt>.</p>',ret:'an integer in the range 0 to 100 (percentage of completion) or a negative error code in case of failure.'};
doc['FirmwareUpdate']['get_progressMessage']={syn:'Returns the last progress message of the firmware update process.',lib:'firmwareupdate.get_progressMessage()',pro:'def get_progressMessage()',cmt:'<p>Returns the last progress message of the firmware update process. If an error occurs during the firmware update process, the error message is returned</p>',ret:'a string with the latest progress message, or the error message.'};
doc['FirmwareUpdate']['startUpdate']={syn:'Starts the firmware update process.',lib:'firmwareupdate.startUpdate()',pro:'def startUpdate()',cmt:'<p>Starts the firmware update process. This method starts the firmware update process in background. This method returns immediately. You can monitor the progress of the firmware update with the <tt>get_progress()</tt> and <tt>get_progressMessage()</tt> methods.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure returns a negative error code.'};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'GPS function interface',inc:'from yocto_gps import *',cmt:'<p>The GPS function allows you to extract positioning data from the GPS device. This class can provides complete positioning information: However, if you wish to define callbacks on position changes, you should use the YLatitude et YLongitude classes.</p>'}};
doc['Gps']['FindGps']={syn:'Retrieves a GPS for a given identifier.',lib:'YGps.FindGps()',pro:'def FindGps(<span id=pn>func</span>)',cmt:'<p>Retrieves a GPS for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the GPS is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGps.isOnline()</tt> to test if the GPS is indeed online at a given time. In case of ambiguity when looking for a GPS by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the GPS'},ret:'a <tt>YGps</tt> object allowing you to drive the GPS.'};
doc['Gps']['FirstGps']={syn:'Starts the enumeration of GPS currently accessible.',lib:'YGps.FirstGps()',pro:'def FirstGps()',cmt:'<p>Starts the enumeration of GPS currently accessible. Use the method <tt>YGps.nextGps()</tt> to iterate on next GPS.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to the first GPS currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gps']['clearCache']={syn:'Invalidates the cache.',lib:'gps.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the GPS attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Gps']['describe']={syn:'Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gps.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the GPS (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gps']['get_advertisedValue']={syn:'Returns the current value of the GPS (no more than 6 characters).',lib:'gps.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the GPS (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the GPS (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gps']['get_altitude']={syn:'Returns the current altitude.',lib:'gps.get_altitude()',pro:'def get_altitude()',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:'On failure, throws an exception or returns <tt>Y_ALTITUDE_INVALID</tt>.'};
doc['Gps']['get_coordSystem']={syn:'Returns the representation system used for positioning data.',lib:'gps.get_coordSystem()',pro:'def get_coordSystem()',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data',ext:'On failure, throws an exception or returns <tt>Y_COORDSYSTEM_INVALID</tt>.'};
doc['Gps']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'gps.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['Gps']['get_dilution']={syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'gps.get_dilution()',pro:'def get_dilution()',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:'On failure, throws an exception or returns <tt>Y_DILUTION_INVALID</tt>.'};
doc['Gps']['get_direction']={syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'gps.get_direction()',pro:'def get_direction()',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:'On failure, throws an exception or returns <tt>Y_DIRECTION_INVALID</tt>.'};
doc['Gps']['get_errorMessage']={syn:'Returns the error message of the latest error with the GPS.',lib:'gps.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the GPS object'};
doc['Gps']['get_errorType']={syn:'Returns the numerical error code of the latest error with the GPS.',lib:'gps.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the GPS object'};
doc['Gps']['get_friendlyName']={syn:'Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gps.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the GPS if they are defined, otherwise the serial number of the module and the hardware identifier of the GPS (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the GPS using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gps']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gps.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gps']['get_functionId']={syn:'Returns the hardware identifier of the GPS, without reference to the module.',lib:'gps.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the GPS, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the GPS (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gps']['get_groundSpeed']={syn:'Returns the current ground speed in Km/h.',lib:'gps.get_groundSpeed()',pro:'def get_groundSpeed()',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:'On failure, throws an exception or returns <tt>Y_GROUNDSPEED_INVALID</tt>.'};
doc['Gps']['get_hardwareId']={syn:'Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gps.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the GPS (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the GPS (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gps']['get_isFixed']={syn:'Returns TRUE if the receiver has found enough satellites to work.',lib:'gps.get_isFixed()',pro:'def get_isFixed()',cmt:'<p>Returns TRUE if the receiver has found enough satellites to work.</p>',ret:'either <tt>Y_ISFIXED_FALSE</tt> or <tt>Y_ISFIXED_TRUE</tt>, according to TRUE if the receiver has found enough satellites to work',ext:'On failure, throws an exception or returns <tt>Y_ISFIXED_INVALID</tt>.'};
doc['Gps']['get_latitude']={syn:'Returns the current latitude.',lib:'gps.get_latitude()',pro:'def get_latitude()',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:'On failure, throws an exception or returns <tt>Y_LATITUDE_INVALID</tt>.'};
doc['Gps']['get_logicalName']={syn:'Returns the logical name of the GPS.',lib:'gps.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the GPS.</p>',ret:'a string corresponding to the logical name of the GPS.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gps']['get_longitude']={syn:'Returns the current longitude.',lib:'gps.get_longitude()',pro:'def get_longitude()',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:'On failure, throws an exception or returns <tt>Y_LONGITUDE_INVALID</tt>.'};
doc['Gps']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gps.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gps']['get_satCount']={syn:'Returns the count of visible satellites.',lib:'gps.get_satCount()',pro:'def get_satCount()',cmt:'<p>Returns the count of visible satellites.</p>',ret:'an integer corresponding to the count of visible satellites',ext:'On failure, throws an exception or returns <tt>Y_SATCOUNT_INVALID</tt>.'};
doc['Gps']['get_unixTime']={syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'gps.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['Gps']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gps.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gps']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'gps.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['Gps']['isOnline']={syn:'Checks if the GPS is currently reachable, without raising any error.',lib:'gps.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the GPS is currently reachable, without raising any error. If there is a cached value for the GPS in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the GPS.</p>',ret:'<tt>true</tt> if the GPS can be reached, and <tt>false</tt> otherwise'};
doc['Gps']['load']={syn:'Preloads the GPS cache with a specified validity duration.',lib:'gps.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the GPS cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'gps.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Gps']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'gps.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['nextGps']={syn:'Continues the enumeration of GPS started using <tt>yFirstGps()</tt>.',lib:'gps.nextGps()',pro:'def nextGps()',cmt:'<p>Continues the enumeration of GPS started using <tt>yFirstGps()</tt>. Caution: You can\x27t make any assumption about the returned GPS order. If you want to find a specific a GPS, use <tt>Gps.findGps()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to a GPS currently online, or a <tt>null</tt> pointer if there are no more GPS to enumerate.'};
doc['Gps']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gps.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gps']['set_coordSystem']={syn:'Changes the representation system used for positioning data.',lib:'gps.set_coordSystem()',pro:'def set_coordSystem(<span id=pn>newval</span>)',cmt:'<p>Changes the representation system used for positioning data.</p>',par:{newval:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_logicalName']={syn:'Changes the logical name of the GPS.',lib:'gps.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the GPS. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the GPS.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gps.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gps']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'gps.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'gps.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Gps)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude function interface',inc:'from yocto_latitude import *',cmt:'<p>The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Latitude']['FindLatitude']={syn:'Retrieves a latitude sensor for a given identifier.',lib:'YLatitude.FindLatitude()',pro:'def FindLatitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a latitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the latitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLatitude.isOnline()</tt> to test if the latitude sensor is indeed online at a given time. In case of ambiguity when looking for a latitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the latitude sensor'},ret:'a <tt>YLatitude</tt> object allowing you to drive the latitude sensor.'};
doc['Latitude']['FirstLatitude']={syn:'Starts the enumeration of latitude sensors currently accessible.',lib:'YLatitude.FirstLatitude()',pro:'def FirstLatitude()',cmt:'<p>Starts the enumeration of latitude sensors currently accessible. Use the method <tt>YLatitude.nextLatitude()</tt> to iterate on next latitude sensors.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to the first latitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Latitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'latitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['clearCache']={syn:'Invalidates the cache.',lib:'latitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the latitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Latitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'latitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the latitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Latitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'latitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Latitude']['get_advertisedValue']={syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'latitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'latitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentValue']={syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'latitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Latitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'latitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Latitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the latitude sensor.',lib:'latitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the latitude sensor object'};
doc['Latitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the latitude sensor.',lib:'latitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the latitude sensor object'};
doc['Latitude']['get_friendlyName']={syn:'Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'latitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the latitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the latitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the latitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Latitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'latitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Latitude']['get_functionId']={syn:'Returns the hardware identifier of the latitude sensor, without reference to the module.',lib:'latitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the latitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the latitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Latitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'latitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the latitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the latitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Latitude']['get_highestValue']={syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'latitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'latitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_logicalName']={syn:'Returns the logical name of the latitude sensor.',lib:'latitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Latitude']['get_lowestValue']={syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'latitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'latitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Latitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'latitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Latitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'latitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'latitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Latitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'latitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Latitude']['get_unit']={syn:'Returns the measuring unit for the latitude.',lib:'latitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Latitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'latitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Latitude']['isOnline']={syn:'Checks if the latitude sensor is currently reachable, without raising any error.',lib:'latitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the latitude sensor is currently reachable, without raising any error. If there is a cached value for the latitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the latitude sensor.</p>',ret:'<tt>true</tt> if the latitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Latitude']['load']={syn:'Preloads the latitude sensor cache with a specified validity duration.',lib:'latitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the latitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'latitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Latitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'latitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'latitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['nextLatitude']={syn:'Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.',lib:'latitude.nextLatitude()',pro:'def nextLatitude()',cmt:'<p>Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>. Caution: You can\x27t make any assumption about the returned latitude sensors order. If you want to find a specific a latitude sensor, use <tt>Latitude.findLatitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to a latitude sensor currently online, or a <tt>null</tt> pointer if there are no more latitude sensors to enumerate.'};
doc['Latitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'latitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Latitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'latitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Latitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'latitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'latitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'latitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logicalName']={syn:'Changes the logical name of the latitude sensor.',lib:'latitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the latitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'latitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'latitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'latitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'latitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Latitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'latitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Latitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'latitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Latitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'latitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude function interface',inc:'from yocto_longitude import *',cmt:'<p>The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Longitude']['FindLongitude']={syn:'Retrieves a longitude sensor for a given identifier.',lib:'YLongitude.FindLongitude()',pro:'def FindLongitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a longitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the longitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLongitude.isOnline()</tt> to test if the longitude sensor is indeed online at a given time. In case of ambiguity when looking for a longitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the longitude sensor'},ret:'a <tt>YLongitude</tt> object allowing you to drive the longitude sensor.'};
doc['Longitude']['FirstLongitude']={syn:'Starts the enumeration of longitude sensors currently accessible.',lib:'YLongitude.FirstLongitude()',pro:'def FirstLongitude()',cmt:'<p>Starts the enumeration of longitude sensors currently accessible. Use the method <tt>YLongitude.nextLongitude()</tt> to iterate on next longitude sensors.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to the first longitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Longitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'longitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['clearCache']={syn:'Invalidates the cache.',lib:'longitude.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the longitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Longitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'longitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the longitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Longitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'longitude.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Longitude']['get_advertisedValue']={syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'longitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'longitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentValue']={syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'longitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Longitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'longitude.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Longitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the longitude sensor.',lib:'longitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the longitude sensor object'};
doc['Longitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the longitude sensor.',lib:'longitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the longitude sensor object'};
doc['Longitude']['get_friendlyName']={syn:'Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'longitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the longitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the longitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the longitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Longitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'longitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Longitude']['get_functionId']={syn:'Returns the hardware identifier of the longitude sensor, without reference to the module.',lib:'longitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the longitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the longitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Longitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'longitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the longitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the longitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Longitude']['get_highestValue']={syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'longitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'longitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_logicalName']={syn:'Returns the logical name of the longitude sensor.',lib:'longitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Longitude']['get_lowestValue']={syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'longitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'longitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Longitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'longitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Longitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'longitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'longitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Longitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'longitude.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Longitude']['get_unit']={syn:'Returns the measuring unit for the longitude.',lib:'longitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Longitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'longitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Longitude']['isOnline']={syn:'Checks if the longitude sensor is currently reachable, without raising any error.',lib:'longitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the longitude sensor is currently reachable, without raising any error. If there is a cached value for the longitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the longitude sensor.</p>',ret:'<tt>true</tt> if the longitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Longitude']['load']={syn:'Preloads the longitude sensor cache with a specified validity duration.',lib:'longitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the longitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'longitude.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Longitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'longitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'longitude.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['nextLongitude']={syn:'Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.',lib:'longitude.nextLongitude()',pro:'def nextLongitude()',cmt:'<p>Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>. Caution: You can\x27t make any assumption about the returned longitude sensors order. If you want to find a specific a longitude sensor, use <tt>Longitude.findLongitude()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to a longitude sensor currently online, or a <tt>null</tt> pointer if there are no more longitude sensors to enumerate.'};
doc['Longitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'longitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Longitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'longitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Longitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'longitude.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'longitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'longitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logicalName']={syn:'Changes the logical name of the longitude sensor.',lib:'longitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the longitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'longitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'longitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'longitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'longitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Longitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'longitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Longitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'longitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Longitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'longitude.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'GroundSpeed function interface',inc:'from yocto_groundspeed import *',cmt:'<p>The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce geolocation sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['GroundSpeed']['FindGroundSpeed']={syn:'Retrieves a ground speed sensor for a given identifier.',lib:'YGroundSpeed.FindGroundSpeed()',pro:'def FindGroundSpeed(<span id=pn>func</span>)',cmt:'<p>Retrieves a ground speed sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the ground speed sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGroundSpeed.isOnline()</tt> to test if the ground speed sensor is indeed online at a given time. In case of ambiguity when looking for a ground speed sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the ground speed sensor'},ret:'a <tt>YGroundSpeed</tt> object allowing you to drive the ground speed sensor.'};
doc['GroundSpeed']['FirstGroundSpeed']={syn:'Starts the enumeration of ground speed sensors currently accessible.',lib:'YGroundSpeed.FirstGroundSpeed()',pro:'def FirstGroundSpeed()',cmt:'<p>Starts the enumeration of ground speed sensors currently accessible. Use the method <tt>YGroundSpeed.nextGroundSpeed()</tt> to iterate on next ground speed sensors.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to the first ground speed sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'groundspeed.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['clearCache']={syn:'Invalidates the cache.',lib:'groundspeed.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the ground speed sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['GroundSpeed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'groundspeed.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the ground speed sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GroundSpeed']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'groundspeed.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GroundSpeed']['get_advertisedValue']={syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'groundspeed.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'groundspeed.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentValue']={syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'groundspeed.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'groundspeed.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['GroundSpeed']['get_errorMessage']={syn:'Returns the error message of the latest error with the ground speed sensor.',lib:'groundspeed.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the ground speed sensor object'};
doc['GroundSpeed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the ground speed sensor.',lib:'groundspeed.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the ground speed sensor object'};
doc['GroundSpeed']['get_friendlyName']={syn:'Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'groundspeed.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the ground speed sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the ground speed sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the ground speed sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'groundspeed.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GroundSpeed']['get_functionId']={syn:'Returns the hardware identifier of the ground speed sensor, without reference to the module.',lib:'groundspeed.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the ground speed sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the ground speed sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GroundSpeed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'groundspeed.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the ground speed sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the ground speed sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GroundSpeed']['get_highestValue']={syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'groundspeed.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'groundspeed.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_logicalName']={syn:'Returns the logical name of the ground speed sensor.',lib:'groundspeed.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_lowestValue']={syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'groundspeed.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'groundspeed.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GroundSpeed']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'groundspeed.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'groundspeed.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'groundspeed.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GroundSpeed']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'groundspeed.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GroundSpeed']['get_unit']={syn:'Returns the measuring unit for the ground speed.',lib:'groundspeed.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GroundSpeed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'groundspeed.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GroundSpeed']['isOnline']={syn:'Checks if the ground speed sensor is currently reachable, without raising any error.',lib:'groundspeed.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the ground speed sensor is currently reachable, without raising any error. If there is a cached value for the ground speed sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the ground speed sensor.</p>',ret:'<tt>true</tt> if the ground speed sensor can be reached, and <tt>false</tt> otherwise'};
doc['GroundSpeed']['load']={syn:'Preloads the ground speed sensor cache with a specified validity duration.',lib:'groundspeed.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the ground speed sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'groundspeed.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'groundspeed.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'groundspeed.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['nextGroundSpeed']={syn:'Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.',lib:'groundspeed.nextGroundSpeed()',pro:'def nextGroundSpeed()',cmt:'<p>Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>. Caution: You can\x27t make any assumption about the returned ground speed sensors order. If you want to find a specific a ground speed sensor, use <tt>GroundSpeed.findGroundSpeed()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to a ground speed sensor currently online, or a <tt>null</tt> pointer if there are no more ground speed sensors to enumerate.'};
doc['GroundSpeed']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'groundspeed.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GroundSpeed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'groundspeed.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GroundSpeed']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'groundspeed.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'groundspeed.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'groundspeed.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logicalName']={syn:'Changes the logical name of the ground speed sensor.',lib:'groundspeed.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the ground speed sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'groundspeed.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'groundspeed.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'groundspeed.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'groundspeed.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GroundSpeed']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'groundspeed.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'groundspeed.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GroundSpeed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'groundspeed.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GroundSpeed)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'External power supply control interface',inc:'from yocto_poweroutput import *',cmt:'<p>Yoctopuce application programming interface allows you to control the power output featured on some devices such as the Yocto-Serial.</p>'}};
doc['PowerOutput']['FindPowerOutput']={syn:'Retrieves a dual power output control for a given identifier.',lib:'YPowerOutput.FindPowerOutput()',pro:'def FindPowerOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power output control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power output control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerOutput.isOnline()</tt> to test if the power output control is indeed online at a given time. In case of ambiguity when looking for a dual power output control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the power output control'},ret:'a <tt>YPowerOutput</tt> object allowing you to drive the power output control.'};
doc['PowerOutput']['FirstPowerOutput']={syn:'Starts the enumeration of dual power output controls currently accessible.',lib:'YPowerOutput.FirstPowerOutput()',pro:'def FirstPowerOutput()',cmt:'<p>Starts the enumeration of dual power output controls currently accessible. Use the method <tt>YPowerOutput.nextPowerOutput()</tt> to iterate on next dual power output controls.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to the first dual power output control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PowerOutput']['clearCache']={syn:'Invalidates the cache.',lib:'poweroutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the power output control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PowerOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power output control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'poweroutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power output control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power output control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerOutput']['get_advertisedValue']={syn:'Returns the current value of the power output control (no more than 6 characters).',lib:'poweroutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the power output control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power output control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the power output control.',lib:'poweroutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power output control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power output control object'};
doc['PowerOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power output control.',lib:'poweroutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power output control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power output control object'};
doc['PowerOutput']['get_friendlyName']={syn:'Returns a global identifier of the power output control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'poweroutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the power output control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power output control if they are defined, otherwise the serial number of the module and the hardware identifier of the power output control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power output control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'poweroutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PowerOutput']['get_functionId']={syn:'Returns the hardware identifier of the power output control, without reference to the module.',lib:'poweroutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the power output control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power output control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power output control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'poweroutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power output control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power output control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power output control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerOutput']['get_logicalName']={syn:'Returns the logical name of the power output control.',lib:'poweroutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the power output control.</p>',ret:'a string corresponding to the logical name of the power output control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'poweroutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PowerOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'poweroutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PowerOutput']['get_voltage']={syn:'Returns the voltage on the power output featured by the module.',lib:'poweroutput.get_voltage()',pro:'def get_voltage()',cmt:'<p>Returns the voltage on the power output featured by the module.</p>',ret:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power output featured by the module',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['PowerOutput']['isOnline']={syn:'Checks if the power output control is currently reachable, without raising any error.',lib:'poweroutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the power output control is currently reachable, without raising any error. If there is a cached value for the power output control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power output control.</p>',ret:'<tt>true</tt> if the power output control can be reached, and <tt>false</tt> otherwise'};
doc['PowerOutput']['load']={syn:'Preloads the power output control cache with a specified validity duration.',lib:'poweroutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the power output control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'poweroutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PowerOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'poweroutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['nextPowerOutput']={syn:'Continues the enumeration of dual power output controls started using <tt>yFirstPowerOutput()</tt>.',lib:'poweroutput.nextPowerOutput()',pro:'def nextPowerOutput()',cmt:'<p>Continues the enumeration of dual power output controls started using <tt>yFirstPowerOutput()</tt>. Caution: You can\x27t make any assumption about the returned dual power output controls order. If you want to find a specific a dual power output control, use <tt>PowerOutput.findPowerOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to a dual power output control currently online, or a <tt>null</tt> pointer if there are no more dual power output controls to enumerate.'};
doc['PowerOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'poweroutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PowerOutput']['set_logicalName']={syn:'Changes the logical name of the power output control.',lib:'poweroutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power output control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power output control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'poweroutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PowerOutput']['set_voltage']={syn:'Changes the voltage on the power output provided by the module.',lib:'poweroutput.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage on the power output provided by the module. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'poweroutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PowerOutput)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular function interface',inc:'from yocto_cellular import *',cmt:'<p>YCellular functions provides control over cellular network parameters and status for devices that are GSM-enabled.</p>'}};
doc['Cellular']['FindCellular']={syn:'Retrieves a cellular interface for a given identifier.',lib:'YCellular.FindCellular()',pro:'def FindCellular(<span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCellular.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the cellular interface'},ret:'a <tt>YCellular</tt> object allowing you to drive the cellular interface.'};
doc['Cellular']['FirstCellular']={syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YCellular.FirstCellular()',pro:'def FirstCellular()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YCellular.nextCellular()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Cellular']['_AT']={syn:'Sends an AT command to the GSM module and returns the command output.',lib:'cellular._AT()',pro:'def _AT(<span id=pn>cmd</span>)',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'};
doc['Cellular']['clearCache']={syn:'Invalidates the cache.',lib:'cellular.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the cellular interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Cellular']['clearDataCounters']={syn:'Clear the transmitted data counters.',lib:'cellular.clearDataCounters()',pro:'def clearDataCounters()',cmt:'<p>Clear the transmitted data counters.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['describe']={syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'cellular.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Cellular']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'cellular.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Cellular']['get_airplaneMode']={syn:'Returns true if the airplane mode is active (radio turned off).',lib:'cellular.get_airplaneMode()',pro:'def get_airplaneMode()',cmt:'<p>Returns true if the airplane mode is active (radio turned off).</p>',ret:'either <tt>Y_AIRPLANEMODE_OFF</tt> or <tt>Y_AIRPLANEMODE_ON</tt>, according to true if the airplane mode is active (radio turned off)',ext:'On failure, throws an exception or returns <tt>Y_AIRPLANEMODE_INVALID</tt>.'};
doc['Cellular']['get_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular.get_apn()',pro:'def get_apn()',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:'On failure, throws an exception or returns <tt>Y_APN_INVALID</tt>.'};
doc['Cellular']['get_apnSecret']={syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'cellular.get_apnSecret()',pro:'def get_apnSecret()',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_APNSECRET_INVALID</tt>.'};
doc['Cellular']['get_availableOperators']={syn:'Returns the list detected cell operators in the neighborhood.',lib:'cellular.get_availableOperators()',pro:'def get_availableOperators()',cmt:'<p>Returns the list detected cell operators in the neighborhood. This function will typically take between 30 seconds to 1 minute to return. Note that any SIM card can usually only connect to specific operators. All networks returned by this function might therefore not be available for connection.</p>',ret:'a list of string (cell operator names).'};
doc['Cellular']['get_cellIdentifier']={syn:'Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.',lib:'cellular.get_cellIdentifier()',pro:'def get_cellIdentifier()',cmt:'<p>Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.</p>',ret:'a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID',ext:'On failure, throws an exception or returns <tt>Y_CELLIDENTIFIER_INVALID</tt>.'};
doc['Cellular']['get_cellOperator']={syn:'Returns the name of the cell operator currently in use.',lib:'cellular.get_cellOperator()',pro:'def get_cellOperator()',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:'On failure, throws an exception or returns <tt>Y_CELLOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_cellType']={syn:'Active cellular connection type.',lib:'cellular.get_cellType()',pro:'def get_cellType()',cmt:'<p>Active cellular connection type.</p>',ret:'a value among <tt>Y_CELLTYPE_GPRS</tt>, <tt>Y_CELLTYPE_EGPRS</tt>, <tt>Y_CELLTYPE_WCDMA</tt>, <tt>Y_CELLTYPE_HSDPA</tt>, <tt>Y_CELLTYPE_NONE</tt> and <tt>Y_CELLTYPE_CDMA</tt>',ext:'On failure, throws an exception or returns <tt>Y_CELLTYPE_INVALID</tt>.'};
doc['Cellular']['get_dataReceived']={syn:'Returns the number of bytes received so far.',lib:'cellular.get_dataReceived()',pro:'def get_dataReceived()',cmt:'<p>Returns the number of bytes received so far.</p>',ret:'an integer corresponding to the number of bytes received so far',ext:'On failure, throws an exception or returns <tt>Y_DATARECEIVED_INVALID</tt>.'};
doc['Cellular']['get_dataSent']={syn:'Returns the number of bytes sent so far.',lib:'cellular.get_dataSent()',pro:'def get_dataSent()',cmt:'<p>Returns the number of bytes sent so far.</p>',ret:'an integer corresponding to the number of bytes sent so far',ext:'On failure, throws an exception or returns <tt>Y_DATASENT_INVALID</tt>.'};
doc['Cellular']['get_enableData']={syn:'Returns the condition for enabling IP data services (GPRS).',lib:'cellular.get_enableData()',pro:'def get_enableData()',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> and <tt>Y_ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATA_INVALID</tt>.'};
doc['Cellular']['get_errorMessage']={syn:'Returns the error message of the latest error with the cellular interface.',lib:'cellular.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'};
doc['Cellular']['get_errorType']={syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'cellular.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'};
doc['Cellular']['get_friendlyName']={syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'cellular.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Cellular']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'cellular.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Cellular']['get_functionId']={syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'cellular.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Cellular']['get_hardwareId']={syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'cellular.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Cellular']['get_imsi']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular.get_imsi()',pro:'def get_imsi()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_IMSI_INVALID</tt>.'};
doc['Cellular']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'cellular.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Cellular']['get_lockedOperator']={syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'cellular.get_lockedOperator()',pro:'def get_lockedOperator()',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:'On failure, throws an exception or returns <tt>Y_LOCKEDOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'cellular.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Cellular']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'cellular.get_message()',pro:'def get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Cellular']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'cellular.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Cellular']['get_pin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular.get_pin()',pro:'def get_pin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_PIN_INVALID</tt>.'};
doc['Cellular']['get_pingInterval']={syn:'Returns the automated connectivity check interval, in seconds.',lib:'cellular.get_pingInterval()',pro:'def get_pingInterval()',cmt:'<p>Returns the automated connectivity check interval, in seconds.</p>',ret:'an integer corresponding to the automated connectivity check interval, in seconds',ext:'On failure, throws an exception or returns <tt>Y_PINGINTERVAL_INVALID</tt>.'};
doc['Cellular']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'cellular.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Cellular']['isOnline']={syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'cellular.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'};
doc['Cellular']['load']={syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'cellular.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'cellular.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Cellular']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'cellular.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['nextCellular']={syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.',lib:'cellular.nextCellular()',pro:'def nextCellular()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>. Caution: You can\x27t make any assumption about the returned cellular interfaces order. If you want to find a specific a cellular interface, use <tt>Cellular.findCellular()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'};
doc['Cellular']['quickCellSurvey']={syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'cellular.quickCellSurvey()',pro:'def quickCellSurvey()',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighbor cells reported by the serving cell.</p>',ret:'a list of YCellRecords.'};
doc['Cellular']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'cellular.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Cellular']['sendPUK']={syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card.',lib:'cellular.sendPUK()',pro:'def sendPUK(<span id=pn>puk</span>, <span id=pn>newPin</span>)',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card. Only ten consecutive tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_airplaneMode']={syn:'Changes the activation state of airplane mode (radio turned off).',lib:'cellular.set_airplaneMode()',pro:'def set_airplaneMode(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of airplane mode (radio turned off).</p>',par:{newval:'either <tt>Y_AIRPLANEMODE_OFF</tt> or <tt>Y_AIRPLANEMODE_ON</tt>, according to the activation state of airplane mode (radio turned off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular.set_apn()',pro:'def set_apn(<span id=pn>newval</span>)',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',par:{newval:'a string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apnAuth']={syn:'Configure authentication parameters to connect to the APN.',lib:'cellular.set_apnAuth()',pro:'def set_apnAuth(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_dataReceived']={syn:'Changes the value of the incoming data counter.',lib:'cellular.set_dataReceived()',pro:'def set_dataReceived(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming data counter.</p>',par:{newval:'an integer corresponding to the value of the incoming data counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_dataSent']={syn:'Changes the value of the outgoing data counter.',lib:'cellular.set_dataSent()',pro:'def set_dataSent(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing data counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing data counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_enableData']={syn:'Changes the condition for enabling IP data services (GPRS).',lib:'cellular.set_enableData()',pro:'def set_enableData(<span id=pn>newval</span>)',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs !</p><p> When data services are disabled, SMS are the only mean of communication.</p>',par:{newval:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> and <tt>Y_ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_lockedOperator']={syn:'Changes the name of the cell operator to be used.',lib:'cellular.set_lockedOperator()',pro:'def set_lockedOperator(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'cellular.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_pin']={syn:'Changes the PIN code used by the module to access the SIM card.',lib:'cellular.set_pin()',pro:'def set_pin(<span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_pingInterval']={syn:'Changes the automated connectivity check interval, in seconds.',lib:'cellular.set_pingInterval()',pro:'def set_pingInterval(<span id=pn>newval</span>)',cmt:'<p>Changes the automated connectivity check interval, in seconds.</p>',par:{newval:'an integer corresponding to the automated connectivity check interval, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'cellular.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Cellular']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'cellular.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Cellular)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'AudioOut function interface',inc:'from yocto_audioout import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the outout.</p>'}};
doc['AudioOut']['FindAudioOut']={syn:'Retrieves an audio output for a given identifier.',lib:'YAudioOut.FindAudioOut()',pro:'def FindAudioOut(<span id=pn>func</span>)',cmt:'<p>Retrieves an audio output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioOut.isOnline()</tt> to test if the audio output is indeed online at a given time. In case of ambiguity when looking for an audio output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio output'},ret:'a <tt>YAudioOut</tt> object allowing you to drive the audio output.'};
doc['AudioOut']['FirstAudioOut']={syn:'Starts the enumeration of audio outputs currently accessible.',lib:'YAudioOut.FirstAudioOut()',pro:'def FirstAudioOut()',cmt:'<p>Starts the enumeration of audio outputs currently accessible. Use the method <tt>YAudioOut.nextAudioOut()</tt> to iterate on next audio outputs.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to the first audio output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AudioOut']['clearCache']={syn:'Invalidates the cache.',lib:'audioout.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AudioOut']['describe']={syn:'Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioout.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioOut']['get_advertisedValue']={syn:'Returns the current value of the audio output (no more than 6 characters).',lib:'audioout.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the audio output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioOut']['get_errorMessage']={syn:'Returns the error message of the latest error with the audio output.',lib:'audioout.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio output object'};
doc['AudioOut']['get_errorType']={syn:'Returns the numerical error code of the latest error with the audio output.',lib:'audioout.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio output object'};
doc['AudioOut']['get_friendlyName']={syn:'Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'audioout.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio output if they are defined, otherwise the serial number of the module and the hardware identifier of the audio output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioOut']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'audioout.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AudioOut']['get_functionId']={syn:'Returns the hardware identifier of the audio output, without reference to the module.',lib:'audioout.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the audio output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioOut']['get_hardwareId']={syn:'Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioout.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioOut']['get_logicalName']={syn:'Returns the logical name of the audio output.',lib:'audioout.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the audio output.</p>',ret:'a string corresponding to the logical name of the audio output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioOut']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'audioout.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AudioOut']['get_mute']={syn:'Returns the state of the mute function.',lib:'audioout.get_mute()',pro:'def get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioOut']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'audioout.get_noSignalFor()',pro:'def get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioOut']['get_signal']={syn:'Returns the detected output current level.',lib:'audioout.get_signal()',pro:'def get_signal()',cmt:'<p>Returns the detected output current level.</p>',ret:'an integer corresponding to the detected output current level',ext:'On failure, throws an exception or returns <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioOut']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'audioout.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AudioOut']['get_volume']={syn:'Returns audio output volume, in per cents.',lib:'audioout.get_volume()',pro:'def get_volume()',cmt:'<p>Returns audio output volume, in per cents.</p>',ret:'an integer corresponding to audio output volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioOut']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'audioout.get_volumeRange()',pro:'def get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioOut']['isOnline']={syn:'Checks if the audio output is currently reachable, without raising any error.',lib:'audioout.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the audio output is currently reachable, without raising any error. If there is a cached value for the audio output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio output.</p>',ret:'<tt>true</tt> if the audio output can be reached, and <tt>false</tt> otherwise'};
doc['AudioOut']['load']={syn:'Preloads the audio output cache with a specified validity duration.',lib:'audioout.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'audioout.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AudioOut']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'audioout.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['nextAudioOut']={syn:'Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>.',lib:'audioout.nextAudioOut()',pro:'def nextAudioOut()',cmt:'<p>Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>. Caution: You can\x27t make any assumption about the returned audio outputs order. If you want to find a specific an audio output, use <tt>AudioOut.findAudioOut()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to an audio output currently online, or a <tt>null</tt> pointer if there are no more audio outputs to enumerate.'};
doc['AudioOut']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'audioout.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AudioOut']['set_logicalName']={syn:'Changes the logical name of the audio output.',lib:'audioout.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['set_mute']={syn:'Changes the state of the mute function.',lib:'audioout.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'audioout.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AudioOut']['set_volume']={syn:'Changes audio output volume, in per cents.',lib:'audioout.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes audio output volume, in per cents.</p>',par:{newval:'an integer corresponding to audio output volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'audioout.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AudioOut)
//--- (generated code: BluetoothLink)
doc['BluetoothLink']={'':{syn:'BluetoothLink function interface',inc:'from yocto_bluetoothlink import *',cmt:'<p>BluetoothLink function provides control over bluetooth link and status for devices that are bluetooth-enabled.</p>'}};
doc['BluetoothLink']['FindBluetoothLink']={syn:'Retrieves a cellular interface for a given identifier.',lib:'YBluetoothLink.FindBluetoothLink()',pro:'def FindBluetoothLink(<span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBluetoothLink.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the cellular interface'},ret:'a <tt>YBluetoothLink</tt> object allowing you to drive the cellular interface.'};
doc['BluetoothLink']['FirstBluetoothLink']={syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YBluetoothLink.FirstBluetoothLink()',pro:'def FirstBluetoothLink()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YBluetoothLink.nextBluetoothLink()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YBluetoothLink</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['BluetoothLink']['clearCache']={syn:'Invalidates the cache.',lib:'bluetoothlink.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the cellular interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['BluetoothLink']['connect']={syn:'Attempt to connect to the previously selected remote device.',lib:'bluetoothlink.connect()',pro:'def connect()',cmt:'<p>Attempt to connect to the previously selected remote device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['describe']={syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'bluetoothlink.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['BluetoothLink']['disconnect']={syn:'Disconnect from the previously selected remote device.',lib:'bluetoothlink.disconnect()',pro:'def disconnect()',cmt:'<p>Disconnect from the previously selected remote device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'bluetoothlink.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['BluetoothLink']['get_errorMessage']={syn:'Returns the error message of the latest error with the cellular interface.',lib:'bluetoothlink.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'};
doc['BluetoothLink']['get_errorType']={syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'bluetoothlink.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'};
doc['BluetoothLink']['get_friendlyName']={syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'bluetoothlink.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'bluetoothlink.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['BluetoothLink']['get_functionId']={syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'bluetoothlink.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['BluetoothLink']['get_hardwareId']={syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'bluetoothlink.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['BluetoothLink']['get_linkQuality']={syn:'Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.',lib:'bluetoothlink.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.</p>',ret:'an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['BluetoothLink']['get_linkState']={syn:'Returns the bluetooth link state.',lib:'bluetoothlink.get_linkState()',pro:'def get_linkState()',cmt:'<p>Returns the bluetooth link state.</p>',ret:'a value among <tt>Y_LINKSTATE_DOWN</tt>, <tt>Y_LINKSTATE_FREE</tt>, <tt>Y_LINKSTATE_SEARCH</tt>, <tt>Y_LINKSTATE_EXISTS</tt>, <tt>Y_LINKSTATE_LINKED</tt> and <tt>Y_LINKSTATE_PLAY</tt> corresponding to the bluetooth link state',ext:'On failure, throws an exception or returns <tt>Y_LINKSTATE_INVALID</tt>.'};
doc['BluetoothLink']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'bluetoothlink.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'bluetoothlink.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['BluetoothLink']['get_mute']={syn:'Returns the state of the mute function.',lib:'bluetoothlink.get_mute()',pro:'def get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['BluetoothLink']['get_ownAddress']={syn:'Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.',lib:'bluetoothlink.get_ownAddress()',pro:'def get_ownAddress()',cmt:'<p>Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.</p>',ret:'a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network',ext:'On failure, throws an exception or returns <tt>Y_OWNADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_pairingPin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'bluetoothlink.get_pairingPin()',pro:'def get_pairingPin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_PAIRINGPIN_INVALID</tt>.'};
doc['BluetoothLink']['get_preAmplifier']={syn:'Returns the audio pre-amplifier volume, in per cents.',lib:'bluetoothlink.get_preAmplifier()',pro:'def get_preAmplifier()',cmt:'<p>Returns the audio pre-amplifier volume, in per cents.</p>',ret:'an integer corresponding to the audio pre-amplifier volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_PREAMPLIFIER_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteAddress']={syn:'Returns the MAC-48 address of the remote device to connect to.',lib:'bluetoothlink.get_remoteAddress()',pro:'def get_remoteAddress()',cmt:'<p>Returns the MAC-48 address of the remote device to connect to.</p>',ret:'a string corresponding to the MAC-48 address of the remote device to connect to',ext:'On failure, throws an exception or returns <tt>Y_REMOTEADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteName']={syn:'Returns the bluetooth name the remote device, if found on the bluetooth network.',lib:'bluetoothlink.get_remoteName()',pro:'def get_remoteName()',cmt:'<p>Returns the bluetooth name the remote device, if found on the bluetooth network.</p>',ret:'a string corresponding to the bluetooth name the remote device, if found on the bluetooth network',ext:'On failure, throws an exception or returns <tt>Y_REMOTENAME_INVALID</tt>.'};
doc['BluetoothLink']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'bluetoothlink.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['BluetoothLink']['get_volume']={syn:'Returns the connected headset volume, in per cents.',lib:'bluetoothlink.get_volume()',pro:'def get_volume()',cmt:'<p>Returns the connected headset volume, in per cents.</p>',ret:'an integer corresponding to the connected headset volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['BluetoothLink']['isOnline']={syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'bluetoothlink.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'};
doc['BluetoothLink']['load']={syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'bluetoothlink.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'bluetoothlink.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['BluetoothLink']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'bluetoothlink.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['nextBluetoothLink']={syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstBluetoothLink()</tt>.',lib:'bluetoothlink.nextBluetoothLink()',pro:'def nextBluetoothLink()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstBluetoothLink()</tt>. Caution: You can\x27t make any assumption about the returned cellular interfaces order. If you want to find a specific a cellular interface, use <tt>BluetoothLink.findBluetoothLink()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YBluetoothLink</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'};
doc['BluetoothLink']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'bluetoothlink.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['BluetoothLink']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'bluetoothlink.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_mute']={syn:'Changes the state of the mute function.',lib:'bluetoothlink.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_pairingPin']={syn:'Changes the PIN code used by the module for bluetooth pairing.',lib:'bluetoothlink.set_pairingPin()',pro:'def set_pairingPin(<span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module for bluetooth pairing. Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module for bluetooth pairing'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_preAmplifier']={syn:'Changes the audio pre-amplifier volume, in per cents.',lib:'bluetoothlink.set_preAmplifier()',pro:'def set_preAmplifier(<span id=pn>newval</span>)',cmt:'<p>Changes the audio pre-amplifier volume, in per cents.</p>',par:{newval:'an integer corresponding to the audio pre-amplifier volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_remoteAddress']={syn:'Changes the MAC-48 address defining which remote device to connect to.',lib:'bluetoothlink.set_remoteAddress()',pro:'def set_remoteAddress(<span id=pn>newval</span>)',cmt:'<p>Changes the MAC-48 address defining which remote device to connect to.</p>',par:{newval:'a string corresponding to the MAC-48 address defining which remote device to connect to'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'bluetoothlink.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['BluetoothLink']['set_volume']={syn:'Changes the connected headset volume, in per cents.',lib:'bluetoothlink.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes the connected headset volume, in per cents.</p>',par:{newval:'an integer corresponding to the connected headset volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'bluetoothlink.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: BluetoothLink)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'AudioIn function interface',inc:'from yocto_audioin import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the input channel.</p>'}};
doc['AudioIn']['FindAudioIn']={syn:'Retrieves an audio input for a given identifier.',lib:'YAudioIn.FindAudioIn()',pro:'def FindAudioIn(<span id=pn>func</span>)',cmt:'<p>Retrieves an audio input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioIn.isOnline()</tt> to test if the audio input is indeed online at a given time. In case of ambiguity when looking for an audio input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio input'},ret:'a <tt>YAudioIn</tt> object allowing you to drive the audio input.'};
doc['AudioIn']['FirstAudioIn']={syn:'Starts the enumeration of audio inputs currently accessible.',lib:'YAudioIn.FirstAudioIn()',pro:'def FirstAudioIn()',cmt:'<p>Starts the enumeration of audio inputs currently accessible. Use the method <tt>YAudioIn.nextAudioIn()</tt> to iterate on next audio inputs.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to the first audio input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AudioIn']['clearCache']={syn:'Invalidates the cache.',lib:'audioin.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AudioIn']['describe']={syn:'Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioin.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioIn']['get_advertisedValue']={syn:'Returns the current value of the audio input (no more than 6 characters).',lib:'audioin.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the audio input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioIn']['get_errorMessage']={syn:'Returns the error message of the latest error with the audio input.',lib:'audioin.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio input object'};
doc['AudioIn']['get_errorType']={syn:'Returns the numerical error code of the latest error with the audio input.',lib:'audioin.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio input object'};
doc['AudioIn']['get_friendlyName']={syn:'Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'audioin.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio input if they are defined, otherwise the serial number of the module and the hardware identifier of the audio input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioIn']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'audioin.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AudioIn']['get_functionId']={syn:'Returns the hardware identifier of the audio input, without reference to the module.',lib:'audioin.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the audio input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioIn']['get_hardwareId']={syn:'Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioin.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioIn']['get_logicalName']={syn:'Returns the logical name of the audio input.',lib:'audioin.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the audio input.</p>',ret:'a string corresponding to the logical name of the audio input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioIn']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'audioin.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AudioIn']['get_mute']={syn:'Returns the state of the mute function.',lib:'audioin.get_mute()',pro:'def get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioIn']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'audioin.get_noSignalFor()',pro:'def get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioIn']['get_signal']={syn:'Returns the detected input signal level.',lib:'audioin.get_signal()',pro:'def get_signal()',cmt:'<p>Returns the detected input signal level.</p>',ret:'an integer corresponding to the detected input signal level',ext:'On failure, throws an exception or returns <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioIn']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'audioin.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AudioIn']['get_volume']={syn:'Returns audio input gain, in per cents.',lib:'audioin.get_volume()',pro:'def get_volume()',cmt:'<p>Returns audio input gain, in per cents.</p>',ret:'an integer corresponding to audio input gain, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioIn']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'audioin.get_volumeRange()',pro:'def get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioIn']['isOnline']={syn:'Checks if the audio input is currently reachable, without raising any error.',lib:'audioin.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the audio input is currently reachable, without raising any error. If there is a cached value for the audio input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio input.</p>',ret:'<tt>true</tt> if the audio input can be reached, and <tt>false</tt> otherwise'};
doc['AudioIn']['load']={syn:'Preloads the audio input cache with a specified validity duration.',lib:'audioin.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'audioin.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AudioIn']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'audioin.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['nextAudioIn']={syn:'Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>.',lib:'audioin.nextAudioIn()',pro:'def nextAudioIn()',cmt:'<p>Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>. Caution: You can\x27t make any assumption about the returned audio inputs order. If you want to find a specific an audio input, use <tt>AudioIn.findAudioIn()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to an audio input currently online, or a <tt>null</tt> pointer if there are no more audio inputs to enumerate.'};
doc['AudioIn']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'audioin.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AudioIn']['set_logicalName']={syn:'Changes the logical name of the audio input.',lib:'audioin.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['set_mute']={syn:'Changes the state of the mute function.',lib:'audioin.set_mute()',pro:'def set_mute(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'audioin.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AudioIn']['set_volume']={syn:'Changes audio input gain, in per cents.',lib:'audioin.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes audio input gain, in per cents.</p>',par:{newval:'an integer corresponding to audio input gain, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'audioin.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AudioIn)
//--- (generated code: QuadratureDecoder)
doc['QuadratureDecoder']={'':{syn:'QuadratureDecoder function interface',inc:'from yocto_quadraturedecoder import *',cmt:'<p>The class YQuadratureDecoder allows you to decode a two-wire signal produced by a quadrature encoder. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['QuadratureDecoder']['FindQuadratureDecoder']={syn:'Retrieves a quadrature decoder for a given identifier.',lib:'YQuadratureDecoder.FindQuadratureDecoder()',pro:'def FindQuadratureDecoder(<span id=pn>func</span>)',cmt:'<p>Retrieves a quadrature decoder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quadrature decoder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQuadratureDecoder.isOnline()</tt> to test if the quadrature decoder is indeed online at a given time. In case of ambiguity when looking for a quadrature decoder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quadrature decoder'},ret:'a <tt>YQuadratureDecoder</tt> object allowing you to drive the quadrature decoder.'};
doc['QuadratureDecoder']['FirstQuadratureDecoder']={syn:'Starts the enumeration of quadrature decoders currently accessible.',lib:'YQuadratureDecoder.FirstQuadratureDecoder()',pro:'def FirstQuadratureDecoder()',cmt:'<p>Starts the enumeration of quadrature decoders currently accessible. Use the method <tt>YQuadratureDecoder.nextQuadratureDecoder()</tt> to iterate on next quadrature decoders.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to the first quadrature decoder currently online, or a <tt>null</tt> pointer if there are none.'};
doc['QuadratureDecoder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'quadraturedecoder.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['clearCache']={syn:'Invalidates the cache.',lib:'quadraturedecoder.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quadrature decoder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['QuadratureDecoder']['describe']={syn:'Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'quadraturedecoder.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quadrature decoder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['QuadratureDecoder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'quadraturedecoder.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_advertisedValue']={syn:'Returns the current value of the quadrature decoder (no more than 6 characters).',lib:'quadraturedecoder.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the quadrature decoder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quadrature decoder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.',lib:'quadraturedecoder.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentValue']={syn:'Returns the current value of the position, in pas, as a floating point number.',lib:'quadraturedecoder.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the position, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the position, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'quadraturedecoder.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['QuadratureDecoder']['get_decoding']={syn:'Returns the current activation state of the quadrature decoder.',lib:'quadraturedecoder.get_decoding()',pro:'def get_decoding()',cmt:'<p>Returns the current activation state of the quadrature decoder.</p>',ret:'either <tt>Y_DECODING_OFF</tt> or <tt>Y_DECODING_ON</tt>, according to the current activation state of the quadrature decoder',ext:'On failure, throws an exception or returns <tt>Y_DECODING_INVALID</tt>.'};
doc['QuadratureDecoder']['get_errorMessage']={syn:'Returns the error message of the latest error with the quadrature decoder.',lib:'quadraturedecoder.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quadrature decoder object'};
doc['QuadratureDecoder']['get_errorType']={syn:'Returns the numerical error code of the latest error with the quadrature decoder.',lib:'quadraturedecoder.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quadrature decoder object'};
doc['QuadratureDecoder']['get_friendlyName']={syn:'Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'quadraturedecoder.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quadrature decoder if they are defined, otherwise the serial number of the module and the hardware identifier of the quadrature decoder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quadrature decoder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'quadraturedecoder.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['QuadratureDecoder']['get_functionId']={syn:'Returns the hardware identifier of the quadrature decoder, without reference to the module.',lib:'quadraturedecoder.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the quadrature decoder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quadrature decoder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_hardwareId']={syn:'Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'quadraturedecoder.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quadrature decoder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quadrature decoder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_highestValue']={syn:'Returns the maximal value observed for the position since the device was started.',lib:'quadraturedecoder.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'quadraturedecoder.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logicalName']={syn:'Returns the logical name of the quadrature decoder.',lib:'quadraturedecoder.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the quadrature decoder.</p>',ret:'a string corresponding to the logical name of the quadrature decoder.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_lowestValue']={syn:'Returns the minimal value observed for the position since the device was started.',lib:'quadraturedecoder.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'quadraturedecoder.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['QuadratureDecoder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'quadraturedecoder.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['QuadratureDecoder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'quadraturedecoder.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'quadraturedecoder.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['QuadratureDecoder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'quadraturedecoder.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_speed']={syn:'Returns the increments frequency, in Hz.',lib:'quadraturedecoder.get_speed()',pro:'def get_speed()',cmt:'<p>Returns the increments frequency, in Hz.</p>',ret:'a floating point number corresponding to the increments frequency, in Hz',ext:'On failure, throws an exception or returns <tt>Y_SPEED_INVALID</tt>.'};
doc['QuadratureDecoder']['get_unit']={syn:'Returns the measuring unit for the position.',lib:'quadraturedecoder.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the position.</p>',ret:'a string corresponding to the measuring unit for the position',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['QuadratureDecoder']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'quadraturedecoder.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['QuadratureDecoder']['isOnline']={syn:'Checks if the quadrature decoder is currently reachable, without raising any error.',lib:'quadraturedecoder.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the quadrature decoder is currently reachable, without raising any error. If there is a cached value for the quadrature decoder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quadrature decoder.</p>',ret:'<tt>true</tt> if the quadrature decoder can be reached, and <tt>false</tt> otherwise'};
doc['QuadratureDecoder']['load']={syn:'Preloads the quadrature decoder cache with a specified validity duration.',lib:'quadraturedecoder.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the quadrature decoder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'quadraturedecoder.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['QuadratureDecoder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'quadraturedecoder.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'quadraturedecoder.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['nextQuadratureDecoder']={syn:'Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>.',lib:'quadraturedecoder.nextQuadratureDecoder()',pro:'def nextQuadratureDecoder()',cmt:'<p>Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>. Caution: You can\x27t make any assumption about the returned quadrature decoders order. If you want to find a specific a quadrature decoder, use <tt>QuadratureDecoder.findQuadratureDecoder()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to a quadrature decoder currently online, or a <tt>null</tt> pointer if there are no more quadrature decoders to enumerate.'};
doc['QuadratureDecoder']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'quadraturedecoder.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['QuadratureDecoder']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'quadraturedecoder.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['QuadratureDecoder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'quadraturedecoder.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_currentValue']={syn:'Changes the current expected position of the quadrature decoder.',lib:'quadraturedecoder.set_currentValue()',pro:'def set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current expected position of the quadrature decoder. Invoking this function implicitly activates the quadrature decoder.</p>',par:{newval:'a floating point number corresponding to the current expected position of the quadrature decoder'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_decoding']={syn:'Changes the activation state of the quadrature decoder.',lib:'quadraturedecoder.set_decoding()',pro:'def set_decoding(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the quadrature decoder.</p>',par:{newval:'either <tt>Y_DECODING_OFF</tt> or <tt>Y_DECODING_ON</tt>, according to the activation state of the quadrature decoder'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'quadraturedecoder.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'quadraturedecoder.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_logicalName']={syn:'Changes the logical name of the quadrature decoder.',lib:'quadraturedecoder.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quadrature decoder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quadrature decoder.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'quadraturedecoder.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'quadraturedecoder.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'quadraturedecoder.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'quadraturedecoder.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['QuadratureDecoder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'quadraturedecoder.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['QuadratureDecoder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'quadraturedecoder.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['QuadratureDecoder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'quadraturedecoder.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: QuadratureDecoder)
//--- (generated code: CurrentLoopOutput)
doc['CurrentLoopOutput']={'':{syn:'CurrentLoopOutput function interface',inc:'from yocto_currentloopoutput import *',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the 4-20mA \x09 output as well as to know the current loop state.</p>'}};
doc['CurrentLoopOutput']['FindCurrentLoopOutput']={syn:'Retrieves a 4-20mA output for a given identifier.',lib:'YCurrentLoopOutput.FindCurrentLoopOutput()',pro:'def FindCurrentLoopOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a 4-20mA output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the 4-20mA output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrentLoopOutput.isOnline()</tt> to test if the 4-20mA output is indeed online at a given time. In case of ambiguity when looking for a 4-20mA output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the 4-20mA output'},ret:'a <tt>YCurrentLoopOutput</tt> object allowing you to drive the 4-20mA output.'};
doc['CurrentLoopOutput']['FirstCurrentLoopOutput']={syn:'Starts the enumeration of 4-20mA outputs currently accessible.',lib:'YCurrentLoopOutput.FirstCurrentLoopOutput()',pro:'def FirstCurrentLoopOutput()',cmt:'<p>Starts the enumeration of 4-20mA outputs currently accessible. Use the method <tt>YCurrentLoopOutput.nextCurrentLoopOutput()</tt> to iterate on next 4-20mA outputs.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to the first 4-20mA output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CurrentLoopOutput']['clearCache']={syn:'Invalidates the cache.',lib:'currentloopoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the 4-20mA output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['CurrentLoopOutput']['currentMove']={syn:'Performs a smooth transition of current flowing in the loop.',lib:'currentloopoutput.currentMove()',pro:'def currentMove(<span id=pn>mA_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of current flowing in the loop. Any current explicit change cancels any ongoing transition process.</p>',par:{mA_target:'new current value at the end of the transition (floating-point number, representing the end current in mA)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.'};
doc['CurrentLoopOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'currentloopoutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the 4-20mA output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CurrentLoopOutput']['get_advertisedValue']={syn:'Returns the current value of the 4-20mA output (no more than 6 characters).',lib:'currentloopoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the 4-20mA output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the 4-20mA output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_current']={syn:'Returns the loop current set point in mA.',lib:'currentloopoutput.get_current()',pro:'def get_current()',cmt:'<p>Returns the loop current set point in mA.</p>',ret:'a floating point number corresponding to the loop current set point in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENT_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_currentAtStartUp']={syn:'Returns the current in the loop at device startup, in mA.',lib:'currentloopoutput.get_currentAtStartUp()',pro:'def get_currentAtStartUp()',cmt:'<p>Returns the current in the loop at device startup, in mA.</p>',ret:'a floating point number corresponding to the current in the loop at device startup, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the 4-20mA output.',lib:'currentloopoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the 4-20mA output object'};
doc['CurrentLoopOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the 4-20mA output.',lib:'currentloopoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the 4-20mA output object'};
doc['CurrentLoopOutput']['get_friendlyName']={syn:'Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'currentloopoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the 4-20mA output if they are defined, otherwise the serial number of the module and the hardware identifier of the 4-20mA output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the 4-20mA output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'currentloopoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_functionId']={syn:'Returns the hardware identifier of the 4-20mA output, without reference to the module.',lib:'currentloopoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the 4-20mA output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the 4-20mA output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'currentloopoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the 4-20mA output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the 4-20mA output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_logicalName']={syn:'Returns the logical name of the 4-20mA output.',lib:'currentloopoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the 4-20mA output.</p>',ret:'a string corresponding to the logical name of the 4-20mA output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_loopPower']={syn:'Returns the loop powerstate.',lib:'currentloopoutput.get_loopPower()',pro:'def get_loopPower()',cmt:'<p>Returns the loop powerstate. POWEROK: the loop \x09 is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not powered enough to maintain the current required (insufficient voltage).</p>',ret:'a value among <tt>Y_LOOPPOWER_NOPWR</tt>, <tt>Y_LOOPPOWER_LOWPWR</tt> and <tt>Y_LOOPPOWER_POWEROK</tt> corresponding to the loop powerstate',ext:'On failure, throws an exception or returns <tt>Y_LOOPPOWER_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'currentloopoutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CurrentLoopOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'currentloopoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CurrentLoopOutput']['isOnline']={syn:'Checks if the 4-20mA output is currently reachable, without raising any error.',lib:'currentloopoutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the 4-20mA output is currently reachable, without raising any error. If there is a cached value for the 4-20mA output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the 4-20mA output.</p>',ret:'<tt>true</tt> if the 4-20mA output can be reached, and <tt>false</tt> otherwise'};
doc['CurrentLoopOutput']['load']={syn:'Preloads the 4-20mA output cache with a specified validity duration.',lib:'currentloopoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the 4-20mA output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'currentloopoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['CurrentLoopOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'currentloopoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['nextCurrentLoopOutput']={syn:'Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>.',lib:'currentloopoutput.nextCurrentLoopOutput()',pro:'def nextCurrentLoopOutput()',cmt:'<p>Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>. Caution: You can\x27t make any assumption about the returned 4-20mA outputs order. If you want to find a specific a 4-20mA output, use <tt>CurrentLoopOutput.findCurrentLoopOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to a 4-20mA output currently online, or a <tt>null</tt> pointer if there are no more 4-20mA outputs to enumerate.'};
doc['CurrentLoopOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'currentloopoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CurrentLoopOutput']['set_current']={syn:'Changes the current loop, the valid range is from 3 to 21mA.',lib:'currentloopoutput.set_current()',pro:'def set_current(<span id=pn>newval</span>)',cmt:'<p>Changes the current loop, the valid range is from 3 to 21mA. If the loop is \x09 not properly powered, the target current is not reached and \x09\x09loopPower is set to LOWPWR.</p>',par:{newval:'a floating point number corresponding to the current loop, the valid range is from 3 to 21mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_currentAtStartUp']={syn:'Changes the loop current at device start up.',lib:'currentloopoutput.set_currentAtStartUp()',pro:'def set_currentAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the loop current at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the loop current at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_logicalName']={syn:'Changes the logical name of the 4-20mA output.',lib:'currentloopoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the 4-20mA output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the 4-20mA output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'currentloopoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['CurrentLoopOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'currentloopoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: CurrentLoopOutput)
//--- (generated code: ColorLedCluster)
doc['ColorLedCluster']={'':{syn:'ColorLedCluster function interface',inc:'from yocto_colorledcluster import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED cluster. Unlike the ColorLed class, the ColorLedCluster allows to handle several LEDs at one. Color changes can be done using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLedCluster']['FindColorLedCluster']={syn:'Retrieves a RGB LED cluster for a given identifier.',lib:'YColorLedCluster.FindColorLedCluster()',pro:'def FindColorLedCluster(<span id=pn>func</span>)',cmt:'<p>Retrieves a RGB LED cluster for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED cluster is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLedCluster.isOnline()</tt> to test if the RGB LED cluster is indeed online at a given time. In case of ambiguity when looking for a RGB LED cluster by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED cluster'},ret:'a <tt>YColorLedCluster</tt> object allowing you to drive the RGB LED cluster.'};
doc['ColorLedCluster']['FirstColorLedCluster']={syn:'Starts the enumeration of RGB LED clusters currently accessible.',lib:'YColorLedCluster.FirstColorLedCluster()',pro:'def FirstColorLedCluster()',cmt:'<p>Starts the enumeration of RGB LED clusters currently accessible. Use the method <tt>YColorLedCluster.nextColorLedCluster()</tt> to iterate on next RGB LED clusters.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to the first RGB LED cluster currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLedCluster']['addHslMoveToBlinkSeq']={syn:'Adds an HSL transition to a sequence.',lib:'colorledcluster.addHslMoveToBlinkSeq()',pro:'def addHslMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Adds an HSL transition to a sequence. A sequence is a transition list, which can be executed in loop by an group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',hslValue:'target color (0xHHSSLL)',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addJumpToBlinkSeq']={syn:'Adds to a sequence a jump to another sequence.',lib:'colorledcluster.addJumpToBlinkSeq()',pro:'def addJumpToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>linkSeqIndex</span>)',cmt:'<p>Adds to a sequence a jump to another sequence. When a pixel will reach this jump, it will be automatically relinked to the new sequence, and will run it starting from the beginning.</p>',par:{seqIndex:'sequence index.',linkSeqIndex:'index of the sequence to chain.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addMirrorToBlinkSeq']={syn:'Adds a mirror ending to a sequence.',lib:'colorledcluster.addMirrorToBlinkSeq()',pro:'def addMirrorToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Adds a mirror ending to a sequence. When the sequence will reach the end of the last transition, its running speed will automatically be reversed so that the sequence plays in the reverse direction, like in a mirror. After the first transition of the sequence is played at the end of the reverse execution, the sequence starts again in the initial direction.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addRgbMoveToBlinkSeq']={syn:'Adds an RGB transition to a sequence.',lib:'colorledcluster.addRgbMoveToBlinkSeq()',pro:'def addRgbMoveToBlinkSeq(<span id=pn>seqIndex</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Adds an RGB transition to a sequence. A sequence is a transition list, which can be executed in loop by a group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',rgbValue:'target color (0xRRGGBB)',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addUnlinkToBlinkSeq']={syn:'Adds a to a sequence a hard stop code.',lib:'colorledcluster.addUnlinkToBlinkSeq()',pro:'def addUnlinkToBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Adds a to a sequence a hard stop code. When a pixel will reach this stop code, instead of restarting the sequence in a loop it will automatically be unlinked from the sequence.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['clearCache']={syn:'Invalidates the cache.',lib:'colorledcluster.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED cluster attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['ColorLedCluster']['describe']={syn:'Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorledcluster.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED cluster (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLedCluster']['get_activeLedCount']={syn:'Returns the number of LEDs currently handled by the device.',lib:'colorledcluster.get_activeLedCount()',pro:'def get_activeLedCount()',cmt:'<p>Returns the number of LEDs currently handled by the device.</p>',ret:'an integer corresponding to the number of LEDs currently handled by the device',ext:'On failure, throws an exception or returns <tt>Y_ACTIVELEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_advertisedValue']={syn:'Returns the current value of the RGB LED cluster (no more than 6 characters).',lib:'colorledcluster.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED cluster (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED cluster (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxCount']={syn:'Returns the maximum number of sequences that the device can handle.',lib:'colorledcluster.get_blinkSeqMaxCount()',pro:'def get_blinkSeqMaxCount()',cmt:'<p>Returns the maximum number of sequences that the device can handle.</p>',ret:'an integer corresponding to the maximum number of sequences that the device can handle',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of sequences.',lib:'colorledcluster.get_blinkSeqMaxSize()',pro:'def get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of sequences.</p>',ret:'an integer corresponding to the maximum length of sequences',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqSignatures']={syn:'Returns a list on 32 bit signatures for specified blinking sequences.',lib:'colorledcluster.get_blinkSeqSignatures()',pro:'def get_blinkSeqSignatures(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 32 bit signatures for specified blinking sequences. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of 32 bit integer signatures',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqState']={syn:'Returns a list of integers with the started state for specified blinking sequences.',lib:'colorledcluster.get_blinkSeqState()',pro:'def get_blinkSeqState(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the started state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqStateAtPowerOn']={syn:'Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.',lib:'colorledcluster.get_blinkSeqStateAtPowerOn()',pro:'def get_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqStateSpeed']={syn:'Returns a list of integers with the current speed for specified blinking sequences.',lib:'colorledcluster.get_blinkSeqStateSpeed()',pro:'def get_blinkSeqStateSpeed(<span id=pn>seqIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the current speed for specified blinking sequences.</p>',par:{seqIndex:'index of the first sequence speed which should be returned',count:'number of sequence speeds which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_errorMessage']={syn:'Returns the error message of the latest error with the RGB LED cluster.',lib:'colorledcluster.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED cluster object'};
doc['ColorLedCluster']['get_errorType']={syn:'Returns the numerical error code of the latest error with the RGB LED cluster.',lib:'colorledcluster.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED cluster object'};
doc['ColorLedCluster']['get_friendlyName']={syn:'Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorledcluster.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED cluster if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED cluster (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED cluster using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorledcluster.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLedCluster']['get_functionId']={syn:'Returns the hardware identifier of the RGB LED cluster, without reference to the module.',lib:'colorledcluster.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED cluster, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED cluster (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLedCluster']['get_hardwareId']={syn:'Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorledcluster.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED cluster (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED cluster (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLedCluster']['get_ledType']={syn:'Returns the RGB LED type currently handled by the device.',lib:'colorledcluster.get_ledType()',pro:'def get_ledType()',cmt:'<p>Returns the RGB LED type currently handled by the device.</p>',ret:'either <tt>Y_LEDTYPE_RGB</tt> or <tt>Y_LEDTYPE_RGBW</tt>, according to the RGB LED type currently handled by the device',ext:'On failure, throws an exception or returns <tt>Y_LEDTYPE_INVALID</tt>.'};
doc['ColorLedCluster']['get_linkedSeqArray']={syn:'Returns a list on sequence index for each RGB LED.',lib:'colorledcluster.get_linkedSeqArray()',pro:'def get_linkedSeqArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on sequence index for each RGB LED. The first number represents the sequence index for the the first LED, the second number represents the sequence index for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of integers with sequence index',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_logicalName']={syn:'Returns the logical name of the RGB LED cluster.',lib:'colorledcluster.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED cluster.</p>',ret:'a string corresponding to the logical name of the RGB LED cluster.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_maxLedCount']={syn:'Returns the maximum number of LEDs that the device can handle.',lib:'colorledcluster.get_maxLedCount()',pro:'def get_maxLedCount()',cmt:'<p>Returns the maximum number of LEDs that the device can handle.</p>',ret:'an integer corresponding to the maximum number of LEDs that the device can handle',ext:'On failure, throws an exception or returns <tt>Y_MAXLEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorledcluster.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLedCluster']['get_rgbColorArray']={syn:'Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs.',lib:'colorledcluster.get_rgbColorArray()',pro:'def get_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the current colors displayed on the RGB LEDs. The first number represents the RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_rgbColorArrayAtPowerOn']={syn:'Returns a list on 24bit RGB color values with the RGB LEDs startup colors.',lib:'colorledcluster.get_rgbColorArrayAtPowerOn()',pro:'def get_rgbColorArrayAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the RGB LEDs startup colors. The first number represents the startup RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_rgbColorBuffer']={syn:'Returns a binary buffer with content from the LED RGB buffer, as is.',lib:'colorledcluster.get_rgbColorBuffer()',pro:'def get_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Returns a binary buffer with content from the LED RGB buffer, as is. First three bytes are RGB components for the first LED in the interval, the next three bytes for the second LED in the interval, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a binary buffer with RGB components of selected LEDs.',ext:'On failure, throws an exception or returns an empty binary buffer.'};
doc['ColorLedCluster']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorledcluster.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLedCluster']['hslArrayOfs_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'colorledcluster.hslArrayOfs_move()',pro:'def hslArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['hslArray_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'colorledcluster.hslArray_move()',pro:'def hslArray_move(<span id=pn>hslList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['hsl_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'colorledcluster.hsl_move()',pro:'def hsl_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>, <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular value (0..360\xB0). There are always two paths to perform the transition: by increasing or by decreasing the hue. The module selects the shortest transition. If the difference is exactly 180\xB0, the module selects the transition which increases the hue.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color (0xHHSSLL).',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['isOnline']={syn:'Checks if the RGB LED cluster is currently reachable, without raising any error.',lib:'colorledcluster.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the RGB LED cluster is currently reachable, without raising any error. If there is a cached value for the RGB LED cluster in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED cluster.</p>',ret:'<tt>true</tt> if the RGB LED cluster can be reached, and <tt>false</tt> otherwise'};
doc['ColorLedCluster']['linkLedToBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'colorledcluster.linkLedToBlinkSeq()',pro:'def linkLedToBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LEDs start to execute the sequence as soon as startBlinkSeq is called. It is possible to add an offset in the execution: that way we can have several groups of LED executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['linkLedToBlinkSeqAtPowerOn']={syn:'Links adjacent LEDs to a specific sequence at device power-on.',lib:'colorledcluster.linkLedToBlinkSeqAtPowerOn()',pro:'def linkLedToBlinkSeqAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence at device power-on. Don\x27t forget to configure the sequence auto start flag as well and call <tt>saveLedsConfigAtPowerOn()</tt>. It is possible to add an offset in the execution: that way we can have several groups of LEDs executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['linkLedToPeriodicBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'colorledcluster.linkLedToPeriodicBlinkSeq()',pro:'def linkLedToPeriodicBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>seqIndex</span>, <span id=pn>periods</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LED start to execute the sequence as soon as startBlinkSeq is called. This function automatically introduces a shift between LEDs so that the specified number of sequence periods appears on the group of LEDs (wave effect).</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',periods:'number of periods to show on LEDs.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['load']={syn:'Preloads the RGB LED cluster cache with a specified validity duration.',lib:'colorledcluster.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cluster cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'colorledcluster.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['ColorLedCluster']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'colorledcluster.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['nextColorLedCluster']={syn:'Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>.',lib:'colorledcluster.nextColorLedCluster()',pro:'def nextColorLedCluster()',cmt:'<p>Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>. Caution: You can\x27t make any assumption about the returned RGB LED clusters order. If you want to find a specific a RGB LED cluster, use <tt>ColorLedCluster.findColorLedCluster()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to a RGB LED cluster currently online, or a <tt>null</tt> pointer if there are no more RGB LED clusters to enumerate.'};
doc['ColorLedCluster']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorledcluster.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLedCluster']['resetBlinkSeq']={syn:'Stops a sequence execution and resets its contents.',lib:'colorledcluster.resetBlinkSeq()',pro:'def resetBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution and resets its contents. LEDs linked to this sequence are not automatically updated anymore.</p>',par:{seqIndex:'index of the sequence to reset'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgbArrayOfs_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'colorledcluster.rgbArrayOfs_move()',pro:'def rgbArrayOfs_move(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgbArray_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'colorledcluster.rgbArray_move()',pro:'def rgbArray_move(<span id=pn>rgbList</span>, <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgb_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'colorledcluster.rgb_move()',pro:'def rgb_move(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>, <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the RGB space.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color (0xRRGGBB).',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['saveBlinkSeq']={syn:'Saves the definition of a sequence.',lib:'colorledcluster.saveBlinkSeq()',pro:'def saveBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Saves the definition of a sequence. Warning: only sequence steps and flags are saved. to save the LEDs startup bindings, the method <tt>saveLedsConfigAtPowerOn()</tt> must be called.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['saveLedsConfigAtPowerOn']={syn:'Saves the LEDs power-on configuration.',lib:'colorledcluster.saveLedsConfigAtPowerOn()',pro:'def saveLedsConfigAtPowerOn()',cmt:'<p>Saves the LEDs power-on configuration. This includes the start-up color or sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the method <tt>saveBlinkSeq()</tt> must also be called to save the sequence definition.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_activeLedCount']={syn:'Changes the number of LEDs currently handled by the device.',lib:'colorledcluster.set_activeLedCount()',pro:'def set_activeLedCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of LEDs currently handled by the device.</p>',par:{newval:'an integer corresponding to the number of LEDs currently handled by the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_blinkSeqSpeed']={syn:'Changes the execution speed of a sequence.',lib:'colorledcluster.set_blinkSeqSpeed()',pro:'def set_blinkSeqSpeed(<span id=pn>seqIndex</span>, <span id=pn>speed</span>)',cmt:'<p>Changes the execution speed of a sequence. The natural execution speed is 1000 per thousand. If you configure a slower speed, you can play the sequence in slow-motion. If you set a negative speed, you can play the sequence in reverse direction.</p>',par:{seqIndex:'index of the sequence to start.',speed:'sequence running speed (-1000...1000).'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_blinkSeqStateAtPowerOn']={syn:'Configures a sequence to make it start automatically at device startup.',lib:'colorledcluster.set_blinkSeqStateAtPowerOn()',pro:'def set_blinkSeqStateAtPowerOn(<span id=pn>seqIndex</span>, <span id=pn>autostart</span>)',cmt:'<p>Configures a sequence to make it start automatically at device startup. Note that a sequence with a zero duration can\x27t be started. Don\x27t forget to call <tt>saveBlinkSeq()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{seqIndex:'index of the sequence to reset.',autostart:'0 to keep the sequence turned off and 1 to start it automatically.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColor']={syn:'Changes the current color of consecutive LEDs in the cluster, using a HSL color.',lib:'colorledcluster.set_hslColor()',pro:'def set_hslColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColorArray']={syn:'Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.',lib:'colorledcluster.set_hslColorArray()',pro:'def set_hslColorArray(<span id=pn>ledIndex</span>, <span id=pn>hslList</span>)',cmt:'<p>Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is. The first number represents the HSL value of the LED specified as parameter, the second number represents the HSL value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of 24bit HSL codes, in the form 0xHHSSLL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColorAtPowerOn']={syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color.',lib:'colorledcluster.set_hslColorAtPowerOn()',pro:'def set_hslColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>hslValue</span>)',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColorBuffer']={syn:'Sends a binary buffer to the LED HSL buffer, as is.',lib:'colorledcluster.set_hslColorBuffer()',pro:'def set_hslColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED HSL buffer, as is. First three bytes are HSL components for the LED specified as parameter, the next three bytes for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_ledType']={syn:'Changes the RGB LED type currently handled by the device.',lib:'colorledcluster.set_ledType()',pro:'def set_ledType(<span id=pn>newval</span>)',cmt:'<p>Changes the RGB LED type currently handled by the device.</p>',par:{newval:'either <tt>Y_LEDTYPE_RGB</tt> or <tt>Y_LEDTYPE_RGBW</tt>, according to the RGB LED type currently handled by the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_logicalName']={syn:'Changes the logical name of the RGB LED cluster.',lib:'colorledcluster.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED cluster. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED cluster.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColor']={syn:'Changes the current color of consecutive LEDs in the cluster, using a RGB color.',lib:'colorledcluster.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorArray']={syn:'Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.',lib:'colorledcluster.set_rgbColorArray()',pro:'def set_rgbColorArray(<span id=pn>ledIndex</span>, <span id=pn>rgbList</span>)',cmt:'<p>Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is. The first number represents the RGB value of the LED specified as parameter, the second number represents the RGB value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of 24bit RGB codes, in the form 0xRRGGBB'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorAtPowerOn']={syn:'Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color.',lib:'colorledcluster.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>ledIndex</span>, <span id=pn>count</span>, <span id=pn>rgbValue</span>)',cmt:'<p>Changes the color at device startup of consecutive LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorBuffer']={syn:'Sends a binary buffer to the LED RGB buffer, as is.',lib:'colorledcluster.set_rgbColorBuffer()',pro:'def set_rgbColorBuffer(<span id=pn>ledIndex</span>, <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED RGB buffer, as is. First three bytes are RGB components for LED specified as parameter, the next three bytes for the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorledcluster.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['ColorLedCluster']['startBlinkSeq']={syn:'Starts a sequence execution: every LED linked to that sequence starts to run it in a loop.',lib:'colorledcluster.startBlinkSeq()',pro:'def startBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Starts a sequence execution: every LED linked to that sequence starts to run it in a loop. Note that a sequence with a zero duration can\x27t be started.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['stopBlinkSeq']={syn:'Stops a sequence execution.',lib:'colorledcluster.stopBlinkSeq()',pro:'def stopBlinkSeq(<span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution. If started again, the execution restarts from the beginning.</p>',par:{seqIndex:'index of the sequence to stop.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['unlinkLedFromBlinkSeq']={syn:'Unlinks adjacent LEDs from a sequence.',lib:'colorledcluster.unlinkLedFromBlinkSeq()',pro:'def unlinkLedFromBlinkSeq(<span id=pn>ledIndex</span>, <span id=pn>count</span>)',cmt:'<p>Unlinks adjacent LEDs from a sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'colorledcluster.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLedCluster)
//--- (generated code: SpiPort)
doc['SpiPort']={'':{syn:'SPI Port function interface',inc:'from yocto_spiport import *',cmt:'<p>The SpiPort function interface allows you to fully drive a Yoctopuce SPI port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce SPI ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SpiPort']['FindSpiPort']={syn:'Retrieves a SPI port for a given identifier.',lib:'YSpiPort.FindSpiPort()',pro:'def FindSpiPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a SPI port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the SPI port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSpiPort.isOnline()</tt> to test if the SPI port is indeed online at a given time. In case of ambiguity when looking for a SPI port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the SPI port'},ret:'a <tt>YSpiPort</tt> object allowing you to drive the SPI port.'};
doc['SpiPort']['FirstSpiPort']={syn:'Starts the enumeration of SPI ports currently accessible.',lib:'YSpiPort.FirstSpiPort()',pro:'def FirstSpiPort()',cmt:'<p>Starts the enumeration of SPI ports currently accessible. Use the method <tt>YSpiPort.nextSpiPort()</tt> to iterate on next SPI ports.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to the first SPI port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SpiPort']['clearCache']={syn:'Invalidates the cache.',lib:'spiport.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the SPI port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SpiPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'spiport.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the SPI port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SpiPort']['get_advertisedValue']={syn:'Returns the current value of the SPI port (no more than 6 characters).',lib:'spiport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the SPI port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SPI port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SpiPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'spiport.get_currentJob()',pro:'def get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SpiPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'spiport.get_errCount()',pro:'def get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the SPI port.',lib:'spiport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the SPI port object'};
doc['SpiPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the SPI port.',lib:'spiport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the SPI port object'};
doc['SpiPort']['get_friendlyName']={syn:'Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'spiport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the SPI port if they are defined, otherwise the serial number of the module and the hardware identifier of the SPI port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the SPI port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SpiPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'spiport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SpiPort']['get_functionId']={syn:'Returns the hardware identifier of the SPI port, without reference to the module.',lib:'spiport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the SPI port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the SPI port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SpiPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'spiport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the SPI port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the SPI port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SpiPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line and Frame protocols).',lib:'spiport.get_lastMsg()',pro:'def get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line and Frame protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line and Frame protocols)',ext:'On failure, throws an exception or returns <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SpiPort']['get_logicalName']={syn:'Returns the logical name of the SPI port.',lib:'spiport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the SPI port.</p>',ret:'a string corresponding to the logical name of the SPI port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SpiPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'spiport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SpiPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'spiport.get_protocol()',pro:'def get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SpiPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'spiport.get_rxCount()',pro:'def get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'spiport.get_rxMsgCount()',pro:'def get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_shiftSampling']={syn:'Returns true when the SDI line phase is shifted with regards to the SDO line.',lib:'spiport.get_shiftSampling()',pro:'def get_shiftSampling()',cmt:'<p>Returns true when the SDI line phase is shifted with regards to the SDO line.</p>',ret:'either <tt>Y_SHIFTSAMPLING_OFF</tt> or <tt>Y_SHIFTSAMPLING_ON</tt>, according to true when the SDI line phase is shifted with regards to the SDO line',ext:'On failure, throws an exception or returns <tt>Y_SHIFTSAMPLING_INVALID</tt>.'};
doc['SpiPort']['get_spiMode']={syn:'Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22.',lib:'spiport.get_spiMode()',pro:'def get_spiMode()',cmt:'<p>Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',ret:'a string corresponding to the SPI port communication parameters, as a string such as \x22125000,0,msb\x22',ext:'On failure, throws an exception or returns <tt>Y_SPIMODE_INVALID</tt>.'};
doc['SpiPort']['get_ssPolarity']={syn:'Returns the SS line polarity.',lib:'spiport.get_ssPolarity()',pro:'def get_ssPolarity()',cmt:'<p>Returns the SS line polarity.</p>',ret:'either <tt>Y_SSPOLARITY_ACTIVE_LOW</tt> or <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity',ext:'On failure, throws an exception or returns <tt>Y_SSPOLARITY_INVALID</tt>.'};
doc['SpiPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'spiport.get_startupJob()',pro:'def get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SpiPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'spiport.get_txCount()',pro:'def get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'spiport.get_txMsgCount()',pro:'def get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'spiport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SpiPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'spiport.get_voltageLevel()',pro:'def get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SpiPort']['isOnline']={syn:'Checks if the SPI port is currently reachable, without raising any error.',lib:'spiport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the SPI port is currently reachable, without raising any error. If there is a cached value for the SPI port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the SPI port.</p>',ret:'<tt>true</tt> if the SPI port can be reached, and <tt>false</tt> otherwise'};
doc['SpiPort']['load']={syn:'Preloads the SPI port cache with a specified validity duration.',lib:'spiport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the SPI port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'spiport.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SpiPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'spiport.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['nextSpiPort']={syn:'Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>.',lib:'spiport.nextSpiPort()',pro:'def nextSpiPort()',cmt:'<p>Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>. Caution: You can\x27t make any assumption about the returned SPI ports order. If you want to find a specific a SPI port, use <tt>SpiPort.findSpiPort()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to a SPI port currently online, or a <tt>null</tt> pointer if there are no more SPI ports to enumerate.'};
doc['SpiPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'spiport.queryLine()',pro:'def queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SpiPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'spiport.readArray()',pro:'def readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'spiport.readBin()',pro:'def readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'spiport.readByte()',pro:'def readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'spiport.readHex()',pro:'def readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'spiport.readLine()',pro:'def readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'spiport.readMessages()',pro:'def readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SpiPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'spiport.readStr()',pro:'def readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'spiport.read_avail()',pro:'def read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SpiPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'spiport.read_seek()',pro:'def read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SpiPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'spiport.read_tell()',pro:'def read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SpiPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'spiport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SpiPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'spiport.reset()',pro:'def reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'spiport.selectJob()',pro:'def selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_SS']={syn:'Manually sets the state of the SS line.',lib:'spiport.set_SS()',pro:'def set_SS(<span id=pn>val</span>)',cmt:'<p>Manually sets the state of the SS line. This function has no effect when the SS line is handled automatically.</p>',par:{val:'1 to turn SS active, 0 to release SS.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'spiport.set_currentJob()',pro:'def set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_logicalName']={syn:'Changes the logical name of the SPI port.',lib:'spiport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the SPI port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the SPI port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'spiport.set_protocol()',pro:'def set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_shiftSampling']={syn:'Changes the SDI line sampling shift.',lib:'spiport.set_shiftSampling()',pro:'def set_shiftSampling(<span id=pn>newval</span>)',cmt:'<p>Changes the SDI line sampling shift. When disabled, SDI line is sampled in the middle of data output time. When enabled, SDI line is samples at the end of data output time.</p>',par:{newval:'either <tt>Y_SHIFTSAMPLING_OFF</tt> or <tt>Y_SHIFTSAMPLING_ON</tt>, according to the SDI line sampling shift'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_spiMode']={syn:'Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22.',lib:'spiport.set_spiMode()',pro:'def set_spiMode(<span id=pn>newval</span>)',cmt:'<p>Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',par:{newval:'a string corresponding to the SPI port communication parameters, with a string such as \x22125000,0,msb\x22'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_ssPolarity']={syn:'Changes the SS line polarity.',lib:'spiport.set_ssPolarity()',pro:'def set_ssPolarity(<span id=pn>newval</span>)',cmt:'<p>Changes the SS line polarity.</p>',par:{newval:'either <tt>Y_SSPOLARITY_ACTIVE_LOW</tt> or <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'spiport.set_startupJob()',pro:'def set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'spiport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SpiPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'spiport.set_voltageLevel()',pro:'def set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'spiport.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'spiport.uploadJob()',pro:'def uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'spiport.writeArray()',pro:'def writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'spiport.writeBin()',pro:'def writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'spiport.writeByte()',pro:'def writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'spiport.writeHex()',pro:'def writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'spiport.writeLine()',pro:'def writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'spiport.writeStr()',pro:'def writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SpiPort)
//--- (generated code: MessageBox)
doc['MessageBox']={'':{syn:'MessageBox function interface',inc:'from yocto_messagebox import *',cmt:'<p>YMessageBox functions provides SMS sending and receiving capability to GSM-enabled Yoctopuce devices.</p>'}};
doc['MessageBox']['FindMessageBox']={syn:'Retrieves a MessageBox interface for a given identifier.',lib:'YMessageBox.FindMessageBox()',pro:'def FindMessageBox(<span id=pn>func</span>)',cmt:'<p>Retrieves a MessageBox interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the MessageBox interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMessageBox.isOnline()</tt> to test if the MessageBox interface is indeed online at a given time. In case of ambiguity when looking for a MessageBox interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the MessageBox interface'},ret:'a <tt>YMessageBox</tt> object allowing you to drive the MessageBox interface.'};
doc['MessageBox']['FirstMessageBox']={syn:'Starts the enumeration of MessageBox interfaces currently accessible.',lib:'YMessageBox.FirstMessageBox()',pro:'def FirstMessageBox()',cmt:'<p>Starts the enumeration of MessageBox interfaces currently accessible. Use the method <tt>YMessageBox.nextMessageBox()</tt> to iterate on next MessageBox interfaces.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to the first MessageBox interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MessageBox']['clearCache']={syn:'Invalidates the cache.',lib:'messagebox.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the MessageBox interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MessageBox']['clearPduCounters']={syn:'Clear the SMS units counters.',lib:'messagebox.clearPduCounters()',pro:'def clearPduCounters()',cmt:'<p>Clear the SMS units counters.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['describe']={syn:'Returns a short text that describes unambiguously the instance of the MessageBox interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'messagebox.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the MessageBox interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the MessageBox interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MessageBox']['get_advertisedValue']={syn:'Returns the current value of the MessageBox interface (no more than 6 characters).',lib:'messagebox.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the MessageBox interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the MessageBox interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MessageBox']['get_errorMessage']={syn:'Returns the error message of the latest error with the MessageBox interface.',lib:'messagebox.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the MessageBox interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the MessageBox interface object'};
doc['MessageBox']['get_errorType']={syn:'Returns the numerical error code of the latest error with the MessageBox interface.',lib:'messagebox.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the MessageBox interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the MessageBox interface object'};
doc['MessageBox']['get_friendlyName']={syn:'Returns a global identifier of the MessageBox interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'messagebox.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the MessageBox interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the MessageBox interface if they are defined, otherwise the serial number of the module and the hardware identifier of the MessageBox interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the MessageBox interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MessageBox']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'messagebox.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MessageBox']['get_functionId']={syn:'Returns the hardware identifier of the MessageBox interface, without reference to the module.',lib:'messagebox.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the MessageBox interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the MessageBox interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MessageBox']['get_hardwareId']={syn:'Returns the unique hardware identifier of the MessageBox interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'messagebox.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the MessageBox interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the MessageBox interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the MessageBox interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MessageBox']['get_logicalName']={syn:'Returns the logical name of the MessageBox interface.',lib:'messagebox.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the MessageBox interface.</p>',ret:'a string corresponding to the logical name of the MessageBox interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MessageBox']['get_messages']={syn:'Returns the list of messages received and not deleted.',lib:'messagebox.get_messages()',pro:'def get_messages()',cmt:'<p>Returns the list of messages received and not deleted. This function will automatically decode concatenated SMS.</p>',ret:'an YSms object list.',ext:'On failure, throws an exception or returns an empty list.'};
doc['MessageBox']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'messagebox.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MessageBox']['get_pduReceived']={syn:'Returns the number of SMS units received so far.',lib:'messagebox.get_pduReceived()',pro:'def get_pduReceived()',cmt:'<p>Returns the number of SMS units received so far.</p>',ret:'an integer corresponding to the number of SMS units received so far',ext:'On failure, throws an exception or returns <tt>Y_PDURECEIVED_INVALID</tt>.'};
doc['MessageBox']['get_pduSent']={syn:'Returns the number of SMS units sent so far.',lib:'messagebox.get_pduSent()',pro:'def get_pduSent()',cmt:'<p>Returns the number of SMS units sent so far.</p>',ret:'an integer corresponding to the number of SMS units sent so far',ext:'On failure, throws an exception or returns <tt>Y_PDUSENT_INVALID</tt>.'};
doc['MessageBox']['get_slotsCount']={syn:'Returns the total number of message storage slots on the SIM card.',lib:'messagebox.get_slotsCount()',pro:'def get_slotsCount()',cmt:'<p>Returns the total number of message storage slots on the SIM card.</p>',ret:'an integer corresponding to the total number of message storage slots on the SIM card',ext:'On failure, throws an exception or returns <tt>Y_SLOTSCOUNT_INVALID</tt>.'};
doc['MessageBox']['get_slotsInUse']={syn:'Returns the number of message storage slots currently in use.',lib:'messagebox.get_slotsInUse()',pro:'def get_slotsInUse()',cmt:'<p>Returns the number of message storage slots currently in use.</p>',ret:'an integer corresponding to the number of message storage slots currently in use',ext:'On failure, throws an exception or returns <tt>Y_SLOTSINUSE_INVALID</tt>.'};
doc['MessageBox']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'messagebox.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MessageBox']['isOnline']={syn:'Checks if the MessageBox interface is currently reachable, without raising any error.',lib:'messagebox.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the MessageBox interface is currently reachable, without raising any error. If there is a cached value for the MessageBox interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the MessageBox interface.</p>',ret:'<tt>true</tt> if the MessageBox interface can be reached, and <tt>false</tt> otherwise'};
doc['MessageBox']['load']={syn:'Preloads the MessageBox interface cache with a specified validity duration.',lib:'messagebox.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the MessageBox interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'messagebox.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MessageBox']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'messagebox.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['newMessage']={syn:'Creates a new empty SMS message, to be configured and sent later on.',lib:'messagebox.newMessage()',pro:'def newMessage(<span id=pn>recipient</span>)',cmt:'<p>Creates a new empty SMS message, to be configured and sent later on.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['nextMessageBox']={syn:'Continues the enumeration of MessageBox interfaces started using <tt>yFirstMessageBox()</tt>.',lib:'messagebox.nextMessageBox()',pro:'def nextMessageBox()',cmt:'<p>Continues the enumeration of MessageBox interfaces started using <tt>yFirstMessageBox()</tt>. Caution: You can\x27t make any assumption about the returned MessageBox interfaces order. If you want to find a specific a MessageBox interface, use <tt>MessageBox.findMessageBox()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to a MessageBox interface currently online, or a <tt>null</tt> pointer if there are no more MessageBox interfaces to enumerate.'};
doc['MessageBox']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'messagebox.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MessageBox']['sendFlashMessage']={syn:'Sends a Flash SMS (class 0 message).',lib:'messagebox.sendFlashMessage()',pro:'def sendFlashMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset immediately and are usually not saved on the SIM card. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['sendTextMessage']={syn:'Sends a regular text SMS, with standard parameters.',lib:'messagebox.sendTextMessage()',pro:'def sendTextMessage(<span id=pn>recipient</span>, <span id=pn>message</span>)',cmt:'<p>Sends a regular text SMS, with standard parameters. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> and <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_logicalName']={syn:'Changes the logical name of the MessageBox interface.',lib:'messagebox.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the MessageBox interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the MessageBox interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_pduReceived']={syn:'Changes the value of the incoming SMS units counter.',lib:'messagebox.set_pduReceived()',pro:'def set_pduReceived(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the incoming SMS units counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_pduSent']={syn:'Changes the value of the outgoing SMS units counter.',lib:'messagebox.set_pduSent()',pro:'def set_pduSent(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing SMS units counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'messagebox.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MessageBox']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'messagebox.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MessageBox)
//--- (generated code: StepperMotor)
doc['StepperMotor']={'':{syn:'StepperMotor function interface',inc:'from yocto_steppermotor import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['StepperMotor']['FindStepperMotor']={syn:'Retrieves a stepper motor for a given identifier.',lib:'YStepperMotor.FindStepperMotor()',pro:'def FindStepperMotor(<span id=pn>func</span>)',cmt:'<p>Retrieves a stepper motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the stepper motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YStepperMotor.isOnline()</tt> to test if the stepper motor is indeed online at a given time. In case of ambiguity when looking for a stepper motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the stepper motor'},ret:'a <tt>YStepperMotor</tt> object allowing you to drive the stepper motor.'};
doc['StepperMotor']['FirstStepperMotor']={syn:'Starts the enumeration of stepper motors currently accessible.',lib:'YStepperMotor.FirstStepperMotor()',pro:'def FirstStepperMotor()',cmt:'<p>Starts the enumeration of stepper motors currently accessible. Use the method <tt>YStepperMotor.nextStepperMotor()</tt> to iterate on next stepper motors.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to the first stepper motor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['StepperMotor']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'steppermotor.abortAndBrake()',pro:'def abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'steppermotor.abortAndHiZ()',pro:'def abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepDir']={syn:'Move one single step in the selected direction without regards to end switches.',lib:'steppermotor.alertStepDir()',pro:'def alertStepDir(<span id=pn>dir</span>)',cmt:'<p>Move one single step in the selected direction without regards to end switches. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',par:{dir:'Value +1 or -1, according to the desired direction of the move'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepOut']={syn:'Move one step in the direction opposite the direction set when the most recent alert was raised.',lib:'steppermotor.alertStepOut()',pro:'def alertStepOut()',cmt:'<p>Move one step in the direction opposite the direction set when the most recent alert was raised. The move occurs even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['changeSpeed']={syn:'Starts the motor at a given speed.',lib:'steppermotor.changeSpeed()',pro:'def changeSpeed(<span id=pn>speed</span>)',cmt:'<p>Starts the motor at a given speed. The time needed to reach the requested speed will depend on the acceleration parameters configured for the motor.</p>',par:{speed:'desired speed, in steps per second. The minimal non-zero speed is 0.001 pulse per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['clearCache']={syn:'Invalidates the cache.',lib:'steppermotor.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the stepper motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['StepperMotor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'steppermotor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the stepper motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['StepperMotor']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'steppermotor.emergencyStop()',pro:'def emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['findHomePosition']={syn:'Starts the motor backward at the specified speed, to search for the motor home position.',lib:'steppermotor.findHomePosition()',pro:'def findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Starts the motor backward at the specified speed, to search for the motor home position.</p>',par:{speed:'desired speed, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['get_advertisedValue']={syn:'Returns the current value of the stepper motor (no more than 6 characters).',lib:'steppermotor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the stepper motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the stepper motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['StepperMotor']['get_auxSignal']={syn:'Returns the current value of the signal generated on the auxiliary output.',lib:'steppermotor.get_auxSignal()',pro:'def get_auxSignal()',cmt:'<p>Returns the current value of the signal generated on the auxiliary output.</p>',ret:'an integer corresponding to the current value of the signal generated on the auxiliary output',ext:'On failure, throws an exception or returns <tt>Y_AUXSIGNAL_INVALID</tt>.'};
doc['StepperMotor']['get_diags']={syn:'Returns the stepper motor controller diagnostics, as a bitmap.',lib:'steppermotor.get_diags()',pro:'def get_diags()',cmt:'<p>Returns the stepper motor controller diagnostics, as a bitmap.</p>',ret:'an integer corresponding to the stepper motor controller diagnostics, as a bitmap',ext:'On failure, throws an exception or returns <tt>Y_DIAGS_INVALID</tt>.'};
doc['StepperMotor']['get_errorMessage']={syn:'Returns the error message of the latest error with the stepper motor.',lib:'steppermotor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the stepper motor object'};
doc['StepperMotor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the stepper motor.',lib:'steppermotor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the stepper motor object'};
doc['StepperMotor']['get_friendlyName']={syn:'Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'steppermotor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the stepper motor if they are defined, otherwise the serial number of the module and the hardware identifier of the stepper motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the stepper motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['StepperMotor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'steppermotor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['StepperMotor']['get_functionId']={syn:'Returns the hardware identifier of the stepper motor, without reference to the module.',lib:'steppermotor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the stepper motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the stepper motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['StepperMotor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'steppermotor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the stepper motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the stepper motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['StepperMotor']['get_logicalName']={syn:'Returns the logical name of the stepper motor.',lib:'steppermotor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the stepper motor.</p>',ret:'a string corresponding to the logical name of the stepper motor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['StepperMotor']['get_maxAccel']={syn:'Returns the maximal motor acceleration, measured in steps per second^2.',lib:'steppermotor.get_maxAccel()',pro:'def get_maxAccel()',cmt:'<p>Returns the maximal motor acceleration, measured in steps per second^2.</p>',ret:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2',ext:'On failure, throws an exception or returns <tt>Y_MAXACCEL_INVALID</tt>.'};
doc['StepperMotor']['get_maxSpeed']={syn:'Returns the maximal motor speed, measured in steps per second.',lib:'steppermotor.get_maxSpeed()',pro:'def get_maxSpeed()',cmt:'<p>Returns the maximal motor speed, measured in steps per second.</p>',ret:'a floating point number corresponding to the maximal motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_MAXSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'steppermotor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['StepperMotor']['get_motorState']={syn:'Returns the motor working state.',lib:'steppermotor.get_motorState()',pro:'def get_motorState()',cmt:'<p>Returns the motor working state.</p>',ret:'a value among <tt>Y_MOTORSTATE_ABSENT</tt>, <tt>Y_MOTORSTATE_ALERT</tt>, <tt>Y_MOTORSTATE_HI_Z</tt>, <tt>Y_MOTORSTATE_STOP</tt>, <tt>Y_MOTORSTATE_RUN</tt> and <tt>Y_MOTORSTATE_BATCH</tt> corresponding to the motor working state',ext:'On failure, throws an exception or returns <tt>Y_MOTORSTATE_INVALID</tt>.'};
doc['StepperMotor']['get_overcurrent']={syn:'Returns the overcurrent alert and emergency stop threshold, measured in mA.',lib:'steppermotor.get_overcurrent()',pro:'def get_overcurrent()',cmt:'<p>Returns the overcurrent alert and emergency stop threshold, measured in mA.</p>',ret:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['StepperMotor']['get_pullinSpeed']={syn:'Returns the motor speed immediately reachable from stop state, measured in steps per second.',lib:'steppermotor.get_pullinSpeed()',pro:'def get_pullinSpeed()',cmt:'<p>Returns the motor speed immediately reachable from stop state, measured in steps per second.</p>',ret:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_PULLINSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_speed']={syn:'Returns current motor speed, measured in steps per second.',lib:'steppermotor.get_speed()',pro:'def get_speed()',cmt:'<p>Returns current motor speed, measured in steps per second. To change speed, use method <tt>changeSpeed()</tt>.</p>',ret:'a floating point number corresponding to current motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_SPEED_INVALID</tt>.'};
doc['StepperMotor']['get_stepPos']={syn:'Returns the current logical motor position, measured in steps.',lib:'steppermotor.get_stepPos()',pro:'def get_stepPos()',cmt:'<p>Returns the current logical motor position, measured in steps. The value may include a fractional part when micro-stepping is in use.</p>',ret:'a floating point number corresponding to the current logical motor position, measured in steps',ext:'On failure, throws an exception or returns <tt>Y_STEPPOS_INVALID</tt>.'};
doc['StepperMotor']['get_stepping']={syn:'Returns the stepping mode used to drive the motor.',lib:'steppermotor.get_stepping()',pro:'def get_stepping()',cmt:'<p>Returns the stepping mode used to drive the motor.</p>',ret:'a value among <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> and <tt>Y_STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor',ext:'On failure, throws an exception or returns <tt>Y_STEPPING_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrRun']={syn:'Returns the torque regulation current when the motor is running, measured in mA.',lib:'steppermotor.get_tCurrRun()',pro:'def get_tCurrRun()',cmt:'<p>Returns the torque regulation current when the motor is running, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is running, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_TCURRRUN_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrStop']={syn:'Returns the torque regulation current when the motor is stopped, measured in mA.',lib:'steppermotor.get_tCurrStop()',pro:'def get_tCurrStop()',cmt:'<p>Returns the torque regulation current when the motor is stopped, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_TCURRSTOP_INVALID</tt>.'};
doc['StepperMotor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'steppermotor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['StepperMotor']['isOnline']={syn:'Checks if the stepper motor is currently reachable, without raising any error.',lib:'steppermotor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the stepper motor is currently reachable, without raising any error. If there is a cached value for the stepper motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the stepper motor.</p>',ret:'<tt>true</tt> if the stepper motor can be reached, and <tt>false</tt> otherwise'};
doc['StepperMotor']['load']={syn:'Preloads the stepper motor cache with a specified validity duration.',lib:'steppermotor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the stepper motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'steppermotor.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['StepperMotor']['moveRel']={syn:'Starts the motor to reach a given relative position.',lib:'steppermotor.moveRel()',pro:'def moveRel(<span id=pn>relPos</span>)',cmt:'<p>Starts the motor to reach a given relative position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveRelSlow']={syn:'Starts the motor to reach a given relative position, keeping the speed under the specified limit.',lib:'steppermotor.moveRelSlow()',pro:'def moveRelSlow(<span id=pn>relPos</span>, <span id=pn>maxSpeed</span>)',cmt:'<p>Starts the motor to reach a given relative position, keeping the speed under the specified limit. The time needed to reach the requested position will depend on the acceleration parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.',maxSpeed:'limit speed, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveTo']={syn:'Starts the motor to reach a given absolute position.',lib:'steppermotor.moveTo()',pro:'def moveTo(<span id=pn>absPos</span>)',cmt:'<p>Starts the motor to reach a given absolute position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{absPos:'absolute position, measured in steps from the origin.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'steppermotor.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['nextStepperMotor']={syn:'Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>.',lib:'steppermotor.nextStepperMotor()',pro:'def nextStepperMotor()',cmt:'<p>Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>. Caution: You can\x27t make any assumption about the returned stepper motors order. If you want to find a specific a stepper motor, use <tt>StepperMotor.findStepperMotor()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to a stepper motor currently online, or a <tt>null</tt> pointer if there are no more stepper motors to enumerate.'};
doc['StepperMotor']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'steppermotor.pause()',pro:'def pause(<span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'steppermotor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['StepperMotor']['reset']={syn:'Reinitialize the controller and clear all alert flags.',lib:'steppermotor.reset()',pro:'def reset()',cmt:'<p>Reinitialize the controller and clear all alert flags.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_auxSignal']={syn:'Changes the value of the signal generated on the auxiliary output.',lib:'steppermotor.set_auxSignal()',pro:'def set_auxSignal(<span id=pn>newval</span>)',cmt:'<p>Changes the value of the signal generated on the auxiliary output. Acceptable values depend on the auxiliary output signal type configured.</p>',par:{newval:'an integer corresponding to the value of the signal generated on the auxiliary output'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_logicalName']={syn:'Changes the logical name of the stepper motor.',lib:'steppermotor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the stepper motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the stepper motor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_maxAccel']={syn:'Changes the maximal motor acceleration, measured in steps per second^2.',lib:'steppermotor.set_maxAccel()',pro:'def set_maxAccel(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor acceleration, measured in steps per second^2.</p>',par:{newval:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_maxSpeed']={syn:'Changes the maximal motor speed, measured in steps per second.',lib:'steppermotor.set_maxSpeed()',pro:'def set_maxSpeed(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor speed, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the maximal motor speed, measured in steps per second'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_overcurrent']={syn:'Changes the overcurrent alert and emergency stop threshold, measured in mA.',lib:'steppermotor.set_overcurrent()',pro:'def set_overcurrent(<span id=pn>newval</span>)',cmt:'<p>Changes the overcurrent alert and emergency stop threshold, measured in mA.</p>',par:{newval:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_pullinSpeed']={syn:'Changes the motor speed immediately reachable from stop state, measured in steps per second.',lib:'steppermotor.set_pullinSpeed()',pro:'def set_pullinSpeed(<span id=pn>newval</span>)',cmt:'<p>Changes the motor speed immediately reachable from stop state, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_stepPos']={syn:'Changes the current logical motor position, measured in steps.',lib:'steppermotor.set_stepPos()',pro:'def set_stepPos(<span id=pn>newval</span>)',cmt:'<p>Changes the current logical motor position, measured in steps. This command does not cause any motor move, as its purpose is only to setup the origin of the position counter. The fractional part of the position, that corresponds to the physical position of the rotor, is not changed. To trigger a motor move, use methods <tt>moveTo()</tt> or <tt>moveRel()</tt> instead.</p>',par:{newval:'a floating point number corresponding to the current logical motor position, measured in steps'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_stepping']={syn:'Changes the stepping mode used to drive the motor.',lib:'steppermotor.set_stepping()',pro:'def set_stepping(<span id=pn>newval</span>)',cmt:'<p>Changes the stepping mode used to drive the motor.</p>',par:{newval:'a value among <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> and <tt>Y_STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_tCurrRun']={syn:'Changes the torque regulation current when the motor is running, measured in mA.',lib:'steppermotor.set_tCurrRun()',pro:'def set_tCurrRun(<span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is running, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is running, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_tCurrStop']={syn:'Changes the torque regulation current when the motor is stopped, measured in mA.',lib:'steppermotor.set_tCurrStop()',pro:'def set_tCurrStop(<span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is stopped, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'steppermotor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['StepperMotor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'steppermotor.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: StepperMotor)
//--- (generated code: Proximity)
doc['Proximity']={'':{syn:'Proximity function interface',inc:'from yocto_proximity import *',cmt:'<p>The Yoctopuce class YProximity allows you to use and configure Yoctopuce proximity sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['Proximity']['FindProximity']={syn:'Retrieves a proximity sensor for a given identifier.',lib:'YProximity.FindProximity()',pro:'def FindProximity(<span id=pn>func</span>)',cmt:'<p>Retrieves a proximity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the proximity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YProximity.isOnline()</tt> to test if the proximity sensor is indeed online at a given time. In case of ambiguity when looking for a proximity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the proximity sensor'},ret:'a <tt>YProximity</tt> object allowing you to drive the proximity sensor.'};
doc['Proximity']['FirstProximity']={syn:'Starts the enumeration of proximity sensors currently accessible.',lib:'YProximity.FirstProximity()',pro:'def FirstProximity()',cmt:'<p>Starts the enumeration of proximity sensors currently accessible. Use the method <tt>YProximity.nextProximity()</tt> to iterate on next proximity sensors.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to the first proximity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Proximity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'proximity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['clearCache']={syn:'Invalidates the cache.',lib:'proximity.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the proximity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Proximity']['describe']={syn:'Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'proximity.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the proximity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Proximity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'proximity.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Proximity']['get_advertisedValue']={syn:'Returns the current value of the proximity sensor (no more than 6 characters).',lib:'proximity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the proximity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the proximity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'proximity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentValue']={syn:'Returns the current value of the proximity detection, in the specified unit, as a floating point number.',lib:'proximity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the proximity detection, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the proximity detection, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Proximity']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'proximity.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Proximity']['get_detectionHysteresis']={syn:'Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity.get_detectionHysteresis()',pro:'def get_detectionHysteresis()',cmt:'<p>Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>Y_DETECTIONHYSTERESIS_INVALID</tt>.'};
doc['Proximity']['get_detectionThreshold']={syn:'Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity.get_detectionThreshold()',pro:'def get_detectionThreshold()',cmt:'<p>Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>Y_DETECTIONTHRESHOLD_INVALID</tt>.'};
doc['Proximity']['get_errorMessage']={syn:'Returns the error message of the latest error with the proximity sensor.',lib:'proximity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the proximity sensor object'};
doc['Proximity']['get_errorType']={syn:'Returns the numerical error code of the latest error with the proximity sensor.',lib:'proximity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the proximity sensor object'};
doc['Proximity']['get_friendlyName']={syn:'Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'proximity.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the proximity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the proximity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the proximity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Proximity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'proximity.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Proximity']['get_functionId']={syn:'Returns the hardware identifier of the proximity sensor, without reference to the module.',lib:'proximity.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the proximity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the proximity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Proximity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'proximity.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the proximity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the proximity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Proximity']['get_highestValue']={syn:'Returns the maximal value observed for the proximity detection since the device was started.',lib:'proximity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_isPresent']={syn:'Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.',lib:'proximity.get_isPresent()',pro:'def get_isPresent()',cmt:'<p>Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.</p>',ret:'either <tt>Y_ISPRESENT_FALSE</tt> or <tt>Y_ISPRESENT_TRUE</tt>, according to true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESENT_INVALID</tt>.'};
doc['Proximity']['get_lastTimeApproached']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).',lib:'proximity.get_lastTimeApproached()',pro:'def get_lastTimeApproached()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEAPPROACHED_INVALID</tt>.'};
doc['Proximity']['get_lastTimeRemoved']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).',lib:'proximity.get_lastTimeRemoved()',pro:'def get_lastTimeRemoved()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEREMOVED_INVALID</tt>.'};
doc['Proximity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'proximity.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_logicalName']={syn:'Returns the logical name of the proximity sensor.',lib:'proximity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the proximity sensor.</p>',ret:'a string corresponding to the logical name of the proximity sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Proximity']['get_lowestValue']={syn:'Returns the minimal value observed for the proximity detection since the device was started.',lib:'proximity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'proximity.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Proximity']['get_presenceMinTime']={syn:'Returns the minimal detection duration before signalling a presence event.',lib:'proximity.get_presenceMinTime()',pro:'def get_presenceMinTime()',cmt:'<p>Returns the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a presence event',ext:'On failure, throws an exception or returns <tt>Y_PRESENCEMINTIME_INVALID</tt>.'};
doc['Proximity']['get_proximityReportMode']={syn:'Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'proximity.get_proximityReportMode()',pro:'def get_proximityReportMode()',cmt:'<p>Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.</p>',ret:'a value among <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>Y_PROXIMITYREPORTMODE_INVALID</tt>.'};
doc['Proximity']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'proximity.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['Proximity']['get_pulseTimer']={syn:'Returns the timer of the pulse counter (ms).',lib:'proximity.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulse counter (ms).</p>',ret:'an integer corresponding to the timer of the pulse counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Proximity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'proximity.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Proximity']['get_removalMinTime']={syn:'Returns the minimal detection duration before signalling a removal event.',lib:'proximity.get_removalMinTime()',pro:'def get_removalMinTime()',cmt:'<p>Returns the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signalling a removal event',ext:'On failure, throws an exception or returns <tt>Y_REMOVALMINTIME_INVALID</tt>.'};
doc['Proximity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'proximity.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'proximity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Proximity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'proximity.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Proximity']['get_signalValue']={syn:'Returns the current value of signal measured by the proximity sensor.',lib:'proximity.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Returns the current value of signal measured by the proximity sensor.</p>',ret:'a floating point number corresponding to the current value of signal measured by the proximity sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Proximity']['get_unit']={syn:'Returns the measuring unit for the proximity detection.',lib:'proximity.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the proximity detection.</p>',ret:'a string corresponding to the measuring unit for the proximity detection',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Proximity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'proximity.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Proximity']['isOnline']={syn:'Checks if the proximity sensor is currently reachable, without raising any error.',lib:'proximity.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the proximity sensor is currently reachable, without raising any error. If there is a cached value for the proximity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the proximity sensor.</p>',ret:'<tt>true</tt> if the proximity sensor can be reached, and <tt>false</tt> otherwise'};
doc['Proximity']['load']={syn:'Preloads the proximity sensor cache with a specified validity duration.',lib:'proximity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the proximity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'proximity.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Proximity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'proximity.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'proximity.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['nextProximity']={syn:'Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>.',lib:'proximity.nextProximity()',pro:'def nextProximity()',cmt:'<p>Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>. Caution: You can\x27t make any assumption about the returned proximity sensors order. If you want to find a specific a proximity sensor, use <tt>Proximity.findProximity()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to a proximity sensor currently online, or a <tt>null</tt> pointer if there are no more proximity sensors to enumerate.'};
doc['Proximity']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'proximity.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Proximity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'proximity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Proximity']['resetCounter']={syn:'Resets the pulse counter value as well as its timer.',lib:'proximity.resetCounter()',pro:'def resetCounter()',cmt:'<p>Resets the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'proximity.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_detectionHysteresis']={syn:'Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity.set_detectionHysteresis()',pro:'def set_detectionHysteresis(<span id=pn>newval</span>)',cmt:'<p>Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_detectionThreshold']={syn:'Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity.set_detectionThreshold()',pro:'def set_detectionThreshold(<span id=pn>newval</span>)',cmt:'<p>Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'proximity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'proximity.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_logicalName']={syn:'Changes the logical name of the proximity sensor.',lib:'proximity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the proximity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the proximity sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'proximity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_presenceMinTime']={syn:'Changes the minimal detection duration before signalling a presence event.',lib:'proximity.set_presenceMinTime()',pro:'def set_presenceMinTime(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signalling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a presence event'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_proximityReportMode']={syn:'Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'proximity.set_proximityReportMode()',pro:'def set_proximityReportMode(<span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_removalMinTime']={syn:'Changes the minimal detection duration before signalling a removal event.',lib:'proximity.set_removalMinTime()',pro:'def set_removalMinTime(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signalling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signalling a removal event'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'proximity.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'proximity.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'proximity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Proximity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'proximity.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Proximity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'proximity.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Proximity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'proximity.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Proximity)
//--- (generated code: MultiAxisController)
doc['MultiAxisController']={'':{syn:'MultiAxisController function interface',inc:'from yocto_multiaxiscontroller import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiAxisController']['FindMultiAxisController']={syn:'Retrieves a multi-axis controller for a given identifier.',lib:'YMultiAxisController.FindMultiAxisController()',pro:'def FindMultiAxisController(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-axis controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-axis controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiAxisController.isOnline()</tt> to test if the multi-axis controller is indeed online at a given time. In case of ambiguity when looking for a multi-axis controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-axis controller'},ret:'a <tt>YMultiAxisController</tt> object allowing you to drive the multi-axis controller.'};
doc['MultiAxisController']['FirstMultiAxisController']={syn:'Starts the enumeration of multi-axis controllers currently accessible.',lib:'YMultiAxisController.FirstMultiAxisController()',pro:'def FirstMultiAxisController()',cmt:'<p>Starts the enumeration of multi-axis controllers currently accessible. Use the method <tt>YMultiAxisController.nextMultiAxisController()</tt> to iterate on next multi-axis controllers.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to the first multi-axis controller currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiAxisController']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'multiaxiscontroller.abortAndBrake()',pro:'def abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'multiaxiscontroller.abortAndHiZ()',pro:'def abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['clearCache']={syn:'Invalidates the cache.',lib:'multiaxiscontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-axis controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiAxisController']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multiaxiscontroller.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-axis controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiAxisController']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'multiaxiscontroller.emergencyStop()',pro:'def emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['findHomePosition']={syn:'Starts all motors backward at the specified speeds, to search for the motor home position.',lib:'multiaxiscontroller.findHomePosition()',pro:'def findHomePosition(<span id=pn>speed</span>)',cmt:'<p>Starts all motors backward at the specified speeds, to search for the motor home position.</p>',par:{speed:'desired speed for all axis, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['get_advertisedValue']={syn:'Returns the current value of the multi-axis controller (no more than 6 characters).',lib:'multiaxiscontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the multi-axis controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-axis controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiAxisController']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-axis controller.',lib:'multiaxiscontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-axis controller object'};
doc['MultiAxisController']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-axis controller.',lib:'multiaxiscontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-axis controller object'};
doc['MultiAxisController']['get_friendlyName']={syn:'Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multiaxiscontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-axis controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-axis controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-axis controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multiaxiscontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiAxisController']['get_functionId']={syn:'Returns the hardware identifier of the multi-axis controller, without reference to the module.',lib:'multiaxiscontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-axis controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-axis controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiAxisController']['get_globalState']={syn:'Returns the stepper motor set overall state.',lib:'multiaxiscontroller.get_globalState()',pro:'def get_globalState()',cmt:'<p>Returns the stepper motor set overall state.</p>',ret:'a value among <tt>Y_GLOBALSTATE_ABSENT</tt>, <tt>Y_GLOBALSTATE_ALERT</tt>, <tt>Y_GLOBALSTATE_HI_Z</tt>, <tt>Y_GLOBALSTATE_STOP</tt>, <tt>Y_GLOBALSTATE_RUN</tt> and <tt>Y_GLOBALSTATE_BATCH</tt> corresponding to the stepper motor set overall state',ext:'On failure, throws an exception or returns <tt>Y_GLOBALSTATE_INVALID</tt>.'};
doc['MultiAxisController']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multiaxiscontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-axis controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-axis controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiAxisController']['get_logicalName']={syn:'Returns the logical name of the multi-axis controller.',lib:'multiaxiscontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the multi-axis controller.</p>',ret:'a string corresponding to the logical name of the multi-axis controller.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multiaxiscontroller.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiAxisController']['get_nAxis']={syn:'Returns the number of synchronized controllers.',lib:'multiaxiscontroller.get_nAxis()',pro:'def get_nAxis()',cmt:'<p>Returns the number of synchronized controllers.</p>',ret:'an integer corresponding to the number of synchronized controllers',ext:'On failure, throws an exception or returns <tt>Y_NAXIS_INVALID</tt>.'};
doc['MultiAxisController']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multiaxiscontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiAxisController']['isOnline']={syn:'Checks if the multi-axis controller is currently reachable, without raising any error.',lib:'multiaxiscontroller.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the multi-axis controller is currently reachable, without raising any error. If there is a cached value for the multi-axis controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-axis controller.</p>',ret:'<tt>true</tt> if the multi-axis controller can be reached, and <tt>false</tt> otherwise'};
doc['MultiAxisController']['load']={syn:'Preloads the multi-axis controller cache with a specified validity duration.',lib:'multiaxiscontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-axis controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multiaxiscontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiAxisController']['moveRel']={syn:'Starts all motors synchronously to reach a given relative position.',lib:'multiaxiscontroller.moveRel()',pro:'def moveRel(<span id=pn>relPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given relative position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['moveTo']={syn:'Starts all motors synchronously to reach a given absolute position.',lib:'multiaxiscontroller.moveTo()',pro:'def moveTo(<span id=pn>absPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given absolute position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{absPos:'absolute position, measured in steps from each origin.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multiaxiscontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['nextMultiAxisController']={syn:'Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>.',lib:'multiaxiscontroller.nextMultiAxisController()',pro:'def nextMultiAxisController()',cmt:'<p>Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>. Caution: You can\x27t make any assumption about the returned multi-axis controllers order. If you want to find a specific a multi-axis controller, use <tt>MultiAxisController.findMultiAxisController()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to a multi-axis controller currently online, or a <tt>null</tt> pointer if there are no more multi-axis controllers to enumerate.'};
doc['MultiAxisController']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'multiaxiscontroller.pause()',pro:'def pause(<span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multiaxiscontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiAxisController']['reset']={syn:'Reinitialize all controllers and clear all alert flags.',lib:'multiaxiscontroller.reset()',pro:'def reset()',cmt:'<p>Reinitialize all controllers and clear all alert flags.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_logicalName']={syn:'Changes the logical name of the multi-axis controller.',lib:'multiaxiscontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-axis controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-axis controller.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_nAxis']={syn:'Changes the number of synchronized controllers.',lib:'multiaxiscontroller.set_nAxis()',pro:'def set_nAxis(<span id=pn>newval</span>)',cmt:'<p>Changes the number of synchronized controllers.</p>',par:{newval:'an integer corresponding to the number of synchronized controllers'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multiaxiscontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiAxisController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multiaxiscontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiAxisController)
//--- (generated code: RangeFinder)
doc['RangeFinder']={'':{syn:'RangeFinder function interface',inc:'from yocto_rangefinder import *',cmt:'<p>The Yoctopuce class YRangeFinder allows you to use and configure Yoctopuce range finder sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['RangeFinder']['FindRangeFinder']={syn:'Retrieves a range finder for a given identifier.',lib:'YRangeFinder.FindRangeFinder()',pro:'def FindRangeFinder(<span id=pn>func</span>)',cmt:'<p>Retrieves a range finder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the range finder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRangeFinder.isOnline()</tt> to test if the range finder is indeed online at a given time. In case of ambiguity when looking for a range finder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the range finder'},ret:'a <tt>YRangeFinder</tt> object allowing you to drive the range finder.'};
doc['RangeFinder']['FirstRangeFinder']={syn:'Starts the enumeration of range finders currently accessible.',lib:'YRangeFinder.FirstRangeFinder()',pro:'def FirstRangeFinder()',cmt:'<p>Starts the enumeration of range finders currently accessible. Use the method <tt>YRangeFinder.nextRangeFinder()</tt> to iterate on next range finders.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to the first range finder currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RangeFinder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'rangefinder.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['cancelCoverGlassCalibrations']={syn:'Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings.',lib:'rangefinder.cancelCoverGlassCalibrations()',pro:'def cancelCoverGlassCalibrations()',cmt:'<p>Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['clearCache']={syn:'Invalidates the cache.',lib:'rangefinder.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the range finder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RangeFinder']['describe']={syn:'Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'rangefinder.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the range finder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RangeFinder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'rangefinder.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['RangeFinder']['get_advertisedValue']={syn:'Returns the current value of the range finder (no more than 6 characters).',lib:'rangefinder.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the range finder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the range finder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.',lib:'rangefinder.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentTemperature']={syn:'Returns the current sensor temperature, as a floating point number.',lib:'rangefinder.get_currentTemperature()',pro:'def get_currentTemperature()',cmt:'<p>Returns the current sensor temperature, as a floating point number.</p>',ret:'a floating point number corresponding to the current sensor temperature, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTTEMPERATURE_INVALID</tt>.'};
doc['RangeFinder']['get_currentValue']={syn:'Returns the current value of the range measured, in mm, as a floating point number.',lib:'rangefinder.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the range measured, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the range measured, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'rangefinder.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['RangeFinder']['get_errorMessage']={syn:'Returns the error message of the latest error with the range finder.',lib:'rangefinder.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the range finder object'};
doc['RangeFinder']['get_errorType']={syn:'Returns the numerical error code of the latest error with the range finder.',lib:'rangefinder.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the range finder object'};
doc['RangeFinder']['get_friendlyName']={syn:'Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'rangefinder.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the range finder if they are defined, otherwise the serial number of the module and the hardware identifier of the range finder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the range finder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RangeFinder']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'rangefinder.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RangeFinder']['get_functionId']={syn:'Returns the hardware identifier of the range finder, without reference to the module.',lib:'rangefinder.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the range finder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the range finder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RangeFinder']['get_hardwareCalibrationTemperature']={syn:'Returns the temperature at the time when the latest calibration was performed.',lib:'rangefinder.get_hardwareCalibrationTemperature()',pro:'def get_hardwareCalibrationTemperature()',cmt:'<p>Returns the temperature at the time when the latest calibration was performed. This function can be used to determine if a new calibration for ambient temperature is required.</p>',ret:'a temperature, as a floating point number. On failure, throws an exception or return YAPI_INVALID_DOUBLE.'};
doc['RangeFinder']['get_hardwareId']={syn:'Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'rangefinder.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the range finder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the range finder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RangeFinder']['get_highestValue']={syn:'Returns the maximal value observed for the range measured since the device was started.',lib:'rangefinder.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'rangefinder.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_logicalName']={syn:'Returns the logical name of the range finder.',lib:'rangefinder.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the range finder.</p>',ret:'a string corresponding to the logical name of the range finder.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RangeFinder']['get_lowestValue']={syn:'Returns the minimal value observed for the range measured since the device was started.',lib:'rangefinder.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'rangefinder.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RangeFinder']['get_rangeFinderMode']={syn:'Returns the range finder running mode.',lib:'rangefinder.get_rangeFinderMode()',pro:'def get_rangeFinderMode()',cmt:'<p>Returns the range finder running mode. The rangefinder running mode allows you to put priority on precision, speed or maximum range.</p>',ret:'a value among <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the range finder running mode',ext:'On failure, throws an exception or returns <tt>Y_RANGEFINDERMODE_INVALID</tt>.'};
doc['RangeFinder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'rangefinder.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['RangeFinder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'rangefinder.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'rangefinder.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['RangeFinder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'rangefinder.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['RangeFinder']['get_unit']={syn:'Returns the measuring unit for the range measured.',lib:'rangefinder.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the range measured.</p>',ret:'a string corresponding to the measuring unit for the range measured',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['RangeFinder']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'rangefinder.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RangeFinder']['isOnline']={syn:'Checks if the range finder is currently reachable, without raising any error.',lib:'rangefinder.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the range finder is currently reachable, without raising any error. If there is a cached value for the range finder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the range finder.</p>',ret:'<tt>true</tt> if the range finder can be reached, and <tt>false</tt> otherwise'};
doc['RangeFinder']['load']={syn:'Preloads the range finder cache with a specified validity duration.',lib:'rangefinder.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the range finder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'rangefinder.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RangeFinder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'rangefinder.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'rangefinder.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['nextRangeFinder']={syn:'Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>.',lib:'rangefinder.nextRangeFinder()',pro:'def nextRangeFinder()',cmt:'<p>Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>. Caution: You can\x27t make any assumption about the returned range finders order. If you want to find a specific a range finder, use <tt>RangeFinder.findRangeFinder()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to a range finder currently online, or a <tt>null</tt> pointer if there are no more range finders to enumerate.'};
doc['RangeFinder']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'rangefinder.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['RangeFinder']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'rangefinder.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RangeFinder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'rangefinder.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'rangefinder.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'rangefinder.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_logicalName']={syn:'Changes the logical name of the range finder.',lib:'rangefinder.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the range finder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the range finder.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'rangefinder.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_rangeFinderMode']={syn:'Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.',lib:'rangefinder.set_rangeFinderMode()',pro:'def set_rangeFinderMode(<span id=pn>newval</span>)',cmt:'<p>Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.</p>',par:{newval:'a value among <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the rangefinder running mode, allowing you to put priority on precision, speed or maximum range'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'rangefinder.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'rangefinder.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_unit']={syn:'Changes the measuring unit for the measured range.',lib:'rangefinder.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured range. That unit is a string. String value can be <tt>\x22</tt> or <tt>mm</tt>. Any other value is ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the rangeFinder function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured range'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'rangefinder.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RangeFinder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'rangefinder.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['RangeFinder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'rangefinder.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['RangeFinder']['triggerOffsetCalibration']={syn:'Triggers the hardware offset calibration of the distance sensor.',lib:'rangefinder.triggerOffsetCalibration()',pro:'def triggerOffsetCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware offset calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerSpadCalibration']={syn:'Triggers the photon detector hardware calibration.',lib:'rangefinder.triggerSpadCalibration()',pro:'def triggerSpadCalibration()',cmt:'<p>Triggers the photon detector hardware calibration. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerTemperatureCalibration']={syn:'Triggers a sensor calibration according to the current ambient temperature.',lib:'rangefinder.triggerTemperatureCalibration()',pro:'def triggerTemperatureCalibration()',cmt:'<p>Triggers a sensor calibration according to the current ambient temperature. That calibration process needs no physical interaction with the sensor. It is performed automatically at device startup, but it is recommended to start it again when the temperature delta since the latest calibration exceeds 8\xB0C.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerXTalkCalibration']={syn:'Triggers the hardware cross-talk calibration of the distance sensor.',lib:'rangefinder.triggerXTalkCalibration()',pro:'def triggerXTalkCalibration(<span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware cross-talk calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'rangefinder.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RangeFinder)
//--- (generated code: DaisyChain)
doc['DaisyChain']={'':{syn:'DaisyChain function interface',inc:'from yocto_daisychain import *',cmt:'<p>The YDaisyChain interface can be used to verify that devices that are daisy-chained directly from device to device, without a hub, are detected properly.</p>'}};
doc['DaisyChain']['FindDaisyChain']={syn:'Retrieves a module chain for a given identifier.',lib:'YDaisyChain.FindDaisyChain()',pro:'def FindDaisyChain(<span id=pn>func</span>)',cmt:'<p>Retrieves a module chain for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the module chain is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDaisyChain.isOnline()</tt> to test if the module chain is indeed online at a given time. In case of ambiguity when looking for a module chain by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the module chain'},ret:'a <tt>YDaisyChain</tt> object allowing you to drive the module chain.'};
doc['DaisyChain']['FirstDaisyChain']={syn:'Starts the enumeration of module chains currently accessible.',lib:'YDaisyChain.FirstDaisyChain()',pro:'def FirstDaisyChain()',cmt:'<p>Starts the enumeration of module chains currently accessible. Use the method <tt>YDaisyChain.nextDaisyChain()</tt> to iterate on next module chains.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to the first module chain currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DaisyChain']['clearCache']={syn:'Invalidates the cache.',lib:'daisychain.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module chain attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DaisyChain']['describe']={syn:'Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'daisychain.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the module chain (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DaisyChain']['get_advertisedValue']={syn:'Returns the current value of the module chain (no more than 6 characters).',lib:'daisychain.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the module chain (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the module chain (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DaisyChain']['get_childCount']={syn:'Returns the number of child nodes currently detected.',lib:'daisychain.get_childCount()',pro:'def get_childCount()',cmt:'<p>Returns the number of child nodes currently detected.</p>',ret:'an integer corresponding to the number of child nodes currently detected',ext:'On failure, throws an exception or returns <tt>Y_CHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_daisyState']={syn:'Returns the state of the daisy-link between modules.',lib:'daisychain.get_daisyState()',pro:'def get_daisyState()',cmt:'<p>Returns the state of the daisy-link between modules.</p>',ret:'a value among <tt>Y_DAISYSTATE_READY</tt>, <tt>Y_DAISYSTATE_IS_CHILD</tt>, <tt>Y_DAISYSTATE_FIRMWARE_MISMATCH</tt>, <tt>Y_DAISYSTATE_CHILD_MISSING</tt> and <tt>Y_DAISYSTATE_CHILD_LOST</tt> corresponding to the state of the daisy-link between modules',ext:'On failure, throws an exception or returns <tt>Y_DAISYSTATE_INVALID</tt>.'};
doc['DaisyChain']['get_errorMessage']={syn:'Returns the error message of the latest error with the module chain.',lib:'daisychain.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the module chain object'};
doc['DaisyChain']['get_errorType']={syn:'Returns the numerical error code of the latest error with the module chain.',lib:'daisychain.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the module chain object'};
doc['DaisyChain']['get_friendlyName']={syn:'Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'daisychain.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the module chain if they are defined, otherwise the serial number of the module and the hardware identifier of the module chain (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the module chain using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DaisyChain']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'daisychain.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DaisyChain']['get_functionId']={syn:'Returns the hardware identifier of the module chain, without reference to the module.',lib:'daisychain.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the module chain, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the module chain (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DaisyChain']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'daisychain.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the module chain (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the module chain (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DaisyChain']['get_logicalName']={syn:'Returns the logical name of the module chain.',lib:'daisychain.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the module chain.</p>',ret:'a string corresponding to the logical name of the module chain.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DaisyChain']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'daisychain.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DaisyChain']['get_requiredChildCount']={syn:'Returns the number of child nodes expected in normal conditions.',lib:'daisychain.get_requiredChildCount()',pro:'def get_requiredChildCount()',cmt:'<p>Returns the number of child nodes expected in normal conditions.</p>',ret:'an integer corresponding to the number of child nodes expected in normal conditions',ext:'On failure, throws an exception or returns <tt>Y_REQUIREDCHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'daisychain.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DaisyChain']['isOnline']={syn:'Checks if the module chain is currently reachable, without raising any error.',lib:'daisychain.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the module chain is currently reachable, without raising any error. If there is a cached value for the module chain in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the module chain.</p>',ret:'<tt>true</tt> if the module chain can be reached, and <tt>false</tt> otherwise'};
doc['DaisyChain']['load']={syn:'Preloads the module chain cache with a specified validity duration.',lib:'daisychain.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module chain cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'daisychain.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DaisyChain']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'daisychain.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['nextDaisyChain']={syn:'Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>.',lib:'daisychain.nextDaisyChain()',pro:'def nextDaisyChain()',cmt:'<p>Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>. Caution: You can\x27t make any assumption about the returned module chains order. If you want to find a specific a module chain, use <tt>DaisyChain.findDaisyChain()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to a module chain currently online, or a <tt>null</tt> pointer if there are no more module chains to enumerate.'};
doc['DaisyChain']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'daisychain.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DaisyChain']['set_logicalName']={syn:'Changes the logical name of the module chain.',lib:'daisychain.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module chain. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module chain.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['set_requiredChildCount']={syn:'Changes the number of child nodes expected in normal conditions.',lib:'daisychain.set_requiredChildCount()',pro:'def set_requiredChildCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of child nodes expected in normal conditions. If the value is zero, no check is performed. If it is non-zero, the number child nodes is checked on startup and the status will change to error if the count does not match.</p>',par:{newval:'an integer corresponding to the number of child nodes expected in normal conditions'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'daisychain.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DaisyChain']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'daisychain.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DaisyChain)
//--- (generated code: VoltageOutput)
doc['VoltageOutput']={'':{syn:'VoltageOutput function interface',inc:'from yocto_voltageoutput import *',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the voltage output.</p>'}};
doc['VoltageOutput']['FindVoltageOutput']={syn:'Retrieves a voltage output for a given identifier.',lib:'YVoltageOutput.FindVoltageOutput()',pro:'def FindVoltageOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltageOutput.isOnline()</tt> to test if the voltage output is indeed online at a given time. In case of ambiguity when looking for a voltage output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage output'},ret:'a <tt>YVoltageOutput</tt> object allowing you to drive the voltage output.'};
doc['VoltageOutput']['FirstVoltageOutput']={syn:'Starts the enumeration of voltage outputs currently accessible.',lib:'YVoltageOutput.FirstVoltageOutput()',pro:'def FirstVoltageOutput()',cmt:'<p>Starts the enumeration of voltage outputs currently accessible. Use the method <tt>YVoltageOutput.nextVoltageOutput()</tt> to iterate on next voltage outputs.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to the first voltage output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VoltageOutput']['clearCache']={syn:'Invalidates the cache.',lib:'voltageoutput.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['VoltageOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltageoutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VoltageOutput']['get_advertisedValue']={syn:'Returns the current value of the voltage output (no more than 6 characters).',lib:'voltageoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VoltageOutput']['get_currentVoltage']={syn:'Returns the output voltage set point, in V.',lib:'voltageoutput.get_currentVoltage()',pro:'def get_currentVoltage()',cmt:'<p>Returns the output voltage set point, in V.</p>',ret:'a floating point number corresponding to the output voltage set point, in V',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVOLTAGE_INVALID</tt>.'};
doc['VoltageOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage output.',lib:'voltageoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage output object'};
doc['VoltageOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage output.',lib:'voltageoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage output object'};
doc['VoltageOutput']['get_friendlyName']={syn:'Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltageoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage output if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltageoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VoltageOutput']['get_functionId']={syn:'Returns the hardware identifier of the voltage output, without reference to the module.',lib:'voltageoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VoltageOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltageoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VoltageOutput']['get_logicalName']={syn:'Returns the logical name of the voltage output.',lib:'voltageoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage output.</p>',ret:'a string corresponding to the logical name of the voltage output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltageoutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VoltageOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltageoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VoltageOutput']['get_voltageAtStartUp']={syn:'Returns the selected voltage output at device startup, in V.',lib:'voltageoutput.get_voltageAtStartUp()',pro:'def get_voltageAtStartUp()',cmt:'<p>Returns the selected voltage output at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage output at device startup, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['VoltageOutput']['isOnline']={syn:'Checks if the voltage output is currently reachable, without raising any error.',lib:'voltageoutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the voltage output is currently reachable, without raising any error. If there is a cached value for the voltage output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage output.</p>',ret:'<tt>true</tt> if the voltage output can be reached, and <tt>false</tt> otherwise'};
doc['VoltageOutput']['load']={syn:'Preloads the voltage output cache with a specified validity duration.',lib:'voltageoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voltageoutput.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['VoltageOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voltageoutput.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['nextVoltageOutput']={syn:'Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>.',lib:'voltageoutput.nextVoltageOutput()',pro:'def nextVoltageOutput()',cmt:'<p>Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>. Caution: You can\x27t make any assumption about the returned voltage outputs order. If you want to find a specific a voltage output, use <tt>VoltageOutput.findVoltageOutput()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to a voltage output currently online, or a <tt>null</tt> pointer if there are no more voltage outputs to enumerate.'};
doc['VoltageOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltageoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VoltageOutput']['set_currentVoltage']={syn:'Changes the output voltage, in V.',lib:'voltageoutput.set_currentVoltage()',pro:'def set_currentVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the output voltage, in V. Valid range is from 0 to 10V.</p>',par:{newval:'a floating point number corresponding to the output voltage, in V'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['set_logicalName']={syn:'Changes the logical name of the voltage output.',lib:'voltageoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltageoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VoltageOutput']['set_voltageAtStartUp']={syn:'Changes the output voltage at device start up.',lib:'voltageoutput.set_voltageAtStartUp()',pro:'def set_voltageAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the output voltage at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the output voltage at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voltageoutput.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['voltageMove']={syn:'Performs a smooth transition of output voltage.',lib:'voltageoutput.voltageMove()',pro:'def voltageMove(<span id=pn>V_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition of output voltage. Any explicit voltage change cancels any ongoing transition process.</p>',par:{V_target:'new output voltage value at the end of the transition (floating-point number, representing the end voltage in V)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.'};
//--- (end of generated code: VoltageOutput)
//--- (generated code: WeighScale)
doc['WeighScale']={'':{syn:'WeighScale function interface',inc:'from yocto_weighscale import *',cmt:'<p>The YWeighScale class provides a weight measurement from a ratiometric load cell sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cell itself.</p>'}};
doc['WeighScale']['FindWeighScale']={syn:'Retrieves a weighing scale sensor for a given identifier.',lib:'YWeighScale.FindWeighScale()',pro:'def FindWeighScale(<span id=pn>func</span>)',cmt:'<p>Retrieves a weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWeighScale.isOnline()</tt> to test if the weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the weighing scale sensor'},ret:'a <tt>YWeighScale</tt> object allowing you to drive the weighing scale sensor.'};
doc['WeighScale']['FirstWeighScale']={syn:'Starts the enumeration of weighing scale sensors currently accessible.',lib:'YWeighScale.FirstWeighScale()',pro:'def FirstWeighScale()',cmt:'<p>Starts the enumeration of weighing scale sensors currently accessible. Use the method <tt>YWeighScale.nextWeighScale()</tt> to iterate on next weighing scale sensors.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to the first weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'weighscale.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['clearCache']={syn:'Invalidates the cache.',lib:'weighscale.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WeighScale']['describe']={syn:'Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'weighscale.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'weighscale.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['WeighScale']['get_advertisedValue']={syn:'Returns the current value of the weighing scale sensor (no more than 6 characters).',lib:'weighscale.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'weighscale.get_compTempAvg()',pro:'def get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['WeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'weighscale.get_compTempChg()',pro:'def get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['WeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'weighscale.get_compensation()',pro:'def get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['WeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'weighscale.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['WeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'weighscale.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'weighscale.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['WeighScale']['get_errorMessage']={syn:'Returns the error message of the latest error with the weighing scale sensor.',lib:'weighscale.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the weighing scale sensor object'};
doc['WeighScale']['get_errorType']={syn:'Returns the numerical error code of the latest error with the weighing scale sensor.',lib:'weighscale.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the weighing scale sensor object'};
doc['WeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'weighscale.get_excitation()',pro:'def get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>Y_EXCITATION_INVALID</tt>.'};
doc['WeighScale']['get_friendlyName']={syn:'Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'weighscale.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WeighScale']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'weighscale.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WeighScale']['get_functionId']={syn:'Returns the hardware identifier of the weighing scale sensor, without reference to the module.',lib:'weighscale.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WeighScale']['get_hardwareId']={syn:'Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'weighscale.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'weighscale.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'weighscale.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_logicalName']={syn:'Returns the logical name of the weighing scale sensor.',lib:'weighscale.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'weighscale.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'weighscale.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'weighscale.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['WeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'weighscale.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'weighscale.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['WeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'weighscale.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['WeighScale']['get_tempAvgAdaptRatio']={syn:'Returns the averaged temperature update rate, in per mille.',lib:'weighscale.get_tempAvgAdaptRatio()',pro:'def get_tempAvgAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:'On failure, throws an exception or returns <tt>Y_TEMPAVGADAPTRATIO_INVALID</tt>.'};
doc['WeighScale']['get_tempChgAdaptRatio']={syn:'Returns the temperature change update rate, in per mille.',lib:'weighscale.get_tempChgAdaptRatio()',pro:'def get_tempChgAdaptRatio()',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:'On failure, throws an exception or returns <tt>Y_TEMPCHGADAPTRATIO_INVALID</tt>.'};
doc['WeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'weighscale.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['WeighScale']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'weighscale.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'weighscale.get_zeroTracking()',pro:'def get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['WeighScale']['isOnline']={syn:'Checks if the weighing scale sensor is currently reachable, without raising any error.',lib:'weighscale.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the weighing scale sensor.</p>',ret:'<tt>true</tt> if the weighing scale sensor can be reached, and <tt>false</tt> otherwise'};
doc['WeighScale']['load']={syn:'Preloads the weighing scale sensor cache with a specified validity duration.',lib:'weighscale.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'weighscale.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'weighscale.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadOffsetAvgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function.',lib:'weighscale.loadOffsetAvgCompensationTable()',pro:'def loadOffsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadOffsetChgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function.',lib:'weighscale.loadOffsetChgCompensationTable()',pro:'def loadOffsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadSpanAvgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function.',lib:'weighscale.loadSpanAvgCompensationTable()',pro:'def loadSpanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadSpanChgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function.',lib:'weighscale.loadSpanChgCompensationTable()',pro:'def loadSpanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all variation of temperature for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of variation of temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'weighscale.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['nextWeighScale']={syn:'Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>.',lib:'weighscale.nextWeighScale()',pro:'def nextWeighScale()',cmt:'<p>Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>. Caution: You can\x27t make any assumption about the returned weighing scale sensors order. If you want to find a specific a weighing scale sensor, use <tt>WeighScale.findWeighScale()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to a weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more weighing scale sensors to enumerate.'};
doc['WeighScale']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'weighscale.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['WeighScale']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'weighscale.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'weighscale.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'weighscale.set_excitation()',pro:'def set_excitation(<span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'weighscale.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'weighscale.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_logicalName']={syn:'Changes the logical name of the weighing scale sensor.',lib:'weighscale.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the weighing scale sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'weighscale.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_offsetAvgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature.',lib:'weighscale.set_offsetAvgCompensationTable()',pro:'def set_offsetAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_offsetChgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'weighscale.set_offsetChgCompensationTable()',pro:'def set_offsetChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'weighscale.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'weighscale.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_spanAvgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature.',lib:'weighscale.set_spanAvgCompensationTable()',pro:'def set_spanAvgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_spanChgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'weighscale.set_spanChgCompensationTable()',pro:'def set_spanChgCompensationTable(<span id=pn>tempValues</span>, <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all variations of temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_tempAvgAdaptRatio']={syn:'Changes the averaged temperature update rate, in per mille.',lib:'weighscale.set_tempAvgAdaptRatio()',pro:'def set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_tempChgAdaptRatio']={syn:'Changes the temperature change update rate, in per mille.',lib:'weighscale.set_tempChgAdaptRatio()',pro:'def set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'weighscale.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'weighscale.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'weighscale.set_zeroTracking()',pro:'def set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['setupSpan']={syn:'Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.',lib:'weighscale.setupSpan()',pro:'def setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'weighscale.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['WeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'weighscale.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['WeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'weighscale.tare()',pro:'def tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'weighscale.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WeighScale)
//--- (generated code: PowerSupply)
doc['PowerSupply']={'':{syn:'PowerSupply function interface',inc:'from yocto_powersupply import *',cmt:'<p>The Yoctopuce application programming interface allows you to change the voltage set point, the current limit and the enable/disable the output.</p>'}};
doc['PowerSupply']['FindPowerSupply']={syn:'Retrieves a regulated power supply for a given identifier.',lib:'YPowerSupply.FindPowerSupply()',pro:'def FindPowerSupply(<span id=pn>func</span>)',cmt:'<p>Retrieves a regulated power supply for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the regulated power supply is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerSupply.isOnline()</tt> to test if the regulated power supply is indeed online at a given time. In case of ambiguity when looking for a regulated power supply by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the regulated power supply'},ret:'a <tt>YPowerSupply</tt> object allowing you to drive the regulated power supply.'};
doc['PowerSupply']['FirstPowerSupply']={syn:'Starts the enumeration of regulated power supplies currently accessible.',lib:'YPowerSupply.FirstPowerSupply()',pro:'def FirstPowerSupply()',cmt:'<p>Starts the enumeration of regulated power supplies currently accessible. Use the method <tt>YPowerSupply.nextPowerSupply()</tt> to iterate on next regulated power supplies.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to the first regulated power supply currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PowerSupply']['clearCache']={syn:'Invalidates the cache.',lib:'powersupply.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the regulated power supply attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PowerSupply']['describe']={syn:'Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'powersupply.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the regulated power supply (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerSupply']['get_advertisedValue']={syn:'Returns the current value of the regulated power supply (no more than 6 characters).',lib:'powersupply.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the regulated power supply (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the regulated power supply (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerSupply']['get_currentAtStartUp']={syn:'Returns the selected current limit at device startup, in mA.',lib:'powersupply.get_currentAtStartUp()',pro:'def get_currentAtStartUp()',cmt:'<p>Returns the selected current limit at device startup, in mA.</p>',ret:'a floating point number corresponding to the selected current limit at device startup, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_currentLimit']={syn:'Returns the current limit, in mA.',lib:'powersupply.get_currentLimit()',pro:'def get_currentLimit()',cmt:'<p>Returns the current limit, in mA.</p>',ret:'a floating point number corresponding to the current limit, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTLIMIT_INVALID</tt>.'};
doc['PowerSupply']['get_errorMessage']={syn:'Returns the error message of the latest error with the regulated power supply.',lib:'powersupply.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the regulated power supply object'};
doc['PowerSupply']['get_errorType']={syn:'Returns the numerical error code of the latest error with the regulated power supply.',lib:'powersupply.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the regulated power supply object'};
doc['PowerSupply']['get_friendlyName']={syn:'Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'powersupply.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the regulated power supply if they are defined, otherwise the serial number of the module and the hardware identifier of the regulated power supply (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the regulated power supply using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerSupply']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'powersupply.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PowerSupply']['get_functionId']={syn:'Returns the hardware identifier of the regulated power supply, without reference to the module.',lib:'powersupply.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the regulated power supply, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the regulated power supply (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerSupply']['get_hardwareId']={syn:'Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'powersupply.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the regulated power supply (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the regulated power supply (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerSupply']['get_inputVoltage']={syn:'Returns the measured input voltage, in V.',lib:'powersupply.get_inputVoltage()',pro:'def get_inputVoltage()',cmt:'<p>Returns the measured input voltage, in V.</p>',ret:'a floating point number corresponding to the measured input voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_INPUTVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_ldoTemperature']={syn:'Returns the LDO temperature, in Celsius.',lib:'powersupply.get_ldoTemperature()',pro:'def get_ldoTemperature()',cmt:'<p>Returns the LDO temperature, in Celsius.</p>',ret:'a floating point number corresponding to the LDO temperature, in Celsius',ext:'On failure, throws an exception or returns <tt>Y_LDOTEMPERATURE_INVALID</tt>.'};
doc['PowerSupply']['get_logicalName']={syn:'Returns the logical name of the regulated power supply.',lib:'powersupply.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the regulated power supply.</p>',ret:'a string corresponding to the logical name of the regulated power supply.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerSupply']['get_measuredCurrent']={syn:'Returns the measured output current, in mA.',lib:'powersupply.get_measuredCurrent()',pro:'def get_measuredCurrent()',cmt:'<p>Returns the measured output current, in mA.</p>',ret:'a floating point number corresponding to the measured output current, in mA',ext:'On failure, throws an exception or returns <tt>Y_MEASUREDCURRENT_INVALID</tt>.'};
doc['PowerSupply']['get_measuredVoltage']={syn:'Returns the measured output voltage, in V.',lib:'powersupply.get_measuredVoltage()',pro:'def get_measuredVoltage()',cmt:'<p>Returns the measured output voltage, in V.</p>',ret:'a floating point number corresponding to the measured output voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_MEASUREDVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'powersupply.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PowerSupply']['get_powerOutput']={syn:'Returns the power supply output switch state.',lib:'powersupply.get_powerOutput()',pro:'def get_powerOutput()',cmt:'<p>Returns the power supply output switch state.</p>',ret:'either <tt>Y_POWEROUTPUT_OFF</tt> or <tt>Y_POWEROUTPUT_ON</tt>, according to the power supply output switch state',ext:'On failure, throws an exception or returns <tt>Y_POWEROUTPUT_INVALID</tt>.'};
doc['PowerSupply']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'powersupply.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PowerSupply']['get_vInt']={syn:'Returns the internal voltage, in V.',lib:'powersupply.get_vInt()',pro:'def get_vInt()',cmt:'<p>Returns the internal voltage, in V.</p>',ret:'a floating point number corresponding to the internal voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_VINT_INVALID</tt>.'};
doc['PowerSupply']['get_voltageAtStartUp']={syn:'Returns the selected voltage set point at device startup, in V.',lib:'powersupply.get_voltageAtStartUp()',pro:'def get_voltageAtStartUp()',cmt:'<p>Returns the selected voltage set point at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage set point at device startup, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSense']={syn:'Returns the output voltage control point.',lib:'powersupply.get_voltageSense()',pro:'def get_voltageSense()',cmt:'<p>Returns the output voltage control point.</p>',ret:'either <tt>Y_VOLTAGESENSE_INT</tt> or <tt>Y_VOLTAGESENSE_EXT</tt>, according to the output voltage control point',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGESENSE_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSetPoint']={syn:'Returns the voltage set point, in V.',lib:'powersupply.get_voltageSetPoint()',pro:'def get_voltageSetPoint()',cmt:'<p>Returns the voltage set point, in V.</p>',ret:'a floating point number corresponding to the voltage set point, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGESETPOINT_INVALID</tt>.'};
doc['PowerSupply']['isOnline']={syn:'Checks if the regulated power supply is currently reachable, without raising any error.',lib:'powersupply.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the regulated power supply is currently reachable, without raising any error. If there is a cached value for the regulated power supply in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the regulated power supply.</p>',ret:'<tt>true</tt> if the regulated power supply can be reached, and <tt>false</tt> otherwise'};
doc['PowerSupply']['load']={syn:'Preloads the regulated power supply cache with a specified validity duration.',lib:'powersupply.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the regulated power supply cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'powersupply.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PowerSupply']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'powersupply.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['nextPowerSupply']={syn:'Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>.',lib:'powersupply.nextPowerSupply()',pro:'def nextPowerSupply()',cmt:'<p>Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>. Caution: You can\x27t make any assumption about the returned regulated power supplies order. If you want to find a specific a regulated power supply, use <tt>PowerSupply.findPowerSupply()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to a regulated power supply currently online, or a <tt>null</tt> pointer if there are no more regulated power supplies to enumerate.'};
doc['PowerSupply']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'powersupply.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PowerSupply']['set_currentAtStartUp']={syn:'Changes the current limit at device start up.',lib:'powersupply.set_currentAtStartUp()',pro:'def set_currentAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the current limit at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the current limit at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_currentLimit']={syn:'Changes the current limit, in mA.',lib:'powersupply.set_currentLimit()',pro:'def set_currentLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the current limit, in mA.</p>',par:{newval:'a floating point number corresponding to the current limit, in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_logicalName']={syn:'Changes the logical name of the regulated power supply.',lib:'powersupply.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the regulated power supply. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the regulated power supply.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_powerOutput']={syn:'Changes the power supply output switch state.',lib:'powersupply.set_powerOutput()',pro:'def set_powerOutput(<span id=pn>newval</span>)',cmt:'<p>Changes the power supply output switch state.</p>',par:{newval:'either <tt>Y_POWEROUTPUT_OFF</tt> or <tt>Y_POWEROUTPUT_ON</tt>, according to the power supply output switch state'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'powersupply.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PowerSupply']['set_voltageAtStartUp']={syn:'Changes the voltage set point at device start up.',lib:'powersupply.set_voltageAtStartUp()',pro:'def set_voltageAtStartUp(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage set point at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the voltage set point at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_voltageSense']={syn:'Changes the voltage control point.',lib:'powersupply.set_voltageSense()',pro:'def set_voltageSense(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage control point.</p>',par:{newval:'either <tt>Y_VOLTAGESENSE_INT</tt> or <tt>Y_VOLTAGESENSE_EXT</tt>, according to the voltage control point'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_voltageSetPoint']={syn:'Changes the voltage set point, in V.',lib:'powersupply.set_voltageSetPoint()',pro:'def set_voltageSetPoint(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage set point, in V.</p>',par:{newval:'a floating point number corresponding to the voltage set point, in V'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'powersupply.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PowerSupply)
//--- (generated code: MultiCellWeighScale)
doc['MultiCellWeighScale']={'':{syn:'MultiCellWeighScale function interface',inc:'from yocto_multicellweighscale import *',cmt:'<p>The YMultiCellWeighScale class provides a weight measurement from a set of ratiometric load cells sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cells themselves.</p>'}};
doc['MultiCellWeighScale']['FindMultiCellWeighScale']={syn:'Retrieves a multi-cell weighing scale sensor for a given identifier.',lib:'YMultiCellWeighScale.FindMultiCellWeighScale()',pro:'def FindMultiCellWeighScale(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-cell weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-cell weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiCellWeighScale.isOnline()</tt> to test if the multi-cell weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a multi-cell weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-cell weighing scale sensor'},ret:'a <tt>YMultiCellWeighScale</tt> object allowing you to drive the multi-cell weighing scale sensor.'};
doc['MultiCellWeighScale']['FirstMultiCellWeighScale']={syn:'Starts the enumeration of multi-cell weighing scale sensors currently accessible.',lib:'YMultiCellWeighScale.FirstMultiCellWeighScale()',pro:'def FirstMultiCellWeighScale()',cmt:'<p>Starts the enumeration of multi-cell weighing scale sensors currently accessible. Use the method <tt>YMultiCellWeighScale.nextMultiCellWeighScale()</tt> to iterate on next multi-cell weighing scale sensors.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to the first multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiCellWeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'multicellweighscale.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['clearCache']={syn:'Invalidates the cache.',lib:'multicellweighscale.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-cell weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiCellWeighScale']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multicellweighscale.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-cell weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiCellWeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'multicellweighscale.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_advertisedValue']={syn:'Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).',lib:'multicellweighscale.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-cell weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_cellCount']={syn:'Returns the number of load cells in use.',lib:'multicellweighscale.get_cellCount()',pro:'def get_cellCount()',cmt:'<p>Returns the number of load cells in use.</p>',ret:'an integer corresponding to the number of load cells in use',ext:'On failure, throws an exception or returns <tt>Y_CELLCOUNT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'multicellweighscale.get_compTempAvg()',pro:'def get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'multicellweighscale.get_compTempChg()',pro:'def get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'multicellweighscale.get_compensation()',pro:'def get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'multicellweighscale.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'multicellweighscale.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'multicellweighscale.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['MultiCellWeighScale']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-cell weighing scale sensor.',lib:'multicellweighscale.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-cell weighing scale sensor object'};
doc['MultiCellWeighScale']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-cell weighing scale sensor.',lib:'multicellweighscale.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-cell weighing scale sensor object'};
doc['MultiCellWeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'multicellweighscale.get_excitation()',pro:'def get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>Y_EXCITATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_friendlyName']={syn:'Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multicellweighscale.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-cell weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-cell weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multicellweighscale.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_functionId']={syn:'Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module.',lib:'multicellweighscale.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-cell weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multicellweighscale.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-cell weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'multicellweighscale.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'multicellweighscale.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logicalName']={syn:'Returns the logical name of the multi-cell weighing scale sensor.',lib:'multicellweighscale.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the multi-cell weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the multi-cell weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'multicellweighscale.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multicellweighscale.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiCellWeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'multicellweighscale.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['MultiCellWeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'multicellweighscale.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'multicellweighscale.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'multicellweighscale.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_tempAvgAdaptRatio']={syn:'Returns the averaged temperature update rate, in per mille.',lib:'multicellweighscale.get_tempAvgAdaptRatio()',pro:'def get_tempAvgAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in per mille',ext:'On failure, throws an exception or returns <tt>Y_TEMPAVGADAPTRATIO_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_tempChgAdaptRatio']={syn:'Returns the temperature change update rate, in per mille.',lib:'multicellweighscale.get_tempChgAdaptRatio()',pro:'def get_tempChgAdaptRatio()',cmt:'<p>Returns the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',ret:'a floating point number corresponding to the temperature change update rate, in per mille',ext:'On failure, throws an exception or returns <tt>Y_TEMPCHGADAPTRATIO_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'multicellweighscale.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multicellweighscale.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiCellWeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'multicellweighscale.get_zeroTracking()',pro:'def get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['MultiCellWeighScale']['isOnline']={syn:'Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error.',lib:'multicellweighscale.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the multi-cell weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-cell weighing scale sensor.</p>',ret:'<tt>true</tt> if the multi-cell weighing scale sensor can be reached, and <tt>false</tt> otherwise'};
doc['MultiCellWeighScale']['load']={syn:'Preloads the multi-cell weighing scale sensor cache with a specified validity duration.',lib:'multicellweighscale.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-cell weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multicellweighscale.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiCellWeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'multicellweighscale.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multicellweighscale.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['nextMultiCellWeighScale']={syn:'Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>.',lib:'multicellweighscale.nextMultiCellWeighScale()',pro:'def nextMultiCellWeighScale()',cmt:'<p>Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>. Caution: You can\x27t make any assumption about the returned multi-cell weighing scale sensors order. If you want to find a specific a multi-cell weighing scale sensor, use <tt>MultiCellWeighScale.findMultiCellWeighScale()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to a multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more multi-cell weighing scale sensors to enumerate.'};
doc['MultiCellWeighScale']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'multicellweighscale.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['MultiCellWeighScale']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multicellweighscale.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiCellWeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'multicellweighscale.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_cellCount']={syn:'Changes the number of load cells in use.',lib:'multicellweighscale.set_cellCount()',pro:'def set_cellCount(<span id=pn>newval</span>)',cmt:'<p>Changes the number of load cells in use.</p>',par:{newval:'an integer corresponding to the number of load cells in use'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'multicellweighscale.set_excitation()',pro:'def set_excitation(<span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'multicellweighscale.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'multicellweighscale.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_logicalName']={syn:'Changes the logical name of the multi-cell weighing scale sensor.',lib:'multicellweighscale.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-cell weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-cell weighing scale sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'multicellweighscale.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'multicellweighscale.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'multicellweighscale.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_tempAvgAdaptRatio']={syn:'Changes the averaged temperature update rate, in per mille.',lib:'multicellweighscale.set_tempAvgAdaptRatio()',pro:'def set_tempAvgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in per mille. The purpose of this adaptation ratio is to model the thermal inertia of the load cell. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current compensation temperature. The standard rate is 0.2 per mille, and the maximal rate is 65 per mille.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in per mille'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_tempChgAdaptRatio']={syn:'Changes the temperature change update rate, in per mille.',lib:'multicellweighscale.set_tempChgAdaptRatio()',pro:'def set_tempChgAdaptRatio(<span id=pn>newval</span>)',cmt:'<p>Changes the temperature change update rate, in per mille. The temperature change is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambient temperature and the current temperature used for change compensation. The standard rate is 0.6 per mille, and the maximal rate is 65 pour mille.</p>',par:{newval:'a floating point number corresponding to the temperature change update rate, in per mille'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'multicellweighscale.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multicellweighscale.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiCellWeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'multicellweighscale.set_zeroTracking()',pro:'def set_zeroTracking(<span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['setupSpan']={syn:'Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.',lib:'multicellweighscale.setupSpan()',pro:'def setupSpan(<span id=pn>currWeight</span>, <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expected on the load cell.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'multicellweighscale.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'multicellweighscale.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'multicellweighscale.tare()',pro:'def tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multicellweighscale.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiCellWeighScale)
//--- (generated code: MultiSensorController)
doc['MultiSensorController']={'':{syn:'MultiSensorController function interface',inc:'from yocto_multisensorcontroller import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiSensorController']['FindMultiSensorController']={syn:'Retrieves a multi-sensor controller for a given identifier.',lib:'YMultiSensorController.FindMultiSensorController()',pro:'def FindMultiSensorController(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-sensor controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-sensor controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiSensorController.isOnline()</tt> to test if the multi-sensor controller is indeed online at a given time. In case of ambiguity when looking for a multi-sensor controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-sensor controller'},ret:'a <tt>YMultiSensorController</tt> object allowing you to drive the multi-sensor controller.'};
doc['MultiSensorController']['FirstMultiSensorController']={syn:'Starts the enumeration of multi-sensor controllers currently accessible.',lib:'YMultiSensorController.FirstMultiSensorController()',pro:'def FirstMultiSensorController()',cmt:'<p>Starts the enumeration of multi-sensor controllers currently accessible. Use the method <tt>YMultiSensorController.nextMultiSensorController()</tt> to iterate on next multi-sensor controllers.</p>',ret:'a pointer to a <tt>YMultiSensorController</tt> object, corresponding to the first multi-sensor controller currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiSensorController']['clearCache']={syn:'Invalidates the cache.',lib:'multisensorcontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-sensor controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiSensorController']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multisensorcontroller.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-sensor controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiSensorController']['get_advertisedValue']={syn:'Returns the current value of the multi-sensor controller (no more than 6 characters).',lib:'multisensorcontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the multi-sensor controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-sensor controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiSensorController']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-sensor controller.',lib:'multisensorcontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-sensor controller object'};
doc['MultiSensorController']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-sensor controller.',lib:'multisensorcontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-sensor controller object'};
doc['MultiSensorController']['get_friendlyName']={syn:'Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multisensorcontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-sensor controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-sensor controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-sensor controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiSensorController']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multisensorcontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiSensorController']['get_functionId']={syn:'Returns the hardware identifier of the multi-sensor controller, without reference to the module.',lib:'multisensorcontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-sensor controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-sensor controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiSensorController']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multisensorcontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-sensor controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-sensor controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiSensorController']['get_logicalName']={syn:'Returns the logical name of the multi-sensor controller.',lib:'multisensorcontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the multi-sensor controller.</p>',ret:'a string corresponding to the logical name of the multi-sensor controller.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiSensorController']['get_maintenanceMode']={syn:'Returns true when the device is in maintenance mode.',lib:'multisensorcontroller.get_maintenanceMode()',pro:'def get_maintenanceMode()',cmt:'<p>Returns true when the device is in maintenance mode.</p>',ret:'either <tt>Y_MAINTENANCEMODE_FALSE</tt> or <tt>Y_MAINTENANCEMODE_TRUE</tt>, according to true when the device is in maintenance mode',ext:'On failure, throws an exception or returns <tt>Y_MAINTENANCEMODE_INVALID</tt>.'};
doc['MultiSensorController']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multisensorcontroller.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiSensorController']['get_nSensors']={syn:'Returns the number of sensors to poll.',lib:'multisensorcontroller.get_nSensors()',pro:'def get_nSensors()',cmt:'<p>Returns the number of sensors to poll.</p>',ret:'an integer corresponding to the number of sensors to poll',ext:'On failure, throws an exception or returns <tt>Y_NSENSORS_INVALID</tt>.'};
doc['MultiSensorController']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multisensorcontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiSensorController']['isOnline']={syn:'Checks if the multi-sensor controller is currently reachable, without raising any error.',lib:'multisensorcontroller.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the multi-sensor controller is currently reachable, without raising any error. If there is a cached value for the multi-sensor controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-sensor controller.</p>',ret:'<tt>true</tt> if the multi-sensor controller can be reached, and <tt>false</tt> otherwise'};
doc['MultiSensorController']['load']={syn:'Preloads the multi-sensor controller cache with a specified validity duration.',lib:'multisensorcontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-sensor controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multisensorcontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiSensorController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multisensorcontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['nextMultiSensorController']={syn:'Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensorController()</tt>.',lib:'multisensorcontroller.nextMultiSensorController()',pro:'def nextMultiSensorController()',cmt:'<p>Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensorController()</tt>. Caution: You can\x27t make any assumption about the returned multi-sensor controllers order. If you want to find a specific a multi-sensor controller, use <tt>MultiSensorController.findMultiSensorController()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiSensorController</tt> object, corresponding to a multi-sensor controller currently online, or a <tt>null</tt> pointer if there are no more multi-sensor controllers to enumerate.'};
doc['MultiSensorController']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multisensorcontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiSensorController']['set_logicalName']={syn:'Changes the logical name of the multi-sensor controller.',lib:'multisensorcontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-sensor controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-sensor controller.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['set_maintenanceMode']={syn:'Changes the device mode to enable maintenance and stop sensors polling.',lib:'multisensorcontroller.set_maintenanceMode()',pro:'def set_maintenanceMode(<span id=pn>newval</span>)',cmt:'<p>Changes the device mode to enable maintenance and stop sensors polling. This way, the device will not restart automatically in case it cannot communicate with one of the sensors.</p>',par:{newval:'either <tt>Y_MAINTENANCEMODE_FALSE</tt> or <tt>Y_MAINTENANCEMODE_TRUE</tt>, according to the device mode to enable maintenance and stop sensors polling'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['set_nSensors']={syn:'Changes the number of sensors to poll.',lib:'multisensorcontroller.set_nSensors()',pro:'def set_nSensors(<span id=pn>newval</span>)',cmt:'<p>Changes the number of sensors to poll. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. Il is recommended to restart the device with <tt>module->reboot()</tt> after modifing (and saving) this settings</p>',par:{newval:'an integer corresponding to the number of sensors to poll'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multisensorcontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiSensorController']['setupAddress']={syn:'Configure the I2C address of the only sensor connected to the device.',lib:'multisensorcontroller.setupAddress()',pro:'def setupAddress(<span id=pn>addr</span>)',cmt:'<p>Configure the I2C address of the only sensor connected to the device. It is recommanded to put the the device in maintenance mode before changing Sensors addresses. This method is only intended to work with a single sensor connected to the device, if several sensors are connected, result is unpredictible. Note that the device is probably expecting to find a string of sensors with specific addresses. Check the device documentation to find out which addresses should be used.</p>',par:{addr:'new address of the connected sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiSensorController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multisensorcontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiSensorController)
//--- (generated code: MultiSensController)
doc['MultiSensController']={'':{syn:'MultiSensController function interface',inc:'from yocto_multisenscontroller import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiSensController']['FindMultiSensController']={syn:'Retrieves a multi-sensor controller for a given identifier.',lib:'YMultiSensController.FindMultiSensController()',pro:'def FindMultiSensController(<span id=pn>func</span>)',cmt:'<p>Retrieves a multi-sensor controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-sensor controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiSensController.isOnline()</tt> to test if the multi-sensor controller is indeed online at a given time. In case of ambiguity when looking for a multi-sensor controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-sensor controller'},ret:'a <tt>YMultiSensController</tt> object allowing you to drive the multi-sensor controller.'};
doc['MultiSensController']['FirstMultiSensController']={syn:'Starts the enumeration of multi-sensor controllers currently accessible.',lib:'YMultiSensController.FirstMultiSensController()',pro:'def FirstMultiSensController()',cmt:'<p>Starts the enumeration of multi-sensor controllers currently accessible. Use the method <tt>YMultiSensController.nextMultiSensController()</tt> to iterate on next multi-sensor controllers.</p>',ret:'a pointer to a <tt>YMultiSensController</tt> object, corresponding to the first multi-sensor controller currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiSensController']['clearCache']={syn:'Invalidates the cache.',lib:'multisenscontroller.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-sensor controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiSensController']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multisenscontroller.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-sensor controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-sensor controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiSensController']['get_advertisedValue']={syn:'Returns the current value of the multi-sensor controller (no more than 6 characters).',lib:'multisenscontroller.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the multi-sensor controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-sensor controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiSensController']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-sensor controller.',lib:'multisenscontroller.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-sensor controller object'};
doc['MultiSensController']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-sensor controller.',lib:'multisenscontroller.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-sensor controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-sensor controller object'};
doc['MultiSensController']['get_friendlyName']={syn:'Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multisenscontroller.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-sensor controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-sensor controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-sensor controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-sensor controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiSensController']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multisenscontroller.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiSensController']['get_functionId']={syn:'Returns the hardware identifier of the multi-sensor controller, without reference to the module.',lib:'multisenscontroller.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-sensor controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-sensor controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiSensController']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multisenscontroller.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-sensor controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-sensor controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-sensor controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiSensController']['get_logicalName']={syn:'Returns the logical name of the multi-sensor controller.',lib:'multisenscontroller.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the multi-sensor controller.</p>',ret:'a string corresponding to the logical name of the multi-sensor controller.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiSensController']['get_maintenanceMode']={syn:'Returns true when the device is in maintenance mode.',lib:'multisenscontroller.get_maintenanceMode()',pro:'def get_maintenanceMode()',cmt:'<p>Returns true when the device is in maintenance mode.</p>',ret:'either <tt>Y_MAINTENANCEMODE_FALSE</tt> or <tt>Y_MAINTENANCEMODE_TRUE</tt>, according to true when the device is in maintenance mode',ext:'On failure, throws an exception or returns <tt>Y_MAINTENANCEMODE_INVALID</tt>.'};
doc['MultiSensController']['get_maxSensors']={syn:'Returns the maximum configurable sensor count allowed on this device.',lib:'multisenscontroller.get_maxSensors()',pro:'def get_maxSensors()',cmt:'<p>Returns the maximum configurable sensor count allowed on this device.</p>',ret:'an integer corresponding to the maximum configurable sensor count allowed on this device',ext:'On failure, throws an exception or returns <tt>Y_MAXSENSORS_INVALID</tt>.'};
doc['MultiSensController']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multisenscontroller.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiSensController']['get_nSensors']={syn:'Returns the number of sensors to poll.',lib:'multisenscontroller.get_nSensors()',pro:'def get_nSensors()',cmt:'<p>Returns the number of sensors to poll.</p>',ret:'an integer corresponding to the number of sensors to poll',ext:'On failure, throws an exception or returns <tt>Y_NSENSORS_INVALID</tt>.'};
doc['MultiSensController']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multisenscontroller.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiSensController']['isOnline']={syn:'Checks if the multi-sensor controller is currently reachable, without raising any error.',lib:'multisenscontroller.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the multi-sensor controller is currently reachable, without raising any error. If there is a cached value for the multi-sensor controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-sensor controller.</p>',ret:'<tt>true</tt> if the multi-sensor controller can be reached, and <tt>false</tt> otherwise'};
doc['MultiSensController']['load']={syn:'Preloads the multi-sensor controller cache with a specified validity duration.',lib:'multisenscontroller.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-sensor controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multisenscontroller.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiSensController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multisenscontroller.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['nextMultiSensController']={syn:'Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensController()</tt>.',lib:'multisenscontroller.nextMultiSensController()',pro:'def nextMultiSensController()',cmt:'<p>Continues the enumeration of multi-sensor controllers started using <tt>yFirstMultiSensController()</tt>. Caution: You can\x27t make any assumption about the returned multi-sensor controllers order. If you want to find a specific a multi-sensor controller, use <tt>MultiSensController.findMultiSensController()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YMultiSensController</tt> object, corresponding to a multi-sensor controller currently online, or a <tt>null</tt> pointer if there are no more multi-sensor controllers to enumerate.'};
doc['MultiSensController']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multisenscontroller.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiSensController']['set_logicalName']={syn:'Changes the logical name of the multi-sensor controller.',lib:'multisenscontroller.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-sensor controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-sensor controller.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['set_maintenanceMode']={syn:'Changes the device mode to enable maintenance and stop sensors polling.',lib:'multisenscontroller.set_maintenanceMode()',pro:'def set_maintenanceMode(<span id=pn>newval</span>)',cmt:'<p>Changes the device mode to enable maintenance and stop sensors polling. This way, the device will not restart automatically in case it cannot communicate with one of the sensors.</p>',par:{newval:'either <tt>Y_MAINTENANCEMODE_FALSE</tt> or <tt>Y_MAINTENANCEMODE_TRUE</tt>, according to the device mode to enable maintenance and stop sensors polling'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['set_nSensors']={syn:'Changes the number of sensors to poll.',lib:'multisenscontroller.set_nSensors()',pro:'def set_nSensors(<span id=pn>newval</span>)',cmt:'<p>Changes the number of sensors to poll. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. It\x27s recommended to restart the device with <tt>module->reboot()</tt> after modifying (and saving) this settings</p>',par:{newval:'an integer corresponding to the number of sensors to poll'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multisenscontroller.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiSensController']['setupAddress']={syn:'Configure the I2C address of the only sensor connected to the device.',lib:'multisenscontroller.setupAddress()',pro:'def setupAddress(<span id=pn>addr</span>)',cmt:'<p>Configure the I2C address of the only sensor connected to the device. It is recommended to put the the device in maintenance mode before changing Sensors addresses. This method is only intended to work with a single sensor connected to the device, if several sensors are connected, result is unpredictable. Note that the device is probably expecting to find a string of sensors with specific addresses. Check the device documentation to find out which addresses should be used.</p>',par:{addr:'new address of the connected sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiSensController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multisenscontroller.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiSensController)
//--- (generated code: Tvoc)
doc['Tvoc']={'':{syn:'Tvoc function interface',inc:'from yocto_tvoc import *',cmt:'<p>The Yoctopuce class YTvoc allows you to read and configure Yoctopuce Total Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Tvoc']['FindTvoc']={syn:'Retrieves a Total Volatile Organic Compound sensor for a given identifier.',lib:'YTvoc.FindTvoc()',pro:'def FindTvoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Total Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Total Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTvoc.isOnline()</tt> to test if the Total Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Total Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Total Volatile Organic Compound sensor'},ret:'a <tt>YTvoc</tt> object allowing you to drive the Total Volatile Organic Compound sensor.'};
doc['Tvoc']['FirstTvoc']={syn:'Starts the enumeration of Total Volatile Organic Compound sensors currently accessible.',lib:'YTvoc.FirstTvoc()',pro:'def FirstTvoc()',cmt:'<p>Starts the enumeration of Total Volatile Organic Compound sensors currently accessible. Use the method <tt>YTvoc.nextTvoc()</tt> to iterate on next Total Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YTvoc</tt> object, corresponding to the first Total Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Tvoc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'tvoc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['clearCache']={syn:'Invalidates the cache.',lib:'tvoc.clearCache()',pro:'def clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Total Volatile Organic Compound sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Tvoc']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Total Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tvoc.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Total Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Total Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tvoc']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'tvoc.get_advMode()',pro:'def get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Tvoc']['get_advertisedValue']={syn:'Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',lib:'tvoc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Total Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tvoc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.',lib:'tvoc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppb, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tvoc']['get_currentValue']={syn:'Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number.',lib:'tvoc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the estimated TVOC concentration, in ppb, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated TVOC concentration, in ppb, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'tvoc.get_dataLogger()',pro:'def get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Tvoc']['get_errorMessage']={syn:'Returns the error message of the latest error with the Total Volatile Organic Compound sensor.',lib:'tvoc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Total Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Total Volatile Organic Compound sensor object'};
doc['Tvoc']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Total Volatile Organic Compound sensor.',lib:'tvoc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Total Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Total Volatile Organic Compound sensor object'};
doc['Tvoc']['get_friendlyName']={syn:'Returns a global identifier of the Total Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'tvoc.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the Total Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Total Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Total Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Total Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tvoc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'tvoc.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Tvoc']['get_functionId']={syn:'Returns the hardware identifier of the Total Volatile Organic Compound sensor, without reference to the module.',lib:'tvoc.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the Total Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Total Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tvoc']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Total Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'tvoc.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Total Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Total Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Total Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tvoc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated TVOC concentration since the device was started.',lib:'tvoc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated TVOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'tvoc.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tvoc']['get_logicalName']={syn:'Returns the logical name of the Total Volatile Organic Compound sensor.',lib:'tvoc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Total Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tvoc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated TVOC concentration since the device was started.',lib:'tvoc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated TVOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated TVOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tvoc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'tvoc.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Tvoc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'tvoc.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any measure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tvoc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'tvoc.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tvoc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'tvoc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tvoc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'tvoc.get_sensorState()',pro:'def get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Tvoc']['get_unit']={syn:'Returns the measuring unit for the estimated TVOC concentration.',lib:'tvoc.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the estimated TVOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated TVOC concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Tvoc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'tvoc.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Tvoc']['isOnline']={syn:'Checks if the Total Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'tvoc.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the Total Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Total Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Total Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Total Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'};
doc['Tvoc']['load']={syn:'Preloads the Total Volatile Organic Compound sensor cache with a specified validity duration.',lib:'tvoc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Total Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'tvoc.loadAttribute()',pro:'def loadAttribute(<span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Tvoc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'tvoc.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'tvoc.muteValueCallbacks()',pro:'def muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['nextTvoc']={syn:'Continues the enumeration of Total Volatile Organic Compound sensors started using <tt>yFirstTvoc()</tt>.',lib:'tvoc.nextTvoc()',pro:'def nextTvoc()',cmt:'<p>Continues the enumeration of Total Volatile Organic Compound sensors started using <tt>yFirstTvoc()</tt>. Caution: You can\x27t make any assumption about the returned Total Volatile Organic Compound sensors order. If you want to find a specific a Total Volatile Organic Compound sensor, use <tt>Tvoc.findTvoc()</tt> and a hardwareID or a logical name.</p>',ret:'a pointer to a <tt>YTvoc</tt> object, corresponding to a Total Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Total Volatile Organic Compound sensors to enumerate.'};
doc['Tvoc']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'tvoc.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Tvoc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'tvoc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Tvoc']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'tvoc.set_advMode()',pro:'def set_advMode(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'tvoc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'tvoc.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_logicalName']={syn:'Changes the logical name of the Total Volatile Organic Compound sensor.',lib:'tvoc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Total Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Total Volatile Organic Compound sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'tvoc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'tvoc.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (e.g. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'tvoc.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tvoc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'tvoc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Tvoc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'tvoc.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tvoc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'tvoc.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tvoc']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'tvoc.unmuteValueCallbacks()',pro:'def unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Tvoc)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

