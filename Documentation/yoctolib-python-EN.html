<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-FR.html 4133 2013-08-14 16:06:19Z mvuilleu $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce 
 *    and Licensee are governed by Yoctopuce General Terms and 
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived 
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute; 
  left:0px; 
  top:0px; 
  width:800px; 
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute; 
  left:0px; 
  top:80px; 
  width:250px; 
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;
 
}

div#FunctionsLayer
{ position:absolute; 
  left:250px; 
  top:80px; 
  width:600px; 
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute; 
  left:0px; 
  top:570px; 
  width: 800px; 
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute; 
  width:10px; 
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize; 
}

div.container
{ width:100%;
  height:100%;
}
 
span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
} 

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }
 
span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }
 
div.methodsList
 { margin-top:0px;
   padding-top:0px;   
   padding-left:10px;
   margin-bottom:10px;
 } 

div.methodsList A
 { color: navy;
   text-decoration:none;
 }
 
div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }
 
span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }
  
span#pn , td.pn
 { font-weight:bold; 
   color:#004000;
   
 } 
 
td.pn
 {vertical-align:top}
 
span.paramAndRet
 {font-weight:bold;

 } 
 
table
 {font-size:14px;}
 
span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;   
   background-color: #f8f8f8; 
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }
 
p.protolabel
 { border-top:1px  solid #f0f0f0;
 }
 
P.protoretval
 { margin-left:20px;}

.paramtable 
 { margin-left:20px; margin-top:0px;}
  
P.protoretval
 { margin-left:20px;}
 
input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }
 
td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040; 
 }
 
td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }
 
p.methodlist
 { border-top:1px solid #e0e0e0;
 } 
 
a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 } 
 
span.synlist
 { margin-left:10px;
 } 
 
p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }  
</style>

<SCRIPT type="text/JavaScript" language="javascript1.5">
<!--
var WinW; 
var WinH; 

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array(); 
var SVN_Id = '$Id: yoctolib-cpp-FR.html 4133 2013-08-14 16:06:19Z mvuilleu $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'from yocto_api import *',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI.CheckLogicalName()',pro:'def CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI.DisableExceptions()',pro:'def DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI.EnableExceptions()',pro:'def EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI.FreeAPI()',pro:'def FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI.GetAPIVersion()',pro:'def GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI.GetTickCount()',pro:'def GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the milisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI.HandleEvents()',pro:'def HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI.InitAPI()',pro:'def InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is pluged.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'def RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is pluged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unpluged.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'def RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unpluged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI.RegisterHub()',pro:'def RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. When using Yoctopuce modules through the VirtualHub gateway, you should provide as parameter the address of the machine on which the VirtualHub software is running (typically <tt>\x22http://127.0.0.1:4444\x22</tt>, which represents the local machine). When you use a language which has direct access to the USB hardware, you can use the pseudo-URL <tt>\x22usb\x22</tt> instead.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access. If acces control has been activated on the VirtualHub you want to reach, the URL parameter should look like: <tt>http://username:password</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterLogFunction']={syn:'Registers a log callback function.',lib:'YAPI.RegisterLogFunction()',pro:'def RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite usefull to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['SelectArchitecture']={syn:'Select the architecture or the library to be loaded to access to USB.',lib:'YAPI.SelectArchitecture()',pro:'def SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>Select the architecture or the library to be loaded to access to USB. By default, the Python library automatically detects the appropriate library to use. However, for Linux ARM, it not possible to reliably distinguish between a Hard Float (armhf) and a Soft Float (armel) install. For in this case, it is therefore recommended to manually select the proper architecture by calling <tt>SelectArchitecture()</tt> before any other call to the library.</p>',par:{arch:'A string containing the architecture to use. Possibles value are: <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>,<tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'nothing.',ext:'On failure, throws an exception.'};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI.Sleep()',pro:'def Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significatively. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'def UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI.UpdateDeviceList()',pro:'def UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: Module)
var Language='Python';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=null;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',null:'None'};
doc['Module']={'':{syn:'Module control interface',inc:'from yocto_api import *',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule.FindModule()',pro:'def FindModule(<span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule.FirstModule()',pro:'def FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module.functionCount()',pro:'def functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module.functionId()',pro:'def functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module.functionName()',pro:'def functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module.functionValue()',pro:'def functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module.get_beacon()',pro:'def get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the last error with this module object.',lib:'module.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the last error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the last error message that occured while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the last error with this module object.',lib:'module.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the last error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the last error that occured while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module.get_firmwareRelease()',pro:'def get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'module.get_moduleDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module.get_icon2d()',pro:'def get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'module.get_lastLogs()',pro:'def get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'module.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module.get_persistentSettings()',pro:'def get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module.get_productId()',pro:'def get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module.get_productName()',pro:'def get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module.get_productRelease()',pro:'def get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module.get_rebootCountdown()',pro:'def get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module.get_serialNumber()',pro:'def get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module.get_upTime()',pro:'def get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbBandwidth']={syn:'Returns the number of USB interfaces used by the module.',lib:'module.get_usbBandwidth()',pro:'def get_usbBandwidth()',cmt:'<p>Returns the number of USB interfaces used by the module.</p>',ret:'either <tt>Y_USBBANDWIDTH_SIMPLE</tt> or <tt>Y_USBBANDWIDTH_DOUBLE</tt>, according to the number of USB interfaces used by the module',ext:'On failure, throws an exception or returns <tt>Y_USBBANDWIDTH_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module.get_usbCurrent()',pro:'def get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'def nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module.reboot()',pro:'def reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module.revertFromFlash()',pro:'def revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module.saveToFlash()',pro:'def saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module.set_beacon()',pro:'def set_beacon(<span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_usbBandwidth']={syn:'Changes the number of USB interfaces used by the module.',lib:'module.set_usbBandwidth()',pro:'def set_usbBandwidth(<span id=pn>newval</span>)',cmt:'<p>Changes the number of USB interfaces used by the module. You must reboot the module after changing this setting.</p>',par:{newval:'either <tt>Y_USBBANDWIDTH_SIMPLE</tt> or <tt>Y_USBBANDWIDTH_DOUBLE</tt>, according to the number of USB interfaces used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module.triggerFirmwareUpdate()',pro:'def triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Module)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'from yocto_colorled import *',cmt:'<p>Yoctopuce application programming interface allows you to drive a color led using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a led with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Retrieves an RGB led for a given identifier.',lib:'YColorLed.FindColorLed()',pro:'def FindColorLed(<span id=pn>func</span>)',cmt:'<p>Retrieves an RGB led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the RGB led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB led is indeed online at a given time. In case of ambiguity when looking for an RGB led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the RGB led'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB led.'};
doc['ColorLed']['FirstColorLed']={syn:'Starts the enumeration of RGB leds currently accessible.',lib:'YColorLed.FirstColorLed()',pro:'def FirstColorLed()',cmt:'<p>Starts the enumeration of RGB leds currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB leds.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB led (no more than 6 characters).',lib:'colorled.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the RGB led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB led (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'colorled.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['ColorLed']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'colorled.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['ColorLed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorled.get_colorledDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the led.',lib:'colorled.get_hslColor()',pro:'def get_hslColor()',cmt:'<p>Returns the current HSL color of the led.</p>',ret:'an integer corresponding to the current HSL color of the led',ext:'On failure, throws an exception or returns <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB led.',lib:'colorled.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the RGB led.</p>',ret:'a string corresponding to the logical name of the RGB led',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorled.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the led.',lib:'colorled.get_rgbColor()',pro:'def get_rgbColor()',cmt:'<p>Returns the current RGB color of the led.</p>',ret:'an integer corresponding to the current RGB color of the led',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'def get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'colorled.hslMove()',pro:'def hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'colorled.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['ColorLed']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'colorled.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['nextColorLed']={syn:'Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.',lib:'colorled.nextColorLed()',pro:'def nextColorLed()',cmt:'<p>Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB led currently online, or a <tt>null</tt> pointer if there are no more RGB leds to enumerate.'};
doc['ColorLed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorled.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'colorled.rgbMove()',pro:'def rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the led, using a color HSL.',lib:'colorled.set_hslColor()',pro:'def set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the led, using a color HSL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB led.',lib:'colorled.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the led, using a RGB color.',lib:'colorled.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the led, using a RGB color'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the led will display by default when the module is turned on.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the color that the led will display by default when the module is turned on. This color will be displayed as soon as the module is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the change should be kept.</p>',par:{newval:'an integer corresponding to the color that the led will display by default when the module is turned on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorled.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: ColorLed)
//--- (generated code: DataRun)
doc['DataRun']={'':{syn:'Formatted data sequence',inc:'from yocto_datalogger import *',cmt:'<p>A run is a continuous interval of time during which a module was powered on. A data run provides easy access to all data collected during a given run, providing on-the-fly resampling at the desired reporting rate.</p>'}};
doc['DataRun']['get_averageValue']={syn:'Returns the average value of the measure observed at the specified time period.',lib:'datarun.get_averageValue()',pro:'def get_averageValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Returns the average value of the measure observed at the specified time period.</p>',par:{measureName:'the name of the desired measure (one of the names returned by <tt>get_measureNames</tt>)',pos:'the position index, between 0 and the value returned by <tt>get_valueCount</tt>'},ret:'a floating point number (the average value)',ext:'On failure, throws an exception or returns Y_AVERAGEVALUE_INVALID.'};
doc['DataRun']['get_duration']={syn:'Returns the duration (in seconds) of the data run.',lib:'datarun.get_duration()',pro:'def get_duration()',cmt:'<p>Returns the duration (in seconds) of the data run. When the datalogger is actively recording and the specified run is the current run, calling this method reloads last sequence(s) from device to make sure it includes the latest recorded data. </p>',ret:'an unsigned number corresponding to the number of seconds between the beginning of the run (when the module was powered up) and the last recorded measure.'};
doc['DataRun']['get_maxValue']={syn:'Returns the maximal value of the measure observed at the specified time period.',lib:'datarun.get_maxValue()',pro:'def get_maxValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Returns the maximal value of the measure observed at the specified time period.</p>',par:{measureName:'the name of the desired measure (one of the names returned by <tt>get_measureNames</tt>)',pos:'the position index, between 0 and the value returned by <tt>get_valueCount</tt>'},ret:'a floating point number (the maximal value)',ext:'On failure, throws an exception or returns Y_MAXVALUE_INVALID.'};
doc['DataRun']['get_measureNames']={syn:'Returns the names of the measures recorded by the data logger.',lib:'datarun.get_measureNames()',pro:'def get_measureNames()',cmt:'<p>Returns the names of the measures recorded by the data logger. In most case, the measure names match the hardware identifier of the sensor that produced the data.</p>',ret:'a list of strings (the measure names) On failure, throws an exception or returns an empty array.'};
doc['DataRun']['get_minValue']={syn:'Returns the minimal value of the measure observed at the specified time period.',lib:'datarun.get_minValue()',pro:'def get_minValue(<span id=pn>measureName</span>, <span id=pn>pos</span>)',cmt:'<p>Returns the minimal value of the measure observed at the specified time period.</p>',par:{measureName:'the name of the desired measure (one of the names returned by <tt>get_measureNames</tt>)',pos:'the position index, between 0 and the value returned by <tt>get_valueCount</tt>'},ret:'a floating point number (the minimal value)',ext:'On failure, throws an exception or returns Y_MINVALUE_INVALID.'};
doc['DataRun']['get_valueCount']={syn:'Returns the number of values accessible in this run, given the selected data samples interval.',lib:'datarun.get_valueCount()',pro:'def get_valueCount()',cmt:'<p>Returns the number of values accessible in this run, given the selected data samples interval. When the datalogger is actively recording and the specified run is the current run, calling this method reloads last sequence(s) from device to make sure it includes the latest recorded data.</p>',ret:'an unsigned number corresponding to the run duration divided by the samples interval.'};
doc['DataRun']['get_valueInterval']={syn:'Returns the number of seconds covered by each value in this run.',lib:'datarun.get_valueInterval()',pro:'def get_valueInterval()',cmt:'<p>Returns the number of seconds covered by each value in this run. By default, the value interval is set to the coarsest data rate archived in the data logger flash for this run. The value interval can however be configured at will to a different rate when desired.</p>',ret:'an unsigned number corresponding to a number of seconds covered by each data sample in the Run.'};
doc['DataRun']['set_valueInterval']={syn:'Changes the number of seconds covered by each value in this run.',lib:'datarun.set_valueInterval()',pro:'def set_valueInterval(<span id=pn>valueInterval</span>)',cmt:'<p>Changes the number of seconds covered by each value in this run. By default, the value interval is set to the coarsest data rate archived in the data logger flash for this run. The value interval can however be configured at will to a different rate when desired. </p>',par:{valueInterval:'an integer number of seconds.'},ret:'nothing'};
//--- (end of generated code: DataRun)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'Recorded data sequence',inc:'from yocto_datalogger import *',cmt:'<p>DataStream objects represent a recorded measure sequence. They are returned by the data logger present on Yoctopuce sensors.</p>'}};
doc['DataStream']['get_columnCount']={syn:'Returns the number of data columns present in this stream.',lib:'datastream.get_columnCount()',pro:'def get_columnCount()',cmt:'<p>Returns the number of data columns present in this stream. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'an unsigned number corresponding to the number of rows. On failure, throws an exception or returns zero.'};
doc['DataStream']['get_columnNames']={syn:'Returns the title (or meaning) of each data column present in this stream.',lib:'datastream.get_columnNames()',pro:'def get_columnNames()',cmt:'<p>Returns the title (or meaning) of each data column present in this stream. In most case, the title of the data column is the hardware identifier of the sensor that produced the data. For archived streams created by summarizing a high-resolution data stream, there can be a suffix appended to the sensor identifier, such as _min for the minimum value, _avg for the average value and _max for the maximal value.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many strings as there are columns in the data stream. On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_data']={syn:'Returns a single measure from the data stream, specified by its row and column index.',lib:'datastream.get_data()',pro:'def get_data(<span id=pn>row</span>, <span id=pn>col</span>)',cmt:'<p>Returns a single measure from the data stream, specified by its row and column index. The meaning of the values present in each column can be obtained using the method get_columnNames().</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',par:{row:'row index',col:'column index'},ret:'a floating-point number On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Returns the whole data set contained in the stream, as a bidimensional table of numbers.',lib:'datastream.get_dataRows()',pro:'def get_dataRows()',cmt:'<p>Returns the whole data set contained in the stream, as a bidimensional table of numbers. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many elements as there are rows in the data stream. Each row itself is a list of floating-point numbers. On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_dataSamplesInterval']={syn:'Returns the number of seconds elapsed between two consecutive rows of this data stream.',lib:'datastream.get_dataSamplesInterval()',pro:'def get_dataSamplesInterval()',cmt:'<p>Returns the number of seconds elapsed between two consecutive rows of this data stream. By default, the data logger records one row per second, but there might be alternative streams at lower resolution created by summarizing the original stream for archiving purposes.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to a number of seconds.'};
doc['DataStream']['get_rowCount']={syn:'Returns the number of data rows present in this stream.',lib:'datastream.get_rowCount()',pro:'def get_rowCount()',cmt:'<p>Returns the number of data rows present in this stream.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'an unsigned number corresponding to the number of rows. On failure, throws an exception or returns zero.'};
doc['DataStream']['get_runIndex']={syn:'Returns the run index of the data stream.',lib:'datastream.get_runIndex()',pro:'def get_runIndex()',cmt:'<p>Returns the run index of the data stream. A run can be made of multiple datastreams, for different time intervals. This method does not cause any access to the device, as the value is preloaded in the object at instantiation time. </p>',ret:'an unsigned number corresponding to the run index.'};
doc['DataStream']['get_startTime']={syn:'Returns the start time of the data stream, relative to the beginning of the run.',lib:'datastream.get_startTime()',pro:'def get_startTime()',cmt:'<p>Returns the start time of the data stream, relative to the beginning of the run. If you need an absolute time, use <tt>get_startTimeUTC()</tt>.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to the number of seconds between the start of the run and the beginning of this data stream.'};
doc['DataStream']['get_startTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p><p> This method does not cause any access to the device, as the value is preloaded in the object at instantiation time.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
//--- (end of generated code: DataStream)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'from yocto_temperature import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Temperature']['FindTemperature']={syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature.FindTemperature()',pro:'def FindTemperature(<span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the temperature sensor'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'};
doc['Temperature']['FirstTemperature']={syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature.FirstTemperature()',pro:'def FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'temperature.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'temperature.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'temperature.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Returns the current measured value.',lib:'temperature.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'temperature.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Temperature']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'temperature.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Temperature']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'temperature.get_temperatureDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'temperature.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'temperature.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'temperature.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'temperature.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'temperature.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'temperature.get_sensorType()',pro:'def get_sensorType()',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt> and <tt>Y_SENSORTYPE_PT100_2WIRES</tt> corresponding to the temperature sensor type',ext:'On failure, throws an exception or returns <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'temperature.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Temperature']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'temperature.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Temperature']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'temperature.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['nextTemperature']={syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'temperature.nextTemperature()',pro:'def nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'};
doc['Temperature']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'temperature.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'temperature.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'temperature.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'temperature.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_sensorType']={syn:'Modify the temperature sensor type.',lib:'temperature.set_sensorType()',pro:'def set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Modify the temperature sensor type. This function is used to to define the type of thermocouple (K,E...) used with the device. This will have no effect if module is using a digital sensor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt> and <tt>Y_SENSORTYPE_PT100_2WIRES</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'temperature.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'from yocto_datalogger import *',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The Yoctopuce application programming interface includes functions to control how this internal data logger works. Beacause the sensors do not include a battery, they do not have an absolute time reference. Therefore, measures are simply indexed by the absolute run number and time relative to the start of the run. Every new power up starts a new run. It is however possible to setup an absolute UTC time by software at a given time, so that the data logger keeps track of it until it is next powered off.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger.FindDataLogger()',pro:'def FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the data logger'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'};
doc['DataLogger']['FirstDataLogger']={syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger.FirstDataLogger()',pro:'def FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'datalogger.forgetAllDataStreams()',pro:'def forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'datalogger.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'datalogger.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'datalogger.get_currentRunIndex()',pro:'def get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataRun']={syn:'Returns a data run object holding all measured data for a given period during which the module was turned on (a run).',lib:'datalogger.get_dataRun()',pro:'def get_dataRun(<span id=pn>runIdx</span>)',cmt:'<p>Returns a data run object holding all measured data for a given period during which the module was turned on (a run). This object can then be used to retrieve measures (min, average and max) at a desired data rate.</p>',par:{runIdx:'the index of the desired run'},ret:'an <tt>YDataRun</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'};
doc['DataLogger']['get_dataStreams']={syn:'Builds a list of all data streams hold by the data logger.',lib:'datalogger.get_dataStreams()',pro:'def get_dataStreams(<span id=pn>v</span>)',cmt:'<p>Builds a list of all data streams hold by the data logger. The caller must pass by reference an empty array to hold YDataStream objects, and the function fills it with objects describing available data sequences.</p>',par:{v:'an array of YDataStream objects to be filled in'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'datalogger.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['DataLogger']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'datalogger.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['DataLogger']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'datalogger.get_dataloggerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'datalogger.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'datalogger.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DataLogger']['get_oldestRunIndex']={syn:'Returns the index of the oldest run for which the non-volatile memory still holds recorded data.',lib:'datalogger.get_oldestRunIndex()',pro:'def get_oldestRunIndex()',cmt:'<p>Returns the index of the oldest run for which the non-volatile memory still holds recorded data.</p>',ret:'an integer corresponding to the index of the oldest run for which the non-volatile memory still holds recorded data',ext:'On failure, throws an exception or returns <tt>Y_OLDESTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'datalogger.get_recording()',pro:'def get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'datalogger.get_timeUTC()',pro:'def get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DataLogger']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'datalogger.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['DataLogger']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'datalogger.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['nextDataLogger']={syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'datalogger.nextDataLogger()',pro:'def nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'};
doc['DataLogger']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'datalogger.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'datalogger.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'datalogger.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'datalogger.set_recording()',pro:'def set_recording(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'datalogger.set_timeUTC()',pro:'def set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'datalogger.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'from yocto_dualpower import *',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Retrieves a dual power control for a given identifier.',lib:'YDualPower.FindDualPower()',pro:'def FindDualPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the power control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the power control is indeed online at a given time. In case of ambiguity when looking for a dual power control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the power control'},ret:'a <tt>YDualPower</tt> object allowing you to drive the power control.'};
doc['DualPower']['FirstDualPower']={syn:'Starts the enumeration of dual power controls currently accessible.',lib:'YDualPower.FirstDualPower()',pro:'def FirstDualPower()',cmt:'<p>Starts the enumeration of dual power controls currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power controls.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'dualpower.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'dualpower.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['DualPower']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'dualpower.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'dualpower.get_extVoltage()',pro:'def get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'dualpower.get_dualpowerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'dualpower.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'dualpower.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'dualpower.get_powerControl()',pro:'def get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'dualpower.get_powerState()',pro:'def get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> and <tt>Y_POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DualPower']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'dualpower.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['DualPower']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'dualpower.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['nextDualPower']={syn:'Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.',lib:'dualpower.nextDualPower()',pro:'def nextDualPower()',cmt:'<p>Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power control currently online, or a <tt>null</tt> pointer if there are no more dual power controls to enumerate.'};
doc['DualPower']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'dualpower.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'dualpower.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power control'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'dualpower.set_powerControl()',pro:'def set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'dualpower.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'from yocto_servo import *',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['FindServo']={syn:'Retrieves a servo for a given identifier.',lib:'YServo.FindServo()',pro:'def FindServo(<span id=pn>func</span>)',cmt:'<p>Retrieves a servo for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the servo is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the servo is indeed online at a given time. In case of ambiguity when looking for a servo by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the servo'},ret:'a <tt>YServo</tt> object allowing you to drive the servo.'};
doc['Servo']['FirstServo']={syn:'Starts the enumeration of servos currently accessible.',lib:'YServo.FirstServo()',pro:'def FirstServo()',cmt:'<p>Starts the enumeration of servos currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next servos.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first servo currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'servo.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'servo.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Servo']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'servo.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Servo']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'servo.get_servoDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'servo.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'servo.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'servo.get_neutral()',pro:'def get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'servo.get_position()',pro:'def get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'servo.get_range()',pro:'def get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Servo']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'servo.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Servo']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'servo.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'servo.move()',pro:'def move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['nextServo']={syn:'Continues the enumeration of servos started using <tt>yFirstServo()</tt>.',lib:'servo.nextServo()',pro:'def nextServo()',cmt:'<p>Continues the enumeration of servos started using <tt>yFirstServo()</tt>.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a servo currently online, or a <tt>null</tt> pointer if there are no more servos to enumerate.'};
doc['Servo']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'servo.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'servo.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the servo. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'servo.set_neutral()',pro:'def set_neutral(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'servo.set_position()',pro:'def set_position(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'servo.set_range()',pro:'def set_range(<span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'servo.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'from yocto_relay import *',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['FindRelay']={syn:'Retrieves a relay for a given identifier.',lib:'YRelay.FindRelay()',pro:'def FindRelay(<span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the relay'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'};
doc['Relay']['FirstRelay']={syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay.FirstRelay()',pro:'def FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'relay.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'relay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'relay.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'relay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Relay']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'relay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Relay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'relay.get_relayDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'relay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'relay.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'relay.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'relay.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'relay.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Relay']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'relay.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Relay']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'relay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Relay']['nextRelay']={syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'relay.nextRelay()',pro:'def nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'relay.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'relay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'relay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'relay.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'relay.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'relay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Relay)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'from yocto_humidity import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity.FindHumidity()',pro:'def FindHumidity(<span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the humidity sensor'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'};
doc['Humidity']['FirstHumidity']={syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity.FirstHumidity()',pro:'def FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'humidity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'humidity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'humidity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Returns the current measured value.',lib:'humidity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'humidity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Humidity']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'humidity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Humidity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'humidity.get_humidityDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'humidity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'humidity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'humidity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'humidity.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'humidity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'humidity.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Humidity']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'humidity.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Humidity']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'humidity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['nextHumidity']={syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'humidity.nextHumidity()',pro:'def nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'};
doc['Humidity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'humidity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'humidity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'humidity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'humidity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'humidity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'from yocto_pressure import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Pressure']['FindPressure']={syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure.FindPressure()',pro:'def FindPressure(<span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the pressure sensor'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'};
doc['Pressure']['FirstPressure']={syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure.FirstPressure()',pro:'def FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pressure.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'pressure.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'pressure.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Returns the current measured value.',lib:'pressure.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'pressure.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Pressure']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'pressure.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Pressure']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pressure.get_pressureDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'pressure.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'pressure.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'pressure.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pressure.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pressure.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'pressure.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Pressure']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'pressure.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Pressure']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'pressure.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['nextPressure']={syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'pressure.nextPressure()',pro:'def nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'};
doc['Pressure']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pressure.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pressure.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'pressure.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pressure.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pressure.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'from yocto_lightsensor import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor.FindLightSensor()',pro:'def FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the light sensor'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'};
doc['LightSensor']['FirstLightSensor']={syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor.FirstLightSensor()',pro:'def FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'lightsensor.calibrate()',pro:'def calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'lightsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'lightsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'lightsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'lightsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'lightsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['LightSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'lightsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['LightSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'lightsensor.get_lightsensorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'lightsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'lightsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'lightsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'lightsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'lightsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'lightsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['LightSensor']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'lightsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['LightSensor']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'lightsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['nextLightSensor']={syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'lightsensor.nextLightSensor()',pro:'def nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'};
doc['LightSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'lightsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'lightsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'lightsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'lightsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'lightsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: LightSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'from yocto_hubport import *'}};
doc['HubPort']['FindHubPort']={syn:'Retrieves a Yocto-hub port for a given identifier.',lib:'YHubPort.FindHubPort()',pro:'def FindHubPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a Yocto-hub port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the Yocto-hub port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the Yocto-hub port is indeed online at a given time. In case of ambiguity when looking for a Yocto-hub port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Yocto-hub port'},ret:'a <tt>YHubPort</tt> object allowing you to drive the Yocto-hub port.'};
doc['HubPort']['FirstHubPort']={syn:'Starts the enumeration of Yocto-hub ports currently accessible.',lib:'YHubPort.FirstHubPort()',pro:'def FirstHubPort()',cmt:'<p>Starts the enumeration of Yocto-hub ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next Yocto-hub ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first Yocto-hub port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'hubport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'hubport.get_baudRate()',pro:'def get_baudRate()',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:'On failure, throws an exception or returns <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'hubport.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'hubport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['HubPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'hubport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['HubPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'hubport.get_hubportDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port, which is always the serial number of the connected module.',lib:'hubport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Yocto-hub port, which is always the serial number of the connected module.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port, which is always the serial number of the connected module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'hubport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'hubport.get_portState()',pro:'def get_portState()',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> and <tt>Y_PORTSTATE_PROG</tt> corresponding to the current state of the Yocto-hub port',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['HubPort']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'hubport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['HubPort']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'hubport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['nextHubPort']={syn:'Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.',lib:'hubport.nextHubPort()',pro:'def nextHubPort()',cmt:'<p>Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a Yocto-hub port currently online, or a <tt>null</tt> pointer if there are no more Yocto-hub ports to enumerate.'};
doc['HubPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'hubport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'hubport.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the * connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_logicalName']={syn:'It is not possible to configure the logical name of a Yocto-hub port.',lib:'hubport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>It is not possible to configure the logical name of a Yocto-hub port. The logical name is automatically set to the serial number of the connected module.</p>',par:{newval:'a string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'hubport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'from yocto_anbutton import *',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton.FindAnButton()',pro:'def FindAnButton(<span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the analog input'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'};
doc['AnButton']['FirstAnButton']={syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton.FirstAnButton()',pro:'def FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'anbutton.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'anbutton.get_analogCalibration()',pro:'def get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'anbutton.get_calibratedValue()',pro:'def get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMax()',pro:'def get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMin()',pro:'def get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'anbutton.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['AnButton']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'anbutton.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['AnButton']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'anbutton.get_anbuttonDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'anbutton.get_isPressed()',pro:'def get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>Y_ISPRESSED_FALSE</tt> or <tt>Y_ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed).',lib:'anbutton.get_lastTimePressed()',pro:'def get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitionned from open to closed)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open).',lib:'anbutton.get_lastTimeReleased()',pro:'def get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitionned from closed to open)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'anbutton.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'anbutton.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value ',lib:'anbutton.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms) ',lib:'anbutton.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms)</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'anbutton.get_rawValue()',pro:'def get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.get_sensitivity()',pro:'def get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AnButton']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'anbutton.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['AnButton']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'anbutton.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['nextAnButton']={syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'anbutton.nextAnButton()',pro:'def nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'};
doc['AnButton']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'anbutton.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as his timer ',lib:'anbutton.resetCounter()',pro:'def resetCounter()',cmt:'<p>Returns the pulse counter value as well as his timer</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'anbutton.set_analogCalibration()',pro:'def set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMax()',pro:'def set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMin()',pro:'def set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'anbutton.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.set_sensitivity()',pro:'def set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'anbutton.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'from yocto_voltage import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage.FindVoltage()',pro:'def FindVoltage(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage sensor'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'};
doc['Voltage']['FirstVoltage']={syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage.FirstVoltage()',pro:'def FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voltage.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'voltage.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'voltage.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Returns the current measured value.',lib:'voltage.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'voltage.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Voltage']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'voltage.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Voltage']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltage.get_voltageDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'voltage.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'voltage.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'voltage.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltage.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voltage.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'voltage.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voltage']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'voltage.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Voltage']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'voltage.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['nextVoltage']={syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'voltage.nextVoltage()',pro:'def nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'};
doc['Voltage']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltage.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voltage.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'voltage.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voltage.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured values.',lib:'voltage.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltage.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'from yocto_current import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Current']['FindCurrent']={syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent.FindCurrent()',pro:'def FindCurrent(<span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the current sensor'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'};
doc['Current']['FirstCurrent']={syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent.FirstCurrent()',pro:'def FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'current.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'current.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'current.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Returns the current measured value.',lib:'current.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'current.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Current']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'current.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Current']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'current.get_currentDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'current.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'current.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'current.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'current.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'current.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'current.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Current']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'current.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Current']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'current.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Current']['nextCurrent']={syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'current.nextCurrent()',pro:'def nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'};
doc['Current']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'current.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'current.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'current.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'current.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured values.',lib:'current.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'current.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'from yocto_carbondioxide import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'def FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'def FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'carbondioxide.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'carbondioxide.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'carbondioxide.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current measured value.',lib:'carbondioxide.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'carbondioxide.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['CarbonDioxide']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'carbondioxide.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'carbondioxide.get_carbondioxideDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'carbondioxide.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'carbondioxide.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'carbondioxide.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'carbondioxide.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'carbondioxide.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'carbondioxide.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CarbonDioxide']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'carbondioxide.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'carbondioxide.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide.nextCarbonDioxide()',pro:'def nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'};
doc['CarbonDioxide']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'carbondioxide.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'carbondioxide.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'carbondioxide.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'carbondioxide.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'carbondioxide.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'from yocto_led import *',cmt:'<p>Yoctopuce application programming interface allows you not only to drive the intensity of the led, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['FindLed']={syn:'Retrieves a led for a given identifier.',lib:'YLed.FindLed()',pro:'def FindLed(<span id=pn>func</span>)',cmt:'<p>Retrieves a led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the led is indeed online at a given time. In case of ambiguity when looking for a led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the led'},ret:'a <tt>YLed</tt> object allowing you to drive the led.'};
doc['Led']['FirstLed']={syn:'Starts the enumeration of leds currently accessible.',lib:'YLed.FirstLed()',pro:'def FirstLed()',cmt:'<p>Starts the enumeration of leds currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next leds.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the led (no more than 6 characters).',lib:'led.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the led (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Returns the current led signaling mode.',lib:'led.get_blinking()',pro:'def get_blinking()',cmt:'<p>Returns the current led signaling mode.</p>',ret:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode',ext:'On failure, throws an exception or returns <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'led.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Led']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'led.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Led']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'led.get_ledDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the led.',lib:'led.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the led.</p>',ret:'a string corresponding to the logical name of the led',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Returns the current led intensity (in per cent).',lib:'led.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the current led intensity (in per cent).</p>',ret:'an integer corresponding to the current led intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'led.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Returns the current led state.',lib:'led.get_power()',pro:'def get_power()',cmt:'<p>Returns the current led state.</p>',ret:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the current led state',ext:'On failure, throws an exception or returns <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Led']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'led.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Led']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'led.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Led']['nextLed']={syn:'Continues the enumeration of leds started using <tt>yFirstLed()</tt>.',lib:'led.nextLed()',pro:'def nextLed()',cmt:'<p>Continues the enumeration of leds started using <tt>yFirstLed()</tt>.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a led currently online, or a <tt>null</tt> pointer if there are no more leds to enumerate.'};
doc['Led']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'led.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Led']['set_blinking']={syn:'Changes the current led signaling mode.',lib:'led.set_blinking()',pro:'def set_blinking(<span id=pn>newval</span>)',cmt:'<p>Changes the current led signaling mode.</p>',par:{newval:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the led.',lib:'led.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_luminosity']={syn:'Changes the current led intensity (in per cent).',lib:'led.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the current led intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current led intensity (in per cent)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_power']={syn:'Changes the state of the led.',lib:'led.set_power()',pro:'def set_power(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the led.</p>',par:{newval:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the state of the led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'led.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Led)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'from yocto_vsource import *',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['FindVSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YVSource.FindVSource()',pro:'def FindVSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YVSource</tt> object allowing you to drive the voltage source.'};
doc['VSource']['FirstVSource']={syn:'Starts the enumeration of voltage sources currently accessible.',lib:'YVSource.FirstVSource()',pro:'def FirstVSource()',cmt:'<p>Starts the enumeration of voltage sources currently accessible. Use the method <tt>YVSource.nextVSource()</tt> to iterate on next voltage sources.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to the first voltage source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'vsource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'vsource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['VSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'vsource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'vsource.get_extPowerFailure()',pro:'def get_extPowerFailure()',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>Y_EXTPOWERFAILURE_FALSE</tt> or <tt>Y_EXTPOWERFAILURE_TRUE</tt>, according to true if external power supply voltage is too low',ext:'On failure, throws an exception or returns <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'vsource.get_failure()',pro:'def get_failure()',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>Y_FAILURE_FALSE</tt> or <tt>Y_FAILURE_TRUE</tt>, according to true if the module is in failure mode',ext:'On failure, throws an exception or returns <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'vsource.get_vsourceDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'vsource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'vsource.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'vsource.get_overCurrent()',pro:'def get_overCurrent()',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>Y_OVERCURRENT_FALSE</tt> or <tt>Y_OVERCURRENT_TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'vsource.get_overHeat()',pro:'def get_overHeat()',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>Y_OVERHEAT_FALSE</tt> or <tt>Y_OVERHEAT_TRUE</tt>, according to TRUE if the module is overheating',ext:'On failure, throws an exception or returns <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'vsource.get_overLoad()',pro:'def get_overLoad()',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>Y_OVERLOAD_FALSE</tt> or <tt>Y_OVERLOAD_TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:'On failure, throws an exception or returns <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'vsource.get_regulationFailure()',pro:'def get_regulationFailure()',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>Y_REGULATIONFAILURE_FALSE</tt> or <tt>Y_REGULATIONFAILURE_TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:'On failure, throws an exception or returns <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'vsource.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VSource']['get_voltage']={syn:'Returns the voltage output command (mV) ',lib:'vsource.get_voltage()',pro:'def get_voltage()',cmt:'<p>Returns the voltage output command (mV)</p>',ret:'an integer corresponding to the voltage output command (mV)',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'vsource.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['VSource']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'vsource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['VSource']['nextVSource']={syn:'Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'def nextVSource()',cmt:'<p>Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more voltage sources to enumerate.'};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'vsource.pulse()',pro:'def pulse(<span id=pn>voltage</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'vsource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'vsource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'vsource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'vsource.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'vsource.voltageMove()',pro:'def voltageMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'from yocto_network import *',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork.FindNetwork()',pro:'def FindNetwork(<span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork.FirstNetwork()',pro:'def FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'network.callbackLogin()',pro:'def callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network.get_adminPassword()',pro:'def get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network.get_callbackCredentials()',pro:'def get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network.get_callbackEncoding()',pro:'def get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the maximum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMaxDelay()',pro:'def get_callbackMaxDelay()',cmt:'<p>Returns the maximum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'network.get_callbackMethod()',pro:'def get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMinDelay()',pro:'def get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network.get_callbackUrl()',pro:'def get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.get_discoverable()',pro:'def get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'network.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'network.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network.get_networkDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network.get_ipAddress()',pro:'def get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The adress may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface, corresponding to the network name of the module.',lib:'network.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the network interface, corresponding to the network name of the module.</p>',ret:'a string corresponding to the logical name of the network interface, corresponding to the network name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network.get_macAddress()',pro:'def get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.',lib:'network.get_poeCurrent()',pro:'def get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network.get_primaryDNS()',pro:'def get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network.get_readiness()',pro:'def get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected, For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network.get_router()',pro:'def get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network.get_secondaryDNS()',pro:'def get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network.get_subnetMask()',pro:'def get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'network.get_userPassword()',pro:'def get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.get_wwwWatchdogDelay()',pro:'def get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'network.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'network.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'def nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['ping']={syn:'Pings str_host to test the network connectivity.',lib:'network.ping()',pro:'def ping(<span id=pn>host</span>)',cmt:'<p>Pings str_host to test the network connectivity. Sends four requests ICMP ECHO_REQUEST from the module to the target str_host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST result.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network.set_adminPassword()',pro:'def set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network.set_callbackCredentials()',pro:'def set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network.set_callbackEncoding()',pro:'def set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the maximum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMaxDelay()',pro:'def set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'network.set_callbackMethod()',pro:'def set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMinDelay()',pro:'def set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'network.set_callbackUrl()',pro:'def set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.set_discoverable()',pro:'def set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface, corresponding to the network name of the module.',lib:'network.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface, corresponding to the network name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface, corresponding to the network name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network.set_primaryDNS()',pro:'def set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondarz name server to be used by the module.',lib:'network.set_secondaryDNS()',pro:'def set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondarz name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondarz name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network.set_userPassword()',pro:'def set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.set_wwwWatchdogDelay()',pro:'def set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disable automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network.useDHCP()',pro:'def useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network.useStaticIP()',pro:'def useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'from yocto_wireless import *'}};
doc['Wireless']['FindWireless']={syn:'Retrieves a wireless lan interface for a given identifier.',lib:'YWireless.FindWireless()',pro:'def FindWireless(<span id=pn>func</span>)',cmt:'<p>Retrieves a wireless lan interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the wireless lan interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless lan interface is indeed online at a given time. In case of ambiguity when looking for a wireless lan interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the wireless lan interface'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless lan interface.'};
doc['Wireless']['FirstWireless']={syn:'Starts the enumeration of wireless lan interfaces currently accessible.',lib:'YWireless.FirstWireless()',pro:'def FirstWireless()',cmt:'<p>Starts the enumeration of wireless lan interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless lan interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless lan interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'wireless.adhocNetwork()',pro:'def adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. If a security key is specified, the network is protected by WEP128, since WPA is not standardized for ad-hoc networks. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'wireless.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Returns the 802.',lib:'wireless.get_channel()',pro:'def get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802',ext:'On failure, throws an exception or returns <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects which describe detected Wireless networks.',lib:'wireless.get_detectedWlans()',pro:'def get_detectedWlans()',cmt:'<p>Returns a list of YWlanRecord objects which describe detected Wireless networks. This list is not updated when the module is already connected to an acces point (infrastructure mode). To force an update of this list, <tt>adhocNetwork()</tt> must be called to disconnect the module from the current network. The returned list must be unallocated by caller, </p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Wireless']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'wireless.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Wireless']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'wireless.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Wireless']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wireless.get_wirelessDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in per cents.',lib:'wireless.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the link quality, expressed in per cents.</p>',ret:'an integer corresponding to the link quality, expressed in per cents',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'wireless.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Returns the last status message from the wireless interface.',lib:'wireless.get_message()',pro:'def get_message()',cmt:'<p>Returns the last status message from the wireless interface.</p>',ret:'a string corresponding to the last status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wireless.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'wireless.get_security()',pro:'def get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> and <tt>Y_SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'wireless.get_ssid()',pro:'def get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Wireless']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'wireless.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'wireless.joinNetwork()',pro:'def joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'wireless.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['nextWireless']={syn:'Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.',lib:'wireless.nextWireless()',pro:'def nextWireless()',cmt:'<p>Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless lan interface currently online, or a <tt>null</tt> pointer if there are no more wireless lan interfaces to enumerate.'};
doc['Wireless']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wireless.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'wireless.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless lan interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wireless.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'from yocto_voc import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Voc']['FindVoc']={syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc.FindVoc()',pro:'def FindVoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'};
doc['Voc']['FirstVoc']={syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc.FirstVoc()',pro:'def FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'voc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Returns the unrounded and uncalibrated raw value returned by the sensor.',lib:'voc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the unrounded and uncalibrated raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the unrounded and uncalibrated raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Returns the current measured value.',lib:'voc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'voc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Voc']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'voc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Voc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voc.get_vocDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'voc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'voc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'voc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voc.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'voc.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voc']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'voc.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Voc']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'voc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Voc']['nextVoc']={syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'voc.nextVoc()',pro:'def nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'};
doc['Voc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'voc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'from yocto_watchdog import *',cmt:'<p>The watchog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog.FindWatchdog()',pro:'def FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the watchdog'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog.FirstWatchdog()',pro:'def FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'watchdog.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'watchdog.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog runing state at module power up.',lib:'watchdog.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the watchdog runing state at module power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runing state at module power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'watchdog.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'watchdog.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Watchdog']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'watchdog.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Watchdog']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'watchdog.get_watchdogDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'watchdog.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'watchdog.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'watchdog.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'watchdog.get_running()',pro:'def get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDelay()',pro:'def get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDuration()',pro:'def get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Watchdog']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'watchdog.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Watchdog']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'watchdog.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['nextWatchdog']={syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'watchdog.nextWatchdog()',pro:'def nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'watchdog.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'watchdog.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'watchdog.resetWatchdog()',pro:'def resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchog to trigger</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog runningsttae at module power up.',lib:'watchdog.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the watchdog runningsttae at module power up. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runningsttae at module power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'watchdog.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'watchdog.set_running()',pro:'def set_running(<span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDelay()',pro:'def set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDuration()',pro:'def set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'watchdog.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'from yocto_power import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['Power']['FindPower']={syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower.FindPower()',pro:'def FindPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'};
doc['Power']['FirstPower']={syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower.FirstPower()',pro:'def FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'power.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'power.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'power.get_cosPhi()',pro:'def get_cosPhi()',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:'On failure, throws an exception or returns <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'power.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Returns the current measured value.',lib:'power.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'power.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Power']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'power.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Power']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'power.get_powerDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'power.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'power.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'power.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'power.get_meter()',pro:'def get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'power.get_meterTimer()',pro:'def get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'power.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'power.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'power.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Power']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'power.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Power']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'power.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Power']['nextPower']={syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'power.nextPower()',pro:'def nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'};
doc['Power']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'power.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'power.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'power.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'power.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured values.',lib:'power.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'power.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'from yocto_display import *',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Retrieves a display for a given identifier.',lib:'YDisplay.FindDisplay()',pro:'def FindDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the display'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'};
doc['Display']['FirstDisplay']={syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay.FirstDisplay()',pro:'def FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'display.copyLayerContent()',pro:'def copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'display.fade()',pro:'def fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'display.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'display.get_brightness()',pro:'def get_brightness()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'display.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'display.get_displayType()',pro:'def get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> and <tt>Y_DISPLAYTYPE_RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'display.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'display.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Display']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'display.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Display']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'display.get_displayDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'display.get_layerCount()',pro:'def get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'display.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'display.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'display.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'display.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'display.get_orientation()',pro:'def get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_powerState']={syn:'Returns the power state of the display.',lib:'display.get_powerState()',pro:'def get_powerState()',cmt:'<p>Returns the power state of the display.</p>',ret:'either <tt>Y_POWERSTATE_OFF</tt> or <tt>Y_POWERSTATE_ON</tt>, according to the power state of the display',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'display.get_startupSeq()',pro:'def get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Display']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'display.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Display']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'display.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'display.newSequence()',pro:'def newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['nextDisplay']={syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'display.nextDisplay()',pro:'def nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'display.pauseSequence()',pro:'def pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'def playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'display.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'display.resetAll()',pro:'def resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'display.saveSequence()',pro:'def saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'display.set_brightness()',pro:'def set_brightness(<span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'display.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'display.set_orientation()',pro:'def set_orientation(<span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_powerState']={syn:'Changes the power state of the display.',lib:'display.set_powerState()',pro:'def set_powerState(<span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>Y_POWERSTATE_OFF</tt> or <tt>Y_POWERSTATE_ON</tt>, according to the power state of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'display.set_startupSeq()',pro:'def set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'display.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'display.stopSequence()',pro:'def stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'display.swapLayerContent()',pro:'def swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between onae hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'display.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'from yocto_display import *',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'displaylayer.clear()',pro:'def clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'displaylayer.clearConsole()',pro:'def clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'displaylayer.consoleOut()',pro:'def consoleOut(<span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'displaylayer.drawBar()',pro:'def drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'displaylayer.drawBitmap()',pro:'def drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'displaylayer.drawCircle()',pro:'def drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'displaylayer.drawDisc()',pro:'def drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'displaylayer.drawImage()',pro:'def drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'displaylayer.drawPixel()',pro:'def drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'displaylayer.drawRect()',pro:'def drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'displaylayer.drawText()',pro:'def drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text ancor point, in pixels',y:'the distance from top of layer to the text ancor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['get_display']={syn:'Gets parent YDisplay.',lib:'displaylayer.get_display()',pro:'def get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'displaylayer.hide()',pro:'def hide()',cmt:'<p>Hides the layer. The state of the layer is perserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'displaylayer.lineTo()',pro:'def lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'displaylayer.moveTo()',pro:'def moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'displaylayer.reset()',pro:'def reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectColorPen()',pro:'def selectColorPen(<span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for text drawing and bitmap copy functions.',lib:'displaylayer.selectEraser()',pro:'def selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for text drawing and bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'displaylayer.selectFont()',pro:'def selectFont(<span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectGrayPen()',pro:'def selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lighest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'displaylayer.setAntialiasingMode()',pro:'def setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzzyness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<t>true</t> to enable antialiasing, <t>false</t> to disable it.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'displaylayer.setConsoleBackground()',pro:'def setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleMargins()',pro:'def setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleWordWrap()',pro:'def setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'displaylayer.setLayerPosition()',pro:'def setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'displaylayer.unhide()',pro:'def unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'from yocto_files import *',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['FindFiles']={syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles.FindFiles()',pro:'def FindFiles(<span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the filesystem'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'};
doc['Files']['FirstFiles']={syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles.FirstFiles()',pro:'def FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'files.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'};
doc['Files']['format_fs']={syn:'Reinitializes the filesystem to its clean, unfragmented, empty state.',lib:'files.format_fs()',pro:'def format_fs()',cmt:'<p>Reinitializes the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'files.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'files.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['Files']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'files.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'files.get_filesCount()',pro:'def get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'files.get_freeSpace()',pro:'def get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'files.get_filesDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'files.get_list()',pro:'def get_list(<span id=pn>pattern</span>)',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wildcards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'files.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'files.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Files']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'files.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['Files']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'files.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Files']['nextFiles']={syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'files.nextFiles()',pro:'def nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'};
doc['Files']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'files.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'files.remove()',pro:'def remove(<span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'files.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'files.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'files.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'from yocto_realtimeclock import *',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Retrieves a clock for a given identifier.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'def FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Retrieves a clock for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the clock is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRealTimeClock.isOnline()</tt> to test if the clock is indeed online at a given time. In case of ambiguity when looking for a clock by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the clock'},ret:'a <tt>YRealTimeClock</tt> object allowing you to drive the clock.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Starts the enumeration of clocks currently accessible.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'def FirstRealTimeClock()',cmt:'<p>Starts the enumeration of clocks currently accessible. Use the method <tt>YRealTimeClock.nextRealTimeClock()</tt> to iterate on next clocks.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to the first clock currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'realtimeclock.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22 ',lib:'realtimeclock.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'realtimeclock.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['RealTimeClock']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'realtimeclock.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'realtimeclock.get_realtimeclockDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'realtimeclock.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'realtimeclock.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'realtimeclock.get_timeSet()',pro:'def get_timeSet()',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>Y_TIMESET_FALSE</tt> or <tt>Y_TIMESET_TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'realtimeclock.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'realtimeclock.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'realtimeclock.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['RealTimeClock']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'realtimeclock.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.',lib:'realtimeclock.nextRealTimeClock()',pro:'def nextRealTimeClock()',cmt:'<p>Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to a clock currently online, or a <tt>null</tt> pointer if there are no more clocks to enumerate.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'realtimeclock.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'realtimeclock.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the clock. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the clock'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'realtimeclock.set_unixTime()',pro:'def set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970). If current UTC time is known, utcOffset will be automatically adjusted for the new specified time.</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'realtimeclock.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time will automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'from yocto_wakeupmonitor import *'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Retrieves a monitor for a given identifier.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'def FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Retrieves a monitor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the monitor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpMonitor.isOnline()</tt> to test if the monitor is indeed online at a given time. In case of ambiguity when looking for a monitor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the monitor'},ret:'a <tt>YWakeUpMonitor</tt> object allowing you to drive the monitor.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Starts the enumeration of monitors currently accessible.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'def FirstWakeUpMonitor()',cmt:'<p>Starts the enumeration of monitors currently accessible. Use the method <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> to iterate on next monitors.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to the first monitor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'wakeupmonitor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'wakeupmonitor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['WakeUpMonitor']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'wakeupmonitor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupmonitor.get_wakeupmonitorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'wakeupmonitor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupmonitor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Returns the next scheduled wake-up date/time (UNIX format) ',lib:'wakeupmonitor.get_nextWakeUp()',pro:'def get_nextWakeUp()',cmt:'<p>Returns the next scheduled wake-up date/time (UNIX format)</p>',ret:'an integer corresponding to the next scheduled wake-up date/time (UNIX format)',ext:'On failure, throws an exception or returns <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (seconds) before going to sleep automatically.',lib:'wakeupmonitor.get_powerDuration()',pro:'def get_powerDuration()',cmt:'<p>Returns the maximal wake up time (seconds) before going to sleep automatically.</p>',ret:'an integer corresponding to the maximal wake up time (seconds) before going to sleep automatically',ext:'On failure, throws an exception or returns <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before next sleep.',lib:'wakeupmonitor.get_sleepCountdown()',pro:'def get_sleepCountdown()',cmt:'<p>Returns the delay before next sleep.</p>',ret:'an integer corresponding to the delay before next sleep',ext:'On failure, throws an exception or returns <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupmonitor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Return the last wake up reason.',lib:'wakeupmonitor.get_wakeUpReason()',pro:'def get_wakeUpReason()',cmt:'<p>Return the last wake up reason.</p>',ret:'a value among <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_EXTSIG2</tt>, <tt>Y_WAKEUPREASON_EXTSIG3</tt>, <tt>Y_WAKEUPREASON_EXTSIG4</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE2</tt>, <tt>Y_WAKEUPREASON_SCHEDULE3</tt>, <tt>Y_WAKEUPREASON_SCHEDULE4</tt>, <tt>Y_WAKEUPREASON_SCHEDULE5</tt> and <tt>Y_WAKEUPREASON_SCHEDULE6</tt>',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Returns the current state of the monitor ',lib:'wakeupmonitor.get_wakeUpState()',pro:'def get_wakeUpState()',cmt:'<p>Returns the current state of the monitor</p>',ret:'either <tt>Y_WAKEUPSTATE_SLEEPING</tt> or <tt>Y_WAKEUPSTATE_AWAKE</tt>, according to the current state of the monitor',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'wakeupmonitor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpMonitor']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'wakeupmonitor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.',lib:'wakeupmonitor.nextWakeUpMonitor()',pro:'def nextWakeUpMonitor()',cmt:'<p>Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to a monitor currently online, or a <tt>null</tt> pointer if there are no more monitors to enumerate.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupmonitor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Reset the sleep countdown.',lib:'wakeupmonitor.resetSleepCountDown()',pro:'def resetSleepCountDown()',cmt:'<p>Reset the sleep countdown.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'wakeupmonitor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the monitor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the monitor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week where a wake up must take place.',lib:'wakeupmonitor.set_nextWakeUp()',pro:'def set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week where a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before going to sleep automatically.',lib:'wakeupmonitor.set_powerDuration()',pro:'def set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal wake up time (seconds) before going to sleep automatically.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before going to sleep automatically'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before next sleep.',lib:'wakeupmonitor.set_sleepCountdown()',pro:'def set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Changes the delay before next sleep.</p>',par:{newval:'an integer corresponding to the delay before next sleep'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupmonitor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpMonitor']['sleep']={syn:'Go to sleep until the next wakeup condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleep()',pro:'def sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until the next wakeup condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepFor']={syn:'Go to sleep for a specific time or until the next wakeup condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepFor()',pro:'def sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep for a specific time or until the next wakeup condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'sleep duration, in secondes',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wakeup condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepUntil()',pro:'def sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until a specific date is reached or until the next wakeup condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wakeup.',lib:'wakeupmonitor.wakeUp()',pro:'def wakeUp()',cmt:'<p>Forces a wakeup.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'from yocto_wakeupschedule import *',cmt:'<p>The WakeUpSchedule function implements a wake-up condition. The wake-up time is specified as a set of months and/or days and/or hours and/or minutes where the wake-up should happen.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Retrieves a wake-up schedule for a given identifier.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'def FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Retrieves a wake-up schedule for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the wake-up schedule is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpSchedule.isOnline()</tt> to test if the wake-up schedule is indeed online at a given time. In case of ambiguity when looking for a wake-up schedule by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the wake-up schedule'},ret:'a <tt>YWakeUpSchedule</tt> object allowing you to drive the wake-up schedule.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Starts the enumeration of wake-up schedules currently accessible.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'def FirstWakeUpSchedule()',cmt:'<p>Starts the enumeration of wake-up schedules currently accessible. Use the method <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> to iterate on next wake-up schedules.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to the first wake-up schedule currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake-up schedule (no more than 6 characters).',lib:'wakeupschedule.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wake-up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake-up schedule (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'wakeupschedule.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['WakeUpSchedule']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'wakeupschedule.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupschedule.get_wakeupscheduleDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake-up.',lib:'wakeupschedule.get_hours()',pro:'def get_hours()',cmt:'<p>Returns the hours scheduled for wake-up.</p>',ret:'an integer corresponding to the hours scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake-up schedule.',lib:'wakeupschedule.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wake-up schedule.</p>',ret:'a string corresponding to the logical name of the wake-up schedule',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns every the minutes of each hour scheduled for wake-up.',lib:'wakeupschedule.get_minutes()',pro:'def get_minutes()',cmt:'<p>Returns every the minutes of each hour scheduled for wake-up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes 00-29 of each hour scheduled for wake-up.',lib:'wakeupschedule.get_minutesA()',pro:'def get_minutesA()',cmt:'<p>Returns the minutes 00-29 of each hour scheduled for wake-up.</p>',ret:'an integer corresponding to the minutes 00-29 of each hour scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes 30-59 of each hour scheduled for wake-up.',lib:'wakeupschedule.get_minutesB()',pro:'def get_minutesB()',cmt:'<p>Returns the minutes 30-59 of each hour scheduled for wake-up.</p>',ret:'an integer corresponding to the minutes 30-59 of each hour scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupschedule.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of week scheduled for wake-up.',lib:'wakeupschedule.get_monthDays()',pro:'def get_monthDays()',cmt:'<p>Returns the days of week scheduled for wake-up.</p>',ret:'an integer corresponding to the days of week scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Returns the days of week scheduled for wake-up.',lib:'wakeupschedule.get_months()',pro:'def get_months()',cmt:'<p>Returns the days of week scheduled for wake-up.</p>',ret:'an integer corresponding to the days of week scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Returns the nextwake up date/time (seconds) wake up occurence ',lib:'wakeupschedule.get_nextOccurence()',pro:'def get_nextOccurence()',cmt:'<p>Returns the nextwake up date/time (seconds) wake up occurence</p>',ret:'an integer corresponding to the nextwake up date/time (seconds) wake up occurence',ext:'On failure, throws an exception or returns <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupschedule.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of week scheduled for wake-up.',lib:'wakeupschedule.get_weekDays()',pro:'def get_weekDays()',cmt:'<p>Returns the days of week scheduled for wake-up.</p>',ret:'an integer corresponding to the days of week scheduled for wake-up',ext:'On failure, throws an exception or returns <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'wakeupschedule.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpSchedule']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'wakeupschedule.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continues the enumeration of wake-up schedules started using <tt>yFirstWakeUpSchedule()</tt>.',lib:'wakeupschedule.nextWakeUpSchedule()',pro:'def nextWakeUpSchedule()',cmt:'<p>Continues the enumeration of wake-up schedules started using <tt>yFirstWakeUpSchedule()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to a wake-up schedule currently online, or a <tt>null</tt> pointer if there are no more wake-up schedules to enumerate.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupschedule.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours where a wake up must take place.',lib:'wakeupschedule.set_hours()',pro:'def set_hours(<span id=pn>newval</span>)',cmt:'<p>Changes the hours where a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake-up schedule.',lib:'wakeupschedule.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake-up schedule. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake-up schedule'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'wakeupschedule.set_minutes()',pro:'def set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake-up.,'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes 00-29 where a wake up must take place.',lib:'wakeupschedule.set_minutesA()',pro:'def set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes 00-29 where a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes 00-29 where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes 30-59 where a wake up must take place.',lib:'wakeupschedule.set_minutesB()',pro:'def set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes 30-59 where a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes 30-59 where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the week where a wake up must take place.',lib:'wakeupschedule.set_monthDays()',pro:'def set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week where a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_months']={syn:'Changes the days of the week where a wake up must take place.',lib:'wakeupschedule.set_months()',pro:'def set_months(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week where a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupschedule.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week where a wake up must take place.',lib:'wakeupschedule.set_weekDays()',pro:'def set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week where a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week where a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'from yocto_genericsensor import *',cmt:'<p>The Yoctopuce application programming interface allows you to read an instant measure of the sensor, as well as the minimal and maximal values observed.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Retrieves a generic sensor for a given identifier.',lib:'YGenericSensor.FindGenericSensor()',pro:'def FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a generic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the generic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGenericSensor.isOnline()</tt> to test if the generic sensor is indeed online at a given time. In case of ambiguity when looking for a generic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the generic sensor'},ret:'a <tt>YGenericSensor</tt> object allowing you to drive the generic sensor.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Starts the enumeration of generic sensors currently accessible.',lib:'YGenericSensor.FirstGenericSensor()',pro:'def FirstGenericSensor()',cmt:'<p>Starts the enumeration of generic sensors currently accessible. Use the method <tt>YGenericSensor.nextGenericSensor()</tt> to iterate on next generic sensors.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to the first generic sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'genericsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'genericsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'genericsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'genericsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'genericsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['GenericSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'genericsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'genericsensor.get_genericsensorDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed.',lib:'genericsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed.</p>',ret:'a floating point number corresponding to the maximal value observed',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'genericsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed.',lib:'genericsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed.</p>',ret:'a floating point number corresponding to the minimal value observed',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'genericsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'genericsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the values, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'genericsensor.get_signalRange()',pro:'def get_signalRange()',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'genericsensor.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Returns the measured value of the electrical signal used by the sensor.',lib:'genericsensor.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Returns the measured value of the electrical signal used by the sensor.</p>',ret:'a floating point number corresponding to the measured value of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'genericsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string corresponding to the measuring unit for the measured value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'genericsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'genericsensor.get_valueRange()',pro:'def get_valueRange()',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'genericsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['GenericSensor']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'genericsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.',lib:'genericsensor.nextGenericSensor()',pro:'def nextGenericSensor()',cmt:'<p>Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to a generic sensor currently online, or a <tt>null</tt> pointer if there are no more generic sensors to enumerate.'};
doc['GenericSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'genericsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'genericsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'genericsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the generic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'genericsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'genericsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'genericsensor.set_signalRange()',pro:'def set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal range used by the sensor.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'genericsensor.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'genericsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'genericsensor.set_valueRange()',pro:'def set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Changes the physical value range measured by the sensor. The range change may have a side effect on the display resolution, as it may be adapted automatically.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'from yocto_oscontrol import *',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Retrieves OS control for a given identifier.',lib:'YOsControl.FindOsControl()',pro:'def FindOsControl(<span id=pn>func</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the OS control'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'};
doc['OsControl']['FirstOsControl']={syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl.FirstOsControl()',pro:'def FirstOsControl()',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'oscontrol.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'oscontrol.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['OsControl']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'oscontrol.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['OsControl']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'oscontrol.get_oscontrolDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control, corresponding to the network name of the module.',lib:'oscontrol.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the OS control, corresponding to the network name of the module.</p>',ret:'a string corresponding to the logical name of the OS control, corresponding to the network name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'oscontrol.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'oscontrol.get_shutdownCountdown()',pro:'def get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['OsControl']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'oscontrol.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['OsControl']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'oscontrol.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['nextOsControl']={syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'oscontrol.nextOsControl()',pro:'def nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'};
doc['OsControl']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'oscontrol.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'oscontrol.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'oscontrol.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'oscontrol.shutdown()',pro:'def shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: OsControl)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 } 	 

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);  
 }	  
 
function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);  
 }	  

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 } 
 
function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }
 
function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist." 
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 } 
 
function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."  
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }
 
function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."  
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."  
    it.style.top  = parseInt(t) + "px";
 } 

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."  
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }
 
function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }
 
function computeWinWH()
 { WinW             = GetWindowWidth() ;  
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight(); 
   if (WinH<400) WinH=400;
} 

 
 function getInnerHeight()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );  
 }		
 
 function getInnerWidth()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct) 
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct; 
  }
  
function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++) 
      resizeCallBacks[i]();
  }  

function jsQuote(str_in) 
{ str_in = str_in+'';
  var str_out   = ''; 
  for (i=0;i<str_in.length;i++) 
   { 
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else 
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex; 
      }  
   } 
   return str_out; 
  }  
 

function resizeMargin()
 { 
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 } 
 
function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110); 
 }
 
function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 } 
 
function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches) 
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }  
  return new positionObject(x,y);
 } 
 
  
function EnableDrag(var_element,onDragMove,onDragEnd)
  {  
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y   
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }  
   else 
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);
       
   if (onDragMove)  var_element.onDragMove = onDragMove;    
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;    
  }
  
 var LastDraggedObject = null;  
  
 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos) 
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;    
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;
   
   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }
   
   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }
      
   if (event.preventDefault)   event.preventDefault();  
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source, 
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else  
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    } 
   document.onmouseup   =   Drag_stopMouseCapture;
 } 
 
 
function Drag_mouseCapture(event)
 { 
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault(); 

 
   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y); 
   
   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;
   
   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;
   
   var p = {x:x,y:y};
  
   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);
    
   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;
    
   lastDraggedObject.element.style.left = p.x+"px";  
   lastDraggedObject.element.style.top  = p.y+"px";  
 }

function Drag_stopMouseCapture()
 { 
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent) 
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }
 
  if (lastDraggedObject) 
    { lastDraggedObject.element.style.cursor='col-resize';   
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }  
 
 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin() 
  }
  
 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  { 
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }
  
    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex; 
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par) 
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'   
          }      

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }              
        
         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }      
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml; 
  } 
  
  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else  
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }    
  } 
  
 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname) 
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'>&nbsp;<img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";
        
       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }  
       }
       marginhtml = marginhtml+'</div>'  
    }
  
    document.getElementById("MarginLayer").innerHTML = marginhtml; 
  }
  
 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()
    
    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }
    
    for (var i=0;i<tosearch.length;i++) 
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }            
          
          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }              
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;    
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;
          
          if (!found) return false;
       }       
    
  
    return true;

  }
 
 var searchTimer = null; 
 
 function doSearch()
  { searchTimer = null; 
    var value= document.forms['yoctoForm'].elements['search'].value;
    
    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           } 
          container["originalDisplay"]=null;           
        }
        Show(lastindex_shown,lastname_shown);
       return;        
      }   
      
    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');  
       for (var method in doc[classname])
       
         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}        
                 } 
              else 
                 { if (it) it.style.display="none";
                 } 
         } 
        
      if  (matchfound) 
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }
   
    Show(firstindex,firstname); 
        
    
  }
  
 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }  
  
 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown); 
    Show(lastindex_shown,lastname_shown); 

  }
  

 
 
 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form> 
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" language="javascript1.5"> 
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);  
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" checked onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;
   
 
 }
doc = sortObject(doc);
ShowFunctions(); 
Show(doc["YAPI"]?"YAPI":"Module",""); 


window.onresize = windowResized;  
-->  
</script>

</BODY>


</HEAD>

