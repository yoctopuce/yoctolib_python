<HTML>
<HEAD>
<title>Python API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-python-EN.html 20166 2015-04-27 14:22:50Z seb $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-python-EN.html 20166 2015-04-27 14:22:50Z seb $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: Module)
var Language='Python';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=false;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI.RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'YAPI.FILE_NOT_FOUND',null:'None'};
doc['Module']={'':{syn:'Module control interface',inc:'from yocto_api import *',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule.FindModule()',pro:'def FindModule(<span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule.FirstModule()',pro:'def FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'module.checkFirmware()',pro:'def checkFirmware(<span id=pn>path</span>, <span id=pn>onlynew</span>)',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate byn file. If the parameter onlynew is true, the function discards firmware that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:': the path of the byn file to use or a empty string if no byn files matches the requirement',ext:'On failure, throws an exception or returns a string that start with \x22error:\x22.'};
doc['Module']['describe']={syn:'Returns a descriptive text that identifies the module.',lib:'module.describe()',pro:'def describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'module.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module.functionCount()',pro:'def functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module.functionId()',pro:'def functionId(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module.functionName()',pro:'def functionName(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module.functionValue()',pro:'def functionValue(<span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_allSettings']={syn:'Returns all the settings of the module.',lib:'module.get_allSettings()',pro:'def get_allSettings()',cmt:'<p>Returns all the settings of the module. Useful to backup all the logical names and calibrations parameters of a connected module.</p>',ret:'a binary buffer with all the settings.',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module.get_beacon()',pro:'def get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the latest error with this module object.',lib:'module.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the latest error with this module object.',lib:'module.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module.get_firmwareRelease()',pro:'def get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'module.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module.get_icon2d()',pro:'def get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'module.get_lastLogs()',pro:'def get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'module.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module.get_persistentSettings()',pro:'def get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module.get_productId()',pro:'def get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module.get_productName()',pro:'def get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module.get_productRelease()',pro:'def get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module.get_rebootCountdown()',pro:'def get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module.get_serialNumber()',pro:'def get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module.get_upTime()',pro:'def get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module.get_usbCurrent()',pro:'def get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module.get_userVar()',pro:'def get_userVar()',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:'On failure, throws an exception or returns <tt>Y_USERVAR_INVALID</tt>.'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'def nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module.reboot()',pro:'def reboot(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['registerLogCallback']={syn:'Registers a device log callback function.',lib:'module.registerLogCallback()',pro:'def registerLogCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a device log callback function. This callback will be called each time that a module sends a new log message. Mostly useful to debug a Yoctopuce module.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the module object that emitted the log message, and the character string containing the log.'}};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module.revertFromFlash()',pro:'def revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module.saveToFlash()',pro:'def saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the module.',lib:'module.set_allSettings()',pro:'def set_allSettings(<span id=pn>settings</span>)',cmt:'<p>Restores all the settings of the module. Useful to restore all the logical names and calibrations parameters of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module.set_beacon()',pro:'def set_beacon(<span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['set_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module.set_userVar()',pro:'def set_userVar(<span id=pn>newval</span>)',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module.triggerFirmwareUpdate()',pro:'def triggerFirmwareUpdate(<span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'module.updateFirmware()',pro:'def updateFirmware(<span id=pn>path</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the byn file to use.'},ret:': A <tt>YFirmwareUpdate</tt> object.'};
//--- (end of generated code: Module)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'from yocto_colorled import *',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color led using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a led with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Retrieves an RGB led for a given identifier.',lib:'YColorLed.FindColorLed()',pro:'def FindColorLed(<span id=pn>func</span>)',cmt:'<p>Retrieves an RGB led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB led is indeed online at a given time. In case of ambiguity when looking for an RGB led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the RGB led'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB led.'};
doc['ColorLed']['FirstColorLed']={syn:'Starts the enumeration of RGB leds currently accessible.',lib:'YColorLed.FirstColorLed()',pro:'def FirstColorLed()',cmt:'<p>Starts the enumeration of RGB leds currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB leds.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'colorled.addHslMoveToBlinkSeq()',pro:'def addHslMoveToBlinkSeq(<span id=pn>HSLcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the traisntion is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the RGB space.',lib:'colorled.addRgbMoveToBlinkSeq()',pro:'def addRgbMoveToBlinkSeq(<span id=pn>RGBcolor</span>, <span id=pn>msDelay</span>)',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the RGB led in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB led in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB led (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB led (no more than 6 characters).',lib:'colorled.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the RGB led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB led (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of the blinking sequence ',lib:'colorled.get_blinkSeqMaxSize()',pro:'def get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of the blinking sequence</p>',ret:'an integer corresponding to the maximum length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Return the blinking sequence signature.',lib:'colorled.get_blinkSeqSignature()',pro:'def get_blinkSeqSignature()',cmt:'<p>Return the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIGNATURE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSize']={syn:'Returns the current length of the blinking sequence ',lib:'colorled.get_blinkSeqSize()',pro:'def get_blinkSeqSize()',cmt:'<p>Returns the current length of the blinking sequence</p>',ret:'an integer corresponding to the current length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIZE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Returns the error message of the latest error with the RGB led.',lib:'colorled.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB led. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB led object'};
doc['ColorLed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the RGB led.',lib:'colorled.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB led. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB led object'};
doc['ColorLed']['get_friendlyName']={syn:'Returns a global identifier of the RGB led in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorled.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB led in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB led if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB led (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB led using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorled.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLed']['get_functionId']={syn:'Returns the hardware identifier of the RGB led, without reference to the module.',lib:'colorled.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB led, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB led (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the RGB led in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorled.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB led in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB led (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB led (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the led.',lib:'colorled.get_hslColor()',pro:'def get_hslColor()',cmt:'<p>Returns the current HSL color of the led.</p>',ret:'an integer corresponding to the current HSL color of the led',ext:'On failure, throws an exception or returns <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB led.',lib:'colorled.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the RGB led.</p>',ret:'a string corresponding to the logical name of the RGB led.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorled.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the led.',lib:'colorled.get_rgbColor()',pro:'def get_rgbColor()',cmt:'<p>Returns the current RGB color of the led.</p>',ret:'an integer corresponding to the current RGB color of the led',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'def get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'colorled.hslMove()',pro:'def hslMove(<span id=pn>hsl_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['isOnline']={syn:'Checks if the RGB led is currently reachable, without raising any error.',lib:'colorled.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the RGB led is currently reachable, without raising any error. If there is a cached value for the RGB led in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB led.</p>',ret:'<tt>true</tt> if the RGB led can be reached, and <tt>false</tt> otherwise'};
doc['ColorLed']['load']={syn:'Preloads the RGB led cache with a specified validity duration.',lib:'colorled.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB led cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['nextColorLed']={syn:'Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.',lib:'colorled.nextColorLed()',pro:'def nextColorLed()',cmt:'<p>Continues the enumeration of RGB leds started using <tt>yFirstColorLed()</tt>.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB led currently online, or a <tt>null</tt> pointer if there are no more RGB leds to enumerate.'};
doc['ColorLed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorled.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLed']['resetBlinkSeq']={syn:'Resets the preprogrammed blinking sequence.',lib:'colorled.resetBlinkSeq()',pro:'def resetBlinkSeq()',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'colorled.rgbMove()',pro:'def rgbMove(<span id=pn>rgb_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the led, using a color HSL.',lib:'colorled.set_hslColor()',pro:'def set_hslColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the led, using a color HSL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB led.',lib:'colorled.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB led.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the led, using a RGB color.',lib:'colorled.set_rgbColor()',pro:'def set_rgbColor(<span id=pn>newval</span>)',cmt:'<p>Changes the current color of the led, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the led, using a RGB color'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the led will display by default when the module is turned on.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'def set_rgbColorAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the color that the led will display by default when the module is turned on.</p>',par:{newval:'an integer corresponding to the color that the led will display by default when the module is turned on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorled.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['ColorLed']['startBlinkSeq']={syn:'Starts the preprogrammed blinking sequence.',lib:'colorled.startBlinkSeq()',pro:'def startBlinkSeq()',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence will run in loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Stops the preprogrammed blinking sequence.',lib:'colorled.stopBlinkSeq()',pro:'def stopBlinkSeq()',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLed)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'from yocto_temperature import *',cmt:'<p>The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}};
doc['Temperature']['FindTemperature']={syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature.FindTemperature()',pro:'def FindTemperature(<span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the temperature sensor'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'};
doc['Temperature']['FirstTemperature']={syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature.FirstTemperature()',pro:'def FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'temperature.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['describe']={syn:'Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the temperature sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'temperature.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'temperature.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'temperature.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_errorMessage']={syn:'Returns the error message of the latest error with the temperature sensor.',lib:'temperature.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the temperature sensor object'};
doc['Temperature']['get_errorType']={syn:'Returns the numerical error code of the latest error with the temperature sensor.',lib:'temperature.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the temperature sensor object'};
doc['Temperature']['get_friendlyName']={syn:'Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'temperature.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the temperature sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the temperature sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the temperature sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'temperature.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Temperature']['get_functionId']={syn:'Returns the hardware identifier of the temperature sensor, without reference to the module.',lib:'temperature.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the temperature sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the temperature sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'temperature.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the temperature sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the temperature sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'temperature.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the temperature since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'temperature.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'temperature.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'temperature.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the temperature since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'temperature.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Temperature']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'temperature.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Temperature']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'temperature.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'temperature.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'temperature.get_sensorType()',pro:'def get_sensorType()',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt> and <tt>Y_SENSORTYPE_RES_LINEAR</tt> corresponding to the temperature sensor type',ext:'On failure, throws an exception or returns <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the temperature.',lib:'temperature.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Temperature']['isOnline']={syn:'Checks if the temperature sensor is currently reachable, without raising any error.',lib:'temperature.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the temperature sensor is currently reachable, without raising any error. If there is a cached value for the temperature sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the temperature sensor.</p>',ret:'<tt>true</tt> if the temperature sensor can be reached, and <tt>false</tt> otherwise'};
doc['Temperature']['load']={syn:'Preloads the temperature sensor cache with a specified validity duration.',lib:'temperature.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the temperature sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'temperature.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadThermistorResponseTable']={syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'temperature.loadThermistorResponseTable()',pro:'def loadThermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['nextTemperature']={syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'temperature.nextTemperature()',pro:'def nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'};
doc['Temperature']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'temperature.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Temperature']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'temperature.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'temperature.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'temperature.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'temperature.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'temperature.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'temperature.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'temperature.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_sensorType']={syn:'Modifies the temperature sensor type.',lib:'temperature.set_sensorType()',pro:'def set_sensorType(<span id=pn>newval</span>)',cmt:'<p>Modifies the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt> and <tt>Y_SENSORTYPE_RES_LINEAR</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_thermistorResponseTable']={syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'temperature.set_thermistorResponseTable()',pro:'def set_thermistorResponseTable(<span id=pn>tempValues</span>, <span id=pn>resValues</span>)',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_unit']={syn:'Changes the measuring unit for the measured temperature.',lib:'temperature.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that String ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'temperature.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Temperature']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'temperature.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Temperature']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'temperature.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'from yocto_datalogger import *',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The DataLogger function controls the global parameters of the internal data logger.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger.FindDataLogger()',pro:'def FindDataLogger(<span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the data logger'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'};
doc['DataLogger']['FirstDataLogger']={syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger.FirstDataLogger()',pro:'def FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DataLogger']['describe']={syn:'Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the data logger (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'datalogger.forgetAllDataStreams()',pro:'def forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'datalogger.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'datalogger.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_beaconDriven']={syn:'Return true if the data logger is synchronised with the localization beacon.',lib:'datalogger.get_beaconDriven()',pro:'def get_beaconDriven()',cmt:'<p>Return true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_BEACONDRIVEN_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'datalogger.get_currentRunIndex()',pro:'def get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataSets']={syn:'Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.',lib:'datalogger.get_dataSets()',pro:'def get_dataSets()',cmt:'<p>Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>',ret:'a list of YDataSet object.',ext:'On failure, throws an exception or returns an empty list.'};
doc['DataLogger']['get_dataStreams']={syn:'Builds a list of all data streams hold by the data logger (legacy method).',lib:'datalogger.get_dataStreams()',pro:'def get_dataStreams(<span id=pn>v</span>)',cmt:'<p>Builds a list of all data streams hold by the data logger (legacy method). The caller must pass by reference an empty array to hold YDataStream objects, and the function fills it with objects describing available data sequences.</p><p> This is the old way to retrieve data from the DataLogger. For new applications, you should rather use <tt>get_dataSets()</tt> method, or call directly <tt>get_recordedData()</tt> on the sensor object.</p>',par:{v:'an array of YDataStream objects to be filled in'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_errorMessage']={syn:'Returns the error message of the latest error with the data logger.',lib:'datalogger.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the data logger object'};
doc['DataLogger']['get_errorType']={syn:'Returns the numerical error code of the latest error with the data logger.',lib:'datalogger.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the data logger object'};
doc['DataLogger']['get_friendlyName']={syn:'Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'datalogger.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the data logger if they are defined, otherwise the serial number of the module and the hardware identifier of the data logger (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the data logger using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'datalogger.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DataLogger']['get_functionId']={syn:'Returns the hardware identifier of the data logger, without reference to the module.',lib:'datalogger.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the data logger, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the data logger (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'datalogger.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the data logger (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the data logger (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'datalogger.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'datalogger.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'datalogger.get_recording()',pro:'def get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'datalogger.get_timeUTC()',pro:'def get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DataLogger']['isOnline']={syn:'Checks if the data logger is currently reachable, without raising any error.',lib:'datalogger.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the data logger is currently reachable, without raising any error. If there is a cached value for the data logger in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the data logger.</p>',ret:'<tt>true</tt> if the data logger can be reached, and <tt>false</tt> otherwise'};
doc['DataLogger']['load']={syn:'Preloads the data logger cache with a specified validity duration.',lib:'datalogger.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the data logger cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['nextDataLogger']={syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'datalogger.nextDataLogger()',pro:'def nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'};
doc['DataLogger']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'datalogger.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'datalogger.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_beaconDriven']={syn:'Changes the type of synchronisation of the data logger.',lib:'datalogger.set_beaconDriven()',pro:'def set_beaconDriven(<span id=pn>newval</span>)',cmt:'<p>Changes the type of synchronisation of the data logger. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'datalogger.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'datalogger.set_recording()',pro:'def set_recording(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'either <tt>Y_RECORDING_OFF</tt> or <tt>Y_RECORDING_ON</tt>, according to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'datalogger.set_timeUTC()',pro:'def set_timeUTC(<span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'datalogger.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'from yocto_dualpower import *',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Retrieves a dual power control for a given identifier.',lib:'YDualPower.FindDualPower()',pro:'def FindDualPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the power control is indeed online at a given time. In case of ambiguity when looking for a dual power control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the power control'},ret:'a <tt>YDualPower</tt> object allowing you to drive the power control.'};
doc['DualPower']['FirstDualPower']={syn:'Starts the enumeration of dual power controls currently accessible.',lib:'YDualPower.FirstDualPower()',pro:'def FirstDualPower()',cmt:'<p>Starts the enumeration of dual power controls currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power controls.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DualPower']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'dualpower.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Returns the error message of the latest error with the power control.',lib:'dualpower.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power control object'};
doc['DualPower']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power control.',lib:'dualpower.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power control object'};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'dualpower.get_extVoltage()',pro:'def get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'dualpower.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power control if they are defined, otherwise the serial number of the module and the hardware identifier of the power control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'dualpower.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DualPower']['get_functionId']={syn:'Returns the hardware identifier of the power control, without reference to the module.',lib:'dualpower.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the power control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dualpower.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'dualpower.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'dualpower.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'dualpower.get_powerControl()',pro:'def get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'dualpower.get_powerState()',pro:'def get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> and <tt>Y_POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DualPower']['isOnline']={syn:'Checks if the power control is currently reachable, without raising any error.',lib:'dualpower.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the power control is currently reachable, without raising any error. If there is a cached value for the power control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power control.</p>',ret:'<tt>true</tt> if the power control can be reached, and <tt>false</tt> otherwise'};
doc['DualPower']['load']={syn:'Preloads the power control cache with a specified validity duration.',lib:'dualpower.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the power control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['nextDualPower']={syn:'Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.',lib:'dualpower.nextDualPower()',pro:'def nextDualPower()',cmt:'<p>Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power control currently online, or a <tt>null</tt> pointer if there are no more dual power controls to enumerate.'};
doc['DualPower']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'dualpower.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'dualpower.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'dualpower.set_powerControl()',pro:'def set_powerControl(<span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'dualpower.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'from yocto_servo import *',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['FindServo']={syn:'Retrieves a servo for a given identifier.',lib:'YServo.FindServo()',pro:'def FindServo(<span id=pn>func</span>)',cmt:'<p>Retrieves a servo for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the servo is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the servo is indeed online at a given time. In case of ambiguity when looking for a servo by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the servo'},ret:'a <tt>YServo</tt> object allowing you to drive the servo.'};
doc['Servo']['FirstServo']={syn:'Starts the enumeration of servos currently accessible.',lib:'YServo.FirstServo()',pro:'def FirstServo()',cmt:'<p>Starts the enumeration of servos currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next servos.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first servo currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Servo']['describe']={syn:'Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the servo (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'servo.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_enabled']={syn:'Returns the state of the servos.',lib:'servo.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns the state of the servos.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the servos',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Servo']['get_enabledAtPowerOn']={syn:'Returns the servo signal generator state at power up.',lib:'servo.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the servo signal generator state at power up',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Returns the error message of the latest error with the servo.',lib:'servo.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the servo object'};
doc['Servo']['get_errorType']={syn:'Returns the numerical error code of the latest error with the servo.',lib:'servo.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the servo object'};
doc['Servo']['get_friendlyName']={syn:'Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'servo.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the servo if they are defined, otherwise the serial number of the module and the hardware identifier of the servo (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the servo using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'servo.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Servo']['get_functionId']={syn:'Returns the hardware identifier of the servo, without reference to the module.',lib:'servo.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the servo, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the servo (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'servo.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the servo (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the servo (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'servo.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'servo.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'servo.get_neutral()',pro:'def get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'servo.get_position()',pro:'def get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_positionAtPowerOn']={syn:'Returns the servo position at device power up.',lib:'servo.get_positionAtPowerOn()',pro:'def get_positionAtPowerOn()',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:'On failure, throws an exception or returns <tt>Y_POSITIONATPOWERON_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'servo.get_range()',pro:'def get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Servo']['isOnline']={syn:'Checks if the servo is currently reachable, without raising any error.',lib:'servo.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the servo is currently reachable, without raising any error. If there is a cached value for the servo in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the servo.</p>',ret:'<tt>true</tt> if the servo can be reached, and <tt>false</tt> otherwise'};
doc['Servo']['load']={syn:'Preloads the servo cache with a specified validity duration.',lib:'servo.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the servo cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'servo.move()',pro:'def move(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['nextServo']={syn:'Continues the enumeration of servos started using <tt>yFirstServo()</tt>.',lib:'servo.nextServo()',pro:'def nextServo()',cmt:'<p>Continues the enumeration of servos started using <tt>yFirstServo()</tt>.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a servo currently online, or a <tt>null</tt> pointer if there are no more servos to enumerate.'};
doc['Servo']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'servo.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Servo']['set_enabled']={syn:'Stops or starts the servo.',lib:'servo.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the servo.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure the servo signal generator state at power up.',lib:'servo.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo signal generator state at power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'servo.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the servo. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the servo.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'servo.set_neutral()',pro:'def set_neutral(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'servo.set_position()',pro:'def set_position(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure the servo position at device power up.',lib:'servo.set_positionAtPowerOn()',pro:'def set_positionAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Configure the servo position at device power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'servo.set_range()',pro:'def set_range(<span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'servo.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'from yocto_relay import *',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['FindRelay']={syn:'Retrieves a relay for a given identifier.',lib:'YRelay.FindRelay()',pro:'def FindRelay(<span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the relay'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'};
doc['Relay']['FirstRelay']={syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay.FirstRelay()',pro:'def FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'relay.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the relay (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'relay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'relay.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Returns the error message of the latest error with the relay.',lib:'relay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the relay object'};
doc['Relay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the relay.',lib:'relay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the relay object'};
doc['Relay']['get_friendlyName']={syn:'Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'relay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the relay if they are defined, otherwise the serial number of the module and the hardware identifier of the relay (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the relay using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'relay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Relay']['get_functionId']={syn:'Returns the hardware identifier of the relay, without reference to the module.',lib:'relay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the relay, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the relay (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'relay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the relay (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the relay (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'relay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'relay.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'relay.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'relay.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'relay.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_stateAtPowerOn']={syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'relay.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Relay']['isOnline']={syn:'Checks if the relay is currently reachable, without raising any error.',lib:'relay.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the relay is currently reachable, without raising any error. If there is a cached value for the relay in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the relay.</p>',ret:'<tt>true</tt> if the relay can be reached, and <tt>false</tt> otherwise'};
doc['Relay']['load']={syn:'Preloads the relay cache with a specified validity duration.',lib:'relay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the relay cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['nextRelay']={syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'relay.nextRelay()',pro:'def nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'relay.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'relay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'relay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'relay.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'relay.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_stateAtPowerOn']={syn:'Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'relay.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'relay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Relay)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'from yocto_humidity import *',cmt:'<p>The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity.FindHumidity()',pro:'def FindHumidity(<span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the humidity sensor'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'};
doc['Humidity']['FirstHumidity']={syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity.FirstHumidity()',pro:'def FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'humidity.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['describe']={syn:'Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the humidity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'humidity.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'humidity.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'humidity.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_errorMessage']={syn:'Returns the error message of the latest error with the humidity sensor.',lib:'humidity.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the humidity sensor object'};
doc['Humidity']['get_errorType']={syn:'Returns the numerical error code of the latest error with the humidity sensor.',lib:'humidity.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the humidity sensor object'};
doc['Humidity']['get_friendlyName']={syn:'Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'humidity.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the humidity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the humidity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the humidity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'humidity.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Humidity']['get_functionId']={syn:'Returns the hardware identifier of the humidity sensor, without reference to the module.',lib:'humidity.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the humidity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the humidity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'humidity.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the humidity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the humidity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'humidity.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the humidity since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'humidity.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'humidity.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'humidity.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the humidity since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'humidity.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Humidity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'humidity.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Humidity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'humidity.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'humidity.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the humidity.',lib:'humidity.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Humidity']['isOnline']={syn:'Checks if the humidity sensor is currently reachable, without raising any error.',lib:'humidity.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the humidity sensor is currently reachable, without raising any error. If there is a cached value for the humidity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the humidity sensor.</p>',ret:'<tt>true</tt> if the humidity sensor can be reached, and <tt>false</tt> otherwise'};
doc['Humidity']['load']={syn:'Preloads the humidity sensor cache with a specified validity duration.',lib:'humidity.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the humidity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'humidity.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['nextHumidity']={syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'humidity.nextHumidity()',pro:'def nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'};
doc['Humidity']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'humidity.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Humidity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'humidity.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'humidity.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'humidity.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'humidity.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'humidity.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'humidity.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'humidity.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'humidity.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Humidity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'humidity.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Humidity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'humidity.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'from yocto_pressure import *',cmt:'<p>The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Pressure']['FindPressure']={syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure.FindPressure()',pro:'def FindPressure(<span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the pressure sensor'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'};
doc['Pressure']['FirstPressure']={syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure.FirstPressure()',pro:'def FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pressure.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['describe']={syn:'Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the pressure sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'pressure.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'pressure.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'pressure.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_errorMessage']={syn:'Returns the error message of the latest error with the pressure sensor.',lib:'pressure.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the pressure sensor object'};
doc['Pressure']['get_errorType']={syn:'Returns the numerical error code of the latest error with the pressure sensor.',lib:'pressure.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the pressure sensor object'};
doc['Pressure']['get_friendlyName']={syn:'Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pressure.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the pressure sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the pressure sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the pressure sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pressure.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Pressure']['get_functionId']={syn:'Returns the hardware identifier of the pressure sensor, without reference to the module.',lib:'pressure.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the pressure sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the pressure sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pressure.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the pressure sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the pressure sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'pressure.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the pressure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pressure.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'pressure.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'pressure.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the pressure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pressure.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Pressure']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pressure.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Pressure']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pressure.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pressure.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the pressure.',lib:'pressure.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Pressure']['isOnline']={syn:'Checks if the pressure sensor is currently reachable, without raising any error.',lib:'pressure.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the pressure sensor is currently reachable, without raising any error. If there is a cached value for the pressure sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the pressure sensor.</p>',ret:'<tt>true</tt> if the pressure sensor can be reached, and <tt>false</tt> otherwise'};
doc['Pressure']['load']={syn:'Preloads the pressure sensor cache with a specified validity duration.',lib:'pressure.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the pressure sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pressure.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['nextPressure']={syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'pressure.nextPressure()',pro:'def nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'};
doc['Pressure']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pressure.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Pressure']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pressure.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pressure.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pressure.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'pressure.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pressure.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pressure.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pressure.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pressure.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Pressure']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pressure.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Pressure']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pressure.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'from yocto_lightsensor import *',cmt:'<p>The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor.FindLightSensor()',pro:'def FindLightSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the light sensor'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'};
doc['LightSensor']['FirstLightSensor']={syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor.FirstLightSensor()',pro:'def FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'lightsensor.calibrate()',pro:'def calibrate(<span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'lightsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the light sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'lightsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number.',lib:'lightsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in lux, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Returns the current value of the ambient light, in lux, as a floating point number.',lib:'lightsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the ambient light, in lux, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in lux, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the light sensor.',lib:'lightsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the light sensor object'};
doc['LightSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the light sensor.',lib:'lightsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the light sensor object'};
doc['LightSensor']['get_friendlyName']={syn:'Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'lightsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the light sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the light sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the light sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'lightsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['LightSensor']['get_functionId']={syn:'Returns the hardware identifier of the light sensor, without reference to the module.',lib:'lightsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the light sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the light sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'lightsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the light sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the light sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'lightsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'lightsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'lightsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'lightsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_measureType']={syn:'Returns the type of light measure.',lib:'lightsensor.get_measureType()',pro:'def get_measureType()',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> corresponding to the type of light measure',ext:'On failure, throws an exception or returns <tt>Y_MEASURETYPE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'lightsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['LightSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'lightsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['LightSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'lightsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'lightsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the ambient light.',lib:'lightsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['LightSensor']['isOnline']={syn:'Checks if the light sensor is currently reachable, without raising any error.',lib:'lightsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the light sensor is currently reachable, without raising any error. If there is a cached value for the light sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the light sensor.</p>',ret:'<tt>true</tt> if the light sensor can be reached, and <tt>false</tt> otherwise'};
doc['LightSensor']['load']={syn:'Preloads the light sensor cache with a specified validity duration.',lib:'lightsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the light sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'lightsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['nextLightSensor']={syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'lightsensor.nextLightSensor()',pro:'def nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'};
doc['LightSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'lightsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['LightSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'lightsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'lightsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'lightsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'lightsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'lightsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_measureType']={syn:'Modify the light sensor type used in the device.',lib:'lightsensor.set_measureType()',pro:'def set_measureType(<span id=pn>newval</span>)',cmt:'<p>Modify the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'lightsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'lightsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'lightsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['LightSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'lightsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['LightSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'lightsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: LightSensor)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'from yocto_hubport import *',cmt:'<p>YHubPort objects provide control over the power supply for every YoctoHub port and provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}};
doc['HubPort']['FindHubPort']={syn:'Retrieves a Yocto-hub port for a given identifier.',lib:'YHubPort.FindHubPort()',pro:'def FindHubPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a Yocto-hub port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Yocto-hub port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the Yocto-hub port is indeed online at a given time. In case of ambiguity when looking for a Yocto-hub port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Yocto-hub port'},ret:'a <tt>YHubPort</tt> object allowing you to drive the Yocto-hub port.'};
doc['HubPort']['FirstHubPort']={syn:'Starts the enumeration of Yocto-hub ports currently accessible.',lib:'YHubPort.FirstHubPort()',pro:'def FirstHubPort()',cmt:'<p>Starts the enumeration of Yocto-hub ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next Yocto-hub ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first Yocto-hub port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['HubPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Yocto-hub port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'hubport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'hubport.get_baudRate()',pro:'def get_baudRate()',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:'On failure, throws an exception or returns <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'hubport.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the Yocto-hub port.',lib:'hubport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Yocto-hub port object'};
doc['HubPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Yocto-hub port.',lib:'hubport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Yocto-hub port object'};
doc['HubPort']['get_friendlyName']={syn:'Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'hubport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Yocto-hub port if they are defined, otherwise the serial number of the module and the hardware identifier of the Yocto-hub port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Yocto-hub port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'hubport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['HubPort']['get_functionId']={syn:'Returns the hardware identifier of the Yocto-hub port, without reference to the module.',lib:'hubport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the Yocto-hub port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Yocto-hub port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'hubport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Yocto-hub port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Yocto-hub port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port.',lib:'hubport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Yocto-hub port.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'hubport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'hubport.get_portState()',pro:'def get_portState()',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> and <tt>Y_PORTSTATE_PROG</tt> corresponding to the current state of the Yocto-hub port',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['HubPort']['isOnline']={syn:'Checks if the Yocto-hub port is currently reachable, without raising any error.',lib:'hubport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the Yocto-hub port is currently reachable, without raising any error. If there is a cached value for the Yocto-hub port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Yocto-hub port.</p>',ret:'<tt>true</tt> if the Yocto-hub port can be reached, and <tt>false</tt> otherwise'};
doc['HubPort']['load']={syn:'Preloads the Yocto-hub port cache with a specified validity duration.',lib:'hubport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Yocto-hub port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['nextHubPort']={syn:'Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.',lib:'hubport.nextHubPort()',pro:'def nextHubPort()',cmt:'<p>Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a Yocto-hub port currently online, or a <tt>null</tt> pointer if there are no more Yocto-hub ports to enumerate.'};
doc['HubPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'hubport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'hubport.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_logicalName']={syn:'Changes the logical name of the Yocto-hub port.',lib:'hubport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Yocto-hub port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Yocto-hub port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'hubport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'from yocto_anbutton import *',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton.FindAnButton()',pro:'def FindAnButton(<span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the analog input'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'};
doc['AnButton']['FirstAnButton']={syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton.FirstAnButton()',pro:'def FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AnButton']['describe']={syn:'Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the analog input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'anbutton.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'anbutton.get_analogCalibration()',pro:'def get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'anbutton.get_calibratedValue()',pro:'def get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMax()',pro:'def get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton.get_calibrationMin()',pro:'def get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Returns the error message of the latest error with the analog input.',lib:'anbutton.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the analog input object'};
doc['AnButton']['get_errorType']={syn:'Returns the numerical error code of the latest error with the analog input.',lib:'anbutton.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the analog input object'};
doc['AnButton']['get_friendlyName']={syn:'Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'anbutton.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the analog input if they are defined, otherwise the serial number of the module and the hardware identifier of the analog input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the analog input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'anbutton.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AnButton']['get_functionId']={syn:'Returns the hardware identifier of the analog input, without reference to the module.',lib:'anbutton.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the analog input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the analog input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'anbutton.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the analog input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the analog input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'anbutton.get_isPressed()',pro:'def get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>Y_ISPRESSED_FALSE</tt> or <tt>Y_ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'anbutton.get_lastTimePressed()',pro:'def get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'anbutton.get_lastTimeReleased()',pro:'def get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'anbutton.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'anbutton.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value ',lib:'anbutton.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms) ',lib:'anbutton.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms)</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'anbutton.get_rawValue()',pro:'def get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.get_sensitivity()',pro:'def get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AnButton']['isOnline']={syn:'Checks if the analog input is currently reachable, without raising any error.',lib:'anbutton.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the analog input is currently reachable, without raising any error. If there is a cached value for the analog input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the analog input.</p>',ret:'<tt>true</tt> if the analog input can be reached, and <tt>false</tt> otherwise'};
doc['AnButton']['load']={syn:'Preloads the analog input cache with a specified validity duration.',lib:'anbutton.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the analog input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['nextAnButton']={syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'anbutton.nextAnButton()',pro:'def nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'};
doc['AnButton']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'anbutton.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'anbutton.resetCounter()',pro:'def resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'anbutton.set_analogCalibration()',pro:'def set_analogCalibration(<span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMax()',pro:'def set_calibrationMax(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton.set_calibrationMin()',pro:'def set_calibrationMin(<span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'anbutton.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton.set_sensitivity()',pro:'def set_sensitivity(<span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'anbutton.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'from yocto_voltage import *',cmt:'<p>The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage.FindVoltage()',pro:'def FindVoltage(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage sensor'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'};
doc['Voltage']['FirstVoltage']={syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage.FirstVoltage()',pro:'def FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voltage.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'voltage.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'voltage.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'voltage.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage sensor.',lib:'voltage.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage sensor object'};
doc['Voltage']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage sensor.',lib:'voltage.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage sensor object'};
doc['Voltage']['get_friendlyName']={syn:'Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltage.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltage.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voltage']['get_functionId']={syn:'Returns the hardware identifier of the voltage sensor, without reference to the module.',lib:'voltage.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltage.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'voltage.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the voltage since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voltage.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'voltage.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'voltage.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the voltage since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltage.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voltage']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voltage.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voltage']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voltage.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voltage.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'voltage.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voltage']['isOnline']={syn:'Checks if the voltage sensor is currently reachable, without raising any error.',lib:'voltage.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the voltage sensor is currently reachable, without raising any error. If there is a cached value for the voltage sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage sensor.</p>',ret:'<tt>true</tt> if the voltage sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voltage']['load']={syn:'Preloads the voltage sensor cache with a specified validity duration.',lib:'voltage.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voltage.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['nextVoltage']={syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'voltage.nextVoltage()',pro:'def nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'};
doc['Voltage']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voltage.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voltage']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltage.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voltage.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voltage.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'voltage.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voltage.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voltage.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voltage.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltage.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voltage']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voltage.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voltage']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voltage.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'from yocto_current import *',cmt:'<p>The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Current']['FindCurrent']={syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent.FindCurrent()',pro:'def FindCurrent(<span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the current sensor'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'};
doc['Current']['FirstCurrent']={syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent.FirstCurrent()',pro:'def FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'current.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['describe']={syn:'Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the current sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'current.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'current.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'current.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the current, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_errorMessage']={syn:'Returns the error message of the latest error with the current sensor.',lib:'current.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the current sensor object'};
doc['Current']['get_errorType']={syn:'Returns the numerical error code of the latest error with the current sensor.',lib:'current.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the current sensor object'};
doc['Current']['get_friendlyName']={syn:'Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'current.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the current sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the current sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the current sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'current.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Current']['get_functionId']={syn:'Returns the hardware identifier of the current sensor, without reference to the module.',lib:'current.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the current sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the current sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'current.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the current sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the current sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed for the current since the device was started.',lib:'current.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the current since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'current.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'current.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed for the current since the device was started.',lib:'current.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the current since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'current.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Current']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'current.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Current']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'current.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'current.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the current.',lib:'current.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Current']['isOnline']={syn:'Checks if the current sensor is currently reachable, without raising any error.',lib:'current.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the current sensor is currently reachable, without raising any error. If there is a cached value for the current sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the current sensor.</p>',ret:'<tt>true</tt> if the current sensor can be reached, and <tt>false</tt> otherwise'};
doc['Current']['load']={syn:'Preloads the current sensor cache with a specified validity duration.',lib:'current.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the current sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'current.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['nextCurrent']={syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'current.nextCurrent()',pro:'def nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'};
doc['Current']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'current.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Current']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'current.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'current.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'current.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'current.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'current.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'current.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'current.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'current.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Current']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'current.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Current']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'current.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'from yocto_carbondioxide import *',cmt:'<p>The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2 sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to perform manual calibration if reuired.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'def FindCarbonDioxide(<span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'def FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'carbondioxide.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['describe']={syn:'Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the CO2 sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'carbondioxide.get_abcPeriod()',pro:'def get_abcPeriod()',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:'On failure, throws an exception or returns <tt>Y_ABCPERIOD_INVALID</tt>.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'carbondioxide.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'carbondioxide.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'carbondioxide.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Returns the error message of the latest error with the CO2 sensor.',lib:'carbondioxide.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the CO2 sensor object'};
doc['CarbonDioxide']['get_errorType']={syn:'Returns the numerical error code of the latest error with the CO2 sensor.',lib:'carbondioxide.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the CO2 sensor object'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'carbondioxide.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the CO2 sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the CO2 sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the CO2 sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'carbondioxide.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionId']={syn:'Returns the hardware identifier of the CO2 sensor, without reference to the module.',lib:'carbondioxide.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the CO2 sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the CO2 sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'carbondioxide.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the CO2 sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the CO2 sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'carbondioxide.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'carbondioxide.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'carbondioxide.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CarbonDioxide']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'carbondioxide.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'carbondioxide.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'carbondioxide.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the CO2 concentration.',lib:'carbondioxide.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CarbonDioxide']['isOnline']={syn:'Checks if the CO2 sensor is currently reachable, without raising any error.',lib:'carbondioxide.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the CO2 sensor is currently reachable, without raising any error. If there is a cached value for the CO2 sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the CO2 sensor.</p>',ret:'<tt>true</tt> if the CO2 sensor can be reached, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['load']={syn:'Preloads the CO2 sensor cache with a specified validity duration.',lib:'carbondioxide.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the CO2 sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'carbondioxide.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide.nextCarbonDioxide()',pro:'def nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'};
doc['CarbonDioxide']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'carbondioxide.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['CarbonDioxide']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'carbondioxide.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Modifies Automatic Baseline Calibration period, in hours.',lib:'carbondioxide.set_abcPeriod()',pro:'def set_abcPeriod(<span id=pn>newval</span>)',cmt:'<p>Modifies Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400ppm CO2), set the period to -1. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'carbondioxide.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'carbondioxide.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'carbondioxide.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'carbondioxide.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'carbondioxide.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'carbondioxide.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'carbondioxide.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['CarbonDioxide']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'carbondioxide.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'carbondioxide.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['triggetBaselineCalibration']={syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'carbondioxide.triggetBaselineCalibration()',pro:'def triggetBaselineCalibration()',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400ppm.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['triggetZeroCalibration']={syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air.',lib:'carbondioxide.triggetZeroCalibration()',pro:'def triggetZeroCalibration()',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'from yocto_led import *',cmt:'<p>Yoctopuce application programming interface allows you not only to drive the intensity of the led, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['FindLed']={syn:'Retrieves a led for a given identifier.',lib:'YLed.FindLed()',pro:'def FindLed(<span id=pn>func</span>)',cmt:'<p>Retrieves a led for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the led is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the led is indeed online at a given time. In case of ambiguity when looking for a led by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the led'},ret:'a <tt>YLed</tt> object allowing you to drive the led.'};
doc['Led']['FirstLed']={syn:'Starts the enumeration of leds currently accessible.',lib:'YLed.FirstLed()',pro:'def FirstLed()',cmt:'<p>Starts the enumeration of leds currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next leds.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first led currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Led']['describe']={syn:'Returns a short text that describes unambiguously the instance of the led in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the led in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the led (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the led (no more than 6 characters).',lib:'led.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the led (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the led (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Returns the current led signaling mode.',lib:'led.get_blinking()',pro:'def get_blinking()',cmt:'<p>Returns the current led signaling mode.</p>',ret:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode',ext:'On failure, throws an exception or returns <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Returns the error message of the latest error with the led.',lib:'led.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the led. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the led object'};
doc['Led']['get_errorType']={syn:'Returns the numerical error code of the latest error with the led.',lib:'led.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the led. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the led object'};
doc['Led']['get_friendlyName']={syn:'Returns a global identifier of the led in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'led.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the led in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the led if they are defined, otherwise the serial number of the module and the hardware identifier of the led (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the led using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'led.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Led']['get_functionId']={syn:'Returns the hardware identifier of the led, without reference to the module.',lib:'led.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the led, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the led (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Returns the unique hardware identifier of the led in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'led.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the led in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the led (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the led (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the led.',lib:'led.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the led.</p>',ret:'a string corresponding to the logical name of the led.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Returns the current led intensity (in per cent).',lib:'led.get_luminosity()',pro:'def get_luminosity()',cmt:'<p>Returns the current led intensity (in per cent).</p>',ret:'an integer corresponding to the current led intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'led.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Returns the current led state.',lib:'led.get_power()',pro:'def get_power()',cmt:'<p>Returns the current led state.</p>',ret:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the current led state',ext:'On failure, throws an exception or returns <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Led']['isOnline']={syn:'Checks if the led is currently reachable, without raising any error.',lib:'led.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the led is currently reachable, without raising any error. If there is a cached value for the led in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the led.</p>',ret:'<tt>true</tt> if the led can be reached, and <tt>false</tt> otherwise'};
doc['Led']['load']={syn:'Preloads the led cache with a specified validity duration.',lib:'led.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the led cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['nextLed']={syn:'Continues the enumeration of leds started using <tt>yFirstLed()</tt>.',lib:'led.nextLed()',pro:'def nextLed()',cmt:'<p>Continues the enumeration of leds started using <tt>yFirstLed()</tt>.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a led currently online, or a <tt>null</tt> pointer if there are no more leds to enumerate.'};
doc['Led']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'led.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Led']['set_blinking']={syn:'Changes the current led signaling mode.',lib:'led.set_blinking()',pro:'def set_blinking(<span id=pn>newval</span>)',cmt:'<p>Changes the current led signaling mode.</p>',par:{newval:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current led signaling mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the led.',lib:'led.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the led. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the led.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_luminosity']={syn:'Changes the current led intensity (in per cent).',lib:'led.set_luminosity()',pro:'def set_luminosity(<span id=pn>newval</span>)',cmt:'<p>Changes the current led intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current led intensity (in per cent)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_power']={syn:'Changes the state of the led.',lib:'led.set_power()',pro:'def set_power(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the led.</p>',par:{newval:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the state of the led'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'led.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Led)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'from yocto_vsource import *',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['FindVSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YVSource.FindVSource()',pro:'def FindVSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YVSource</tt> object allowing you to drive the voltage source.'};
doc['VSource']['FirstVSource']={syn:'Starts the enumeration of voltage sources currently accessible.',lib:'YVSource.FirstVSource()',pro:'def FirstVSource()',cmt:'<p>Starts the enumeration of voltage sources currently accessible. Use the method <tt>YVSource.nextVSource()</tt> to iterate on next voltage sources.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to the first voltage source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'vsource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'vsource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['VSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'vsource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'vsource.get_extPowerFailure()',pro:'def get_extPowerFailure()',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>Y_EXTPOWERFAILURE_FALSE</tt> or <tt>Y_EXTPOWERFAILURE_TRUE</tt>, according to true if external power supply voltage is too low',ext:'On failure, throws an exception or returns <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'vsource.get_failure()',pro:'def get_failure()',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>Y_FAILURE_FALSE</tt> or <tt>Y_FAILURE_TRUE</tt>, according to true if the module is in failure mode',ext:'On failure, throws an exception or returns <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'vsource.get_vsourceDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'vsource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'vsource.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'vsource.get_overCurrent()',pro:'def get_overCurrent()',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>Y_OVERCURRENT_FALSE</tt> or <tt>Y_OVERCURRENT_TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'vsource.get_overHeat()',pro:'def get_overHeat()',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>Y_OVERHEAT_FALSE</tt> or <tt>Y_OVERHEAT_TRUE</tt>, according to TRUE if the module is overheating',ext:'On failure, throws an exception or returns <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'vsource.get_overLoad()',pro:'def get_overLoad()',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>Y_OVERLOAD_FALSE</tt> or <tt>Y_OVERLOAD_TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:'On failure, throws an exception or returns <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'vsource.get_regulationFailure()',pro:'def get_regulationFailure()',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>Y_REGULATIONFAILURE_FALSE</tt> or <tt>Y_REGULATIONFAILURE_TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:'On failure, throws an exception or returns <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'vsource.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VSource']['get_voltage']={syn:'Returns the voltage output command (mV) ',lib:'vsource.get_voltage()',pro:'def get_voltage()',cmt:'<p>Returns the voltage output command (mV)</p>',ret:'an integer corresponding to the voltage output command (mV)',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'vsource.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['VSource']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'vsource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['VSource']['nextVSource']={syn:'Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'def nextVSource()',cmt:'<p>Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more voltage sources to enumerate.'};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'vsource.pulse()',pro:'def pulse(<span id=pn>voltage</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'vsource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'vsource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'vsource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'vsource.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'vsource.voltageMove()',pro:'def voltageMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'from yocto_network import *',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork.FindNetwork()',pro:'def FindNetwork(<span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork.FirstNetwork()',pro:'def FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'network.callbackLogin()',pro:'def callbackLogin(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['describe']={syn:'Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the network interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network.get_adminPassword()',pro:'def get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network.get_callbackCredentials()',pro:'def get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network.get_callbackEncoding()',pro:'def get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the maximum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMaxDelay()',pro:'def get_callbackMaxDelay()',cmt:'<p>Returns the maximum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'network.get_callbackMethod()',pro:'def get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two callback notifications, in seconds.',lib:'network.get_callbackMinDelay()',pro:'def get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two callback notifications, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network.get_callbackUrl()',pro:'def get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.get_discoverable()',pro:'def get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with the network interface.',lib:'network.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the network interface object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with the network interface.',lib:'network.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the network interface object'};
doc['Network']['get_friendlyName']={syn:'Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'network.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the network interface if they are defined, otherwise the serial number of the module and the hardware identifier of the network interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the network interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_functionId']={syn:'Returns the hardware identifier of the network interface, without reference to the module.',lib:'network.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the network interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the network interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'network.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the network interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the network interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network.get_ipAddress()',pro:'def get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'network.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network.get_macAddress()',pro:'def get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.',lib:'network.get_poeCurrent()',pro:'def get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network.get_primaryDNS()',pro:'def get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network.get_readiness()',pro:'def get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network.get_router()',pro:'def get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network.get_secondaryDNS()',pro:'def get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network.get_subnetMask()',pro:'def get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'network.get_userPassword()',pro:'def get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.get_wwwWatchdogDelay()',pro:'def get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the network interface is currently reachable, without raising any error.',lib:'network.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the network interface is currently reachable, without raising any error. If there is a cached value for the network interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the network interface.</p>',ret:'<tt>true</tt> if the network interface can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the network interface cache with a specified validity duration.',lib:'network.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the network interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'def nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['ping']={syn:'Pings str_host to test the network connectivity.',lib:'network.ping()',pro:'def ping(<span id=pn>host</span>)',cmt:'<p>Pings str_host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target str_host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network.set_adminPassword()',pro:'def set_adminPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network.set_callbackCredentials()',pro:'def set_callbackCredentials(<span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network.set_callbackEncoding()',pro:'def set_callbackEncoding(<span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the maximum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMaxDelay()',pro:'def set_callbackMaxDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the maximum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the maximum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'network.set_callbackMethod()',pro:'def set_callbackMethod(<span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two callback notifications, in seconds.',lib:'network.set_callbackMinDelay()',pro:'def set_callbackMinDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'network.set_callbackUrl()',pro:'def set_callbackUrl(<span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network.set_discoverable()',pro:'def set_discoverable(<span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'network.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network.set_primaryDNS()',pro:'def set_primaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'network.set_secondaryDNS()',pro:'def set_secondaryDNS(<span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network.set_userPassword()',pro:'def set_userPassword(<span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network.set_wwwWatchdogDelay()',pro:'def set_wwwWatchdogDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network.useDHCP()',pro:'def useDHCP(<span id=pn>fallbackIpAddr</span>, <span id=pn>fallbackSubnetMaskLen</span>, <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network.useStaticIP()',pro:'def useStaticIP(<span id=pn>ipAddress</span>, <span id=pn>subnetMaskLen</span>, <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'from yocto_wireless import *',cmt:'<p>YWireless functions provides control over wireless network parameters and status for devices that are wireless-enabled.</p>'}};
doc['Wireless']['FindWireless']={syn:'Retrieves a wireless lan interface for a given identifier.',lib:'YWireless.FindWireless()',pro:'def FindWireless(<span id=pn>func</span>)',cmt:'<p>Retrieves a wireless lan interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wireless lan interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless lan interface is indeed online at a given time. In case of ambiguity when looking for a wireless lan interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the wireless lan interface'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless lan interface.'};
doc['Wireless']['FirstWireless']={syn:'Starts the enumeration of wireless lan interfaces currently accessible.',lib:'YWireless.FirstWireless()',pro:'def FirstWireless()',cmt:'<p>Starts the enumeration of wireless lan interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless lan interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless lan interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'wireless.adhocNetwork()',pro:'def adhocNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g, it is best to use softAPNetworkInstead(), which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wireless lan interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'wireless.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'wireless.get_channel()',pro:'def get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:'On failure, throws an exception or returns <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects that describe detected Wireless networks.',lib:'wireless.get_detectedWlans()',pro:'def get_detectedWlans()',cmt:'<p>Returns a list of YWlanRecord objects that describe detected Wireless networks. This list is not updated when the module is already connected to an acces point (infrastructure mode). To force an update of this list, <tt>adhocNetwork()</tt> must be called to disconnect the module from the current network. The returned list must be unallocated by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Wireless']['get_errorMessage']={syn:'Returns the error message of the latest error with the wireless lan interface.',lib:'wireless.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wireless lan interface object'};
doc['Wireless']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wireless lan interface.',lib:'wireless.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wireless lan interface object'};
doc['Wireless']['get_friendlyName']={syn:'Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wireless.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wireless lan interface if they are defined, otherwise the serial number of the module and the hardware identifier of the wireless lan interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wireless lan interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wireless.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Wireless']['get_functionId']={syn:'Returns the hardware identifier of the wireless lan interface, without reference to the module.',lib:'wireless.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the wireless lan interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wireless lan interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wireless.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wireless lan interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wireless lan interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'wireless.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'wireless.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'wireless.get_message()',pro:'def get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wireless.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'wireless.get_security()',pro:'def get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> and <tt>Y_SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'wireless.get_ssid()',pro:'def get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Wireless']['isOnline']={syn:'Checks if the wireless lan interface is currently reachable, without raising any error.',lib:'wireless.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the wireless lan interface is currently reachable, without raising any error. If there is a cached value for the wireless lan interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wireless lan interface.</p>',ret:'<tt>true</tt> if the wireless lan interface can be reached, and <tt>false</tt> otherwise'};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'wireless.joinNetwork()',pro:'def joinNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['load']={syn:'Preloads the wireless lan interface cache with a specified validity duration.',lib:'wireless.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wireless lan interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['nextWireless']={syn:'Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.',lib:'wireless.nextWireless()',pro:'def nextWireless()',cmt:'<p>Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless lan interface currently online, or a <tt>null</tt> pointer if there are no more wireless lan interfaces to enumerate.'};
doc['Wireless']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wireless.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'wireless.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless lan interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wireless.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Wireless']['softAPNetwork']={syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'wireless.softAPNetwork()',pro:'def softAPNetwork(<span id=pn>ssid</span>, <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g.</p><p> When a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'from yocto_voc import *',cmt:'<p>The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger.</p>'}};
doc['Voc']['FindVoc']={syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc.FindVoc()',pro:'def FindVoc(<span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'};
doc['Voc']['FirstVoc']={syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc.FirstVoc()',pro:'def FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voc.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'voc.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'voc.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'voc.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_errorMessage']={syn:'Returns the error message of the latest error with the Volatile Organic Compound sensor.',lib:'voc.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Volatile Organic Compound sensor.',lib:'voc.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_friendlyName']={syn:'Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voc.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voc.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voc']['get_functionId']={syn:'Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module.',lib:'voc.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voc.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'voc.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voc.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'voc.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'voc.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voc.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voc.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voc.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voc.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'voc.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voc']['isOnline']={syn:'Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'voc.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voc']['load']={syn:'Preloads the Volatile Organic Compound sensor cache with a specified validity duration.',lib:'voc.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voc.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['nextVoc']={syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'voc.nextVoc()',pro:'def nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'};
doc['Voc']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voc.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voc.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voc.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voc.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'voc.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voc.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voc.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voc.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voc.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voc.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voc.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'from yocto_watchdog import *',cmt:'<p>The watchog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog.FindWatchdog()',pro:'def FindWatchdog(<span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the watchdog'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog.FirstWatchdog()',pro:'def FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'watchdog.delayedPulse()',pro:'def delayedPulse(<span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['describe']={syn:'Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the watchdog (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'watchdog.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog runing state at module power on.',lib:'watchdog.get_autoStart()',pro:'def get_autoStart()',cmt:'<p>Returns the watchdog runing state at module power on.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runing state at module power on',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'watchdog.get_countdown()',pro:'def get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Returns the error message of the latest error with the watchdog.',lib:'watchdog.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the watchdog object'};
doc['Watchdog']['get_errorType']={syn:'Returns the numerical error code of the latest error with the watchdog.',lib:'watchdog.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the watchdog object'};
doc['Watchdog']['get_friendlyName']={syn:'Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'watchdog.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the watchdog if they are defined, otherwise the serial number of the module and the hardware identifier of the watchdog (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the watchdog using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'watchdog.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Watchdog']['get_functionId']={syn:'Returns the hardware identifier of the watchdog, without reference to the module.',lib:'watchdog.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the watchdog, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the watchdog (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'watchdog.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the watchdog (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the watchdog (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'watchdog.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog.get_maxTimeOnStateA()',pro:'def get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog.get_maxTimeOnStateB()',pro:'def get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'watchdog.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.get_output()',pro:'def get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'watchdog.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'watchdog.get_running()',pro:'def get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.get_state()',pro:'def get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'watchdog.get_stateAtPowerOn()',pro:'def get_stateAtPowerOn()',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDelay()',pro:'def get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.get_triggerDuration()',pro:'def get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Watchdog']['isOnline']={syn:'Checks if the watchdog is currently reachable, without raising any error.',lib:'watchdog.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the watchdog is currently reachable, without raising any error. If there is a cached value for the watchdog in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the watchdog.</p>',ret:'<tt>true</tt> if the watchdog can be reached, and <tt>false</tt> otherwise'};
doc['Watchdog']['load']={syn:'Preloads the watchdog cache with a specified validity duration.',lib:'watchdog.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the watchdog cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['nextWatchdog']={syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'watchdog.nextWatchdog()',pro:'def nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'watchdog.pulse()',pro:'def pulse(<span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'watchdog.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'watchdog.resetWatchdog()',pro:'def resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchog to trigger</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog runningsttae at module power on.',lib:'watchdog.set_autoStart()',pro:'def set_autoStart(<span id=pn>newval</span>)',cmt:'<p>Changes the watchdog runningsttae at module power on. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runningsttae at module power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'watchdog.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog.set_maxTimeOnStateA()',pro:'def set_maxTimeOnStateA(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog.set_maxTimeOnStateB()',pro:'def set_maxTimeOnStateB(<span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog.set_output()',pro:'def set_output(<span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'watchdog.set_running()',pro:'def set_running(<span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog.set_state()',pro:'def set_state(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'watchdog.set_stateAtPowerOn()',pro:'def set_stateAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDelay()',pro:'def set_triggerDelay(<span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog.set_triggerDuration()',pro:'def set_triggerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'watchdog.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'from yocto_power import *',cmt:'<p>The Yoctopuce class YPower allows you to read and configure Yoctopuce power sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}};
doc['Power']['FindPower']={syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower.FindPower()',pro:'def FindPower(<span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'};
doc['Power']['FirstPower']={syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower.FirstPower()',pro:'def FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'power.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['describe']={syn:'Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the electrical power sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'power.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'power.get_cosPhi()',pro:'def get_cosPhi()',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:'On failure, throws an exception or returns <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'power.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'power.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_errorMessage']={syn:'Returns the error message of the latest error with the electrical power sensor.',lib:'power.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the electrical power sensor object'};
doc['Power']['get_errorType']={syn:'Returns the numerical error code of the latest error with the electrical power sensor.',lib:'power.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the electrical power sensor object'};
doc['Power']['get_friendlyName']={syn:'Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'power.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the electrical power sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the electrical power sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the electrical power sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'power.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Power']['get_functionId']={syn:'Returns the hardware identifier of the electrical power sensor, without reference to the module.',lib:'power.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the electrical power sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the electrical power sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'power.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the electrical power sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the electrical power sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'power.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'power.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'power.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'power.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'power.get_meter()',pro:'def get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'power.get_meterTimer()',pro:'def get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'power.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Power']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'power.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Power']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'power.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'power.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the electrical power.',lib:'power.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Power']['isOnline']={syn:'Checks if the electrical power sensor is currently reachable, without raising any error.',lib:'power.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the electrical power sensor is currently reachable, without raising any error. If there is a cached value for the electrical power sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the electrical power sensor.</p>',ret:'<tt>true</tt> if the electrical power sensor can be reached, and <tt>false</tt> otherwise'};
doc['Power']['load']={syn:'Preloads the electrical power sensor cache with a specified validity duration.',lib:'power.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the electrical power sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'power.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['nextPower']={syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'power.nextPower()',pro:'def nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'};
doc['Power']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'power.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Power']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'power.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Power']['reset']={syn:'Resets the energy counter.',lib:'power.reset()',pro:'def reset()',cmt:'<p>Resets the energy counter.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'power.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'power.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'power.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'power.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'power.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'power.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'power.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Power']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'power.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Power']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'power.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'from yocto_display import *',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Retrieves a display for a given identifier.',lib:'YDisplay.FindDisplay()',pro:'def FindDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the display'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'};
doc['Display']['FirstDisplay']={syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay.FirstDisplay()',pro:'def FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'display.copyLayerContent()',pro:'def copyLayerContent(<span id=pn>srcLayerId</span>, <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['describe']={syn:'Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the display (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'display.fade()',pro:'def fade(<span id=pn>brightness</span>, <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'display.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'display.get_brightness()',pro:'def get_brightness()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'display.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Returns a YDisplayLayer object that can be used to draw on the specified layer.',lib:'display.get_displayLayer()',pro:'def get_displayLayer(<span id=pn>layerId</span>)',cmt:'<p>Returns a YDisplayLayer object that can be used to draw on the specified layer. The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>',par:{layerId:'the identifier of the layer (a number in range 0..layerCount-1)'},ret:'an <tt>YDisplayLayer</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'display.get_displayType()',pro:'def get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> and <tt>Y_DISPLAYTYPE_RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'display.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_enabled']={syn:'Returns true if the screen is powered, false otherwise.',lib:'display.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the screen is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Returns the error message of the latest error with the display.',lib:'display.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the display object'};
doc['Display']['get_errorType']={syn:'Returns the numerical error code of the latest error with the display.',lib:'display.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the display object'};
doc['Display']['get_friendlyName']={syn:'Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'display.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the display if they are defined, otherwise the serial number of the module and the hardware identifier of the display (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the display using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'display.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Display']['get_functionId']={syn:'Returns the hardware identifier of the display, without reference to the module.',lib:'display.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the display, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the display (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'display.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the display (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the display (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'display.get_layerCount()',pro:'def get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'display.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'display.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'display.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'display.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'display.get_orientation()',pro:'def get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'display.get_startupSeq()',pro:'def get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Display']['isOnline']={syn:'Checks if the display is currently reachable, without raising any error.',lib:'display.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the display is currently reachable, without raising any error. If there is a cached value for the display in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the display.</p>',ret:'<tt>true</tt> if the display can be reached, and <tt>false</tt> otherwise'};
doc['Display']['load']={syn:'Preloads the display cache with a specified validity duration.',lib:'display.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the display cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'display.newSequence()',pro:'def newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['nextDisplay']={syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'display.nextDisplay()',pro:'def nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'display.pauseSequence()',pro:'def pauseSequence(<span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'def playSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'display.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'display.resetAll()',pro:'def resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'display.saveSequence()',pro:'def saveSequence(<span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'display.set_brightness()',pro:'def set_brightness(<span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_enabled']={syn:'Changes the power state of the display.',lib:'display.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the power state of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'display.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'display.set_orientation()',pro:'def set_orientation(<span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'display.set_startupSeq()',pro:'def set_startupSeq(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'display.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'display.stopSequence()',pro:'def stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'display.swapLayerContent()',pro:'def swapLayerContent(<span id=pn>layerIdA</span>, <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between onae hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'display.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Display)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'from yocto_files import *',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['FindFiles']={syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles.FindFiles()',pro:'def FindFiles(<span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the filesystem'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'};
doc['Files']['FirstFiles']={syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles.FirstFiles()',pro:'def FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Files']['describe']={syn:'Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the filesystem (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'files.download()',pro:'def download(<span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'};
doc['Files']['format_fs']={syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'files.format_fs()',pro:'def format_fs()',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'files.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Returns the error message of the latest error with the filesystem.',lib:'files.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the filesystem object'};
doc['Files']['get_errorType']={syn:'Returns the numerical error code of the latest error with the filesystem.',lib:'files.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the filesystem object'};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'files.get_filesCount()',pro:'def get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'files.get_freeSpace()',pro:'def get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'files.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the filesystem if they are defined, otherwise the serial number of the module and the hardware identifier of the filesystem (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the filesystem using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'files.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Files']['get_functionId']={syn:'Returns the hardware identifier of the filesystem, without reference to the module.',lib:'files.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the filesystem, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the filesystem (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'files.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the filesystem (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the filesystem (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'files.get_list()',pro:'def get_list(<span id=pn>pattern</span>)',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wildcards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'files.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'files.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Files']['isOnline']={syn:'Checks if the filesystem is currently reachable, without raising any error.',lib:'files.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the filesystem is currently reachable, without raising any error. If there is a cached value for the filesystem in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the filesystem.</p>',ret:'<tt>true</tt> if the filesystem can be reached, and <tt>false</tt> otherwise'};
doc['Files']['load']={syn:'Preloads the filesystem cache with a specified validity duration.',lib:'files.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the filesystem cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['nextFiles']={syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'files.nextFiles()',pro:'def nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'};
doc['Files']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'files.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'files.remove()',pro:'def remove(<span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'files.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'files.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'files.upload()',pro:'def upload(<span id=pn>pathname</span>, <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'from yocto_realtimeclock import *',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Retrieves a clock for a given identifier.',lib:'YRealTimeClock.FindRealTimeClock()',pro:'def FindRealTimeClock(<span id=pn>func</span>)',cmt:'<p>Retrieves a clock for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the clock is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRealTimeClock.isOnline()</tt> to test if the clock is indeed online at a given time. In case of ambiguity when looking for a clock by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the clock'},ret:'a <tt>YRealTimeClock</tt> object allowing you to drive the clock.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Starts the enumeration of clocks currently accessible.',lib:'YRealTimeClock.FirstRealTimeClock()',pro:'def FirstRealTimeClock()',cmt:'<p>Starts the enumeration of clocks currently accessible. Use the method <tt>YRealTimeClock.nextRealTimeClock()</tt> to iterate on next clocks.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to the first clock currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RealTimeClock']['describe']={syn:'Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'realtimeclock.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the clock (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'realtimeclock.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22 ',lib:'realtimeclock.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Returns the error message of the latest error with the clock.',lib:'realtimeclock.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the clock object'};
doc['RealTimeClock']['get_errorType']={syn:'Returns the numerical error code of the latest error with the clock.',lib:'realtimeclock.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the clock object'};
doc['RealTimeClock']['get_friendlyName']={syn:'Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'realtimeclock.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the clock if they are defined, otherwise the serial number of the module and the hardware identifier of the clock (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the clock using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'realtimeclock.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RealTimeClock']['get_functionId']={syn:'Returns the hardware identifier of the clock, without reference to the module.',lib:'realtimeclock.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the clock, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the clock (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RealTimeClock']['get_hardwareId']={syn:'Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'realtimeclock.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the clock (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the clock (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'realtimeclock.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'realtimeclock.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'realtimeclock.get_timeSet()',pro:'def get_timeSet()',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>Y_TIMESET_FALSE</tt> or <tt>Y_TIMESET_TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'realtimeclock.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'realtimeclock.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'Checks if the clock is currently reachable, without raising any error.',lib:'realtimeclock.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the clock is currently reachable, without raising any error. If there is a cached value for the clock in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the clock.</p>',ret:'<tt>true</tt> if the clock can be reached, and <tt>false</tt> otherwise'};
doc['RealTimeClock']['load']={syn:'Preloads the clock cache with a specified validity duration.',lib:'realtimeclock.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the clock cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.',lib:'realtimeclock.nextRealTimeClock()',pro:'def nextRealTimeClock()',cmt:'<p>Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to a clock currently online, or a <tt>null</tt> pointer if there are no more clocks to enumerate.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'realtimeclock.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'realtimeclock.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the clock. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the clock.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'realtimeclock.set_unixTime()',pro:'def set_unixTime(<span id=pn>newval</span>)',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970). If current UTC time is known, utcOffset will be automatically adjusted for the new specified time.</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'realtimeclock.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time will automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'from yocto_wakeupmonitor import *',cmt:'<p>The WakeUpMonitor function handles globally all wake-up sources, as well as automated sleep mode.</p>'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Retrieves a monitor for a given identifier.',lib:'YWakeUpMonitor.FindWakeUpMonitor()',pro:'def FindWakeUpMonitor(<span id=pn>func</span>)',cmt:'<p>Retrieves a monitor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the monitor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpMonitor.isOnline()</tt> to test if the monitor is indeed online at a given time. In case of ambiguity when looking for a monitor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the monitor'},ret:'a <tt>YWakeUpMonitor</tt> object allowing you to drive the monitor.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Starts the enumeration of monitors currently accessible.',lib:'YWakeUpMonitor.FirstWakeUpMonitor()',pro:'def FirstWakeUpMonitor()',cmt:'<p>Starts the enumeration of monitors currently accessible. Use the method <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> to iterate on next monitors.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to the first monitor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpMonitor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupmonitor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the monitor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'wakeupmonitor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Returns the error message of the latest error with the monitor.',lib:'wakeupmonitor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the monitor object'};
doc['WakeUpMonitor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the monitor.',lib:'wakeupmonitor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the monitor object'};
doc['WakeUpMonitor']['get_friendlyName']={syn:'Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupmonitor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the monitor if they are defined, otherwise the serial number of the module and the hardware identifier of the monitor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the monitor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupmonitor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionId']={syn:'Returns the hardware identifier of the monitor, without reference to the module.',lib:'wakeupmonitor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the monitor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the monitor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupmonitor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the monitor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the monitor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'wakeupmonitor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupmonitor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Returns the next scheduled wake up date/time (UNIX format) ',lib:'wakeupmonitor.get_nextWakeUp()',pro:'def get_nextWakeUp()',cmt:'<p>Returns the next scheduled wake up date/time (UNIX format)</p>',ret:'an integer corresponding to the next scheduled wake up date/time (UNIX format)',ext:'On failure, throws an exception or returns <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'wakeupmonitor.get_powerDuration()',pro:'def get_powerDuration()',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:'On failure, throws an exception or returns <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before the next sleep period.',lib:'wakeupmonitor.get_sleepCountdown()',pro:'def get_sleepCountdown()',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:'On failure, throws an exception or returns <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupmonitor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Returns the latest wake up reason.',lib:'wakeupmonitor.get_wakeUpReason()',pro:'def get_wakeUpReason()',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt> and <tt>Y_WAKEUPREASON_SCHEDULE2</tt> corresponding to the latest wake up reason',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Returns the current state of the monitor ',lib:'wakeupmonitor.get_wakeUpState()',pro:'def get_wakeUpState()',cmt:'<p>Returns the current state of the monitor</p>',ret:'either <tt>Y_WAKEUPSTATE_SLEEPING</tt> or <tt>Y_WAKEUPSTATE_AWAKE</tt>, according to the current state of the monitor',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'Checks if the monitor is currently reachable, without raising any error.',lib:'wakeupmonitor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the monitor is currently reachable, without raising any error. If there is a cached value for the monitor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the monitor.</p>',ret:'<tt>true</tt> if the monitor can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpMonitor']['load']={syn:'Preloads the monitor cache with a specified validity duration.',lib:'wakeupmonitor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the monitor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.',lib:'wakeupmonitor.nextWakeUpMonitor()',pro:'def nextWakeUpMonitor()',cmt:'<p>Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to a monitor currently online, or a <tt>null</tt> pointer if there are no more monitors to enumerate.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupmonitor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Resets the sleep countdown.',lib:'wakeupmonitor.resetSleepCountDown()',pro:'def resetSleepCountDown()',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'wakeupmonitor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the monitor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the monitor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupmonitor.set_nextWakeUp()',pro:'def set_nextWakeUp(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'wakeupmonitor.set_powerDuration()',pro:'def set_powerDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before the next sleep period.',lib:'wakeupmonitor.set_sleepCountdown()',pro:'def set_sleepCountdown(<span id=pn>newval</span>)',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupmonitor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpMonitor']['sleep']={syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleep()',pro:'def sleep(<span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepFor']={syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepFor()',pro:'def sleepFor(<span id=pn>secUntilWakeUp</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor.sleepUntil()',pro:'def sleepUntil(<span id=pn>wakeUpTime</span>, <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wake up.',lib:'wakeupmonitor.wakeUp()',pro:'def wakeUp()',cmt:'<p>Forces a wake up.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'from yocto_wakeupschedule import *',cmt:'<p>The WakeUpSchedule function implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Retrieves a wake up schedule for a given identifier.',lib:'YWakeUpSchedule.FindWakeUpSchedule()',pro:'def FindWakeUpSchedule(<span id=pn>func</span>)',cmt:'<p>Retrieves a wake up schedule for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wake up schedule is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpSchedule.isOnline()</tt> to test if the wake up schedule is indeed online at a given time. In case of ambiguity when looking for a wake up schedule by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the wake up schedule'},ret:'a <tt>YWakeUpSchedule</tt> object allowing you to drive the wake up schedule.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Starts the enumeration of wake up schedules currently accessible.',lib:'YWakeUpSchedule.FirstWakeUpSchedule()',pro:'def FirstWakeUpSchedule()',cmt:'<p>Starts the enumeration of wake up schedules currently accessible. Use the method <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> to iterate on next wake up schedules.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to the first wake up schedule currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpSchedule']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupschedule.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wake up schedule (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'wakeupschedule.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Returns the error message of the latest error with the wake up schedule.',lib:'wakeupschedule.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wake up schedule object'};
doc['WakeUpSchedule']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wake up schedule.',lib:'wakeupschedule.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wake up schedule object'};
doc['WakeUpSchedule']['get_friendlyName']={syn:'Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupschedule.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wake up schedule if they are defined, otherwise the serial number of the module and the hardware identifier of the wake up schedule (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wake up schedule using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupschedule.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionId']={syn:'Returns the hardware identifier of the wake up schedule, without reference to the module.',lib:'wakeupschedule.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the wake up schedule, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wake up schedule (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupschedule.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wake up schedule (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wake up schedule (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake up.',lib:'wakeupschedule.get_hours()',pro:'def get_hours()',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake up schedule.',lib:'wakeupschedule.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'wakeupschedule.get_minutes()',pro:'def get_minutes()',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'wakeupschedule.get_minutesA()',pro:'def get_minutesA()',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.',lib:'wakeupschedule.get_minutesB()',pro:'def get_minutesB()',cmt:'<p>Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 intervalof each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupschedule.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of the month scheduled for wake up.',lib:'wakeupschedule.get_monthDays()',pro:'def get_monthDays()',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Returns the months scheduled for wake up.',lib:'wakeupschedule.get_months()',pro:'def get_months()',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Returns the date/time (seconds) of the next wake up occurence ',lib:'wakeupschedule.get_nextOccurence()',pro:'def get_nextOccurence()',cmt:'<p>Returns the date/time (seconds) of the next wake up occurence</p>',ret:'an integer corresponding to the date/time (seconds) of the next wake up occurence',ext:'On failure, throws an exception or returns <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupschedule.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of the week scheduled for wake up.',lib:'wakeupschedule.get_weekDays()',pro:'def get_weekDays()',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'Checks if the wake up schedule is currently reachable, without raising any error.',lib:'wakeupschedule.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the wake up schedule is currently reachable, without raising any error. If there is a cached value for the wake up schedule in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wake up schedule.</p>',ret:'<tt>true</tt> if the wake up schedule can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpSchedule']['load']={syn:'Preloads the wake up schedule cache with a specified validity duration.',lib:'wakeupschedule.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the wake up schedule cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.',lib:'wakeupschedule.nextWakeUpSchedule()',pro:'def nextWakeUpSchedule()',cmt:'<p>Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to a wake up schedule currently online, or a <tt>null</tt> pointer if there are no more wake up schedules to enumerate.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupschedule.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours when a wake up must take place.',lib:'wakeupschedule.set_hours()',pro:'def set_hours(<span id=pn>newval</span>)',cmt:'<p>Changes the hours when a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake up schedule.',lib:'wakeupschedule.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake up schedule. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'wakeupschedule.set_minutes()',pro:'def set_minutes(<span id=pn>bitmap</span>)',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'wakeupschedule.set_minutesA()',pro:'def set_minutesA(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'wakeupschedule.set_minutesB()',pro:'def set_minutesB(<span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the month when a wake up must take place.',lib:'wakeupschedule.set_monthDays()',pro:'def set_monthDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the month when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_months']={syn:'Changes the months when a wake up must take place.',lib:'wakeupschedule.set_months()',pro:'def set_months(<span id=pn>newval</span>)',cmt:'<p>Changes the months when a wake up must take place.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupschedule.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupschedule.set_weekDays()',pro:'def set_weekDays(<span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'from yocto_genericsensor import *',cmt:'<p>The YGenericSensor class allows you to read and configure Yoctopuce signal transducers. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Retrieves a generic sensor for a given identifier.',lib:'YGenericSensor.FindGenericSensor()',pro:'def FindGenericSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a generic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the generic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGenericSensor.isOnline()</tt> to test if the generic sensor is indeed online at a given time. In case of ambiguity when looking for a generic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the generic sensor'},ret:'a <tt>YGenericSensor</tt> object allowing you to drive the generic sensor.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Starts the enumeration of generic sensors currently accessible.',lib:'YGenericSensor.FirstGenericSensor()',pro:'def FirstGenericSensor()',cmt:'<p>Starts the enumeration of generic sensors currently accessible. Use the method <tt>YGenericSensor.nextGenericSensor()</tt> to iterate on next generic sensors.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to the first generic sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'genericsensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'genericsensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the generic sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'genericsensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'genericsensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'genericsensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the generic sensor.',lib:'genericsensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the generic sensor object'};
doc['GenericSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the generic sensor.',lib:'genericsensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the generic sensor object'};
doc['GenericSensor']['get_friendlyName']={syn:'Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'genericsensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the generic sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the generic sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the generic sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'genericsensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GenericSensor']['get_functionId']={syn:'Returns the hardware identifier of the generic sensor, without reference to the module.',lib:'genericsensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the generic sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the generic sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GenericSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'genericsensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the generic sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the generic sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'genericsensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'genericsensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'genericsensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'genericsensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'genericsensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GenericSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'genericsensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'genericsensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'genericsensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_signalBias']={syn:'Returns the electric signal bias for zero shift adjustment.',lib:'genericsensor.get_signalBias()',pro:'def get_signalBias()',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is underreporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:'On failure, throws an exception or returns <tt>Y_SIGNALBIAS_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'genericsensor.get_signalRange()',pro:'def get_signalRange()',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalSampling']={syn:'Returns the electric signal sampling method to use.',lib:'genericsensor.get_signalSampling()',pro:'def get_signalSampling()',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt> and <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use',ext:'On failure, throws an exception or returns <tt>Y_SIGNALSAMPLING_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'genericsensor.get_signalUnit()',pro:'def get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Returns the measured value of the electrical signal used by the sensor.',lib:'genericsensor.get_signalValue()',pro:'def get_signalValue()',cmt:'<p>Returns the measured value of the electrical signal used by the sensor.</p>',ret:'a floating point number corresponding to the measured value of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'genericsensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'genericsensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'genericsensor.get_valueRange()',pro:'def get_valueRange()',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'Checks if the generic sensor is currently reachable, without raising any error.',lib:'genericsensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the generic sensor is currently reachable, without raising any error. If there is a cached value for the generic sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the generic sensor.</p>',ret:'<tt>true</tt> if the generic sensor can be reached, and <tt>false</tt> otherwise'};
doc['GenericSensor']['load']={syn:'Preloads the generic sensor cache with a specified validity duration.',lib:'genericsensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the generic sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'genericsensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.',lib:'genericsensor.nextGenericSensor()',pro:'def nextGenericSensor()',cmt:'<p>Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to a generic sensor currently online, or a <tt>null</tt> pointer if there are no more generic sensors to enumerate.'};
doc['GenericSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'genericsensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GenericSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'genericsensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'genericsensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'genericsensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'genericsensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the generic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'genericsensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'genericsensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'genericsensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalBias']={syn:'Changes the electric signal bias for zero shift adjustment.',lib:'genericsensor.set_signalBias()',pro:'def set_signalBias(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positif when it should be zero, setup a positive signalBias of the same value to fix the zero shift.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'genericsensor.set_signalRange()',pro:'def set_signalRange(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal range used by the sensor.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalSampling']={syn:'Changes the electric signal sampling method to use.',lib:'genericsensor.set_signalSampling()',pro:'def set_signalSampling(<span id=pn>newval</span>)',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',par:{newval:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt> and <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'genericsensor.set_unit()',pro:'def set_unit(<span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'genericsensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'genericsensor.set_valueRange()',pro:'def set_valueRange(<span id=pn>newval</span>)',cmt:'<p>Changes the physical value range measured by the sensor. As a side effect, the range modification may automatically modify the display resolution.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'genericsensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'genericsensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['zeroAdjust']={syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'genericsensor.zeroAdjust()',pro:'def zeroAdjust()',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO function interface',inc:'from yocto_digitalio import *',cmt:'<p>The Yoctopuce application programming interface allows you to switch the state of each bit of the I/O port. You can switch all bits at once, or one by one. The library can also automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}};
doc['DigitalIO']['FindDigitalIO']={syn:'Retrieves a digital IO port for a given identifier.',lib:'YDigitalIO.FindDigitalIO()',pro:'def FindDigitalIO(<span id=pn>func</span>)',cmt:'<p>Retrieves a digital IO port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the digital IO port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDigitalIO.isOnline()</tt> to test if the digital IO port is indeed online at a given time. In case of ambiguity when looking for a digital IO port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the digital IO port'},ret:'a <tt>YDigitalIO</tt> object allowing you to drive the digital IO port.'};
doc['DigitalIO']['FirstDigitalIO']={syn:'Starts the enumeration of digital IO ports currently accessible.',lib:'YDigitalIO.FirstDigitalIO()',pro:'def FirstDigitalIO()',cmt:'<p>Starts the enumeration of digital IO ports currently accessible. Use the method <tt>YDigitalIO.nextDigitalIO()</tt> to iterate on next digital IO ports.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to the first digital IO port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DigitalIO']['delayedPulse']={syn:'Schedules a pulse on a single bit for a specified duration.',lib:'digitalio.delayedPulse()',pro:'def delayedPulse(<span id=pn>bitno</span>, <span id=pn>ms_delay</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['describe']={syn:'Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'digitalio.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the digital IO port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DigitalIO']['get_advertisedValue']={syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'digitalio.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DigitalIO']['get_bitDirection']={syn:'Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).',lib:'digitalio.get_bitDirection()',pro:'def get_bitDirection(<span id=pn>bitno</span>)',cmt:'<p>Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'digitalio.get_bitOpenDrain()',pro:'def get_bitOpenDrain(<span id=pn>bitno</span>)',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitPolarity']={syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'digitalio.get_bitPolarity()',pro:'def get_bitPolarity(<span id=pn>bitno</span>)',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitState']={syn:'Returns the state of a single bit of the I/O port.',lib:'digitalio.get_bitState()',pro:'def get_bitState(<span id=pn>bitno</span>)',cmt:'<p>Returns the state of a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_errorMessage']={syn:'Returns the error message of the latest error with the digital IO port.',lib:'digitalio.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the digital IO port object'};
doc['DigitalIO']['get_errorType']={syn:'Returns the numerical error code of the latest error with the digital IO port.',lib:'digitalio.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the digital IO port object'};
doc['DigitalIO']['get_friendlyName']={syn:'Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'digitalio.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the digital IO port if they are defined, otherwise the serial number of the module and the hardware identifier of the digital IO port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the digital IO port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DigitalIO']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'digitalio.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DigitalIO']['get_functionId']={syn:'Returns the hardware identifier of the digital IO port, without reference to the module.',lib:'digitalio.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the digital IO port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the digital IO port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DigitalIO']['get_hardwareId']={syn:'Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'digitalio.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the digital IO port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the digital IO port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DigitalIO']['get_logicalName']={syn:'Returns the logical name of the digital IO port.',lib:'digitalio.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DigitalIO']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'digitalio.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DigitalIO']['get_outputVoltage']={syn:'Returns the voltage source used to drive output bits.',lib:'digitalio.get_outputVoltage()',pro:'def get_outputVoltage()',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:'On failure, throws an exception or returns <tt>Y_OUTPUTVOLTAGE_INVALID</tt>.'};
doc['DigitalIO']['get_portDirection']={syn:'Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'digitalio.get_portDirection()',pro:'def get_portDirection()',cmt:'<p>Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output',ext:'On failure, throws an exception or returns <tt>Y_PORTDIRECTION_INVALID</tt>.'};
doc['DigitalIO']['get_portOpenDrain']={syn:'Returns the electrical interface for each bit of the port.',lib:'digitalio.get_portOpenDrain()',pro:'def get_portOpenDrain()',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTOPENDRAIN_INVALID</tt>.'};
doc['DigitalIO']['get_portPolarity']={syn:'Returns the polarity of all the bits of the port.',lib:'digitalio.get_portPolarity()',pro:'def get_portPolarity()',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTPOLARITY_INVALID</tt>.'};
doc['DigitalIO']['get_portSize']={syn:'Returns the number of bits implemented in the I/O port.',lib:'digitalio.get_portSize()',pro:'def get_portSize()',cmt:'<p>Returns the number of bits implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits implemented in the I/O port',ext:'On failure, throws an exception or returns <tt>Y_PORTSIZE_INVALID</tt>.'};
doc['DigitalIO']['get_portState']={syn:'Returns the digital IO port state: bit 0 represents input 0, and so on.',lib:'digitalio.get_portState()',pro:'def get_portState()',cmt:'<p>Returns the digital IO port state: bit 0 represents input 0, and so on.</p>',ret:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['DigitalIO']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'digitalio.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DigitalIO']['isOnline']={syn:'Checks if the digital IO port is currently reachable, without raising any error.',lib:'digitalio.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the digital IO port is currently reachable, without raising any error. If there is a cached value for the digital IO port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the digital IO port.</p>',ret:'<tt>true</tt> if the digital IO port can be reached, and <tt>false</tt> otherwise'};
doc['DigitalIO']['load']={syn:'Preloads the digital IO port cache with a specified validity duration.',lib:'digitalio.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the digital IO port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['nextDigitalIO']={syn:'Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.',lib:'digitalio.nextDigitalIO()',pro:'def nextDigitalIO()',cmt:'<p>Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to a digital IO port currently online, or a <tt>null</tt> pointer if there are no more digital IO ports to enumerate.'};
doc['DigitalIO']['pulse']={syn:'Triggers a pulse on a single bit for a specified duration.',lib:'digitalio.pulse()',pro:'def pulse(<span id=pn>bitno</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'digitalio.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DigitalIO']['set_bitDirection']={syn:'Changes the direction of a single bit from the I/O port.',lib:'digitalio.set_bitDirection()',pro:'def set_bitDirection(<span id=pn>bitno</span>, <span id=pn>bitdirection</span>)',cmt:'<p>Changes the direction of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'digitalio.set_bitOpenDrain()',pro:'def set_bitOpenDrain(<span id=pn>bitno</span>, <span id=pn>opendrain</span>)',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitPolarity']={syn:'Changes the polarity of a single bit from the I/O port.',lib:'digitalio.set_bitPolarity()',pro:'def set_bitPolarity(<span id=pn>bitno</span>, <span id=pn>bitpolarity</span>)',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitState']={syn:'Sets a single bit of the I/O port.',lib:'digitalio.set_bitState()',pro:'def set_bitState(<span id=pn>bitno</span>, <span id=pn>bitstate</span>)',cmt:'<p>Sets a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_logicalName']={syn:'Changes the logical name of the digital IO port.',lib:'digitalio.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the digital IO port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_outputVoltage']={syn:'Changes the voltage source used to drive output bits.',lib:'digitalio.set_outputVoltage()',pro:'def set_outputVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage source used to drive output bits. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portDirection']={syn:'Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'digitalio.set_portDirection()',pro:'def set_portDirection(<span id=pn>newval</span>)',cmt:'<p>Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portOpenDrain']={syn:'Changes the electrical interface for each bit of the port.',lib:'digitalio.set_portOpenDrain()',pro:'def set_portOpenDrain(<span id=pn>newval</span>)',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portPolarity']={syn:'Changes the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'digitalio.set_portPolarity()',pro:'def set_portPolarity(<span id=pn>newval</span>)',cmt:'<p>Changes the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting will be kept after a reboot.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: 0 makes a bit an input, 1 makes it an output'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portState']={syn:'Changes the digital IO port state: bit 0 represents input 0, and so on.',lib:'digitalio.set_portState()',pro:'def set_portState(<span id=pn>newval</span>)',cmt:'<p>Changes the digital IO port state: bit 0 represents input 0, and so on. This function has no effect on bits configured as input in <tt>portDirection</tt>.</p>',par:{newval:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'digitalio.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DigitalIO']['toggle_bitState']={syn:'Reverts a single bit of the I/O port.',lib:'digitalio.toggle_bitState()',pro:'def toggle_bitState(<span id=pn>bitno</span>)',cmt:'<p>Reverts a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DigitalIO)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'from yocto_oscontrol import *',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Retrieves OS control for a given identifier.',lib:'YOsControl.FindOsControl()',pro:'def FindOsControl(<span id=pn>func</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the OS control'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'};
doc['OsControl']['FirstOsControl']={syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl.FirstOsControl()',pro:'def FirstOsControl()',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['OsControl']['describe']={syn:'Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'oscontrol.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the OS control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'oscontrol.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Returns the error message of the latest error with the OS control.',lib:'oscontrol.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the OS control object'};
doc['OsControl']['get_errorType']={syn:'Returns the numerical error code of the latest error with the OS control.',lib:'oscontrol.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the OS control object'};
doc['OsControl']['get_friendlyName']={syn:'Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'oscontrol.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the OS control if they are defined, otherwise the serial number of the module and the hardware identifier of the OS control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the OS control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['OsControl']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'oscontrol.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['OsControl']['get_functionId']={syn:'Returns the hardware identifier of the OS control, without reference to the module.',lib:'oscontrol.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the OS control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the OS control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['OsControl']['get_hardwareId']={syn:'Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'oscontrol.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the OS control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the OS control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control.',lib:'oscontrol.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'oscontrol.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'oscontrol.get_shutdownCountdown()',pro:'def get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'oscontrol.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['OsControl']['isOnline']={syn:'Checks if the OS control is currently reachable, without raising any error.',lib:'oscontrol.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the OS control is currently reachable, without raising any error. If there is a cached value for the OS control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the OS control.</p>',ret:'<tt>true</tt> if the OS control can be reached, and <tt>false</tt> otherwise'};
doc['OsControl']['load']={syn:'Preloads the OS control cache with a specified validity duration.',lib:'oscontrol.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the OS control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['nextOsControl']={syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'oscontrol.nextOsControl()',pro:'def nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'};
doc['OsControl']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'oscontrol.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'oscontrol.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'oscontrol.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'oscontrol.shutdown()',pro:'def shutdown(<span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: OsControl)
//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'from yocto_api import *',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI.CheckLogicalName()',pro:'def CheckLogicalName(<span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI.DisableExceptions()',pro:'def DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI.EnableExceptions()',pro:'def EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI.FreeAPI()',pro:'def FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI.GetAPIVersion()',pro:'def GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI.GetTickCount()',pro:'def GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the millisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI.HandleEvents()',pro:'def HandleEvents(<span id=pn>errmsg</span>=None)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI.InitAPI()',pro:'def InitAPI(<span id=pn>mode</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['PreregisterHub']={syn:'Fault-tolerant alternative to RegisterHub().',lib:'YAPI.PreregisterHub()',pro:'def PreregisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Fault-tolerant alternative to RegisterHub(). This function has the same purpose and same arguments as <tt>RegisterHub()</tt>, but does not trigger an error when the selected hub is not available at the time of the function call. This makes it possible to register a network hub independently of the current connectivity, and to try to contact it only when a device is actively needed.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is plugged.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'def RegisterDeviceArrivalCallback(<span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is plugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unplugged.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'def RegisterDeviceRemovalCallback(<span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unplugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI.RegisterHub()',pro:'def RegisterHub(<span id=pn>url</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. The parameter will determine how the API will work. Use the following values:</p><p> <b>usb</b>: When the <ui>usb</ui> keyword is used, the API will work with devices connected directly to the USB bus. Some programming languages such a Javascript, PHP, and Java don\x27t provide direct access to USB hardware, so <ui>usb</ui> will not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).</p><p> <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the host with the given IP address or hostname. That host can be a regular computer running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or YoctoHub-Wireless. If you want to use the VirtualHub running on you local computer, use the IP address 127.0.0.1.</p><p> <b>callback</b>: that keyword make the API run in \x22<i>HTTP Callback</i>\x22 mode. This a special mode allowing to take control of Yoctopuce devices through a NAT filter when using a VirtualHub or a networked YoctoHub. You only need to configure your hub to call your server script on a regular basis. This mode is currently available for PHP and Node.JS only.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access.</p><p> If access control has been activated on the hub, virtual or not, you want to reach, the URL parameter should look like:</p><p> <tt>http://username:password@address:port</tt></p><p> You can call <i>RegisterHub</i> several times to connect to several machines.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterHubDiscoveryCallback']={syn:'Register a callback function, to be called each time an Network Hub send an SSDP message.',lib:'YAPI.RegisterHubDiscoveryCallback()',pro:'def RegisterHubDiscoveryCallback(<span id=pn>hubDiscoveryCallback</span>)',cmt:'<p>Register a callback function, to be called each time an Network Hub send an SSDP message. The callback has two string parameter, the first one contain the serial number of the hub and the second contain the URL of the network hub (this URL can be passed to RegisterHub). This callback will be invoked while yUpdateDeviceList is running. You will have to call this function on a regular basis.</p>',par:{hubDiscoveryCallback:'a procedure taking two string parameter, or null to unregister a previously registered callback.'}};
doc['YAPI']['RegisterLogFunction']={syn:'Registers a log callback function.',lib:'YAPI.RegisterLogFunction()',pro:'def RegisterLogFunction(<span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite useful to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['SelectArchitecture']={syn:'Select the architecture or the library to be loaded to access to USB.',lib:'YAPI.SelectArchitecture()',pro:'def SelectArchitecture(<span id=pn>arch</span>)',cmt:'<p>Select the architecture or the library to be loaded to access to USB. By default, the Python library automatically detects the appropriate library to use. However, for Linux ARM, it not possible to reliably distinguish between a Hard Float (armhf) and a Soft Float (armel) install. For in this case, it is therefore recommended to manually select the proper architecture by calling <tt>SelectArchitecture()</tt> before any other call to the library.</p>',par:{arch:'A string containing the architecture to use. Possibles value are: <tt>\x22armhf\x22</tt>,<tt>\x22armel\x22</tt>, <tt>\x22i386\x22</tt>,<tt>\x22x86_64\x22</tt>,<tt>\x2232bit\x22</tt>, <tt>\x2264bit\x22</tt>'},ret:'nothing.',ext:'On failure, throws an exception.'};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI.Sleep()',pro:'def Sleep(<span id=pn>ms_duration</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significantly. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['TestHub']={syn:'Test if the hub is reachable.',lib:'YAPI.TestHub()',pro:'def TestHub(<span id=pn>url</span>, <span id=pn>mstimeout</span>, <span id=pn>errmsg</span>=None)',cmt:'<p>Test if the hub is reachable. This method do not register the hub, it only test if the hub is usable. The url parameter follow the same convention as the <tt>RegisterHub</tt> method. This method is useful to verify the authentication parameters for a hub. It is possible to force this method to return after mstimeout milliseconds.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',mstimeout:'the number of millisecond available to test the connection.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'};
doc['YAPI']['TriggerHubDiscovery']={syn:'Force a hub discovery, if a callback as been registered with <tt>yRegisterDeviceRemovalCallback</tt> it will be called for each net work hub that will respond to the discovery.',lib:'YAPI.TriggerHubDiscovery()',pro:'def TriggerHubDiscovery(<span id=pn>errmsg</span>=None)',cmt:'<p>Force a hub discovery, if a callback as been registered with <tt>yRegisterDeviceRemovalCallback</tt> it will be called for each net work hub that will respond to the discovery.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'def UnregisterHub(<span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI.UpdateDeviceList()',pro:'def UpdateDeviceList(<span id=pn>errmsg</span>=None)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'Unformatted data sequence',inc:'from yocto_api import *',cmt:'<p>YDataStream objects represent bare recorded measure sequences, exactly as found within the data logger present on Yoctopuce sensors.</p><p> In most cases, it is not necessary to use YDataStream objects directly, as the YDataSet objects (returned by the <tt>get_recordedData()</tt> method from sensors and the <tt>get_dataSets()</tt> method from the data logger) provide a more convenient interface.</p>'}};
doc['DataStream']['get_averageValue']={syn:'Returns the average of all measures observed within this stream.',lib:'datastream.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Returns the average of all measures observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the average value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_columnCount']={syn:'Returns the number of data columns present in this stream.',lib:'datastream.get_columnCount()',pro:'def get_columnCount()',cmt:'<p>Returns the number of data columns present in this stream. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of columns.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_columnNames']={syn:'Returns the title (or meaning) of each data column present in this stream.',lib:'datastream.get_columnNames()',pro:'def get_columnNames()',cmt:'<p>Returns the title (or meaning) of each data column present in this stream. In most case, the title of the data column is the hardware identifier of the sensor that produced the data. For streams recorded at a lower recording rate, the dataLogger stores the min, average and max value during each measure interval into three columns with suffixes _min, _avg and _max respectively.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'a list containing as many strings as there are columns in the data stream.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_data']={syn:'Returns a single measure from the data stream, specified by its row and column index.',lib:'datastream.get_data()',pro:'def get_data(<span id=pn>row</span>, <span id=pn>col</span>)',cmt:'<p>Returns a single measure from the data stream, specified by its row and column index. The meaning of the values present in each column can be obtained using the method get_columnNames().</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',par:{row:'row index',col:'column index'},ret:'a floating-point number',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Returns the whole data set contained in the stream, as a bidimensional table of numbers.',lib:'datastream.get_dataRows()',pro:'def get_dataRows()',cmt:'<p>Returns the whole data set contained in the stream, as a bidimensional table of numbers. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many elements as there are rows in the data stream. Each row itself is a list of floating-point numbers.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_dataSamplesIntervalMs']={syn:'Returns the number of milliseconds between two consecutive rows of this data stream.',lib:'datastream.get_dataSamplesIntervalMs()',pro:'def get_dataSamplesIntervalMs()',cmt:'<p>Returns the number of milliseconds between two consecutive rows of this data stream. By default, the data logger records one row per second, but the recording frequency can be changed for each device function</p>',ret:'an unsigned number corresponding to a number of milliseconds.'};
doc['DataStream']['get_duration']={syn:'Returns the approximate duration of this stream, in seconds.',lib:'datastream.get_duration()',pro:'def get_duration()',cmt:'<p>Returns the approximate duration of this stream, in seconds.</p>',ret:'the number of seconds covered by this stream.',ext:'On failure, throws an exception or returns Y_DURATION_INVALID.'};
doc['DataStream']['get_maxValue']={syn:'Returns the largest measure observed within this stream.',lib:'datastream.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Returns the largest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the largest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_minValue']={syn:'Returns the smallest measure observed within this stream.',lib:'datastream.get_minValue()',pro:'def get_minValue()',cmt:'<p>Returns the smallest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the smallest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_rowCount']={syn:'Returns the number of data rows present in this stream.',lib:'datastream.get_rowCount()',pro:'def get_rowCount()',cmt:'<p>Returns the number of data rows present in this stream.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of rows.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_runIndex']={syn:'Returns the run index of the data stream.',lib:'datastream.get_runIndex()',pro:'def get_runIndex()',cmt:'<p>Returns the run index of the data stream. A run can be made of multiple datastreams, for different time intervals.</p>',ret:'an unsigned number corresponding to the run index.'};
doc['DataStream']['get_startTime']={syn:'Returns the relative start time of the data stream, measured in seconds.',lib:'datastream.get_startTime()',pro:'def get_startTime()',cmt:'<p>Returns the relative start time of the data stream, measured in seconds. For recent firmwares, the value is relative to the present time, which means the value is always negative. If the device uses a firmware older than version 13000, value is relative to the start of the time the device was powered on, and is always positive. If you need an absolute UTC timestamp, use <tt>get_startTimeUTC()</tt>.</p>',ret:'an unsigned number corresponding to the number of seconds between the start of the run and the beginning of this data stream.'};
doc['DataStream']['get_startTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
//--- (end of generated code: DataStream)
//--- (generated code: DataSet)
doc['DataSet']={'':{syn:'Recorded data sequence',inc:'from yocto_api import *',cmt:'<p>YDataSet objects make it possible to retrieve a set of recorded measures for a given sensor and a specified time interval. They can be used to load data points with a progress report. When the YDataSet object is instantiated by the <tt>get_recordedData()</tt> function, no data is yet loaded from the module. It is only when the <tt>loadMore()</tt> method is called over and over than data will be effectively loaded from the dataLogger.</p><p> A preview of available measures is available using the function <tt>get_preview()</tt> as soon as <tt>loadMore()</tt> has been called once. Measures themselves are available using function <tt>get_measures()</tt> when loaded by subsequent calls to <tt>loadMore()</tt>.</p><p> This class can only be used on devices that use a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>'}};
doc['DataSet']['get_endTimeUTC']={syn:'Returns the end time of the dataset, relative to the Jan 1, 1970.',lib:'dataset.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Returns the end time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the end time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the end time is updated to reflect the timestamp of the last measure actually found in the dataLogger within the specified range.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the end of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_functionId']={syn:'Returns the hardware identifier of the function that performed the measure, without reference to the module.',lib:'dataset.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the function that performed the measure, without reference to the module. For example <tt>temperature1</tt>.</p>',ret:'a string that identifies the function (ex: <tt>temperature1</tt>)'};
doc['DataSet']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dataset.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function (for example <tt>THRMCPL1-123456.temperature1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>THRMCPL1-123456.temperature1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataSet']['get_measures']={syn:'Returns all measured values currently available for this DataSet, as a list of YMeasure objects.',lib:'dataset.get_measures()',pro:'def get_measures()',cmt:'<p>Returns all measured values currently available for this DataSet, as a list of YMeasure objects. Each item includes: - the start of the measure time interval - the end of the measure time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> Before calling this method, you should call <tt>loadMore()</tt> to load data from the device. You may have to call loadMore() several time until all rows are loaded, but you can start looking at available data rows before the load is complete.</p><p> The oldest measures are always loaded first, and the most recent measures will be loaded last. As a result, timestamps are normally sorted in ascending order within the measure table, unless there was an unexpected adjustment of the datalogger UTC clock.</p>',ret:'a table of records, where each record depicts the measured value for a given time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_preview']={syn:'Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects.',lib:'dataset.get_preview()',pro:'def get_preview()',cmt:'<p>Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects. Each item includes: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This preview is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_progress']={syn:'Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100.',lib:'dataset.get_progress()',pro:'def get_progress()',cmt:'<p>Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100. When the object is instantiated by <tt>get_dataSet</tt>, the progress is zero. Each time <tt>loadMore()</tt> is invoked, the progress is updated, to reach the value 100 only once all measures have been loaded.</p>',ret:'an integer in the range 0 to 100 (percentage of completion).'};
doc['DataSet']['get_startTimeUTC']={syn:'Returns the start time of the dataset, relative to the Jan 1, 1970.',lib:'dataset.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the start time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the start time is updated to reflect the timestamp of the first measure actually found in the dataLogger within the specified range.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_summary']={syn:'Returns an YMeasure object which summarizes the whole DataSet.',lib:'dataset.get_summary()',pro:'def get_summary()',cmt:'<p>Returns an YMeasure object which summarizes the whole DataSet. In includes the following information: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This summary is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'an YMeasure object'};
doc['DataSet']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'dataset.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string that represents a physical unit.',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['DataSet']['loadMore']={syn:'Loads the the next block of measures from the dataLogger, and updates the progress indicator.',lib:'dataset.loadMore()',pro:'def loadMore()',cmt:'<p>Loads the the next block of measures from the dataLogger, and updates the progress indicator.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DataSet)
//--- (generated code: Measure)
doc['Measure']={'':{syn:'Measured value',inc:'from yocto_api import *',cmt:'<p>YMeasure objects are used within the API to represent a value measured at a specified time. These objects are used in particular in conjunction with the YDataSet class.</p>'}};
doc['Measure']['get_averageValue']={syn:'Returns the average value observed during the time interval covered by this measure.',lib:'measure.get_averageValue()',pro:'def get_averageValue()',cmt:'<p>Returns the average value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the average value observed.'};
doc['Measure']['get_endTimeUTC']={syn:'Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure.get_endTimeUTC()',pro:'def get_endTimeUTC()',cmt:'<p>Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher than 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the end of this measure.'};
doc['Measure']['get_maxValue']={syn:'Returns the largest value observed during the time interval covered by this measure.',lib:'measure.get_maxValue()',pro:'def get_maxValue()',cmt:'<p>Returns the largest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the largest value observed.'};
doc['Measure']['get_minValue']={syn:'Returns the smallest value observed during the time interval covered by this measure.',lib:'measure.get_minValue()',pro:'def get_minValue()',cmt:'<p>Returns the smallest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the smallest value observed.'};
doc['Measure']['get_startTimeUTC']={syn:'Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure.get_startTimeUTC()',pro:'def get_startTimeUTC()',cmt:'<p>Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher then 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the beginning of this measure.'};
//--- (end of generated code: Measure)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'from yocto_display import *',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'displaylayer.clear()',pro:'def clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'displaylayer.clearConsole()',pro:'def clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'displaylayer.consoleOut()',pro:'def consoleOut(<span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'displaylayer.drawBar()',pro:'def drawBar(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'displaylayer.drawBitmap()',pro:'def drawBitmap(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>w</span>, <span id=pn>bitmap</span>, <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'displaylayer.drawCircle()',pro:'def drawCircle(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'displaylayer.drawDisc()',pro:'def drawDisc(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'displaylayer.drawImage()',pro:'def drawImage(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'displaylayer.drawPixel()',pro:'def drawPixel(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'displaylayer.drawRect()',pro:'def drawRect(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'displaylayer.drawText()',pro:'def drawText(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>anchor</span>, <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['get_display']={syn:'Gets parent YDisplay.',lib:'displaylayer.get_display()',pro:'def get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'};
doc['DisplayLayer']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'displaylayer.get_displayHeight()',pro:'def get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.'};
doc['DisplayLayer']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'displaylayer.get_displayWidth()',pro:'def get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.'};
doc['DisplayLayer']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'displaylayer.get_layerHeight()',pro:'def get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.'};
doc['DisplayLayer']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'displaylayer.get_layerWidth()',pro:'def get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.'};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'displaylayer.hide()',pro:'def hide()',cmt:'<p>Hides the layer. The state of the layer is perserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'displaylayer.lineTo()',pro:'def lineTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'displaylayer.moveTo()',pro:'def moveTo(<span id=pn>x</span>, <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'displaylayer.reset()',pro:'def reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectColorPen()',pro:'def selectColorPen(<span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'displaylayer.selectEraser()',pro:'def selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'displaylayer.selectFont()',pro:'def selectFont(<span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'displaylayer.selectGrayPen()',pro:'def selectGrayPen(<span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lighest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'displaylayer.setAntialiasingMode()',pro:'def setAntialiasingMode(<span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzzyness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<t>true</t> to enable antialiasing, <t>false</t> to disable it.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'displaylayer.setConsoleBackground()',pro:'def setConsoleBackground(<span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleMargins()',pro:'def setConsoleMargins(<span id=pn>x1</span>, <span id=pn>y1</span>, <span id=pn>x2</span>, <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.',lib:'displaylayer.setConsoleWordWrap()',pro:'def setConsoleWordWrap(<span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'displaylayer.setLayerPosition()',pro:'def setLayerPosition(<span id=pn>x</span>, <span id=pn>y</span>, <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'displaylayer.unhide()',pro:'def unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'from yocto_api import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['FindSensor']={syn:'Retrieves a sensor for a given identifier.',lib:'YSensor.FindSensor()',pro:'def FindSensor(<span id=pn>func</span>)',cmt:'<p>Retrieves a sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSensor.isOnline()</tt> to test if the sensor is indeed online at a given time. In case of ambiguity when looking for a sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the sensor'},ret:'a <tt>YSensor</tt> object allowing you to drive the sensor.'};
doc['Sensor']['FirstSensor']={syn:'Starts the enumeration of sensors currently accessible.',lib:'YSensor.FirstSensor()',pro:'def FirstSensor()',cmt:'<p>Starts the enumeration of sensors currently accessible. Use the method <tt>YSensor.nextSensor()</tt> to iterate on next sensors.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to the first sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'sensor.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'sensor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Sensor']['get_advertisedValue']={syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'sensor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'sensor.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'sensor.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Sensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the sensor.',lib:'sensor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the sensor object'};
doc['Sensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the sensor.',lib:'sensor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the sensor object'};
doc['Sensor']['get_friendlyName']={syn:'Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'sensor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Sensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'sensor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Sensor']['get_functionId']={syn:'Returns the hardware identifier of the sensor, without reference to the module.',lib:'sensor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Sensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'sensor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Sensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'sensor.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'sensor.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_logicalName']={syn:'Returns the logical name of the sensor.',lib:'sensor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Sensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'sensor.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'sensor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'sensor.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'sensor.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'sensor.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Sensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'sensor.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Sensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'sensor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Sensor']['isOnline']={syn:'Checks if the sensor is currently reachable, without raising any error.',lib:'sensor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the sensor is currently reachable, without raising any error. If there is a cached value for the sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the sensor.</p>',ret:'<tt>true</tt> if the sensor can be reached, and <tt>false</tt> otherwise'};
doc['Sensor']['load']={syn:'Preloads the sensor cache with a specified validity duration.',lib:'sensor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'sensor.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['nextSensor']={syn:'Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.',lib:'sensor.nextSensor()',pro:'def nextSensor()',cmt:'<p>Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to a sensor currently online, or a <tt>null</tt> pointer if there are no more sensors to enumerate.'};
doc['Sensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'sensor.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Sensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'sensor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Sensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'sensor.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'sensor.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logicalName']={syn:'Changes the logical name of the sensor.',lib:'sensor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'sensor.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'sensor.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'sensor.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'sensor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'sensor.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'sensor.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Sensor)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer function interface',inc:'from yocto_accelerometer import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Accelerometer']['FindAccelerometer']={syn:'Retrieves an accelerometer for a given identifier.',lib:'YAccelerometer.FindAccelerometer()',pro:'def FindAccelerometer(<span id=pn>func</span>)',cmt:'<p>Retrieves an accelerometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the accelerometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAccelerometer.isOnline()</tt> to test if the accelerometer is indeed online at a given time. In case of ambiguity when looking for an accelerometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the accelerometer'},ret:'a <tt>YAccelerometer</tt> object allowing you to drive the accelerometer.'};
doc['Accelerometer']['FirstAccelerometer']={syn:'Starts the enumeration of accelerometers currently accessible.',lib:'YAccelerometer.FirstAccelerometer()',pro:'def FirstAccelerometer()',cmt:'<p>Starts the enumeration of accelerometers currently accessible. Use the method <tt>YAccelerometer.nextAccelerometer()</tt> to iterate on next accelerometers.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to the first accelerometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Accelerometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'accelerometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'accelerometer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the accelerometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Accelerometer']['get_advertisedValue']={syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'accelerometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'accelerometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_currentValue']={syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'accelerometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the accelerometer.',lib:'accelerometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the accelerometer object'};
doc['Accelerometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the accelerometer.',lib:'accelerometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the accelerometer object'};
doc['Accelerometer']['get_friendlyName']={syn:'Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'accelerometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the accelerometer if they are defined, otherwise the serial number of the module and the hardware identifier of the accelerometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the accelerometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Accelerometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'accelerometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Accelerometer']['get_functionId']={syn:'Returns the hardware identifier of the accelerometer, without reference to the module.',lib:'accelerometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the accelerometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the accelerometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Accelerometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'accelerometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the accelerometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the accelerometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Accelerometer']['get_highestValue']={syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'accelerometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'accelerometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_logicalName']={syn:'Returns the logical name of the accelerometer.',lib:'accelerometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Accelerometer']['get_lowestValue']={syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'accelerometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'accelerometer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Accelerometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'accelerometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'accelerometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'accelerometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Accelerometer']['get_unit']={syn:'Returns the measuring unit for the acceleration.',lib:'accelerometer.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Accelerometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'accelerometer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Accelerometer']['get_xValue']={syn:'Returns the X component of the acceleration, as a floating point number.',lib:'accelerometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_yValue']={syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'accelerometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_zValue']={syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'accelerometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Accelerometer']['isOnline']={syn:'Checks if the accelerometer is currently reachable, without raising any error.',lib:'accelerometer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the accelerometer is currently reachable, without raising any error. If there is a cached value for the accelerometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the accelerometer.</p>',ret:'<tt>true</tt> if the accelerometer can be reached, and <tt>false</tt> otherwise'};
doc['Accelerometer']['load']={syn:'Preloads the accelerometer cache with a specified validity duration.',lib:'accelerometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the accelerometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'accelerometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['nextAccelerometer']={syn:'Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.',lib:'accelerometer.nextAccelerometer()',pro:'def nextAccelerometer()',cmt:'<p>Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to an accelerometer currently online, or a <tt>null</tt> pointer if there are no more accelerometers to enumerate.'};
doc['Accelerometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'accelerometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Accelerometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'accelerometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Accelerometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'accelerometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'accelerometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logicalName']={syn:'Changes the logical name of the accelerometer.',lib:'accelerometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the accelerometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'accelerometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'accelerometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'accelerometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'accelerometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Accelerometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'accelerometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Accelerometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'accelerometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer function interface',inc:'from yocto_magnetometer import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Magnetometer']['FindMagnetometer']={syn:'Retrieves a magnetometer for a given identifier.',lib:'YMagnetometer.FindMagnetometer()',pro:'def FindMagnetometer(<span id=pn>func</span>)',cmt:'<p>Retrieves a magnetometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the magnetometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMagnetometer.isOnline()</tt> to test if the magnetometer is indeed online at a given time. In case of ambiguity when looking for a magnetometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the magnetometer'},ret:'a <tt>YMagnetometer</tt> object allowing you to drive the magnetometer.'};
doc['Magnetometer']['FirstMagnetometer']={syn:'Starts the enumeration of magnetometers currently accessible.',lib:'YMagnetometer.FirstMagnetometer()',pro:'def FirstMagnetometer()',cmt:'<p>Starts the enumeration of magnetometers currently accessible. Use the method <tt>YMagnetometer.nextMagnetometer()</tt> to iterate on next magnetometers.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to the first magnetometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Magnetometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'magnetometer.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'magnetometer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the magnetometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Magnetometer']['get_advertisedValue']={syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'magnetometer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'magnetometer.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_currentValue']={syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'magnetometer.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the magnetometer.',lib:'magnetometer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the magnetometer object'};
doc['Magnetometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the magnetometer.',lib:'magnetometer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the magnetometer object'};
doc['Magnetometer']['get_friendlyName']={syn:'Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'magnetometer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the magnetometer if they are defined, otherwise the serial number of the module and the hardware identifier of the magnetometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the magnetometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Magnetometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'magnetometer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Magnetometer']['get_functionId']={syn:'Returns the hardware identifier of the magnetometer, without reference to the module.',lib:'magnetometer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the magnetometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the magnetometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Magnetometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'magnetometer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the magnetometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the magnetometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Magnetometer']['get_highestValue']={syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'magnetometer.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'magnetometer.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_logicalName']={syn:'Returns the logical name of the magnetometer.',lib:'magnetometer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Magnetometer']['get_lowestValue']={syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'magnetometer.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'magnetometer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Magnetometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'magnetometer.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'magnetometer.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'magnetometer.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Magnetometer']['get_unit']={syn:'Returns the measuring unit for the magnetic field.',lib:'magnetometer.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Magnetometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'magnetometer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Magnetometer']['get_xValue']={syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'magnetometer.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_yValue']={syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'magnetometer.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_zValue']={syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'magnetometer.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Magnetometer']['isOnline']={syn:'Checks if the magnetometer is currently reachable, without raising any error.',lib:'magnetometer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the magnetometer is currently reachable, without raising any error. If there is a cached value for the magnetometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the magnetometer.</p>',ret:'<tt>true</tt> if the magnetometer can be reached, and <tt>false</tt> otherwise'};
doc['Magnetometer']['load']={syn:'Preloads the magnetometer cache with a specified validity duration.',lib:'magnetometer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the magnetometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'magnetometer.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['nextMagnetometer']={syn:'Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.',lib:'magnetometer.nextMagnetometer()',pro:'def nextMagnetometer()',cmt:'<p>Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to a magnetometer currently online, or a <tt>null</tt> pointer if there are no more magnetometers to enumerate.'};
doc['Magnetometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'magnetometer.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Magnetometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'magnetometer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Magnetometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'magnetometer.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'magnetometer.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logicalName']={syn:'Changes the logical name of the magnetometer.',lib:'magnetometer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the magnetometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'magnetometer.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'magnetometer.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'magnetometer.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'magnetometer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Magnetometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'magnetometer.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Magnetometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'magnetometer.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Magnetometer)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Reference frame configuration',inc:'from yocto_refframe import *',cmt:'<p>This class is used to setup the base orientation of the Yocto-3D, so that the orientation functions, relative to the earth surface plane, use the proper reference frame. The class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}};
doc['RefFrame']['FindRefFrame']={syn:'Retrieves a reference frame for a given identifier.',lib:'YRefFrame.FindRefFrame()',pro:'def FindRefFrame(<span id=pn>func</span>)',cmt:'<p>Retrieves a reference frame for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the reference frame is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRefFrame.isOnline()</tt> to test if the reference frame is indeed online at a given time. In case of ambiguity when looking for a reference frame by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the reference frame'},ret:'a <tt>YRefFrame</tt> object allowing you to drive the reference frame.'};
doc['RefFrame']['FirstRefFrame']={syn:'Starts the enumeration of reference frames currently accessible.',lib:'YRefFrame.FirstRefFrame()',pro:'def FirstRefFrame()',cmt:'<p>Starts the enumeration of reference frames currently accessible. Use the method <tt>YRefFrame.nextRefFrame()</tt> to iterate on next reference frames.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to the first reference frame currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RefFrame']['cancel3DCalibration']={syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'refframe.cancel3DCalibration()',pro:'def cancel3DCalibration()',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['describe']={syn:'Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'refframe.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the reference frame (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationHint()',pro:'def get_3DCalibrationHint()',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Returns the latest log message from the calibration process.',lib:'refframe.get_3DCalibrationLogMsg()',pro:'def get_3DCalibrationLogMsg()',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationProgress()',pro:'def get_3DCalibrationProgress()',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStage()',pro:'def get_3DCalibrationStage()',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe.get_3DCalibrationStageProgress()',pro:'def get_3DCalibrationStageProgress()',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_advertisedValue']={syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'refframe.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RefFrame']['get_bearing']={syn:'Returns the reference bearing used by the compass.',lib:'refframe.get_bearing()',pro:'def get_bearing()',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:'On failure, throws an exception or returns <tt>Y_BEARING_INVALID</tt>.'};
doc['RefFrame']['get_errorMessage']={syn:'Returns the error message of the latest error with the reference frame.',lib:'refframe.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the reference frame object'};
doc['RefFrame']['get_errorType']={syn:'Returns the numerical error code of the latest error with the reference frame.',lib:'refframe.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the reference frame object'};
doc['RefFrame']['get_friendlyName']={syn:'Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'refframe.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the reference frame if they are defined, otherwise the serial number of the module and the hardware identifier of the reference frame (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the reference frame using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RefFrame']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'refframe.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RefFrame']['get_functionId']={syn:'Returns the hardware identifier of the reference frame, without reference to the module.',lib:'refframe.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the reference frame, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the reference frame (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RefFrame']['get_hardwareId']={syn:'Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'refframe.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the reference frame (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the reference frame (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RefFrame']['get_logicalName']={syn:'Returns the logical name of the reference frame.',lib:'refframe.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RefFrame']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'refframe.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RefFrame']['get_mountOrientation']={syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe.get_mountOrientation()',pro:'def get_mountOrientation()',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['get_mountPosition']={syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe.get_mountPosition()',pro:'def get_mountPosition()',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'refframe.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RefFrame']['isOnline']={syn:'Checks if the reference frame is currently reachable, without raising any error.',lib:'refframe.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the reference frame is currently reachable, without raising any error. If there is a cached value for the reference frame in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the reference frame.</p>',ret:'<tt>true</tt> if the reference frame can be reached, and <tt>false</tt> otherwise'};
doc['RefFrame']['load']={syn:'Preloads the reference frame cache with a specified validity duration.',lib:'refframe.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the reference frame cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['more3DCalibration']={syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'refframe.more3DCalibration()',pro:'def more3DCalibration()',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['nextRefFrame']={syn:'Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.',lib:'refframe.nextRefFrame()',pro:'def nextRefFrame()',cmt:'<p>Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to a reference frame currently online, or a <tt>null</tt> pointer if there are no more reference frames to enumerate.'};
doc['RefFrame']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'refframe.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RefFrame']['save3DCalibration']={syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'refframe.save3DCalibration()',pro:'def save3DCalibration()',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed. Remember to call the <tt>saveToFlash()</tt> method of the module if the changes must be kept when the device is restarted. On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['set_bearing']={syn:'Changes the reference bearing used by the compass.',lib:'refframe.set_bearing()',pro:'def set_bearing(<span id=pn>newval</span>)',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here. For instance, if you setup as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North. Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_logicalName']={syn:'Changes the logical name of the reference frame.',lib:'refframe.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the reference frame. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_mountPosition']={syn:'Changes the compass and tilt sensor frame of reference.',lib:'refframe.set_mountPosition()',pro:'def set_mountPosition(<span id=pn>position</span>, <span id=pn>orientation</span>)',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.'}};
doc['RefFrame']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'refframe.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RefFrame']['start3DCalibration']={syn:'Initiates the sensors tridimensional calibration process.',lib:'refframe.start3DCalibration()',pro:'def start3DCalibration()',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors. After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be canceled at any time using method <tt>cancel3DCalibration</tt>. On failure, throws an exception or returns a negative error code.</p>'};
//--- (end of generated code: RefFrame)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function interface',inc:'from yocto_compass import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Compass']['FindCompass']={syn:'Retrieves a compass for a given identifier.',lib:'YCompass.FindCompass()',pro:'def FindCompass(<span id=pn>func</span>)',cmt:'<p>Retrieves a compass for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the compass is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCompass.isOnline()</tt> to test if the compass is indeed online at a given time. In case of ambiguity when looking for a compass by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the compass'},ret:'a <tt>YCompass</tt> object allowing you to drive the compass.'};
doc['Compass']['FirstCompass']={syn:'Starts the enumeration of compasses currently accessible.',lib:'YCompass.FirstCompass()',pro:'def FirstCompass()',cmt:'<p>Starts the enumeration of compasses currently accessible. Use the method <tt>YCompass.nextCompass()</tt> to iterate on next compasses.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to the first compass currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Compass']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'compass.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['describe']={syn:'Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'compass.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the compass (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Compass']['get_advertisedValue']={syn:'Returns the current value of the compass (no more than 6 characters).',lib:'compass.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the compass (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Compass']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'compass.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Compass']['get_currentValue']={syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'compass.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Compass']['get_errorMessage']={syn:'Returns the error message of the latest error with the compass.',lib:'compass.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the compass object'};
doc['Compass']['get_errorType']={syn:'Returns the numerical error code of the latest error with the compass.',lib:'compass.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the compass object'};
doc['Compass']['get_friendlyName']={syn:'Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'compass.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the compass if they are defined, otherwise the serial number of the module and the hardware identifier of the compass (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the compass using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Compass']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'compass.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Compass']['get_functionId']={syn:'Returns the hardware identifier of the compass, without reference to the module.',lib:'compass.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the compass, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the compass (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Compass']['get_hardwareId']={syn:'Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'compass.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the compass (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the compass (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Compass']['get_highestValue']={syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'compass.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Compass']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'compass.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_logicalName']={syn:'Returns the logical name of the compass.',lib:'compass.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the compass.</p>',ret:'a string corresponding to the logical name of the compass.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Compass']['get_lowestValue']={syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'compass.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Compass']['get_magneticHeading']={syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'compass.get_magneticHeading()',pro:'def get_magneticHeading()',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:'On failure, throws an exception or returns <tt>Y_MAGNETICHEADING_INVALID</tt>.'};
doc['Compass']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'compass.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Compass']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'compass.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Compass']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'compass.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'compass.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Compass']['get_unit']={syn:'Returns the measuring unit for the relative bearing.',lib:'compass.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Compass']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'compass.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Compass']['isOnline']={syn:'Checks if the compass is currently reachable, without raising any error.',lib:'compass.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the compass is currently reachable, without raising any error. If there is a cached value for the compass in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the compass.</p>',ret:'<tt>true</tt> if the compass can be reached, and <tt>false</tt> otherwise'};
doc['Compass']['load']={syn:'Preloads the compass cache with a specified validity duration.',lib:'compass.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the compass cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'compass.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['nextCompass']={syn:'Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>.',lib:'compass.nextCompass()',pro:'def nextCompass()',cmt:'<p>Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to a compass currently online, or a <tt>null</tt> pointer if there are no more compasses to enumerate.'};
doc['Compass']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'compass.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Compass']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'compass.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Compass']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'compass.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'compass.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logicalName']={syn:'Changes the logical name of the compass.',lib:'compass.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the compass. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the compass.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'compass.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'compass.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'compass.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'compass.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Compass']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'compass.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Compass']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'compass.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope function interface',inc:'from yocto_gyro import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Gyro']['FindGyro']={syn:'Retrieves a gyroscope for a given identifier.',lib:'YGyro.FindGyro()',pro:'def FindGyro(<span id=pn>func</span>)',cmt:'<p>Retrieves a gyroscope for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the gyroscope is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGyro.isOnline()</tt> to test if the gyroscope is indeed online at a given time. In case of ambiguity when looking for a gyroscope by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the gyroscope'},ret:'a <tt>YGyro</tt> object allowing you to drive the gyroscope.'};
doc['Gyro']['FirstGyro']={syn:'Starts the enumeration of gyroscopes currently accessible.',lib:'YGyro.FirstGyro()',pro:'def FirstGyro()',cmt:'<p>Starts the enumeration of gyroscopes currently accessible. Use the method <tt>YGyro.nextGyro()</tt> to iterate on next gyroscopes.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to the first gyro currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gyro']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'gyro.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['describe']={syn:'Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gyro.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the gyroscope (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gyro']['get_advertisedValue']={syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'gyro.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gyro']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'gyro.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Gyro']['get_currentValue']={syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'gyro.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Gyro']['get_errorMessage']={syn:'Returns the error message of the latest error with the gyroscope.',lib:'gyro.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the gyroscope object'};
doc['Gyro']['get_errorType']={syn:'Returns the numerical error code of the latest error with the gyroscope.',lib:'gyro.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the gyroscope object'};
doc['Gyro']['get_friendlyName']={syn:'Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gyro.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the gyroscope if they are defined, otherwise the serial number of the module and the hardware identifier of the gyroscope (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the gyroscope using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gyro']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gyro.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gyro']['get_functionId']={syn:'Returns the hardware identifier of the gyroscope, without reference to the module.',lib:'gyro.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the gyroscope, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the gyroscope (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gyro']['get_hardwareId']={syn:'Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gyro.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the gyroscope (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the gyroscope (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gyro']['get_heading']={syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_heading()',pro:'def get_heading()',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'};
doc['Gyro']['get_highestValue']={syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'gyro.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'gyro.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_logicalName']={syn:'Returns the logical name of the gyroscope.',lib:'gyro.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gyro']['get_lowestValue']={syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'gyro.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gyro.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gyro']['get_pitch']={syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_pitch()',pro:'def get_pitch()',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'};
doc['Gyro']['get_quaternionW']={syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionW()',pro:'def get_quaternionW()',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. </p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionX()',pro:'def get_quaternionX()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionY()',pro:'def get_quaternionY()',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_quaternionZ()',pro:'def get_quaternionZ()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'gyro.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Gyro']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'gyro.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'gyro.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Gyro']['get_roll']={syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro.get_roll()',pro:'def get_roll()',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'};
doc['Gyro']['get_unit']={syn:'Returns the measuring unit for the angular velocity.',lib:'gyro.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Gyro']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gyro.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gyro']['get_xValue']={syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'gyro.get_xValue()',pro:'def get_xValue()',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Gyro']['get_yValue']={syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'gyro.get_yValue()',pro:'def get_yValue()',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Gyro']['get_zValue']={syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'gyro.get_zValue()',pro:'def get_zValue()',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Gyro']['isOnline']={syn:'Checks if the gyroscope is currently reachable, without raising any error.',lib:'gyro.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the gyroscope is currently reachable, without raising any error. If there is a cached value for the gyroscope in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the gyroscope.</p>',ret:'<tt>true</tt> if the gyroscope can be reached, and <tt>false</tt> otherwise'};
doc['Gyro']['load']={syn:'Preloads the gyroscope cache with a specified validity duration.',lib:'gyro.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the gyroscope cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'gyro.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['nextGyro']={syn:'Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.',lib:'gyro.nextGyro()',pro:'def nextGyro()',cmt:'<p>Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to a gyroscope currently online, or a <tt>null</tt> pointer if there are no more gyroscopes to enumerate.'};
doc['Gyro']['registerAnglesCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro.registerAnglesCallback()',pro:'def registerAnglesCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take four arguments: the YGyro object of the turning device, and the floating point values of the three angles roll, pitch and heading in degrees (as floating-point numbers).'}};
doc['Gyro']['registerQuaternionCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro.registerQuaternionCallback()',pro:'def registerQuaternionCallback(<span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take five arguments: the YGyro object of the turning device, and the floating point values of the four components w, x, y and z (as floating-point numbers).'}};
doc['Gyro']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'gyro.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Gyro']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gyro.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gyro']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'gyro.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'gyro.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logicalName']={syn:'Changes the logical name of the gyroscope.',lib:'gyro.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the gyroscope. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'gyro.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'gyro.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'gyro.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gyro.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gyro']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'gyro.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Gyro']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'gyro.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt function interface',inc:'from yocto_tilt import *',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Tilt']['FindTilt']={syn:'Retrieves a tilt sensor for a given identifier.',lib:'YTilt.FindTilt()',pro:'def FindTilt(<span id=pn>func</span>)',cmt:'<p>Retrieves a tilt sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the tilt sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTilt.isOnline()</tt> to test if the tilt sensor is indeed online at a given time. In case of ambiguity when looking for a tilt sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the tilt sensor'},ret:'a <tt>YTilt</tt> object allowing you to drive the tilt sensor.'};
doc['Tilt']['FirstTilt']={syn:'Starts the enumeration of tilt sensors currently accessible.',lib:'YTilt.FirstTilt()',pro:'def FirstTilt()',cmt:'<p>Starts the enumeration of tilt sensors currently accessible. Use the method <tt>YTilt.nextTilt()</tt> to iterate on next tilt sensors.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to the first tilt sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Tilt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'tilt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tilt.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the tilt sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tilt']['get_advertisedValue']={syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'tilt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tilt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'tilt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tilt']['get_currentValue']={syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'tilt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tilt']['get_errorMessage']={syn:'Returns the error message of the latest error with the tilt sensor.',lib:'tilt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the tilt sensor object'};
doc['Tilt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the tilt sensor.',lib:'tilt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the tilt sensor object'};
doc['Tilt']['get_friendlyName']={syn:'Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'tilt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the tilt sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the tilt sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the tilt sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tilt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'tilt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Tilt']['get_functionId']={syn:'Returns the hardware identifier of the tilt sensor, without reference to the module.',lib:'tilt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the tilt sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the tilt sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tilt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'tilt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the tilt sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the tilt sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tilt']['get_highestValue']={syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'tilt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the inclination since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'tilt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_logicalName']={syn:'Returns the logical name of the tilt sensor.',lib:'tilt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tilt']['get_lowestValue']={syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'tilt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the inclination since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'tilt.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Tilt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'tilt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tilt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'tilt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'tilt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tilt']['get_unit']={syn:'Returns the measuring unit for the inclination.',lib:'tilt.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Tilt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'tilt.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Tilt']['isOnline']={syn:'Checks if the tilt sensor is currently reachable, without raising any error.',lib:'tilt.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the tilt sensor is currently reachable, without raising any error. If there is a cached value for the tilt sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the tilt sensor.</p>',ret:'<tt>true</tt> if the tilt sensor can be reached, and <tt>false</tt> otherwise'};
doc['Tilt']['load']={syn:'Preloads the tilt sensor cache with a specified validity duration.',lib:'tilt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the tilt sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'tilt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['nextTilt']={syn:'Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.',lib:'tilt.nextTilt()',pro:'def nextTilt()',cmt:'<p>Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to a tilt sensor currently online, or a <tt>null</tt> pointer if there are no more tilt sensors to enumerate.'};
doc['Tilt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'tilt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Tilt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'tilt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Tilt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'tilt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'tilt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logicalName']={syn:'Changes the logical name of the tilt sensor.',lib:'tilt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the tilt sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'tilt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'tilt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'tilt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'tilt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Tilt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'tilt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tilt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'tilt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Tilt)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Quaternion interface',inc:'from yocto_gyro import *',cmt:'<p>The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation using a quaternion. It is usually not needed to use the YQt class directly, as the YGyro class provides a more convenient higher-level interface.</p>'}};
doc['Qt']['FindQt']={syn:'Retrieves a quaternion component for a given identifier.',lib:'YQt.FindQt()',pro:'def FindQt(<span id=pn>func</span>)',cmt:'<p>Retrieves a quaternion component for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quaternion component is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQt.isOnline()</tt> to test if the quaternion component is indeed online at a given time. In case of ambiguity when looking for a quaternion component by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the quaternion component'},ret:'a <tt>YQt</tt> object allowing you to drive the quaternion component.'};
doc['Qt']['FirstQt']={syn:'Starts the enumeration of quaternion components currently accessible.',lib:'YQt.FirstQt()',pro:'def FirstQt()',cmt:'<p>Starts the enumeration of quaternion components currently accessible. Use the method <tt>YQt.nextQt()</tt> to iterate on next quaternion components.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to the first quaternion component currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Qt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'qt.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'qt.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quaternion component (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Qt']['get_advertisedValue']={syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'qt.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Qt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'qt.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Qt']['get_currentValue']={syn:'Returns the current value of the value, in units, as a floating point number.',lib:'qt.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the value, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Qt']['get_errorMessage']={syn:'Returns the error message of the latest error with the quaternion component.',lib:'qt.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quaternion component object'};
doc['Qt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the quaternion component.',lib:'qt.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quaternion component object'};
doc['Qt']['get_friendlyName']={syn:'Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'qt.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quaternion component if they are defined, otherwise the serial number of the module and the hardware identifier of the quaternion component (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quaternion component using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Qt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'qt.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Qt']['get_functionId']={syn:'Returns the hardware identifier of the quaternion component, without reference to the module.',lib:'qt.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the quaternion component, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quaternion component (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Qt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'qt.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quaternion component (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quaternion component (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Qt']['get_highestValue']={syn:'Returns the maximal value observed for the value since the device was started.',lib:'qt.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the value since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Qt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'qt.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_logicalName']={syn:'Returns the logical name of the quaternion component.',lib:'qt.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Qt']['get_lowestValue']={syn:'Returns the minimal value observed for the value since the device was started.',lib:'qt.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the value since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Qt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'qt.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Qt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'qt.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Qt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'qt.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'qt.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Qt']['get_unit']={syn:'Returns the measuring unit for the value.',lib:'qt.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Qt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'qt.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Qt']['isOnline']={syn:'Checks if the quaternion component is currently reachable, without raising any error.',lib:'qt.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the quaternion component is currently reachable, without raising any error. If there is a cached value for the quaternion component in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quaternion component.</p>',ret:'<tt>true</tt> if the quaternion component can be reached, and <tt>false</tt> otherwise'};
doc['Qt']['load']={syn:'Preloads the quaternion component cache with a specified validity duration.',lib:'qt.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the quaternion component cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'qt.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['nextQt']={syn:'Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.',lib:'qt.nextQt()',pro:'def nextQt()',cmt:'<p>Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to a quaternion component currently online, or a <tt>null</tt> pointer if there are no more quaternion components to enumerate.'};
doc['Qt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'qt.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Qt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'qt.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Qt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'qt.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'qt.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logicalName']={syn:'Changes the logical name of the quaternion component.',lib:'qt.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quaternion component. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'qt.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'qt.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'qt.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'qt.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Qt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'qt.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Qt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'qt.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Qt)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'Pwm function interface',inc:'from yocto_pwmoutput import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.</p>'}};
doc['PwmOutput']['FindPwmOutput']={syn:'Retrieves a PWM for a given identifier.',lib:'YPwmOutput.FindPwmOutput()',pro:'def FindPwmOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmOutput.isOnline()</tt> to test if the PWM is indeed online at a given time. In case of ambiguity when looking for a PWM by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the PWM'},ret:'a <tt>YPwmOutput</tt> object allowing you to drive the PWM.'};
doc['PwmOutput']['FirstPwmOutput']={syn:'Starts the enumeration of PWMs currently accessible.',lib:'YPwmOutput.FirstPwmOutput()',pro:'def FirstPwmOutput()',cmt:'<p>Starts the enumeration of PWMs currently accessible. Use the method <tt>YPwmOutput.nextPwmOutput()</tt> to iterate on next PWMs.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to the first PWM currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmoutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmOutput']['dutyCycleMove']={syn:'Performs a smooth change of the pulse duration toward a given value.',lib:'pwmoutput.dutyCycleMove()',pro:'def dutyCycleMove(<span id=pn>target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth change of the pulse duration toward a given value.</p>',par:{target:'new duty cycle at the end of the transition (floating-point number, between 0 and 1)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['get_advertisedValue']={syn:'Returns the current value of the PWM (no more than 6 characters).',lib:'pwmoutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the PWM (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwmoutput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycleAtPowerOn']={syn:'Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100 ',lib:'pwmoutput.get_dutyCycleAtPowerOn()',pro:'def get_dutyCycleAtPowerOn()',cmt:'<p>Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100</p>',ret:'a floating point number corresponding to the PWMs duty cycle at device power on as a floating point number between 0 and 100',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLEATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_enabled']={syn:'Returns the state of the PWMs.',lib:'pwmoutput.get_enabled()',pro:'def get_enabled()',cmt:'<p>Returns the state of the PWMs.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the PWMs',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Returns the state of the PWM at device power on.',lib:'pwmoutput.get_enabledAtPowerOn()',pro:'def get_enabledAtPowerOn()',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM.',lib:'pwmoutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM object'};
doc['PwmOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM.',lib:'pwmoutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM object'};
doc['PwmOutput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwmoutput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmOutput']['get_friendlyName']={syn:'Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmoutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmoutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmOutput']['get_functionId']={syn:'Returns the hardware identifier of the PWM, without reference to the module.',lib:'pwmoutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmoutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmOutput']['get_logicalName']={syn:'Returns the logical name of the PWM.',lib:'pwmoutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the PWM.</p>',ret:'a string corresponding to the logical name of the PWM.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmoutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmOutput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwmoutput.get_period()',pro:'def get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmOutput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwmoutput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmoutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmOutput']['isOnline']={syn:'Checks if the PWM is currently reachable, without raising any error.',lib:'pwmoutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the PWM is currently reachable, without raising any error. If there is a cached value for the PWM in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM.</p>',ret:'<tt>true</tt> if the PWM can be reached, and <tt>false</tt> otherwise'};
doc['PwmOutput']['load']={syn:'Preloads the PWM cache with a specified validity duration.',lib:'pwmoutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['nextPwmOutput']={syn:'Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>.',lib:'pwmoutput.nextPwmOutput()',pro:'def nextPwmOutput()',cmt:'<p>Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to a PWM currently online, or a <tt>null</tt> pointer if there are no more PWMs to enumerate.'};
doc['PwmOutput']['pulseDurationMove']={syn:'Performs a smooth transistion of the pulse duration toward a given value.',lib:'pwmoutput.pulseDurationMove()',pro:'def pulseDurationMove(<span id=pn>ms_target</span>, <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transistion of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmoutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmOutput']['set_dutyCycle']={syn:'Changes the PWM duty cycle, in per cents.',lib:'pwmoutput.set_dutyCycle()',pro:'def set_dutyCycle(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Changes the PWM duty cycle at device power on.',lib:'pwmoutput.set_dutyCycleAtPowerOn()',pro:'def set_dutyCycleAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabled']={syn:'Stops or starts the PWM.',lib:'pwmoutput.set_enabled()',pro:'def set_enabled(<span id=pn>newval</span>)',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Changes the state of the PWM at device power on.',lib:'pwmoutput.set_enabledAtPowerOn()',pro:'def set_enabledAtPowerOn(<span id=pn>newval</span>)',cmt:'<p>Changes the state of the PWM at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_frequency']={syn:'Changes the PWM frequency.',lib:'pwmoutput.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_logicalName']={syn:'Changes the logical name of the PWM.',lib:'pwmoutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_period']={syn:'Changes the PWM period in milliseconds.',lib:'pwmoutput.set_period()',pro:'def set_period(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM period in milliseconds.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_pulseDuration']={syn:'Changes the PWM pulse length, in milliseconds.',lib:'pwmoutput.set_pulseDuration()',pro:'def set_pulseDuration(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmoutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PwmPowerSource function interface',inc:'from yocto_pwmpowersource import *',cmt:'<p>The Yoctopuce application programming interface allows you to configure the voltage source used by all PWM on the same device.</p>'}};
doc['PwmPowerSource']['FindPwmPowerSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YPwmPowerSource.FindPwmPowerSource()',pro:'def FindPwmPowerSource(<span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmPowerSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YPwmPowerSource</tt> object allowing you to drive the voltage source.'};
doc['PwmPowerSource']['FirstPwmPowerSource']={syn:'Starts the enumeration of Voltage sources currently accessible.',lib:'YPwmPowerSource.FirstPwmPowerSource()',pro:'def FirstPwmPowerSource()',cmt:'<p>Starts the enumeration of Voltage sources currently accessible. Use the method <tt>YPwmPowerSource.nextPwmPowerSource()</tt> to iterate on next Voltage sources.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to the first source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmPowerSource']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmpowersource.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage source (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'pwmpowersource.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmPowerSource']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage source.',lib:'pwmpowersource.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage source object'};
doc['PwmPowerSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage source.',lib:'pwmpowersource.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage source object'};
doc['PwmPowerSource']['get_friendlyName']={syn:'Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmpowersource.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage source if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage source (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage source using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmpowersource.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionId']={syn:'Returns the hardware identifier of the voltage source, without reference to the module.',lib:'pwmpowersource.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage source, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage source (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmPowerSource']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmpowersource.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage source (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage source (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmPowerSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'pwmpowersource.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmpowersource.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmPowerSource']['get_powerMode']={syn:'Returns the selected power source for the PWM on the same device ',lib:'pwmpowersource.get_powerMode()',pro:'def get_powerMode()',cmt:'<p>Returns the selected power source for the PWM on the same device</p>',ret:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the selected power source for the PWM on the same device',ext:'On failure, throws an exception or returns <tt>Y_POWERMODE_INVALID</tt>.'};
doc['PwmPowerSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmpowersource.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmPowerSource']['isOnline']={syn:'Checks if the voltage source is currently reachable, without raising any error.',lib:'pwmpowersource.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the voltage source is currently reachable, without raising any error. If there is a cached value for the voltage source in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage source.</p>',ret:'<tt>true</tt> if the voltage source can be reached, and <tt>false</tt> otherwise'};
doc['PwmPowerSource']['load']={syn:'Preloads the voltage source cache with a specified validity duration.',lib:'pwmpowersource.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage source cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['nextPwmPowerSource']={syn:'Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>.',lib:'pwmpowersource.nextPwmPowerSource()',pro:'def nextPwmPowerSource()',cmt:'<p>Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more Voltage sources to enumerate.'};
doc['PwmPowerSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmpowersource.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmPowerSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'pwmpowersource.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_powerMode']={syn:'Changes the PWM power source.',lib:'pwmpowersource.set_powerMode()',pro:'def set_powerMode(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmpowersource.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altitude function interface',inc:'from yocto_altitude import *',cmt:'<p>The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}};
doc['Altitude']['FindAltitude']={syn:'Retrieves an altimeter for a given identifier.',lib:'YAltitude.FindAltitude()',pro:'def FindAltitude(<span id=pn>func</span>)',cmt:'<p>Retrieves an altimeter for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the altimeter is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAltitude.isOnline()</tt> to test if the altimeter is indeed online at a given time. In case of ambiguity when looking for an altimeter by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the altimeter'},ret:'a <tt>YAltitude</tt> object allowing you to drive the altimeter.'};
doc['Altitude']['FirstAltitude']={syn:'Starts the enumeration of altimeters currently accessible.',lib:'YAltitude.FirstAltitude()',pro:'def FirstAltitude()',cmt:'<p>Starts the enumeration of altimeters currently accessible. Use the method <tt>YAltitude.nextAltitude()</tt> to iterate on next altimeters.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to the first altimeter currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Altitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'altitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'altitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the altimeter (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Altitude']['get_advertisedValue']={syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'altitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'altitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentValue']={syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'altitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Altitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the altimeter.',lib:'altitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the altimeter object'};
doc['Altitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the altimeter.',lib:'altitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the altimeter object'};
doc['Altitude']['get_friendlyName']={syn:'Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'altitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the altimeter if they are defined, otherwise the serial number of the module and the hardware identifier of the altimeter (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the altimeter using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Altitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'altitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Altitude']['get_functionId']={syn:'Returns the hardware identifier of the altimeter, without reference to the module.',lib:'altitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the altimeter, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the altimeter (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Altitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'altitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the altimeter (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the altimeter (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Altitude']['get_highestValue']={syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'altitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the altitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'altitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_logicalName']={syn:'Returns the logical name of the altimeter.',lib:'altitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Altitude']['get_lowestValue']={syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'altitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the altitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'altitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Altitude']['get_qnh']={syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude.get_qnh()',pro:'def get_qnh()',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:'On failure, throws an exception or returns <tt>Y_QNH_INVALID</tt>.'};
doc['Altitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'altitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Altitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'altitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'altitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Altitude']['get_technology']={syn:'Returns the technology used by the sesnor to compute altitude.',lib:'altitude.get_technology()',pro:'def get_technology()',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:'On failure, throws an exception or returns <tt>Y_TECHNOLOGY_INVALID</tt>.'};
doc['Altitude']['get_unit']={syn:'Returns the measuring unit for the altitude.',lib:'altitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Altitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'altitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Altitude']['isOnline']={syn:'Checks if the altimeter is currently reachable, without raising any error.',lib:'altitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the altimeter is currently reachable, without raising any error. If there is a cached value for the altimeter in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the altimeter.</p>',ret:'<tt>true</tt> if the altimeter can be reached, and <tt>false</tt> otherwise'};
doc['Altitude']['load']={syn:'Preloads the altimeter cache with a specified validity duration.',lib:'altitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the altimeter cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'altitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['nextAltitude']={syn:'Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.',lib:'altitude.nextAltitude()',pro:'def nextAltitude()',cmt:'<p>Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to an altimeter currently online, or a <tt>null</tt> pointer if there are no more altimeters to enumerate.'};
doc['Altitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'altitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Altitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'altitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Altitude']['set_currentValue']={syn:'Changes the current estimated altitude.',lib:'altitude.set_currentValue()',pro:'def set_currentValue(<span id=pn>newval</span>)',cmt:'<p>Changes the current estimated altitude. This allows to compensate for ambient pressure variations and to work in relative mode.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'altitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'altitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logicalName']={syn:'Changes the logical name of the altimeter.',lib:'altitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the altimeter. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'altitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_qnh']={syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude.set_qnh()',pro:'def set_qnh(<span id=pn>newval</span>)',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'altitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'altitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'altitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Altitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'altitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Altitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'altitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Altitude)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor function interface',inc:'from yocto_motor import *',cmt:'<p>Yoctopuce application programming interface allows you to drive the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}};
doc['Motor']['FindMotor']={syn:'Retrieves a motor for a given identifier.',lib:'YMotor.FindMotor()',pro:'def FindMotor(<span id=pn>func</span>)',cmt:'<p>Retrieves a motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMotor.isOnline()</tt> to test if the motor is indeed online at a given time. In case of ambiguity when looking for a motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the motor'},ret:'a <tt>YMotor</tt> object allowing you to drive the motor.'};
doc['Motor']['FirstMotor']={syn:'Starts the enumeration of motors currently accessible.',lib:'YMotor.FirstMotor()',pro:'def FirstMotor()',cmt:'<p>Starts the enumeration of motors currently accessible. Use the method <tt>YMotor.nextMotor()</tt> to iterate on next motors.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to the first motor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Motor']['brakingForceMove']={syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'motor.brakingForceMove()',pro:'def brakingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'motor.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Motor']['drivingForceMove']={syn:'Changes progressively the power sent to the moteur for a specific duration.',lib:'motor.drivingForceMove()',pro:'def drivingForceMove(<span id=pn>targetPower</span>, <span id=pn>delay</span>)',cmt:'<p>Changes progressively the power sent to the moteur for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['get_advertisedValue']={syn:'Returns the current value of the motor (no more than 6 characters).',lib:'motor.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Motor']['get_brakingForce']={syn:'Returns the braking force applied to the motor, as a percentage.',lib:'motor.get_brakingForce()',pro:'def get_brakingForce()',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:'On failure, throws an exception or returns <tt>Y_BRAKINGFORCE_INVALID</tt>.'};
doc['Motor']['get_cutOffVoltage']={syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor.get_cutOffVoltage()',pro:'def get_cutOffVoltage()',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:'On failure, throws an exception or returns <tt>Y_CUTOFFVOLTAGE_INVALID</tt>.'};
doc['Motor']['get_drivingForce']={syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'motor.get_drivingForce()',pro:'def get_drivingForce()',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:'On failure, throws an exception or returns <tt>Y_DRIVINGFORCE_INVALID</tt>.'};
doc['Motor']['get_errorMessage']={syn:'Returns the error message of the latest error with the motor.',lib:'motor.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the motor object'};
doc['Motor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the motor.',lib:'motor.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the motor object'};
doc['Motor']['get_failSafeTimeout']={syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor.get_failSafeTimeout()',pro:'def get_failSafeTimeout()',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:'On failure, throws an exception or returns <tt>Y_FAILSAFETIMEOUT_INVALID</tt>.'};
doc['Motor']['get_frequency']={syn:'Returns the PWM frequency used to control the motor.',lib:'motor.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Motor']['get_friendlyName']={syn:'Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'motor.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the motor if they are defined, otherwise the serial number of the module and the hardware identifier of the motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Motor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'motor.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Motor']['get_functionId']={syn:'Returns the hardware identifier of the motor, without reference to the module.',lib:'motor.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Motor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'motor.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Motor']['get_logicalName']={syn:'Returns the logical name of the motor.',lib:'motor.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Motor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'motor.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Motor']['get_motorStatus']={syn:'Return the controller state.',lib:'motor.get_motorStatus()',pro:'def get_motorStatus()',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an overcurrent condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>Y_MOTORSTATUS_IDLE</tt>, <tt>Y_MOTORSTATUS_BRAKE</tt>, <tt>Y_MOTORSTATUS_FORWD</tt>, <tt>Y_MOTORSTATUS_BACKWD</tt>, <tt>Y_MOTORSTATUS_LOVOLT</tt>, <tt>Y_MOTORSTATUS_HICURR</tt>, <tt>Y_MOTORSTATUS_HIHEAT</tt> and <tt>Y_MOTORSTATUS_FAILSF</tt>',ext:'On failure, throws an exception or returns <tt>Y_MOTORSTATUS_INVALID</tt>.'};
doc['Motor']['get_overCurrentLimit']={syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor.get_overCurrentLimit()',pro:'def get_overCurrentLimit()',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENTLIMIT_INVALID</tt>.'};
doc['Motor']['get_starterTime']={syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor.get_starterTime()',pro:'def get_starterTime()',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:'On failure, throws an exception or returns <tt>Y_STARTERTIME_INVALID</tt>.'};
doc['Motor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'motor.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Motor']['isOnline']={syn:'Checks if the motor is currently reachable, without raising any error.',lib:'motor.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the motor is currently reachable, without raising any error. If there is a cached value for the motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the motor.</p>',ret:'<tt>true</tt> if the motor can be reached, and <tt>false</tt> otherwise'};
doc['Motor']['keepALive']={syn:'Rearms the controller failsafe timer.',lib:'motor.keepALive()',pro:'def keepALive()',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitely rearms the failsafe timer.</p>'};
doc['Motor']['load']={syn:'Preloads the motor cache with a specified validity duration.',lib:'motor.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['nextMotor']={syn:'Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.',lib:'motor.nextMotor()',pro:'def nextMotor()',cmt:'<p>Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to a motor currently online, or a <tt>null</tt> pointer if there are no more motors to enumerate.'};
doc['Motor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'motor.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Motor']['resetStatus']={syn:'Reset the controller state to IDLE.',lib:'motor.resetStatus()',pro:'def resetStatus()',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitely after any error condition is signaled.</p>'};
doc['Motor']['set_brakingForce']={syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'motor.set_brakingForce()',pro:'def set_brakingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_cutOffVoltage']={syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor.set_cutOffVoltage()',pro:'def set_cutOffVoltage(<span id=pn>newval</span>)',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_drivingForce']={syn:'Changes immediately the power sent to the motor.',lib:'motor.set_drivingForce()',pro:'def set_drivingForce(<span id=pn>newval</span>)',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_failSafeTimeout']={syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor.set_failSafeTimeout()',pro:'def set_failSafeTimeout(<span id=pn>newval</span>)',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_frequency']={syn:'Changes the PWM frequency used to control the motor.',lib:'motor.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_logicalName']={syn:'Changes the logical name of the motor.',lib:'motor.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_overCurrentLimit']={syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor.set_overCurrentLimit()',pro:'def set_overCurrentLimit(<span id=pn>newval</span>)',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_starterTime']={syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor.set_starterTime()',pro:'def set_starterTime(<span id=pn>newval</span>)',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'motor.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Motor)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'SerialPort function interface',inc:'from yocto_serialport import *',cmt:'<p>The SerialPort function interface allows you to fully drive a Yoctopuce serial port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SerialPort']['FindSerialPort']={syn:'Retrieves a serial port for a given identifier.',lib:'YSerialPort.FindSerialPort()',pro:'def FindSerialPort(<span id=pn>func</span>)',cmt:'<p>Retrieves a serial port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the serial port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSerialPort.isOnline()</tt> to test if the serial port is indeed online at a given time. In case of ambiguity when looking for a serial port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the serial port'},ret:'a <tt>YSerialPort</tt> object allowing you to drive the serial port.'};
doc['SerialPort']['FirstSerialPort']={syn:'Starts the enumeration of serial ports currently accessible.',lib:'YSerialPort.FirstSerialPort()',pro:'def FirstSerialPort()',cmt:'<p>Starts the enumeration of serial ports currently accessible. Use the method <tt>YSerialPort.nextSerialPort()</tt> to iterate on next serial ports.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to the first serial port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SerialPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'serialport.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the serial port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SerialPort']['get_CTS']={syn:'Reads the level of the CTS line.',lib:'serialport.get_CTS()',pro:'def get_CTS()',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['get_advertisedValue']={syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'serialport.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SerialPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'serialport.get_currentJob()',pro:'def get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SerialPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'serialport.get_errCount()',pro:'def get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the serial port.',lib:'serialport.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the serial port object'};
doc['SerialPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the serial port.',lib:'serialport.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the serial port object'};
doc['SerialPort']['get_friendlyName']={syn:'Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'serialport.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the serial port if they are defined, otherwise the serial number of the module and the hardware identifier of the serial port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the serial port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SerialPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'serialport.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SerialPort']['get_functionId']={syn:'Returns the hardware identifier of the serial port, without reference to the module.',lib:'serialport.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the serial port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the serial port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SerialPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'serialport.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the serial port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the serial port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SerialPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'serialport.get_lastMsg()',pro:'def get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:'On failure, throws an exception or returns <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SerialPort']['get_logicalName']={syn:'Returns the logical name of the serial port.',lib:'serialport.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SerialPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'serialport.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SerialPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'serialport.get_protocol()',pro:'def get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SerialPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'serialport.get_rxCount()',pro:'def get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'serialport.get_rxMsgCount()',pro:'def get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_serialMode']={syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'serialport.get_serialMode()',pro:'def get_serialMode()',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:'On failure, throws an exception or returns <tt>Y_SERIALMODE_INVALID</tt>.'};
doc['SerialPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'serialport.get_startupJob()',pro:'def get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SerialPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'serialport.get_txCount()',pro:'def get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'serialport.get_txMsgCount()',pro:'def get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'serialport.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SerialPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'serialport.get_voltageLevel()',pro:'def get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SerialPort']['isOnline']={syn:'Checks if the serial port is currently reachable, without raising any error.',lib:'serialport.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the serial port is currently reachable, without raising any error. If there is a cached value for the serial port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the serial port.</p>',ret:'<tt>true</tt> if the serial port can be reached, and <tt>false</tt> otherwise'};
doc['SerialPort']['load']={syn:'Preloads the serial port cache with a specified validity duration.',lib:'serialport.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the serial port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['modbusReadBits']={syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'serialport.modbusReadBits()',pro:'def modbusReadBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputBits']={syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'serialport.modbusReadInputBits()',pro:'def modbusReadInputBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'serialport.modbusReadInputRegisters()',pro:'def modbusReadInputRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadRegisters']={syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'serialport.modbusReadRegisters()',pro:'def modbusReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'serialport.modbusWriteAndReadRegisters()',pro:'def modbusWriteAndReadRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduWriteAddr</span>, <span id=pn>values</span>, <span id=pn>pduReadAddr</span>, <span id=pn>nReadWords</span>)',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteBit']={syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'serialport.modbusWriteBit()',pro:'def modbusWriteBit(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteBits']={syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'serialport.modbusWriteBits()',pro:'def modbusWriteBits(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>bits</span>)',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegister']={syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'serialport.modbusWriteRegister()',pro:'def modbusWriteRegister(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>value</span>)',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegisters']={syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'serialport.modbusWriteRegisters()',pro:'def modbusWriteRegisters(<span id=pn>slaveNo</span>, <span id=pn>pduAddr</span>, <span id=pn>values</span>)',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['nextSerialPort']={syn:'Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.',lib:'serialport.nextSerialPort()',pro:'def nextSerialPort()',cmt:'<p>Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to a serial port currently online, or a <tt>null</tt> pointer if there are no more serial ports to enumerate.'};
doc['SerialPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'serialport.queryLine()',pro:'def queryLine(<span id=pn>query</span>, <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['queryMODBUS']={syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'serialport.queryMODBUS()',pro:'def queryMODBUS(<span id=pn>slaveNo</span>, <span id=pn>pduBytes</span>)',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:'On failure, throws an exception or returns an empty array (or a MODBUS error reply).'};
doc['SerialPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'serialport.readArray()',pro:'def readArray(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'serialport.readBin()',pro:'def readBin(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'serialport.readByte()',pro:'def readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'serialport.readHex()',pro:'def readHex(<span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'serialport.readLine()',pro:'def readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or MODBUS protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'serialport.readMessages()',pro:'def readMessages(<span id=pn>pattern</span>, <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'serialport.readStr()',pro:'def readStr(<span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the YSerialPort object.',lib:'serialport.read_avail()',pro:'def read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the YSerialPort object.</p>',ret:'the number of bytes available to read'};
doc['SerialPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'serialport.read_seek()',pro:'def read_seek(<span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the YSerialPort object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SerialPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the YSerialPort object.',lib:'serialport.read_tell()',pro:'def read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the YSerialPort object.</p>',ret:'the absolute position index for next read operations.'};
doc['SerialPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'serialport.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SerialPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'serialport.reset()',pro:'def reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'serialport.selectJob()',pro:'def selectJob(<span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_RTS']={syn:'Manually sets the state of the RTS line.',lib:'serialport.set_RTS()',pro:'def set_RTS(<span id=pn>val</span>)',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport.set_currentJob()',pro:'def set_currentJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_logicalName']={syn:'Changes the logical name of the serial port.',lib:'serialport.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the serial port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'serialport.set_protocol()',pro:'def set_protocol(<span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_serialMode']={syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'serialport.set_serialMode()',pro:'def set_serialMode(<span id=pn>newval</span>)',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport.set_startupJob()',pro:'def set_startupJob(<span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'serialport.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SerialPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'serialport.set_voltageLevel()',pro:'def set_voltageLevel(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'serialport.uploadJob()',pro:'def uploadJob(<span id=pn>jobfile</span>, <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'serialport.writeArray()',pro:'def writeArray(<span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'serialport.writeBin()',pro:'def writeBin(<span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'serialport.writeByte()',pro:'def writeByte(<span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'serialport.writeHex()',pro:'def writeHex(<span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'serialport.writeLine()',pro:'def writeLine(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeMODBUS']={syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'serialport.writeMODBUS()',pro:'def writeMODBUS(<span id=pn>hexString</span>)',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'serialport.writeStr()',pro:'def writeStr(<span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SerialPort)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PwmInput function interface',inc:'from yocto_pwminput import *',cmt:'<p>The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM sensors. It inherits from YSensor class the core functions to read measurements, register callback functions, access to the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cacle, the frequency or the pulse width.</p>'}};
doc['PwmInput']['FindPwmInput']={syn:'Retrieves a PWM input for a given identifier.',lib:'YPwmInput.FindPwmInput()',pro:'def FindPwmInput(<span id=pn>func</span>)',cmt:'<p>Retrieves a PWM input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmInput.isOnline()</tt> to test if the PWM input is indeed online at a given time. In case of ambiguity when looking for a PWM input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the PWM input'},ret:'a <tt>YPwmInput</tt> object allowing you to drive the PWM input.'};
doc['PwmInput']['FirstPwmInput']={syn:'Starts the enumeration of PWM inputs currently accessible.',lib:'YPwmInput.FirstPwmInput()',pro:'def FirstPwmInput()',cmt:'<p>Starts the enumeration of PWM inputs currently accessible. Use the method <tt>YPwmInput.nextPwmInput()</tt> to iterate on next PWM inputs.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to the first PWM input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmInput']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pwminput.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwminput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmInput']['get_advertisedValue']={syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'pwminput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'pwminput.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentValue']={syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'pwminput.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in % or the pulse length in ms.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwminput.get_dutyCycle()',pro:'def get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmInput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM input.',lib:'pwminput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM input object'};
doc['PwmInput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM input.',lib:'pwminput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM input object'};
doc['PwmInput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwminput.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_friendlyName']={syn:'Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwminput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM input if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmInput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwminput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmInput']['get_functionId']={syn:'Returns the hardware identifier of the PWM input, without reference to the module.',lib:'pwminput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmInput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwminput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmInput']['get_highestValue']={syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'pwminput.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the PWM since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pwminput.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_logicalName']={syn:'Returns the logical name of the PWM input.',lib:'pwminput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmInput']['get_lowestValue']={syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'pwminput.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the PWM since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwminput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmInput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwminput.get_period()',pro:'def get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmInput']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'pwminput.get_pulseCounter()',pro:'def get_pulseCounter()',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['PwmInput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwminput.get_pulseDuration()',pro:'def get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmInput']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms) ',lib:'pwminput.get_pulseTimer()',pro:'def get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms)</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['PwmInput']['get_pwmReportMode']={syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'pwminput.get_pwmReportMode()',pro:'def get_pwmReportMode()',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt> and <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>Y_PWMREPORTMODE_INVALID</tt>.'};
doc['PwmInput']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pwminput.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['PwmInput']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pwminput.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pwminput.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['PwmInput']['get_unit']={syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'pwminput.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['PwmInput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwminput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmInput']['isOnline']={syn:'Checks if the PWM input is currently reachable, without raising any error.',lib:'pwminput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the PWM input is currently reachable, without raising any error. If there is a cached value for the PWM input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM input.</p>',ret:'<tt>true</tt> if the PWM input can be reached, and <tt>false</tt> otherwise'};
doc['PwmInput']['load']={syn:'Preloads the PWM input cache with a specified validity duration.',lib:'pwminput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pwminput.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['nextPwmInput']={syn:'Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.',lib:'pwminput.nextPwmInput()',pro:'def nextPwmInput()',cmt:'<p>Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to a PWM input currently online, or a <tt>null</tt> pointer if there are no more PWM inputs to enumerate.'};
doc['PwmInput']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pwminput.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['PwmInput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwminput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmInput']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'pwminput.resetCounter()',pro:'def resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pwminput.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pwminput.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logicalName']={syn:'Changes the logical name of the PWM input.',lib:'pwminput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pwminput.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_pwmReportMode']={syn:'Modifies the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'pwminput.set_pwmReportMode()',pro:'def set_pwmReportMode(<span id=pn>newval</span>)',cmt:'<p>Modifies the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt> and <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pwminput.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pwminput.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwminput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmInput']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pwminput.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['PwmInput']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pwminput.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: PwmInput)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'SegmentedDisplay function interface',inc:'from yocto_segmenteddisplay import *',cmt:'<p>The SegmentedDisplay class allows you to drive segmented displays.</p>'}};
doc['SegmentedDisplay']['FindSegmentedDisplay']={syn:'Retrieves a segmented display for a given identifier.',lib:'YSegmentedDisplay.FindSegmentedDisplay()',pro:'def FindSegmentedDisplay(<span id=pn>func</span>)',cmt:'<p>Retrieves a segmented display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the segmented displays is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSegmentedDisplay.isOnline()</tt> to test if the segmented displays is indeed online at a given time. In case of ambiguity when looking for a segmented display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the segmented displays'},ret:'a <tt>YSegmentedDisplay</tt> object allowing you to drive the segmented displays.'};
doc['SegmentedDisplay']['FirstSegmentedDisplay']={syn:'Starts the enumeration of segmented displays currently accessible.',lib:'YSegmentedDisplay.FirstSegmentedDisplay()',pro:'def FirstSegmentedDisplay()',cmt:'<p>Starts the enumeration of segmented displays currently accessible. Use the method <tt>YSegmentedDisplay.nextSegmentedDisplay()</tt> to iterate on next segmented displays.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to the first segmented displays currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SegmentedDisplay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'segmenteddisplay.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the segmented displays (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Returns the current value of the segmented displays (no more than 6 characters).',lib:'segmenteddisplay.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the segmented displays (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented displays (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SegmentedDisplay']['get_displayedText']={syn:'Returns the text currently displayed on the screen.',lib:'segmenteddisplay.get_displayedText()',pro:'def get_displayedText()',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYEDTEXT_INVALID</tt>.'};
doc['SegmentedDisplay']['get_errorMessage']={syn:'Returns the error message of the latest error with the segmented displays.',lib:'segmenteddisplay.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the segmented displays object'};
doc['SegmentedDisplay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the segmented displays.',lib:'segmenteddisplay.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the segmented displays object'};
doc['SegmentedDisplay']['get_friendlyName']={syn:'Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'segmenteddisplay.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the segmented displays if they are defined, otherwise the serial number of the module and the hardware identifier of the segmented displays (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the segmented displays using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'segmenteddisplay.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionId']={syn:'Returns the hardware identifier of the segmented displays, without reference to the module.',lib:'segmenteddisplay.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the segmented displays, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the segmented displays (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'segmenteddisplay.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the segmented displays (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the segmented displays (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_logicalName']={syn:'Returns the logical name of the segmented displays.',lib:'segmenteddisplay.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the segmented displays.</p>',ret:'a string corresponding to the logical name of the segmented displays.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'segmenteddisplay.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SegmentedDisplay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'segmenteddisplay.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SegmentedDisplay']['isOnline']={syn:'Checks if the segmented displays is currently reachable, without raising any error.',lib:'segmenteddisplay.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the segmented displays is currently reachable, without raising any error. If there is a cached value for the segmented displays in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the segmented displays.</p>',ret:'<tt>true</tt> if the segmented displays can be reached, and <tt>false</tt> otherwise'};
doc['SegmentedDisplay']['load']={syn:'Preloads the segmented displays cache with a specified validity duration.',lib:'segmenteddisplay.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the segmented displays cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['nextSegmentedDisplay']={syn:'Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.',lib:'segmenteddisplay.nextSegmentedDisplay()',pro:'def nextSegmentedDisplay()',cmt:'<p>Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to a segmented display currently online, or a <tt>null</tt> pointer if there are no more segmented displays to enumerate.'};
doc['SegmentedDisplay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'segmenteddisplay.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SegmentedDisplay']['set_displayedText']={syn:'Changes the text currently displayed on the screen.',lib:'segmenteddisplay.set_displayedText()',pro:'def set_displayedText(<span id=pn>newval</span>)',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_logicalName']={syn:'Changes the logical name of the segmented displays.',lib:'segmenteddisplay.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the segmented displays. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the segmented displays.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'segmenteddisplay.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer function interface',inc:'from yocto_buzzer import *',cmt:'<p>The Yoctopuce application programming interface allows you to choose the frequency and volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}};
doc['Buzzer']['FindBuzzer']={syn:'Retrieves a buzzer for a given identifier.',lib:'YBuzzer.FindBuzzer()',pro:'def FindBuzzer(<span id=pn>func</span>)',cmt:'<p>Retrieves a buzzer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the buzzer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBuzzer.isOnline()</tt> to test if the buzzer is indeed online at a given time. In case of ambiguity when looking for a buzzer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the buzzer'},ret:'a <tt>YBuzzer</tt> object allowing you to drive the buzzer.'};
doc['Buzzer']['FirstBuzzer']={syn:'Starts the enumeration of buzzers currently accessible.',lib:'YBuzzer.FirstBuzzer()',pro:'def FirstBuzzer()',cmt:'<p>Starts the enumeration of buzzers currently accessible. Use the method <tt>YBuzzer.nextBuzzer()</tt> to iterate on next buzzers.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to the first buzzer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Adds a new frequency transition to the playing sequence.',lib:'buzzer.addFreqMoveToPlaySeq()',pro:'def addFreqMoveToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDelay</span>)',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Adds a pulse to the playing sequence.',lib:'buzzer.addPulseToPlaySeq()',pro:'def addPulseToPlaySeq(<span id=pn>freq</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Adds a new volume transition to the playing sequence.',lib:'buzzer.addVolMoveToPlaySeq()',pro:'def addVolMoveToPlaySeq(<span id=pn>volume</span>, <span id=pn>msDuration</span>)',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'buzzer.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the buzzer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Buzzer']['freqMove']={syn:'Makes the buzzer frequency change over a period of time.',lib:'buzzer.freqMove()',pro:'def freqMove(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['get_advertisedValue']={syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'buzzer.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Buzzer']['get_errorMessage']={syn:'Returns the error message of the latest error with the buzzer.',lib:'buzzer.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the buzzer object'};
doc['Buzzer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the buzzer.',lib:'buzzer.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the buzzer object'};
doc['Buzzer']['get_frequency']={syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'buzzer.get_frequency()',pro:'def get_frequency()',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Buzzer']['get_friendlyName']={syn:'Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'buzzer.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the buzzer if they are defined, otherwise the serial number of the module and the hardware identifier of the buzzer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the buzzer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Buzzer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'buzzer.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Buzzer']['get_functionId']={syn:'Returns the hardware identifier of the buzzer, without reference to the module.',lib:'buzzer.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the buzzer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the buzzer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Buzzer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'buzzer.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the buzzer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the buzzer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Buzzer']['get_logicalName']={syn:'Returns the logical name of the buzzer.',lib:'buzzer.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Buzzer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'buzzer.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Buzzer']['get_playSeqMaxSize']={syn:'Returns the maximum length of the playing sequence ',lib:'buzzer.get_playSeqMaxSize()',pro:'def get_playSeqMaxSize()',cmt:'<p>Returns the maximum length of the playing sequence</p>',ret:'an integer corresponding to the maximum length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQMAXSIZE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSignature']={syn:'Returns the playing sequence signature.',lib:'buzzer.get_playSeqSignature()',pro:'def get_playSeqSignature()',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIGNATURE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSize']={syn:'Returns the current length of the playing sequence ',lib:'buzzer.get_playSeqSize()',pro:'def get_playSeqSize()',cmt:'<p>Returns the current length of the playing sequence</p>',ret:'an integer corresponding to the current length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIZE_INVALID</tt>.'};
doc['Buzzer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'buzzer.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Buzzer']['get_volume']={syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'buzzer.get_volume()',pro:'def get_volume()',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['Buzzer']['isOnline']={syn:'Checks if the buzzer is currently reachable, without raising any error.',lib:'buzzer.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the buzzer is currently reachable, without raising any error. If there is a cached value for the buzzer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the buzzer.</p>',ret:'<tt>true</tt> if the buzzer can be reached, and <tt>false</tt> otherwise'};
doc['Buzzer']['load']={syn:'Preloads the buzzer cache with a specified validity duration.',lib:'buzzer.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the buzzer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['nextBuzzer']={syn:'Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.',lib:'buzzer.nextBuzzer()',pro:'def nextBuzzer()',cmt:'<p>Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to a buzzer currently online, or a <tt>null</tt> pointer if there are no more buzzers to enumerate.'};
doc['Buzzer']['pulse']={syn:'Activates the buzzer for a short duration.',lib:'buzzer.pulse()',pro:'def pulse(<span id=pn>frequency</span>, <span id=pn>duration</span>)',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'buzzer.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Buzzer']['resetPlaySeq']={syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer.resetPlaySeq()',pro:'def resetPlaySeq()',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_frequency']={syn:'Changes the frequency of the signal sent to the buzzer.',lib:'buzzer.set_frequency()',pro:'def set_frequency(<span id=pn>newval</span>)',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_logicalName']={syn:'Changes the logical name of the buzzer.',lib:'buzzer.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the buzzer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'buzzer.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Buzzer']['set_volume']={syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'buzzer.set_volume()',pro:'def set_volume(<span id=pn>newval</span>)',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['startPlaySeq']={syn:'Starts the preprogrammed playing sequence.',lib:'buzzer.startPlaySeq()',pro:'def startPlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['stopPlaySeq']={syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer.stopPlaySeq()',pro:'def stopPlaySeq()',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['volumeMove']={syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'buzzer.volumeMove()',pro:'def volumeMove(<span id=pn>volume</span>, <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Buzzer)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Control interface for the firmware update process',inc:'from yocto_api import *',cmt:'<p>The YFirmwareUpdate class let you control the firmware update of a Yoctopuce module. This class should not be instantiate directly, instead the method <tt>updateFirmware</tt> should be called to get an instance of YFirmwareUpdate.</p>'}};
doc['FirmwareUpdate']['CheckFirmware']={syn:'Test if the byn file is valid for this module.',lib:'YFirmwareUpdate.CheckFirmware()',pro:'def CheckFirmware(<span id=pn>serial</span>, <span id=pn>path</span>, <span id=pn>minrelease</span>)',cmt:'<p>Test if the byn file is valid for this module. It\x27s possible to pass an directory instead of a file. In this case this method return the path of the most recent appropriate byn file. This method will ignore firmware that are older than mintrelase.</p>',par:{serial:'the serial number of the module to update',path:'the path of a byn file or a directory that contain byn files',minrelease:'an positif integer'},ret:': the path of the byn file to use or a empty string if no byn files match the requirement',ext:'On failure, returns a string that start with \x22error:\x22.'};
doc['FirmwareUpdate']['GetAllBootLoaders']={syn:'Retruns a list of all the modules in \x22update\x22 mode.',lib:'YFirmwareUpdate.GetAllBootLoaders()',pro:'def GetAllBootLoaders()',cmt:'<p>Retruns a list of all the modules in \x22update\x22 mode. Only USB connected devices are listed. For modules connected to a YoctoHub, you must connect yourself to the YoctoHub web interface.</p>',ret:'an array of strings containing the serial list of module in \x22update\x22 mode.'};
doc['FirmwareUpdate']['get_progress']={syn:'Returns the progress of the firmware update, on a scale from 0 to 100.',lib:'firmwareupdate.get_progress()',pro:'def get_progress()',cmt:'<p>Returns the progress of the firmware update, on a scale from 0 to 100. When the object is instantiated, the progress is zero. The value is updated during the firmware update process until the value of 100 is reached. The 100 value means that the firmware update was completed successfully. If an error occurs during the firmware update, a negative value is returned, and the error message can be retrieved with <tt>get_progressMessage</tt>.</p>',ret:'an integer in the range 0 to 100 (percentage of completion) or a negative error code in case of failure.'};
doc['FirmwareUpdate']['get_progressMessage']={syn:'Returns the last progress message of the firmware update process.',lib:'firmwareupdate.get_progressMessage()',pro:'def get_progressMessage()',cmt:'<p>Returns the last progress message of the firmware update process. If an error occurs during the firmware update process, the error message is returned</p>',ret:'a string with the latest progress message, or the error message.'};
doc['FirmwareUpdate']['startUpdate']={syn:'Starts the firmware update process.',lib:'firmwareupdate.startUpdate()',pro:'def startUpdate()',cmt:'<p>Starts the firmware update process. This method starts the firmware update process in background. This method returns immediately. You can monitor the progress of the firmware update with the <tt>get_progress()</tt> and <tt>get_progressMessage()</tt> methods.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure returns a negative error code.'};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'GPS function interface',inc:'from yocto_gps import *',cmt:'<p>The Gps function allows you to extract positionning data from the GPS device. This class can provides complete positionning information: However, if you whish to define callbacks on position changes, you should use the YLatitude et YLongitude classes.</p>'}};
doc['Gps']['FindGps']={syn:'Retrieves a GPS for a given identifier.',lib:'YGps.FindGps()',pro:'def FindGps(<span id=pn>func</span>)',cmt:'<p>Retrieves a GPS for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the GPS is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGps.isOnline()</tt> to test if the GPS is indeed online at a given time. In case of ambiguity when looking for a GPS by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the GPS'},ret:'a <tt>YGps</tt> object allowing you to drive the GPS.'};
doc['Gps']['FirstGps']={syn:'Starts the enumeration of GPS currently accessible.',lib:'YGps.FirstGps()',pro:'def FirstGps()',cmt:'<p>Starts the enumeration of GPS currently accessible. Use the method <tt>YGps.nextGps()</tt> to iterate on next GPS.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to the first GPS currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gps']['describe']={syn:'Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gps.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the GPS (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gps']['get_advertisedValue']={syn:'Returns the current value of the GPS (no more than 6 characters).',lib:'gps.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the GPS (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the GPS (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gps']['get_altitude']={syn:'Returns the current altitude.',lib:'gps.get_altitude()',pro:'def get_altitude()',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:'On failure, throws an exception or returns <tt>Y_ALTITUDE_INVALID</tt>.'};
doc['Gps']['get_coordSystem']={syn:'Returns the representation system used for positioning data.',lib:'gps.get_coordSystem()',pro:'def get_coordSystem()',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data',ext:'On failure, throws an exception or returns <tt>Y_COORDSYSTEM_INVALID</tt>.'};
doc['Gps']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22 ',lib:'gps.get_dateTime()',pro:'def get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['Gps']['get_dilution']={syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'gps.get_dilution()',pro:'def get_dilution()',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:'On failure, throws an exception or returns <tt>Y_DILUTION_INVALID</tt>.'};
doc['Gps']['get_direction']={syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'gps.get_direction()',pro:'def get_direction()',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:'On failure, throws an exception or returns <tt>Y_DIRECTION_INVALID</tt>.'};
doc['Gps']['get_errorMessage']={syn:'Returns the error message of the latest error with the GPS.',lib:'gps.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the GPS object'};
doc['Gps']['get_errorType']={syn:'Returns the numerical error code of the latest error with the GPS.',lib:'gps.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the GPS object'};
doc['Gps']['get_friendlyName']={syn:'Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gps.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the GPS if they are defined, otherwise the serial number of the module and the hardware identifier of the GPS (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the GPS using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gps']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gps.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gps']['get_functionId']={syn:'Returns the hardware identifier of the GPS, without reference to the module.',lib:'gps.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the GPS, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the GPS (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gps']['get_groundSpeed']={syn:'Returns the current ground speed in Km/h.',lib:'gps.get_groundSpeed()',pro:'def get_groundSpeed()',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:'On failure, throws an exception or returns <tt>Y_GROUNDSPEED_INVALID</tt>.'};
doc['Gps']['get_hardwareId']={syn:'Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gps.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the GPS (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the GPS (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gps']['get_isFixed']={syn:'Returns TRUE if the receiver has found enough satellites to work ',lib:'gps.get_isFixed()',pro:'def get_isFixed()',cmt:'<p>Returns TRUE if the receiver has found enough satellites to work</p>',ret:'either <tt>Y_ISFIXED_FALSE</tt> or <tt>Y_ISFIXED_TRUE</tt>, according to TRUE if the receiver has found enough satellites to work',ext:'On failure, throws an exception or returns <tt>Y_ISFIXED_INVALID</tt>.'};
doc['Gps']['get_latitude']={syn:'Returns the current latitude.',lib:'gps.get_latitude()',pro:'def get_latitude()',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:'On failure, throws an exception or returns <tt>Y_LATITUDE_INVALID</tt>.'};
doc['Gps']['get_logicalName']={syn:'Returns the logical name of the GPS.',lib:'gps.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the GPS.</p>',ret:'a string corresponding to the logical name of the GPS.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gps']['get_longitude']={syn:'Returns the current longitude.',lib:'gps.get_longitude()',pro:'def get_longitude()',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:'On failure, throws an exception or returns <tt>Y_LONGITUDE_INVALID</tt>.'};
doc['Gps']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gps.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gps']['get_satCount']={syn:'Returns the count of visible satellites.',lib:'gps.get_satCount()',pro:'def get_satCount()',cmt:'<p>Returns the count of visible satellites.</p>',ret:'an integer corresponding to the count of visible satellites',ext:'On failure, throws an exception or returns <tt>Y_SATCOUNT_INVALID</tt>.'};
doc['Gps']['get_unixTime']={syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'gps.get_unixTime()',pro:'def get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['Gps']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gps.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gps']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'gps.get_utcOffset()',pro:'def get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['Gps']['isOnline']={syn:'Checks if the GPS is currently reachable, without raising any error.',lib:'gps.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the GPS is currently reachable, without raising any error. If there is a cached value for the GPS in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the GPS.</p>',ret:'<tt>true</tt> if the GPS can be reached, and <tt>false</tt> otherwise'};
doc['Gps']['load']={syn:'Preloads the GPS cache with a specified validity duration.',lib:'gps.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the GPS cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['nextGps']={syn:'Continues the enumeration of GPS started using <tt>yFirstGps()</tt>.',lib:'gps.nextGps()',pro:'def nextGps()',cmt:'<p>Continues the enumeration of GPS started using <tt>yFirstGps()</tt>.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to a GPS currently online, or a <tt>null</tt> pointer if there are no more GPS to enumerate.'};
doc['Gps']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gps.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gps']['set_coordSystem']={syn:'Changes the representation system used for positioning data.',lib:'gps.set_coordSystem()',pro:'def set_coordSystem(<span id=pn>newval</span>)',cmt:'<p>Changes the representation system used for positioning data.</p>',par:{newval:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_logicalName']={syn:'Changes the logical name of the GPS.',lib:'gps.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the GPS. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the GPS.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gps.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gps']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'gps.set_utcOffset()',pro:'def set_utcOffset(<span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Gps)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude function interface',inc:'from yocto_latitude import *',cmt:'<p>The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Latitude']['FindLatitude']={syn:'Retrieves a latitude sensor for a given identifier.',lib:'YLatitude.FindLatitude()',pro:'def FindLatitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a latitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the latitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLatitude.isOnline()</tt> to test if the latitude sensor is indeed online at a given time. In case of ambiguity when looking for a latitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the latitude sensor'},ret:'a <tt>YLatitude</tt> object allowing you to drive the latitude sensor.'};
doc['Latitude']['FirstLatitude']={syn:'Starts the enumeration of latitude sensors currently accessible.',lib:'YLatitude.FirstLatitude()',pro:'def FirstLatitude()',cmt:'<p>Starts the enumeration of latitude sensors currently accessible. Use the method <tt>YLatitude.nextLatitude()</tt> to iterate on next latitude sensors.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to the first latitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Latitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'latitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'latitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the latitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Latitude']['get_advertisedValue']={syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'latitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'latitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentValue']={syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'latitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Latitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the latitude sensor.',lib:'latitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the latitude sensor object'};
doc['Latitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the latitude sensor.',lib:'latitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the latitude sensor object'};
doc['Latitude']['get_friendlyName']={syn:'Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'latitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the latitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the latitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the latitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Latitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'latitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Latitude']['get_functionId']={syn:'Returns the hardware identifier of the latitude sensor, without reference to the module.',lib:'latitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the latitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the latitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Latitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'latitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the latitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the latitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Latitude']['get_highestValue']={syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'latitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the latitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'latitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_logicalName']={syn:'Returns the logical name of the latitude sensor.',lib:'latitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Latitude']['get_lowestValue']={syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'latitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the latitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'latitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Latitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'latitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Latitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'latitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'latitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Latitude']['get_unit']={syn:'Returns the measuring unit for the latitude.',lib:'latitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Latitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'latitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Latitude']['isOnline']={syn:'Checks if the latitude sensor is currently reachable, without raising any error.',lib:'latitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the latitude sensor is currently reachable, without raising any error. If there is a cached value for the latitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the latitude sensor.</p>',ret:'<tt>true</tt> if the latitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Latitude']['load']={syn:'Preloads the latitude sensor cache with a specified validity duration.',lib:'latitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the latitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'latitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['nextLatitude']={syn:'Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.',lib:'latitude.nextLatitude()',pro:'def nextLatitude()',cmt:'<p>Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to a latitude sensor currently online, or a <tt>null</tt> pointer if there are no more latitude sensors to enumerate.'};
doc['Latitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'latitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Latitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'latitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Latitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'latitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'latitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logicalName']={syn:'Changes the logical name of the latitude sensor.',lib:'latitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the latitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'latitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'latitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'latitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'latitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Latitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'latitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Latitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'latitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude function interface',inc:'from yocto_longitude import *',cmt:'<p>The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Longitude']['FindLongitude']={syn:'Retrieves a longitude sensor for a given identifier.',lib:'YLongitude.FindLongitude()',pro:'def FindLongitude(<span id=pn>func</span>)',cmt:'<p>Retrieves a longitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the longitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLongitude.isOnline()</tt> to test if the longitude sensor is indeed online at a given time. In case of ambiguity when looking for a longitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the longitude sensor'},ret:'a <tt>YLongitude</tt> object allowing you to drive the longitude sensor.'};
doc['Longitude']['FirstLongitude']={syn:'Starts the enumeration of longitude sensors currently accessible.',lib:'YLongitude.FirstLongitude()',pro:'def FirstLongitude()',cmt:'<p>Starts the enumeration of longitude sensors currently accessible. Use the method <tt>YLongitude.nextLongitude()</tt> to iterate on next longitude sensors.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to the first longitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Longitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'longitude.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'longitude.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the longitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Longitude']['get_advertisedValue']={syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'longitude.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'longitude.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentValue']={syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'longitude.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Longitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the longitude sensor.',lib:'longitude.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the longitude sensor object'};
doc['Longitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the longitude sensor.',lib:'longitude.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the longitude sensor object'};
doc['Longitude']['get_friendlyName']={syn:'Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'longitude.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the longitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the longitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the longitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Longitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'longitude.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Longitude']['get_functionId']={syn:'Returns the hardware identifier of the longitude sensor, without reference to the module.',lib:'longitude.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the longitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the longitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Longitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'longitude.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the longitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the longitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Longitude']['get_highestValue']={syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'longitude.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the longitude since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'longitude.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_logicalName']={syn:'Returns the logical name of the longitude sensor.',lib:'longitude.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Longitude']['get_lowestValue']={syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'longitude.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the longitude since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'longitude.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Longitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'longitude.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Longitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'longitude.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'longitude.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Longitude']['get_unit']={syn:'Returns the measuring unit for the longitude.',lib:'longitude.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Longitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'longitude.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Longitude']['isOnline']={syn:'Checks if the longitude sensor is currently reachable, without raising any error.',lib:'longitude.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the longitude sensor is currently reachable, without raising any error. If there is a cached value for the longitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the longitude sensor.</p>',ret:'<tt>true</tt> if the longitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Longitude']['load']={syn:'Preloads the longitude sensor cache with a specified validity duration.',lib:'longitude.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the longitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'longitude.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['nextLongitude']={syn:'Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.',lib:'longitude.nextLongitude()',pro:'def nextLongitude()',cmt:'<p>Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to a longitude sensor currently online, or a <tt>null</tt> pointer if there are no more longitude sensors to enumerate.'};
doc['Longitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'longitude.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Longitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'longitude.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Longitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'longitude.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'longitude.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logicalName']={syn:'Changes the logical name of the longitude sensor.',lib:'longitude.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the longitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'longitude.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'longitude.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'longitude.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'longitude.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Longitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'longitude.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Longitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'longitude.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'GroundSpeed function interface',inc:'from yocto_groundspeed import *',cmt:'<p>The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['GroundSpeed']['FindGroundSpeed']={syn:'Retrieves a ground speed sensor for a given identifier.',lib:'YGroundSpeed.FindGroundSpeed()',pro:'def FindGroundSpeed(<span id=pn>func</span>)',cmt:'<p>Retrieves a ground speed sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the ground speed sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGroundSpeed.isOnline()</tt> to test if the ground speed sensor is indeed online at a given time. In case of ambiguity when looking for a ground speed sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the ground speed sensor'},ret:'a <tt>YGroundSpeed</tt> object allowing you to drive the ground speed sensor.'};
doc['GroundSpeed']['FirstGroundSpeed']={syn:'Starts the enumeration of ground speed sensors currently accessible.',lib:'YGroundSpeed.FirstGroundSpeed()',pro:'def FirstGroundSpeed()',cmt:'<p>Starts the enumeration of ground speed sensors currently accessible. Use the method <tt>YGroundSpeed.nextGroundSpeed()</tt> to iterate on next ground speed sensors.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to the first ground speed sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'groundspeed.calibrateFromPoints()',pro:'def calibrateFromPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'groundspeed.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the ground speed sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GroundSpeed']['get_advertisedValue']={syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'groundspeed.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'groundspeed.get_currentRawValue()',pro:'def get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentValue']={syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'groundspeed.get_currentValue()',pro:'def get_currentValue()',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_errorMessage']={syn:'Returns the error message of the latest error with the ground speed sensor.',lib:'groundspeed.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the ground speed sensor object'};
doc['GroundSpeed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the ground speed sensor.',lib:'groundspeed.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the ground speed sensor object'};
doc['GroundSpeed']['get_friendlyName']={syn:'Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'groundspeed.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the ground speed sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the ground speed sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the ground speed sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'groundspeed.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GroundSpeed']['get_functionId']={syn:'Returns the hardware identifier of the ground speed sensor, without reference to the module.',lib:'groundspeed.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the ground speed sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the ground speed sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GroundSpeed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'groundspeed.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the ground speed sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the ground speed sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GroundSpeed']['get_highestValue']={syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'groundspeed.get_highestValue()',pro:'def get_highestValue()',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started.</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'groundspeed.get_logFrequency()',pro:'def get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_logicalName']={syn:'Returns the logical name of the ground speed sensor.',lib:'groundspeed.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_lowestValue']={syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'groundspeed.get_lowestValue()',pro:'def get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started.</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'groundspeed.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GroundSpeed']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'groundspeed.get_recordedData()',pro:'def get_recordedData(<span id=pn>startTime</span>, <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'groundspeed.get_reportFrequency()',pro:'def get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'groundspeed.get_resolution()',pro:'def get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GroundSpeed']['get_unit']={syn:'Returns the measuring unit for the ground speed.',lib:'groundspeed.get_unit()',pro:'def get_unit()',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GroundSpeed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'groundspeed.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GroundSpeed']['isOnline']={syn:'Checks if the ground speed sensor is currently reachable, without raising any error.',lib:'groundspeed.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the ground speed sensor is currently reachable, without raising any error. If there is a cached value for the ground speed sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the ground speed sensor.</p>',ret:'<tt>true</tt> if the ground speed sensor can be reached, and <tt>false</tt> otherwise'};
doc['GroundSpeed']['load']={syn:'Preloads the ground speed sensor cache with a specified validity duration.',lib:'groundspeed.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the ground speed sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'groundspeed.loadCalibrationPoints()',pro:'def loadCalibrationPoints(<span id=pn>rawValues</span>, <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['nextGroundSpeed']={syn:'Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.',lib:'groundspeed.nextGroundSpeed()',pro:'def nextGroundSpeed()',cmt:'<p>Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to a ground speed sensor currently online, or a <tt>null</tt> pointer if there are no more ground speed sensors to enumerate.'};
doc['GroundSpeed']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'groundspeed.registerTimedReportCallback()',pro:'def registerTimedReportCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GroundSpeed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'groundspeed.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GroundSpeed']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'groundspeed.set_highestValue()',pro:'def set_highestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'groundspeed.set_logFrequency()',pro:'def set_logFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logicalName']={syn:'Changes the logical name of the ground speed sensor.',lib:'groundspeed.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the ground speed sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'groundspeed.set_lowestValue()',pro:'def set_lowestValue(<span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed.</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'groundspeed.set_reportFrequency()',pro:'def set_reportFrequency(<span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'groundspeed.set_resolution()',pro:'def set_resolution(<span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'groundspeed.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GroundSpeed']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'groundspeed.startDataLogger()',pro:'def startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'groundspeed.stopDataLogger()',pro:'def stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
//--- (end of generated code: GroundSpeed)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'External power supply control interface',inc:'from yocto_poweroutput import *',cmt:'<p>Yoctopuce application programming interface allows you to control the power ouput featured on some devices such as the Yocto-Serial.</p>'}};
doc['PowerOutput']['FindPowerOutput']={syn:'Retrieves a dual power ouput control for a given identifier.',lib:'YPowerOutput.FindPowerOutput()',pro:'def FindPowerOutput(<span id=pn>func</span>)',cmt:'<p>Retrieves a dual power ouput control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power ouput control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerOutput.isOnline()</tt> to test if the power ouput control is indeed online at a given time. In case of ambiguity when looking for a dual power ouput control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the power ouput control'},ret:'a <tt>YPowerOutput</tt> object allowing you to drive the power ouput control.'};
doc['PowerOutput']['FirstPowerOutput']={syn:'Starts the enumeration of dual power ouput controls currently accessible.',lib:'YPowerOutput.FirstPowerOutput()',pro:'def FirstPowerOutput()',cmt:'<p>Starts the enumeration of dual power ouput controls currently accessible. Use the method <tt>YPowerOutput.nextPowerOutput()</tt> to iterate on next dual power ouput controls.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to the first dual power ouput control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PowerOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power ouput control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'poweroutput.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power ouput control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power ouput control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerOutput']['get_advertisedValue']={syn:'Returns the current value of the power ouput control (no more than 6 characters).',lib:'poweroutput.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the power ouput control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power ouput control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the power ouput control.',lib:'poweroutput.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power ouput control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power ouput control object'};
doc['PowerOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power ouput control.',lib:'poweroutput.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power ouput control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power ouput control object'};
doc['PowerOutput']['get_friendlyName']={syn:'Returns a global identifier of the power ouput control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'poweroutput.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the power ouput control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power ouput control if they are defined, otherwise the serial number of the module and the hardware identifier of the power ouput control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power ouput control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'poweroutput.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PowerOutput']['get_functionId']={syn:'Returns the hardware identifier of the power ouput control, without reference to the module.',lib:'poweroutput.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the power ouput control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power ouput control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power ouput control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'poweroutput.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power ouput control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power ouput control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power ouput control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerOutput']['get_logicalName']={syn:'Returns the logical name of the power ouput control.',lib:'poweroutput.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the power ouput control.</p>',ret:'a string corresponding to the logical name of the power ouput control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'poweroutput.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PowerOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'poweroutput.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PowerOutput']['get_voltage']={syn:'Returns the voltage on the power ouput featured by the module.',lib:'poweroutput.get_voltage()',pro:'def get_voltage()',cmt:'<p>Returns the voltage on the power ouput featured by the module.</p>',ret:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power ouput featured by the module',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['PowerOutput']['isOnline']={syn:'Checks if the power ouput control is currently reachable, without raising any error.',lib:'poweroutput.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the power ouput control is currently reachable, without raising any error. If there is a cached value for the power ouput control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power ouput control.</p>',ret:'<tt>true</tt> if the power ouput control can be reached, and <tt>false</tt> otherwise'};
doc['PowerOutput']['load']={syn:'Preloads the power ouput control cache with a specified validity duration.',lib:'poweroutput.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the power ouput control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['nextPowerOutput']={syn:'Continues the enumeration of dual power ouput controls started using <tt>yFirstPowerOutput()</tt>.',lib:'poweroutput.nextPowerOutput()',pro:'def nextPowerOutput()',cmt:'<p>Continues the enumeration of dual power ouput controls started using <tt>yFirstPowerOutput()</tt>.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to a dual power ouput control currently online, or a <tt>null</tt> pointer if there are no more dual power ouput controls to enumerate.'};
doc['PowerOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'poweroutput.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PowerOutput']['set_logicalName']={syn:'Changes the logical name of the power ouput control.',lib:'poweroutput.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power ouput control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power ouput control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'poweroutput.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PowerOutput']['set_voltage']={syn:'Changes the voltage on the power output provided by the module.',lib:'poweroutput.set_voltage()',pro:'def set_voltage(<span id=pn>newval</span>)',cmt:'<p>Changes the voltage on the power output provided by the module. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PowerOutput)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular function interface',inc:'from yocto_cellular import *',cmt:'<p>YCellular functions provides control over cellular network parameters and status for devices that are GSM-enabled.</p>'}};
doc['Cellular']['FindCellular']={syn:'Retrieves a cellular interface for a given identifier.',lib:'YCellular.FindCellular()',pro:'def FindCellular(<span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCellular.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the cellular interface'},ret:'a <tt>YCellular</tt> object allowing you to drive the cellular interface.'};
doc['Cellular']['FirstCellular']={syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YCellular.FirstCellular()',pro:'def FirstCellular()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YCellular.nextCellular()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Cellular']['_AT']={syn:'Sends an AT command to the GSM module and returns the command output.',lib:'cellular._AT()',pro:'def _AT(<span id=pn>cmd</span>)',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'};
doc['Cellular']['describe']={syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'cellular.describe()',pro:'def describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Cellular']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'cellular.get_advertisedValue()',pro:'def get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Cellular']['get_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular.get_apn()',pro:'def get_apn()',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:'On failure, throws an exception or returns <tt>Y_APN_INVALID</tt>.'};
doc['Cellular']['get_apnSecret']={syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'cellular.get_apnSecret()',pro:'def get_apnSecret()',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_APNSECRET_INVALID</tt>.'};
doc['Cellular']['get_cellOperator']={syn:'Returns the name of the cell operator currently in use.',lib:'cellular.get_cellOperator()',pro:'def get_cellOperator()',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:'On failure, throws an exception or returns <tt>Y_CELLOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_enableData']={syn:'Returns the condition for enabling IP data services (GPRS).',lib:'cellular.get_enableData()',pro:'def get_enableData()',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt> and <tt>Y_ENABLEDATA_NEVER</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATA_INVALID</tt>.'};
doc['Cellular']['get_errorMessage']={syn:'Returns the error message of the latest error with the cellular interface.',lib:'cellular.get_errorMessage()',pro:'def get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'};
doc['Cellular']['get_errorType']={syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'cellular.get_errorType()',pro:'def get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'};
doc['Cellular']['get_friendlyName']={syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'cellular.get_friendlyName()',pro:'def get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Cellular']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'cellular.get_functionDescriptor()',pro:'def get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Cellular']['get_functionId']={syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'cellular.get_functionId()',pro:'def get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Cellular']['get_hardwareId']={syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'cellular.get_hardwareId()',pro:'def get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Cellular']['get_imsi']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular.get_imsi()',pro:'def get_imsi()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_IMSI_INVALID</tt>.'};
doc['Cellular']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'cellular.get_linkQuality()',pro:'def get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Cellular']['get_lockedOperator']={syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'cellular.get_lockedOperator()',pro:'def get_lockedOperator()',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:'On failure, throws an exception or returns <tt>Y_LOCKEDOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'cellular.get_logicalName()',pro:'def get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Cellular']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'cellular.get_message()',pro:'def get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Cellular']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'cellular.get_module()',pro:'def get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Cellular']['get_pin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular.get_pin()',pro:'def get_pin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_PIN_INVALID</tt>.'};
doc['Cellular']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'cellular.get_userData()',pro:'def get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Cellular']['isOnline']={syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'cellular.isOnline()',pro:'def isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'};
doc['Cellular']['load']={syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'cellular.load()',pro:'def load(<span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['nextCellular']={syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.',lib:'cellular.nextCellular()',pro:'def nextCellular()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'};
doc['Cellular']['quickCellSurvey']={syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'cellular.quickCellSurvey()',pro:'def quickCellSurvey()',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighboor cells reported by the serving cell.</p>',ret:'a list of YCellRecords.'};
doc['Cellular']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'cellular.registerValueCallback()',pro:'def registerValueCallback(<span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Cellular']['sendPUK']={syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card.',lib:'cellular.sendPUK()',pro:'def sendPUK(<span id=pn>puk</span>, <span id=pn>newPin</span>)',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card. Only ten consecutives tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular.set_apn()',pro:'def set_apn(<span id=pn>newval</span>)',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',par:{newval:'a string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apnAuth']={syn:'Configure authentication parameters to connect to the APN.',lib:'cellular.set_apnAuth()',pro:'def set_apnAuth(<span id=pn>username</span>, <span id=pn>password</span>)',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_enableData']={syn:'Changes the condition for enabling IP data services (GPRS).',lib:'cellular.set_enableData()',pro:'def set_enableData(<span id=pn>newval</span>)',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs ! When data services are disabled, SMS are the only mean of communication.</p>',par:{newval:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt> and <tt>Y_ENABLEDATA_NEVER</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_lockedOperator']={syn:'Changes the name of the cell operator to be used.',lib:'cellular.set_lockedOperator()',pro:'def set_lockedOperator(<span id=pn>newval</span>)',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'cellular.set_logicalName()',pro:'def set_logicalName(<span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_pin']={syn:'Changes the PIN code used by the module to access the SIM card.',lib:'cellular.set_pin()',pro:'def set_pin(<span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'cellular.set_userData()',pro:'def set_userData(<span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
//--- (end of generated code: Cellular)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

